/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/


var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to2;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AIMCPPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");
var import_uuid = require("uuid");
var import_mistralai = require("@langchain/mistralai");
var import_js_client_rest = require("@qdrant/js-client-rest");

// src/performance.ts
var PerformanceOptimizer = class {
  // 1 second
  constructor(plugin) {
    this.plugin = plugin;
    this.cache = /* @__PURE__ */ new Map();
    this.batchQueue = [];
    this.isProcessing = false;
    this.CACHE_TTL = 5 * 60 * 1e3;
    // 5 minutes
    this.BATCH_SIZE = 10;
    this.BATCH_DELAY = 1e3;
    // Debounced File Processing
    this.fileProcessingTimeouts = /* @__PURE__ */ new Map();
    // Performance Monitoring
    this.performanceMetrics = {
      embeddingRequests: 0,
      cacheHits: 0,
      cacheMisses: 0,
      batchJobsProcessed: 0,
      averageResponseTime: 0
    };
    this.startBatchProcessor();
    this.startCacheCleanup();
  }
  // Cache Management
  setCache(key, data, ttl = this.CACHE_TTL) {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  getCache(key) {
    const entry = this.cache.get(key);
    if (!entry)
      return null;
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }
    return entry.data;
  }
  clearCache() {
    this.cache.clear();
  }
  // Lazy Loading for Large Files
  async lazyLoadFile(file) {
    const cacheKey = `file_${file.path}_${file.stat.mtime}`;
    const cached = this.getCache(cacheKey);
    if (cached)
      return cached;
    if (file.stat.size > this.plugin.projectInstructions.mcp_config.memory_graph.vault_integration.max_file_size) {
      console.warn(`File ${file.path} too large, skipping`);
      return null;
    }
    try {
      const content = await this.plugin.app.vault.read(file);
      this.setCache(cacheKey, content);
      return content;
    } catch (e) {
      console.error(`Failed to load file ${file.path}:`, e);
      return null;
    }
  }
  // Batch Processing
  addToBatch(job) {
    const id = `${job.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const batchJob = {
      ...job,
      id,
      timestamp: Date.now()
    };
    this.batchQueue.push(batchJob);
    this.batchQueue.sort((a, b) => b.priority - a.priority);
    return id;
  }
  startBatchProcessor() {
    setInterval(async () => {
      if (this.isProcessing || this.batchQueue.length === 0)
        return;
      this.isProcessing = true;
      const batch = this.batchQueue.splice(0, this.BATCH_SIZE);
      try {
        await this.processBatch(batch);
      } catch (e) {
        console.error("Batch processing failed:", e);
      } finally {
        this.isProcessing = false;
      }
    }, this.BATCH_DELAY);
  }
  async processBatch(jobs) {
    const embeddingJobs = jobs.filter((job) => job.type === "embedding");
    const indexingJobs = jobs.filter((job) => job.type === "indexing");
    const syncJobs = jobs.filter((job) => job.type === "sync");
    if (embeddingJobs.length > 0) {
      await this.processEmbeddingBatch(embeddingJobs);
    }
    if (indexingJobs.length > 0) {
      await this.processIndexingBatch(indexingJobs);
    }
    if (syncJobs.length > 0) {
      await this.processSyncBatch(syncJobs);
    }
  }
  async processEmbeddingBatch(jobs) {
    const maxConcurrent = this.plugin.projectInstructions.performance?.max_concurrent_requests || 3;
    const chunks = this.chunkArray(jobs, maxConcurrent);
    for (const chunk of chunks) {
      const promises = chunk.map(async (job) => {
        try {
          const embedding = await this.plugin.embeddings.embedQuery(job.data.text);
          const cacheKey = `embedding_${this.hashString(job.data.text)}`;
          this.setCache(cacheKey, embedding, 24 * 60 * 60 * 1e3);
          await this.plugin.memoryGraph.addNode({
            type: job.data.type || "context",
            content: job.data.text,
            sources: job.data.sources || []
          }, embedding);
          await this.plugin.ragIntegrator.upsertToQdrant(
            job.id,
            embedding,
            job.data.text
          );
        } catch (e) {
          console.error(`Failed to process embedding job ${job.id}:`, e);
        }
      });
      await Promise.allSettled(promises);
    }
  }
  async processIndexingBatch(jobs) {
    for (const job of jobs) {
      try {
        await this.indexContent(job.data);
      } catch (e) {
        console.error(`Failed to process indexing job ${job.id}:`, e);
      }
    }
  }
  async processSyncBatch(jobs) {
    for (const job of jobs) {
      try {
        await this.syncData(job.data);
      } catch (e) {
        console.error(`Failed to process sync job ${job.id}:`, e);
      }
    }
  }
  async indexContent(data) {
    console.log("Indexing content:", data);
  }
  async syncData(data) {
    if (this.plugin.settings.enableCustomCloudSync) {
      await this.plugin.exportToCustomCloud(data.type);
    }
  }
  debounceFileProcessing(file, delay = 2e3) {
    const existing = this.fileProcessingTimeouts.get(file.path);
    if (existing) {
      clearTimeout(existing);
    }
    const timeout = setTimeout(async () => {
      await this.processFileChange(file);
      this.fileProcessingTimeouts.delete(file.path);
    }, delay);
    this.fileProcessingTimeouts.set(file.path, timeout);
  }
  async processFileChange(file) {
    const content = await this.lazyLoadFile(file);
    if (!content)
      return;
    const contentHash = this.hashString(content);
    const lastHash = this.plugin.lastHashes.get(file.path);
    if (lastHash === contentHash)
      return;
    this.addToBatch({
      type: "embedding",
      data: {
        text: content,
        type: "markdown",
        sources: [{
          type: "vault_file",
          id: file.path,
          description: file.name
        }]
      },
      priority: 1
    });
    this.plugin.lastHashes.set(file.path, contentHash);
  }
  // Memory Management
  async optimizeMemoryUsage() {
    this.cleanupCache();
    await this.pruneMemoryGraph();
    this.cleanupBatchQueue();
    if (globalThis.gc) {
      globalThis.gc();
    }
  }
  cleanupCache() {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > entry.ttl) {
        this.cache.delete(key);
      }
    }
  }
  async pruneMemoryGraph() {
    const graph = await this.plugin.memoryGraph.load();
    const threshold = this.plugin.projectInstructions.mcp_config.memory_graph.prune_threshold;
    graph.nodes = graph.nodes.filter((node) => node.confidence >= threshold);
    const nodeIds = new Set(graph.nodes.map((n) => n.id));
    graph.edges = graph.edges.filter(
      (edge) => nodeIds.has(edge.from) && nodeIds.has(edge.to)
    );
    await this.plugin.memoryGraph.save(graph);
  }
  cleanupBatchQueue() {
    const cutoff = Date.now() - 60 * 60 * 1e3;
    this.batchQueue = this.batchQueue.filter((job) => job.timestamp > cutoff);
  }
  startCacheCleanup() {
    setInterval(() => {
      this.cleanupCache();
    }, 10 * 60 * 1e3);
  }
  // Utility Methods
  chunkArray(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
  hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString();
  }
  recordEmbeddingRequest() {
    this.performanceMetrics.embeddingRequests++;
  }
  recordCacheHit() {
    this.performanceMetrics.cacheHits++;
  }
  recordCacheMiss() {
    this.performanceMetrics.cacheMisses++;
  }
  recordBatchJobProcessed() {
    this.performanceMetrics.batchJobsProcessed++;
  }
  getPerformanceMetrics() {
    return { ...this.performanceMetrics };
  }
  getCacheStats() {
    const total = this.performanceMetrics.cacheHits + this.performanceMetrics.cacheMisses;
    const hitRate = total > 0 ? this.performanceMetrics.cacheHits / total : 0;
    return {
      size: this.cache.size,
      hitRate: Math.round(hitRate * 100) / 100
    };
  }
  // Cleanup
  destroy() {
    for (const timeout of this.fileProcessingTimeouts.values()) {
      clearTimeout(timeout);
    }
    this.fileProcessingTimeouts.clear();
    this.clearCache();
    this.batchQueue = [];
  }
};

// src/advanced-features.ts
var import_obsidian = require("obsidian");
var AdvancedFeatures = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  // Smart Suggestions System
  async generateSmartSuggestions(context) {
    const suggestions = [];
    const graph = await this.plugin.memoryGraph.load();
    const activeFile = this.plugin.app.workspace.getActiveFile();
    const taskSuggestions = await this.generateTaskSuggestions(graph, activeFile);
    suggestions.push(...taskSuggestions);
    const connectionSuggestions = await this.generateConnectionSuggestions(graph, activeFile);
    suggestions.push(...connectionSuggestions);
    const researchSuggestions = await this.generateResearchSuggestions(context);
    suggestions.push(...researchSuggestions);
    return suggestions.sort((a, b) => b.confidence - a.confidence).slice(0, 10);
  }
  async generateTaskSuggestions(graph, activeFile) {
    const suggestions = [];
    const taskNodes = graph.nodes.filter((n) => n.type === "task");
    const overdueTasks = taskNodes.filter((task) => {
      const dueDate = task.attributes?.due_date;
      return dueDate && new Date(dueDate) < /* @__PURE__ */ new Date();
    });
    for (const task of overdueTasks.slice(0, 3)) {
      suggestions.push({
        id: `overdue_${task.id}`,
        type: "task",
        title: `Complete overdue task: ${task.summary}`,
        description: `This task was due on ${task.attributes.due_date}`,
        confidence: 0.9,
        action: async () => {
          await this.createTaskNote(task);
        },
        metadata: { taskId: task.id, type: "overdue" }
      });
    }
    const nextTasks = this.findNextLogicalTasks(graph, taskNodes);
    for (const task of nextTasks.slice(0, 2)) {
      suggestions.push({
        id: `next_${task.id}`,
        type: "task",
        title: `Ready to start: ${task.summary}`,
        description: "All dependencies completed",
        confidence: 0.8,
        action: async () => {
          await this.createTaskNote(task);
        },
        metadata: { taskId: task.id, type: "ready" }
      });
    }
    return suggestions;
  }
  async generateConnectionSuggestions(graph, activeFile) {
    const suggestions = [];
    if (!activeFile || !this.plugin.embeddings)
      return suggestions;
    try {
      const content = await this.plugin.app.vault.read(activeFile);
      const embedding = await this.plugin.embeddings.embedQuery(content.substring(0, 500));
      const similarNodes = await this.findSimilarNodes(graph, embedding);
      for (const node of similarNodes.slice(0, 3)) {
        if (node.sources?.[0]?.id !== activeFile.path) {
          suggestions.push({
            id: `connect_${node.id}`,
            type: "connection",
            title: `Connect to: ${node.summary}`,
            description: `Similar content found (${(node.similarity * 100).toFixed(1)}% match)`,
            confidence: node.similarity,
            action: async () => {
              await this.createConnection(activeFile, node);
            },
            metadata: { nodeId: node.id, similarity: node.similarity }
          });
        }
      }
    } catch (e) {
      console.error("Failed to generate connection suggestions:", e);
    }
    return suggestions;
  }
  async generateResearchSuggestions(context) {
    const suggestions = [];
    const graph = await this.plugin.memoryGraph.load();
    const gaps = this.identifyKnowledgeGaps(graph);
    for (const gap of gaps.slice(0, 2)) {
      suggestions.push({
        id: `research_${gap.topic}`,
        type: "research",
        title: `Research: ${gap.topic}`,
        description: `Found ${gap.mentions} mentions but limited depth`,
        confidence: 0.7,
        action: async () => {
          await this.createResearchNote(gap.topic);
        },
        metadata: { topic: gap.topic, mentions: gap.mentions }
      });
    }
    return suggestions;
  }
  // Contextual Insights
  async generateContextualInsights(activeFile) {
    const insights = [];
    const graph = await this.plugin.memoryGraph.load();
    const patterns = this.detectPatterns(graph);
    insights.push(...patterns);
    const gaps = this.identifyKnowledgeGaps(graph);
    insights.push(...gaps.map((gap) => ({
      type: "gap",
      title: `Knowledge Gap: ${gap.topic}`,
      description: `Topic mentioned ${gap.mentions} times but lacks detailed information`,
      relevance: gap.mentions / 10,
      sources: gap.sources,
      suggestions: [
        `Research ${gap.topic} in depth`,
        `Create a comprehensive note about ${gap.topic}`,
        `Connect existing mentions of ${gap.topic}`
      ]
    })));
    const trends = this.identifyTrends(graph);
    insights.push(...trends);
    return insights.sort((a, b) => b.relevance - a.relevance);
  }
  detectPatterns(graph) {
    const patterns = [];
    const themes = this.extractThemes(graph);
    for (const theme of themes.slice(0, 3)) {
      patterns.push({
        type: "pattern",
        title: `Recurring Theme: ${theme.name}`,
        description: `Appears in ${theme.frequency} nodes across different contexts`,
        relevance: theme.frequency / graph.nodes.length,
        sources: theme.sources,
        suggestions: [
          `Create a master note for ${theme.name}`,
          `Tag related content with #${theme.name.toLowerCase()}`,
          `Explore connections between ${theme.name} instances`
        ]
      });
    }
    return patterns;
  }
  identifyTrends(graph) {
    const trends = [];
    const recentNodes = graph.nodes.filter((n) => {
      const created = new Date(n.timestamp.created_at);
      const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1e3);
      return created > weekAgo;
    });
    if (recentNodes.length > 0) {
      const topicCounts = this.countTopics(recentNodes);
      const trendingTopics = Object.entries(topicCounts).sort(([, a], [, b]) => b - a).slice(0, 3);
      for (const [topic, count] of trendingTopics) {
        trends.push({
          type: "trend",
          title: `Trending: ${topic}`,
          description: `${count} mentions in the past week`,
          relevance: count / recentNodes.length,
          sources: recentNodes.filter((n) => n.content.toLowerCase().includes(topic.toLowerCase())).map((n) => n.sources?.[0]?.id || "Unknown").slice(0, 5),
          suggestions: [
            `Consolidate recent work on ${topic}`,
            `Plan next steps for ${topic}`,
            `Review progress on ${topic}-related goals`
          ]
        });
      }
    }
    return trends;
  }
  // Auto-tagging System
  async autoTagContent(file, content) {
    if (!this.plugin.embeddings)
      return [];
    try {
      const embedding = await this.plugin.embeddings.embedQuery(content);
      const graph = await this.plugin.memoryGraph.load();
      const similarNodes = await this.findSimilarNodes(graph, embedding);
      const tags = /* @__PURE__ */ new Set();
      for (const node of similarNodes.slice(0, 5)) {
        if (node.similarity > 0.7) {
          const nodeTags = this.extractTagsFromContent(node.content);
          nodeTags.forEach((tag) => tags.add(tag));
        }
      }
      const semanticTags = await this.generateSemanticTags(content);
      semanticTags.forEach((tag) => tags.add(tag));
      return Array.from(tags).slice(0, 10);
    } catch (e) {
      console.error("Auto-tagging failed:", e);
      return [];
    }
  }
  async generateSemanticTags(content) {
    const words = content.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((word) => word.length > 3);
    const wordCounts = words.reduce((acc, word) => {
      acc[word] = (acc[word] || 0) + 1;
      return acc;
    }, {});
    return Object.entries(wordCounts).sort(([, a], [, b]) => b - a).slice(0, 5).map(([word]) => word);
  }
  // Smart Search
  async smartSearch(query, options2 = {}) {
    const { includeContext = true, searchType = "hybrid", maxResults = 10 } = options2;
    if (!this.plugin.embeddings)
      return [];
    try {
      const queryEmbedding = await this.plugin.embeddings.embedQuery(query);
      let results = [];
      if (searchType === "semantic" || searchType === "hybrid") {
        const semanticResults = await this.plugin.ragIntegrator.searchSimilar(queryEmbedding, maxResults);
        results.push(...semanticResults.map((r) => ({ ...r, type: "semantic" })));
      }
      if (searchType === "keyword" || searchType === "hybrid") {
        const keywordResults = await this.keywordSearch(query, maxResults);
        results.push(...keywordResults.map((r) => ({ ...r, type: "keyword" })));
      }
      const uniqueResults = this.deduplicateResults(results);
      const sortedResults = uniqueResults.sort((a, b) => (b.score || 0) - (a.score || 0));
      if (includeContext) {
        return await this.enrichResultsWithContext(sortedResults.slice(0, maxResults));
      }
      return sortedResults.slice(0, maxResults);
    } catch (e) {
      console.error("Smart search failed:", e);
      return [];
    }
  }
  async keywordSearch(query, maxResults) {
    const graph = await this.plugin.memoryGraph.load();
    const queryWords = query.toLowerCase().split(/\s+/);
    const results = graph.nodes.map((node) => {
      const content = node.content.toLowerCase();
      const matches = queryWords.filter((word) => content.includes(word));
      const score = matches.length / queryWords.length;
      return { ...node, score, matches };
    }).filter((node) => node.score > 0).sort((a, b) => b.score - a.score).slice(0, maxResults);
    return results;
  }
  // Utility Methods
  findNextLogicalTasks(graph, taskNodes) {
    const completedTasks = new Set(
      taskNodes.filter((task) => task.attributes?.status === "completed").map((task) => task.id)
    );
    return taskNodes.filter((task) => {
      if (task.attributes?.status === "completed")
        return false;
      const dependencies = graph.edges.filter((edge) => edge.to === task.id && edge.type === "temporal").map((edge) => edge.from);
      return dependencies.every((dep) => completedTasks.has(dep));
    });
  }
  async findSimilarNodes(graph, embedding) {
    return graph.nodes.map((node) => ({
      ...node,
      similarity: this.cosineSimilarity(embedding, node.embeddings || [])
    })).filter((node) => node.similarity > 0.5).sort((a, b) => b.similarity - a.similarity);
  }
  cosineSimilarity(a, b) {
    if (a.length !== b.length || a.length === 0)
      return 0;
    const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);
    const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
    const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (magnitudeA * magnitudeB);
  }
  extractThemes(graph) {
    const themes = /* @__PURE__ */ new Map();
    for (const node of graph.nodes) {
      const words = node.content.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((word) => word.length > 4);
      for (const word of words) {
        if (!themes.has(word)) {
          themes.set(word, { frequency: 0, sources: [] });
        }
        const theme = themes.get(word);
        theme.frequency++;
        if (node.sources?.[0]?.id && !theme.sources.includes(node.sources[0].id)) {
          theme.sources.push(node.sources[0].id);
        }
      }
    }
    return Array.from(themes.entries()).map(([name, data]) => ({ name, ...data })).filter((theme) => theme.frequency > 2).sort((a, b) => b.frequency - a.frequency);
  }
  identifyKnowledgeGaps(graph) {
    const topics = /* @__PURE__ */ new Map();
    for (const node of graph.nodes) {
      const content = node.content.toLowerCase();
      const sentences = content.split(/[.!?]+/);
      for (const sentence of sentences) {
        if (sentence.includes("need to learn") || sentence.includes("don't understand") || sentence.includes("research") || sentence.includes("find out")) {
          const words = sentence.split(/\s+/).filter((word) => word.length > 4);
          for (const word of words) {
            if (!topics.has(word)) {
              topics.set(word, { mentions: 0, sources: [] });
            }
            const topic = topics.get(word);
            topic.mentions++;
            if (node.sources?.[0]?.id && !topic.sources.includes(node.sources[0].id)) {
              topic.sources.push(node.sources[0].id);
            }
          }
        }
      }
    }
    return Array.from(topics.entries()).map(([topic, data]) => ({ topic, ...data })).filter((gap) => gap.mentions >= 2).sort((a, b) => b.mentions - a.mentions);
  }
  countTopics(nodes) {
    const topics = {};
    for (const node of nodes) {
      const words = node.content.toLowerCase().replace(/[^\w\s]/g, " ").split(/\s+/).filter((word) => word.length > 4);
      for (const word of words) {
        topics[word] = (topics[word] || 0) + 1;
      }
    }
    return topics;
  }
  extractTagsFromContent(content) {
    const tagRegex = /#(\w+)/g;
    const matches = content.match(tagRegex);
    return matches ? matches.map((tag) => tag.substring(1)) : [];
  }
  deduplicateResults(results) {
    const seen = /* @__PURE__ */ new Set();
    return results.filter((result) => {
      const key = result.id || result.text || JSON.stringify(result);
      if (seen.has(key))
        return false;
      seen.add(key);
      return true;
    });
  }
  async enrichResultsWithContext(results) {
    const graph = await this.plugin.memoryGraph.load();
    return results.map((result) => {
      const relatedNodes = graph.nodes.filter(
        (node) => node.id !== result.id && this.cosineSimilarity(result.embeddings || [], node.embeddings || []) > 0.7
      ).slice(0, 3);
      return {
        ...result,
        context: {
          related: relatedNodes.map((node) => ({
            id: node.id,
            summary: node.summary,
            type: node.type
          }))
        }
      };
    });
  }
  // Action Methods
  async createTaskNote(task) {
    const fileName = `Task - ${task.summary.replace(/[^\w\s]/g, "")}.md`;
    const content = `# ${task.summary}

## Details
${task.content}

## Status
- [ ] ${task.summary}

## Due Date
${task.attributes?.due_date || "Not set"}

## Priority
${task.attributes?.priority || "Normal"}

## Notes
<!-- Add your notes here -->

---
*Created from AI suggestion on ${(/* @__PURE__ */ new Date()).toLocaleDateString()}*
`;
    await this.plugin.app.vault.create(fileName, content);
    new import_obsidian.Notice(`Created task note: ${fileName}`);
  }
  async createConnection(file, node) {
    const content = await this.plugin.app.vault.read(file);
    const sourceFile = node.sources?.[0]?.id;
    if (sourceFile) {
      const linkText = `

## Related
- [[${sourceFile}]] - Similar content (AI suggested)
`;
      await this.plugin.app.vault.modify(file, content + linkText);
      new import_obsidian.Notice(`Added connection to ${sourceFile}`);
    }
  }
  async createResearchNote(topic) {
    const fileName = `Research - ${topic}.md`;
    const content = `# Research: ${topic}

## Overview
<!-- What do you want to learn about ${topic}? -->

## Current Knowledge
<!-- What do you already know? -->

## Questions to Explore
- 
- 
- 

## Sources
<!-- Add your research sources here -->

## Notes
<!-- Your research notes -->

---
*Research topic suggested by AI on ${(/* @__PURE__ */ new Date()).toLocaleDateString()}*
`;
    await this.plugin.app.vault.create(fileName, content);
    new import_obsidian.Notice(`Created research note: ${fileName}`);
  }
};
var SmartSuggestionsModal = class extends import_obsidian.Modal {
  constructor(plugin, suggestions) {
    super(plugin.app);
    this.plugin = plugin;
    this.suggestions = suggestions;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Smart Suggestions" });
    if (this.suggestions.length === 0) {
      contentEl.createEl("p", { text: "No suggestions available at the moment." });
      return;
    }
    const suggestionsList = contentEl.createEl("div", { cls: "suggestions-list" });
    for (const suggestion of this.suggestions) {
      const item = suggestionsList.createEl("div", { cls: "suggestion-item" });
      item.createEl("div", { cls: "suggestion-header" }, (header) => {
        header.createEl("h3", { text: suggestion.title });
        header.createEl("span", {
          cls: "suggestion-confidence",
          text: `${Math.round(suggestion.confidence * 100)}%`
        });
      });
      item.createEl("p", {
        cls: "suggestion-description",
        text: suggestion.description
      });
      item.createEl("button", {
        text: "Apply",
        cls: "mod-cta"
      }).onclick = async () => {
        await suggestion.action();
        this.close();
      };
    }
  }
};

// src/voyage-ai.ts
var import_obsidian2 = require("obsidian");
var VoyageAIProvider = class {
  constructor(plugin, config) {
    this.plugin = plugin;
    this.config = config;
    this.baseUrl = config.baseUrl || "https://api.voyageai.com/v1";
  }
  async rerank(request) {
    try {
      const response = await fetch(`${this.baseUrl}/rerank`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          model: request.model || this.config.model || "rerank-lite-1",
          query: request.query,
          documents: request.documents,
          top_k: request.top_k || 10,
          return_documents: request.return_documents !== false
        })
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Voyage AI rerank failed: ${response.status} ${errorText}`);
      }
      const result = await response.json();
      return result;
    } catch (error) {
      console.error("Voyage AI rerank error:", error);
      throw error;
    }
  }
  async embed(request) {
    try {
      const response = await fetch(`${this.baseUrl}/embeddings`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          model: request.model || this.config.model || "voyage-large-2",
          input: request.input,
          input_type: request.input_type || "document",
          truncation: request.truncation !== false
        })
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Voyage AI embedding failed: ${response.status} ${errorText}`);
      }
      const result = await response.json();
      return result;
    } catch (error) {
      console.error("Voyage AI embedding error:", error);
      throw error;
    }
  }
  async rerankSearchResults(query, searchResults, options2 = {}) {
    const { topK = 10, threshold = 0 } = options2;
    if (searchResults.length === 0)
      return [];
    try {
      const documents = searchResults.map((result) => result.text);
      const rerankResponse = await this.rerank({
        query,
        documents,
        top_k: Math.min(topK, documents.length),
        return_documents: true
      });
      const rerankedResults = rerankResponse.data.filter((result) => result.relevance_score >= threshold).map((result) => ({
        text: result.document || searchResults[result.index].text,
        score: searchResults[result.index].score,
        rerankScore: result.relevance_score,
        metadata: {
          ...searchResults[result.index].metadata,
          originalIndex: result.index,
          rerankModel: rerankResponse.model
        }
      }));
      return rerankedResults;
    } catch (error) {
      console.error("Rerank search results failed:", error);
      return searchResults.slice(0, topK).map((result) => ({
        ...result,
        rerankScore: result.score
      }));
    }
  }
  async batchEmbed(texts, options2 = {}) {
    const { inputType = "document", batchSize = 100 } = options2;
    const embeddings = [];
    for (let i = 0; i < texts.length; i += batchSize) {
      const batch = texts.slice(i, i + batchSize);
      try {
        const response = await this.embed({
          input: batch,
          input_type: inputType
        });
        const batchEmbeddings = response.data.sort((a, b) => a.index - b.index).map((result) => result.embedding);
        embeddings.push(...batchEmbeddings);
      } catch (error) {
        console.error(`Batch embedding failed for batch ${i / batchSize + 1}:`, error);
        const zeroVector = new Array(1024).fill(0);
        for (let j = 0; j < batch.length; j++) {
          embeddings.push(zeroVector);
        }
      }
    }
    return embeddings;
  }
  async getModelInfo() {
    return {
      embedding_models: [
        "voyage-large-2",
        "voyage-code-2",
        "voyage-2",
        "voyage-lite-02-instruct"
      ],
      rerank_models: [
        "rerank-lite-1",
        "rerank-1"
      ],
      default_embedding: "voyage-large-2",
      default_rerank: "rerank-lite-1"
    };
  }
  async testConnection() {
    try {
      const testResponse = await this.embed({
        input: "test connection",
        input_type: "query"
      });
      return testResponse.data.length > 0;
    } catch (error) {
      console.error("Voyage AI connection test failed:", error);
      return false;
    }
  }
  // Utility methods for search enhancement
  async enhanceSearch(query, initialResults, options2 = {}) {
    const {
      rerankTopK = 20,
      rerankThreshold = 0.1,
      useSemanticBoost = true
    } = options2;
    const rerankedResults = await this.rerankSearchResults(
      query,
      initialResults.slice(0, rerankTopK * 2),
      // Take more for reranking
      { topK: rerankTopK, threshold: rerankThreshold }
    );
    const enhancedResults = rerankedResults.map((result) => {
      let finalScore = result.rerankScore;
      if (useSemanticBoost) {
        finalScore = result.score * 0.3 + result.rerankScore * 0.7;
      }
      return {
        ...result,
        finalScore
      };
    });
    enhancedResults.sort((a, b) => b.finalScore - a.finalScore);
    return enhancedResults;
  }
  async generateQueryVariations(query) {
    const variations = [query];
    const words = query.toLowerCase().split(/\s+/);
    const synonymMap = {
      "find": ["search", "locate", "discover"],
      "how": ["what", "which way"],
      "create": ["make", "build", "generate"],
      "delete": ["remove", "eliminate"],
      "update": ["modify", "change", "edit"]
    };
    for (const [word, synonyms] of Object.entries(synonymMap)) {
      if (words.includes(word)) {
        for (const synonym of synonyms) {
          const variation = query.replace(new RegExp(`\\b${word}\\b`, "gi"), synonym);
          if (variation !== query) {
            variations.push(variation);
          }
        }
      }
    }
    return variations.slice(0, 5);
  }
};
var VoyageAIIntegration = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.provider = null;
    this.isEnabled = false;
  }
  async initialize(config) {
    try {
      this.provider = new VoyageAIProvider(this.plugin, config);
      const isConnected = await this.provider.testConnection();
      if (isConnected) {
        this.isEnabled = true;
        new import_obsidian2.Notice("Voyage AI connected successfully");
        return true;
      } else {
        throw new Error("Connection test failed");
      }
    } catch (error) {
      console.error("Voyage AI initialization failed:", error);
      new import_obsidian2.Notice(`Voyage AI initialization failed: ${error.message}`);
      this.isEnabled = false;
      return false;
    }
  }
  isReady() {
    return this.isEnabled && this.provider !== null;
  }
  getProvider() {
    return this.provider;
  }
  async enhancedSearch(query, initialResults) {
    if (!this.isReady() || !this.provider) {
      return initialResults.map((result) => ({
        ...result,
        rerankScore: result.score,
        finalScore: result.score
      }));
    }
    return await this.provider.enhanceSearch(query, initialResults);
  }
  async rerankOnly(query, documents, topK) {
    if (!this.isReady() || !this.provider) {
      return null;
    }
    return await this.provider.rerank({
      query,
      documents,
      top_k: topK
    });
  }
  async embedBatch(texts, inputType = "document") {
    if (!this.isReady() || !this.provider) {
      return null;
    }
    return await this.provider.batchEmbed(texts, { inputType });
  }
  destroy() {
    this.provider = null;
    this.isEnabled = false;
  }
};

// src/vercel-ai.ts
var import_obsidian3 = require("obsidian");

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});

// node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};

// node_modules/zod/v3/locales/en.js
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var en_default = errorMap;

// node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function setErrorMap(map3) {
  overrideErrorMap = map3;
}
function getErrorMap() {
  return overrideErrorMap;
}

// node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map3 of maps) {
    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options2) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options2) });
  }
  ip(options2) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options2) });
  }
  cidr(options2) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options2) });
  }
  datetime(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options2
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      offset: options2?.offset ?? false,
      local: options2?.local ?? false,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options2) {
    if (typeof options2 === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options2
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options2?.precision === "undefined" ? null : options2?.precision,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options2) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options2?.position,
      ...errorUtil.errToObj(options2?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
};
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") {
      } else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new _ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options2 = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options2.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options2) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options2, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options2) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options: options2,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a.length; index2++) {
      const itemA = a[index2];
      const itemB = b[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements3) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements3) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements2 = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements2).then((elements3) => finalizeSet(elements3));
    } else {
      return finalizeSet(elements2);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;

// src/vercel-ai.ts
var TaskSchema = external_exports.object({
  title: external_exports.string().describe("Task title"),
  description: external_exports.string().describe("Detailed task description"),
  priority: external_exports.enum(["low", "medium", "high"]).describe("Task priority"),
  estimatedTime: external_exports.number().describe("Estimated time in minutes"),
  tags: external_exports.array(external_exports.string()).describe("Relevant tags"),
  dependencies: external_exports.array(external_exports.string()).describe("Task dependencies")
});
var SummarySchema = external_exports.object({
  mainPoints: external_exports.array(external_exports.string()).describe("Key points from the content"),
  summary: external_exports.string().describe("Concise summary"),
  keywords: external_exports.array(external_exports.string()).describe("Important keywords"),
  sentiment: external_exports.enum(["positive", "negative", "neutral"]).describe("Overall sentiment"),
  actionItems: external_exports.array(external_exports.string()).describe("Actionable items identified")
});
var AnalysisSchema = external_exports.object({
  topics: external_exports.array(external_exports.string()).describe("Main topics discussed"),
  entities: external_exports.array(external_exports.object({
    name: external_exports.string(),
    type: external_exports.string(),
    confidence: external_exports.number()
  })).describe("Named entities found"),
  relationships: external_exports.array(external_exports.object({
    from: external_exports.string(),
    to: external_exports.string(),
    type: external_exports.string()
  })).describe("Relationships between entities"),
  insights: external_exports.array(external_exports.string()).describe("Key insights derived")
});
var VercelAIProvider = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.providers = /* @__PURE__ */ new Map();
    this.configs = /* @__PURE__ */ new Map();
    this.defaultProvider = "openai";
    this.initializeProviders();
  }
  initializeProviders() {
    this.providers.set("openai", { name: "openai", baseUrl: "https://api.openai.com/v1" });
    this.providers.set("anthropic", { name: "anthropic", baseUrl: "https://api.anthropic.com/v1" });
    this.providers.set("google", { name: "google", baseUrl: "https://generativelanguage.googleapis.com/v1" });
    this.providers.set("mistral", { name: "mistral", baseUrl: "https://api.mistral.ai/v1" });
  }
  addProvider(config) {
    try {
      const provider = this.providers.get(config.name);
      if (!provider) {
        throw new Error(`Provider ${config.name} not supported`);
      }
      const configuredProvider = provider({
        apiKey: config.apiKey,
        baseURL: config.baseUrl
      });
      this.providers.set(config.name, configuredProvider);
      this.configs.set(config.name, config);
      if (config.enabled && this.configs.size === 1) {
        this.defaultProvider = config.name;
      }
      return true;
    } catch (error) {
      console.error(`Failed to add provider ${config.name}:`, error);
      return false;
    }
  }
  setDefaultProvider(providerName) {
    if (this.configs.has(providerName) && this.configs.get(providerName)?.enabled) {
      this.defaultProvider = providerName;
      return true;
    }
    return false;
  }
  getAvailableProviders() {
    return Array.from(this.configs.values()).filter((config) => config.enabled);
  }
  getProvider(providerName) {
    const name = providerName || this.defaultProvider;
    const provider = this.providers.get(name);
    const config = this.configs.get(name);
    if (!provider || !config?.enabled) {
      throw new Error(`Provider ${name} not available or not enabled`);
    }
    return { provider, config };
  }
  async generateText(messages, options2 = {}) {
    try {
      const { provider, config } = this.getProvider(options2.provider);
      console.log("Simulating text generation with:", {
        provider: config.name,
        model: config.model,
        messages: messages.length,
        options: options2
      });
      return `Generated response from ${config.name} for: ${messages[messages.length - 1]?.content || "No content"}`;
    } catch (error) {
      console.error("Text generation failed:", error);
      throw error;
    }
  }
  async streamText(messages, options2 = {}) {
    try {
      const { provider, config } = this.getProvider(options2.provider);
      const response = await this.generateText(messages, options2);
      const chunks = response.split(" ");
      let fullText = "";
      for (const chunk of chunks) {
        fullText += chunk + " ";
        options2.onChunk?.(chunk + " ");
        await new Promise((resolve2) => setTimeout(resolve2, 50));
      }
      options2.onComplete?.(fullText.trim());
    } catch (error) {
      console.error("Streaming text generation failed:", error);
      options2.onError?.(error);
      throw error;
    }
  }
  async generateStructuredOutput(messages, schema, options2 = {}) {
    try {
      const { provider, config } = this.getProvider(options2.provider);
      console.log("Simulating structured output generation");
      const mockData = this.generateMockData(schema);
      return mockData;
    } catch (error) {
      console.error("Structured output generation failed:", error);
      throw error;
    }
  }
  generateMockData(schema) {
    return {
      title: "Mock Task",
      description: "This is a mock task generated for demonstration",
      priority: "medium",
      estimatedTime: 30,
      tags: ["mock", "demo"],
      dependencies: []
    };
  }
  async generateTask(content, context) {
    const messages = [
      {
        role: "system",
        content: "You are a task planning assistant. Analyze the given content and create a well-structured task."
      },
      {
        role: "user",
        content: `Content: ${content}
${context ? `Context: ${context}` : ""}

Create a task based on this content.`
      }
    ];
    return await this.generateStructuredOutput(messages, TaskSchema);
  }
  async generateSummary(content) {
    const messages = [
      {
        role: "system",
        content: "You are a content summarization expert. Analyze the given content and provide a comprehensive summary."
      },
      {
        role: "user",
        content: `Please summarize this content:

${content}`
      }
    ];
    return await this.generateStructuredOutput(messages, SummarySchema);
  }
  async analyzeContent(content) {
    const messages = [
      {
        role: "system",
        content: "You are a content analysis expert. Analyze the given content to extract topics, entities, relationships, and insights."
      },
      {
        role: "user",
        content: `Please analyze this content:

${content}`
      }
    ];
    return await this.generateStructuredOutput(messages, AnalysisSchema);
  }
  async embedText(text, options2 = {}) {
    try {
      const { provider, config } = this.getProvider(options2.provider);
      if (!["openai", "mistral"].includes(config.name)) {
        throw new Error(`Provider ${config.name} does not support embeddings`);
      }
      console.log("Simulating text embedding for:", text.substring(0, 50));
      return Array.from({ length: 1536 }, () => Math.random() - 0.5);
    } catch (error) {
      console.error("Text embedding failed:", error);
      throw error;
    }
  }
  async embedMany(texts, options2 = {}) {
    try {
      const { provider, config } = this.getProvider(options2.provider);
      const batchSize = options2.batchSize || 100;
      if (!["openai", "mistral"].includes(config.name)) {
        throw new Error(`Provider ${config.name} does not support embeddings`);
      }
      console.log("Simulating batch embedding for", texts.length, "texts");
      const embeddings = [];
      for (const text of texts) {
        embeddings.push(Array.from({ length: 1536 }, () => Math.random() - 0.5));
      }
      return embeddings;
    } catch (error) {
      console.error("Batch embedding failed:", error);
      throw error;
    }
  }
  async testProvider(providerName) {
    try {
      const testMessage = [
        { role: "user", content: "Hello, this is a test message." }
      ];
      await this.generateText(testMessage, {
        provider: providerName,
        maxTokens: 10
      });
      return true;
    } catch (error) {
      console.error(`Provider ${providerName} test failed:`, error);
      return false;
    }
  }
  // Utility methods for common AI tasks
  async improveWriting(text, style = "formal") {
    const messages = [
      {
        role: "system",
        content: `You are a writing improvement assistant. Improve the given text to be more ${style}, clear, and engaging while maintaining the original meaning.`
      },
      {
        role: "user",
        content: `Please improve this text:

${text}`
      }
    ];
    return await this.generateText(messages);
  }
  async translateText(text, targetLanguage) {
    const messages = [
      {
        role: "system",
        content: `You are a professional translator. Translate the given text to ${targetLanguage} while maintaining the original tone and meaning.`
      },
      {
        role: "user",
        content: `Please translate this text to ${targetLanguage}:

${text}`
      }
    ];
    return await this.generateText(messages);
  }
  async generateQuestions(content, count = 5) {
    const messages = [
      {
        role: "system",
        content: `You are an educational content expert. Generate ${count} thoughtful questions based on the given content that would help someone understand and engage with the material better.`
      },
      {
        role: "user",
        content: `Content:

${content}

Generate ${count} questions about this content.`
      }
    ];
    const response = await this.generateText(messages);
    return response.split("\n").filter((line) => line.trim().length > 0).slice(0, count);
  }
  async explainConcept(concept, level = "intermediate") {
    const messages = [
      {
        role: "system",
        content: `You are an expert educator. Explain concepts clearly and appropriately for a ${level} level audience.`
      },
      {
        role: "user",
        content: `Please explain this concept for a ${level} level audience:

${concept}`
      }
    ];
    return await this.generateText(messages);
  }
};
var VercelAIIntegration = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.isInitialized = false;
    this.provider = new VercelAIProvider(plugin);
  }
  async initialize(configs) {
    try {
      let successCount = 0;
      for (const config of configs) {
        if (this.provider.addProvider(config)) {
          successCount++;
        }
      }
      if (successCount > 0) {
        this.isInitialized = true;
        new import_obsidian3.Notice(`Vercel AI initialized with ${successCount} provider(s)`);
        return true;
      } else {
        throw new Error("No providers could be initialized");
      }
    } catch (error) {
      console.error("Vercel AI initialization failed:", error);
      new import_obsidian3.Notice(`Vercel AI initialization failed: ${error.message}`);
      return false;
    }
  }
  isReady() {
    return this.isInitialized;
  }
  getProvider() {
    return this.provider;
  }
  async testAllProviders() {
    const results = {};
    const providers = this.provider.getAvailableProviders();
    for (const config of providers) {
      results[config.name] = await this.provider.testProvider(config.name);
    }
    return results;
  }
  destroy() {
    this.isInitialized = false;
  }
};

// src/dashboard.ts
var import_obsidian4 = require("obsidian");

// node_modules/marked/lib/marked.esm.js
function _getDefaults() {
  return {
    async: false,
    breaks: false,
    extensions: null,
    gfm: true,
    hooks: null,
    pedantic: false,
    renderer: null,
    silent: false,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(newDefaults) {
  _defaults = newDefaults;
}
var escapeTest = /[&<>"']/;
var escapeReplace = new RegExp(escapeTest.source, "g");
var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
var escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
var getEscapeReplacement = (ch) => escapeReplacements[ch];
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
function unescape(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
var caret = /(^|[^\[])\^/g;
function edit(regex, opt) {
  regex = typeof regex === "string" ? regex : regex.source;
  opt = opt || "";
  const obj = {
    replace: (name, val) => {
      val = typeof val === "object" && "source" in val ? val.source : val;
      val = val.replace(caret, "$1");
      regex = regex.replace(name, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex, opt);
    }
  };
  return obj;
}
function cleanUrl(href) {
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
var noopTest = { exec: () => null };
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false;
    let curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (count) {
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.slice(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  let level = 0;
  for (let i = 0; i < str.length; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text)
    };
    lexer2.state.inLink = false;
    return token;
  }
  return {
    type: "image",
    raw,
    href,
    title,
    text: escape(text)
  };
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
var _Tokenizer = class {
  constructor(options2) {
    __publicField(this, "options");
    // TODO: Fix this rules type
    __publicField(this, "rules");
    __publicField(this, "lexer");
    this.options = options2 || _defaults;
  }
  space(src) {
    const cap = this.rules.block.newline.exec(src);
    if (cap && cap[0].length > 0) {
      return {
        type: "space",
        raw: cap[0]
      };
    }
  }
  code(src) {
    const cap = this.rules.block.code.exec(src);
    if (cap) {
      const text = cap[0].replace(/^ {1,4}/gm, "");
      return {
        type: "code",
        raw: cap[0],
        codeBlockStyle: "indented",
        text: !this.options.pedantic ? rtrim(text, "\n") : text
      };
    }
  }
  fences(src) {
    const cap = this.rules.block.fences.exec(src);
    if (cap) {
      const raw = cap[0];
      const text = indentCodeCompensation(raw, cap[3] || "");
      return {
        type: "code",
        raw,
        lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
        text
      };
    }
  }
  heading(src) {
    const cap = this.rules.block.heading.exec(src);
    if (cap) {
      let text = cap[2].trim();
      if (/#$/.test(text)) {
        const trimmed = rtrim(text, "#");
        if (this.options.pedantic) {
          text = trimmed.trim();
        } else if (!trimmed || / $/.test(trimmed)) {
          text = trimmed.trim();
        }
      }
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[1].length,
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  hr(src) {
    const cap = this.rules.block.hr.exec(src);
    if (cap) {
      return {
        type: "hr",
        raw: cap[0]
      };
    }
  }
  blockquote(src) {
    const cap = this.rules.block.blockquote.exec(src);
    if (cap) {
      const text = rtrim(cap[0].replace(/^ *>[ \t]?/gm, ""), "\n");
      const top = this.lexer.state.top;
      this.lexer.state.top = true;
      const tokens = this.lexer.blockTokens(text);
      this.lexer.state.top = top;
      return {
        type: "blockquote",
        raw: cap[0],
        tokens,
        text
      };
    }
  }
  list(src) {
    let cap = this.rules.block.list.exec(src);
    if (cap) {
      let bull = cap[1].trim();
      const isordered = bull.length > 1;
      const list = {
        type: "list",
        raw: "",
        ordered: isordered,
        start: isordered ? +bull.slice(0, -1) : "",
        loose: false,
        items: []
      };
      bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
      if (this.options.pedantic) {
        bull = isordered ? bull : "[*+-]";
      }
      const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
      let raw = "";
      let itemContents = "";
      let endsWithBlankLine = false;
      while (src) {
        let endEarly = false;
        if (!(cap = itemRegex.exec(src))) {
          break;
        }
        if (this.rules.block.hr.test(src)) {
          break;
        }
        raw = cap[0];
        src = src.substring(raw.length);
        let line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t) => " ".repeat(3 * t.length));
        let nextLine = src.split("\n", 1)[0];
        let indent = 0;
        if (this.options.pedantic) {
          indent = 2;
          itemContents = line.trimStart();
        } else {
          indent = cap[2].search(/[^ ]/);
          indent = indent > 4 ? 1 : indent;
          itemContents = line.slice(indent);
          indent += cap[1].length;
        }
        let blankLine = false;
        if (!line && /^ *$/.test(nextLine)) {
          raw += nextLine + "\n";
          src = src.substring(nextLine.length + 1);
          endEarly = true;
        }
        if (!endEarly) {
          const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
          const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
          const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
          const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
          while (src) {
            const rawLine = src.split("\n", 1)[0];
            nextLine = rawLine;
            if (this.options.pedantic) {
              nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
            }
            if (fencesBeginRegex.test(nextLine)) {
              break;
            }
            if (headingBeginRegex.test(nextLine)) {
              break;
            }
            if (nextBulletRegex.test(nextLine)) {
              break;
            }
            if (hrRegex.test(src)) {
              break;
            }
            if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
              itemContents += "\n" + nextLine.slice(indent);
            } else {
              if (blankLine) {
                break;
              }
              if (line.search(/[^ ]/) >= 4) {
                break;
              }
              if (fencesBeginRegex.test(line)) {
                break;
              }
              if (headingBeginRegex.test(line)) {
                break;
              }
              if (hrRegex.test(line)) {
                break;
              }
              itemContents += "\n" + nextLine;
            }
            if (!blankLine && !nextLine.trim()) {
              blankLine = true;
            }
            raw += rawLine + "\n";
            src = src.substring(rawLine.length + 1);
            line = nextLine.slice(indent);
          }
        }
        if (!list.loose) {
          if (endsWithBlankLine) {
            list.loose = true;
          } else if (/\n *\n *$/.test(raw)) {
            endsWithBlankLine = true;
          }
        }
        let istask = null;
        let ischecked;
        if (this.options.gfm) {
          istask = /^\[[ xX]\] /.exec(itemContents);
          if (istask) {
            ischecked = istask[0] !== "[ ] ";
            itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
          }
        }
        list.items.push({
          type: "list_item",
          raw,
          task: !!istask,
          checked: ischecked,
          loose: false,
          text: itemContents,
          tokens: []
        });
        list.raw += raw;
      }
      list.items[list.items.length - 1].raw = raw.trimEnd();
      list.items[list.items.length - 1].text = itemContents.trimEnd();
      list.raw = list.raw.trimEnd();
      for (let i = 0; i < list.items.length; i++) {
        this.lexer.state.top = false;
        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);
        if (!list.loose) {
          const spacers = list.items[i].tokens.filter((t) => t.type === "space");
          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t) => /\n.*\n/.test(t.raw));
          list.loose = hasMultipleLineBreaks;
        }
      }
      if (list.loose) {
        for (let i = 0; i < list.items.length; i++) {
          list.items[i].loose = true;
        }
      }
      return list;
    }
  }
  html(src) {
    const cap = this.rules.block.html.exec(src);
    if (cap) {
      const token = {
        type: "html",
        block: true,
        raw: cap[0],
        pre: cap[1] === "pre" || cap[1] === "script" || cap[1] === "style",
        text: cap[0]
      };
      return token;
    }
  }
  def(src) {
    const cap = this.rules.block.def.exec(src);
    if (cap) {
      const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
      const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
      return {
        type: "def",
        tag,
        raw: cap[0],
        href,
        title
      };
    }
  }
  table(src) {
    const cap = this.rules.block.table.exec(src);
    if (cap) {
      if (!/[:|]/.test(cap[2])) {
        return;
      }
      const item = {
        type: "table",
        raw: cap[0],
        header: splitCells(cap[1]).map((c) => {
          return { text: c, tokens: [] };
        }),
        align: cap[2].replace(/^\||\| *$/g, "").split("|"),
        rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
      };
      if (item.header.length === item.align.length) {
        let l = item.align.length;
        let i, j, k, row;
        for (i = 0; i < l; i++) {
          const align = item.align[i];
          if (align) {
            if (/^ *-+: *$/.test(align)) {
              item.align[i] = "right";
            } else if (/^ *:-+: *$/.test(align)) {
              item.align[i] = "center";
            } else if (/^ *:-+ *$/.test(align)) {
              item.align[i] = "left";
            } else {
              item.align[i] = null;
            }
          }
        }
        l = item.rows.length;
        for (i = 0; i < l; i++) {
          item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
            return { text: c, tokens: [] };
          });
        }
        l = item.header.length;
        for (j = 0; j < l; j++) {
          item.header[j].tokens = this.lexer.inline(item.header[j].text);
        }
        l = item.rows.length;
        for (j = 0; j < l; j++) {
          row = item.rows[j];
          for (k = 0; k < row.length; k++) {
            row[k].tokens = this.lexer.inline(row[k].text);
          }
        }
        return item;
      }
    }
  }
  lheading(src) {
    const cap = this.rules.block.lheading.exec(src);
    if (cap) {
      return {
        type: "heading",
        raw: cap[0],
        depth: cap[2].charAt(0) === "=" ? 1 : 2,
        text: cap[1],
        tokens: this.lexer.inline(cap[1])
      };
    }
  }
  paragraph(src) {
    const cap = this.rules.block.paragraph.exec(src);
    if (cap) {
      const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
      return {
        type: "paragraph",
        raw: cap[0],
        text,
        tokens: this.lexer.inline(text)
      };
    }
  }
  text(src) {
    const cap = this.rules.block.text.exec(src);
    if (cap) {
      return {
        type: "text",
        raw: cap[0],
        text: cap[0],
        tokens: this.lexer.inline(cap[0])
      };
    }
  }
  escape(src) {
    const cap = this.rules.inline.escape.exec(src);
    if (cap) {
      return {
        type: "escape",
        raw: cap[0],
        text: escape(cap[1])
      };
    }
  }
  tag(src) {
    const cap = this.rules.inline.tag.exec(src);
    if (cap) {
      if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
        this.lexer.state.inLink = true;
      } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
        this.lexer.state.inLink = false;
      }
      if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = true;
      } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
        this.lexer.state.inRawBlock = false;
      }
      return {
        type: "html",
        raw: cap[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: false,
        text: cap[0]
      };
    }
  }
  link(src) {
    const cap = this.rules.inline.link.exec(src);
    if (cap) {
      const trimmedUrl = cap[2].trim();
      if (!this.options.pedantic && /^</.test(trimmedUrl)) {
        if (!/>$/.test(trimmedUrl)) {
          return;
        }
        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
          return;
        }
      } else {
        const lastParenIndex = findClosingBracket(cap[2], "()");
        if (lastParenIndex > -1) {
          const start = cap[0].indexOf("!") === 0 ? 5 : 4;
          const linkLen = start + cap[1].length + lastParenIndex;
          cap[2] = cap[2].substring(0, lastParenIndex);
          cap[0] = cap[0].substring(0, linkLen).trim();
          cap[3] = "";
        }
      }
      let href = cap[2];
      let title = "";
      if (this.options.pedantic) {
        const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
        if (link) {
          href = link[1];
          title = link[3];
        }
      } else {
        title = cap[3] ? cap[3].slice(1, -1) : "";
      }
      href = href.trim();
      if (/^</.test(href)) {
        if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
          href = href.slice(1);
        } else {
          href = href.slice(1, -1);
        }
      }
      return outputLink(cap, {
        href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
        title: title ? title.replace(this.rules.inline._escapes, "$1") : title
      }, cap[0], this.lexer);
    }
  }
  reflink(src, links) {
    let cap;
    if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
      let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
      link = links[link.toLowerCase()];
      if (!link) {
        const text = cap[0].charAt(0);
        return {
          type: "text",
          raw: text,
          text
        };
      }
      return outputLink(cap, link, cap[0], this.lexer);
    }
  }
  emStrong(src, maskedSrc, prevChar = "") {
    let match = this.rules.inline.emStrong.lDelim.exec(src);
    if (!match)
      return;
    if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
      return;
    const nextChar = match[1] || match[2] || "";
    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {
      const lLength = [...match[0]].length - 1;
      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
      const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
      endReg.lastIndex = 0;
      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
      while ((match = endReg.exec(maskedSrc)) != null) {
        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
        if (!rDelim)
          continue;
        rLength = [...rDelim].length;
        if (match[3] || match[4]) {
          delimTotal += rLength;
          continue;
        } else if (match[5] || match[6]) {
          if (lLength % 3 && !((lLength + rLength) % 3)) {
            midDelimTotal += rLength;
            continue;
          }
        }
        delimTotal -= rLength;
        if (delimTotal > 0)
          continue;
        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
        const lastCharLength = [...match[0]][0].length;
        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);
        if (Math.min(lLength, rLength) % 2) {
          const text2 = raw.slice(1, -1);
          return {
            type: "em",
            raw,
            text: text2,
            tokens: this.lexer.inlineTokens(text2)
          };
        }
        const text = raw.slice(2, -2);
        return {
          type: "strong",
          raw,
          text,
          tokens: this.lexer.inlineTokens(text)
        };
      }
    }
  }
  codespan(src) {
    const cap = this.rules.inline.code.exec(src);
    if (cap) {
      let text = cap[2].replace(/\n/g, " ");
      const hasNonSpaceChars = /[^ ]/.test(text);
      const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
        text = text.substring(1, text.length - 1);
      }
      text = escape(text, true);
      return {
        type: "codespan",
        raw: cap[0],
        text
      };
    }
  }
  br(src) {
    const cap = this.rules.inline.br.exec(src);
    if (cap) {
      return {
        type: "br",
        raw: cap[0]
      };
    }
  }
  del(src) {
    const cap = this.rules.inline.del.exec(src);
    if (cap) {
      return {
        type: "del",
        raw: cap[0],
        text: cap[2],
        tokens: this.lexer.inlineTokens(cap[2])
      };
    }
  }
  autolink(src) {
    const cap = this.rules.inline.autolink.exec(src);
    if (cap) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(cap[1]);
        href = "mailto:" + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  url(src) {
    let cap;
    if (cap = this.rules.inline.url.exec(src)) {
      let text, href;
      if (cap[2] === "@") {
        text = escape(cap[0]);
        href = "mailto:" + text;
      } else {
        let prevCapZero;
        do {
          prevCapZero = cap[0];
          cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
        } while (prevCapZero !== cap[0]);
        text = escape(cap[0]);
        if (cap[1] === "www.") {
          href = "http://" + cap[0];
        } else {
          href = cap[0];
        }
      }
      return {
        type: "link",
        raw: cap[0],
        text,
        href,
        tokens: [
          {
            type: "text",
            raw: text,
            text
          }
        ]
      };
    }
  }
  inlineText(src) {
    const cap = this.rules.inline.text.exec(src);
    if (cap) {
      let text;
      if (this.lexer.state.inRawBlock) {
        text = cap[0];
      } else {
        text = escape(cap[0]);
      }
      return {
        type: "text",
        raw: cap[0],
        text
      };
    }
  }
};
var block = {
  newline: /^(?: *(?:\n|$))+/,
  code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
  fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
  hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
  heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
  blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
  list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
  html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
  def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
  table: noopTest,
  lheading: /^(?!bull )((?:.|\n(?!\s*?\n|bull ))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  // regex template, placeholders will be replaced according to different paragraph
  // interruption rules of commonmark and the original markdown spec:
  _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
  text: /^[^\n]+/
};
block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
block.lheading = edit(block.lheading).replace(/bull/g, block.bullet).getRegex();
block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
block.normal = { ...block };
block.gfm = {
  ...block.normal,
  table: "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
  // Cells
};
block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
block.pedantic = {
  ...block.normal,
  html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
};
var inline = {
  escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
  autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
  url: noopTest,
  tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
  link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
  reflink: /^!?\[(label)\]\[(ref)\]/,
  nolink: /^!?\[(ref)\](?:\[\])?/,
  reflinkSearch: "reflink|nolink(?!\\()",
  emStrong: {
    lDelim: /^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/,
    //         (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
    //         | Skip orphan inside strong      | Consume to delim | (1) #***              | (2) a***#, a***                    | (3) #***a, ***a                  | (4) ***#                 | (5) #***#                         | (6) a***a
    rDelimAst: /^[^_*]*?__[^_*]*?\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\*)[punct](\*+)(?=[\s]|$)|[^punct\s](\*+)(?!\*)(?=[punct\s]|$)|(?!\*)[punct\s](\*+)(?=[^punct\s])|[\s](\*+)(?!\*)(?=[punct])|(?!\*)[punct](\*+)(?!\*)(?=[punct])|[^punct\s](\*+)(?=[^punct\s])/,
    rDelimUnd: /^[^_*]*?\*\*[^_*]*?_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\s]|$)|[^punct\s](_+)(?!_)(?=[punct\s]|$)|(?!_)[punct\s](_+)(?=[^punct\s])|[\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])/
    // ^- Not allowed for _
  },
  code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
  br: /^( {2,}|\\)\n(?!\s*$)/,
  del: noopTest,
  text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
  punctuation: /^((?![*_])[\spunctuation])/
};
inline._punctuation = "\\p{P}$+<=>`^|~";
inline.punctuation = edit(inline.punctuation, "u").replace(/punctuation/g, inline._punctuation).getRegex();
inline.blockSkip = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g;
inline.anyPunctuation = /\\[punct]/g;
inline._escapes = /\\([punct])/g;
inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
inline.emStrong.lDelim = edit(inline.emStrong.lDelim, "u").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline.anyPunctuation = edit(inline.anyPunctuation, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline._escapes = edit(inline._escapes, "gu").replace(/punct/g, inline._punctuation).getRegex();
inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
inline.normal = { ...inline };
inline.pedantic = {
  ...inline.normal,
  strong: {
    start: /^__|\*\*/,
    middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
    endAst: /\*\*(?!\*)/g,
    endUnd: /__(?!_)/g
  },
  em: {
    start: /^_|\*/,
    middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
    endAst: /\*(?!\*)/g,
    endUnd: /_(?!_)/g
  },
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
};
inline.gfm = {
  ...inline.normal,
  escape: edit(inline.escape).replace("])", "~|])").getRegex(),
  _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
  url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
};
inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
inline.breaks = {
  ...inline.gfm,
  br: edit(inline.br).replace("{2,}", "*").getRegex(),
  text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
};
var _Lexer = class __Lexer {
  constructor(options2) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [];
    this.tokens.links = /* @__PURE__ */ Object.create(null);
    this.options = options2 || _defaults;
    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();
    this.tokenizer = this.options.tokenizer;
    this.tokenizer.options = this.options;
    this.tokenizer.lexer = this;
    this.inlineQueue = [];
    this.state = {
      inLink: false,
      inRawBlock: false,
      top: true
    };
    const rules = {
      block: block.normal,
      inline: inline.normal
    };
    if (this.options.pedantic) {
      rules.block = block.pedantic;
      rules.inline = inline.pedantic;
    } else if (this.options.gfm) {
      rules.block = block.gfm;
      if (this.options.breaks) {
        rules.inline = inline.breaks;
      } else {
        rules.inline = inline.gfm;
      }
    }
    this.tokenizer.rules = rules;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.lex(src);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(src, options2) {
    const lexer2 = new __Lexer(options2);
    return lexer2.inlineTokens(src);
  }
  /**
   * Preprocessing
   */
  lex(src) {
    src = src.replace(/\r\n|\r/g, "\n");
    this.blockTokens(src, this.tokens);
    let next;
    while (next = this.inlineQueue.shift()) {
      this.inlineTokens(next.src, next.tokens);
    }
    return this.tokens;
  }
  blockTokens(src, tokens = []) {
    if (this.options.pedantic) {
      src = src.replace(/\t/g, "    ").replace(/^ +$/gm, "");
    } else {
      src = src.replace(/^( *)(\t+)/gm, (_, leading, tabs) => {
        return leading + "    ".repeat(tabs.length);
      });
    }
    let token;
    let lastToken;
    let cutSrc;
    let lastParagraphClipped;
    while (src) {
      if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.space(src)) {
        src = src.substring(token.raw.length);
        if (token.raw.length === 1 && tokens.length > 0) {
          tokens[tokens.length - 1].raw += "\n";
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.code(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.fences(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.heading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.hr(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.blockquote(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.list(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.html(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.def(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.raw;
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else if (!this.tokens.links[token.tag]) {
          this.tokens.links[token.tag] = {
            href: token.href,
            title: token.title
          };
        }
        continue;
      }
      if (token = this.tokenizer.table(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.lheading(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startBlock) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startBlock.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
        lastToken = tokens[tokens.length - 1];
        if (lastParagraphClipped && lastToken.type === "paragraph") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        lastParagraphClipped = cutSrc.length !== src.length;
        src = src.substring(token.raw.length);
        continue;
      }
      if (token = this.tokenizer.text(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += "\n" + token.raw;
          lastToken.text += "\n" + token.text;
          this.inlineQueue.pop();
          this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    this.state.top = true;
    return tokens;
  }
  inline(src, tokens = []) {
    this.inlineQueue.push({ src, tokens });
    return tokens;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(src, tokens = []) {
    let token, lastToken, cutSrc;
    let maskedSrc = src;
    let match;
    let keepPrevChar, prevChar;
    if (this.tokens.links) {
      const links = Object.keys(this.tokens.links);
      if (links.length > 0) {
        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
          if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
            maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
          }
        }
      }
    }
    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "[" + "a".repeat(match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    }
    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {
      maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    }
    while (src) {
      if (!keepPrevChar) {
        prevChar = "";
      }
      keepPrevChar = false;
      if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
          src = src.substring(token.raw.length);
          tokens.push(token);
          return true;
        }
        return false;
      })) {
        continue;
      }
      if (token = this.tokenizer.escape(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.tag(src)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.link(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.reflink(src, this.tokens.links)) {
        src = src.substring(token.raw.length);
        lastToken = tokens[tokens.length - 1];
        if (lastToken && token.type === "text" && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.codespan(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.br(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.del(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (token = this.tokenizer.autolink(src)) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      if (!this.state.inLink && (token = this.tokenizer.url(src))) {
        src = src.substring(token.raw.length);
        tokens.push(token);
        continue;
      }
      cutSrc = src;
      if (this.options.extensions && this.options.extensions.startInline) {
        let startIndex = Infinity;
        const tempSrc = src.slice(1);
        let tempStart;
        this.options.extensions.startInline.forEach((getStartIndex) => {
          tempStart = getStartIndex.call({ lexer: this }, tempSrc);
          if (typeof tempStart === "number" && tempStart >= 0) {
            startIndex = Math.min(startIndex, tempStart);
          }
        });
        if (startIndex < Infinity && startIndex >= 0) {
          cutSrc = src.substring(0, startIndex + 1);
        }
      }
      if (token = this.tokenizer.inlineText(cutSrc)) {
        src = src.substring(token.raw.length);
        if (token.raw.slice(-1) !== "_") {
          prevChar = token.raw.slice(-1);
        }
        keepPrevChar = true;
        lastToken = tokens[tokens.length - 1];
        if (lastToken && lastToken.type === "text") {
          lastToken.raw += token.raw;
          lastToken.text += token.text;
        } else {
          tokens.push(token);
        }
        continue;
      }
      if (src) {
        const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
        if (this.options.silent) {
          console.error(errMsg);
          break;
        } else {
          throw new Error(errMsg);
        }
      }
    }
    return tokens;
  }
};
var _Renderer = class {
  constructor(options2) {
    __publicField(this, "options");
    this.options = options2 || _defaults;
  }
  code(code, infostring, escaped) {
    const lang = (infostring || "").match(/^\S*/)?.[0];
    code = code.replace(/\n$/, "") + "\n";
    if (!lang) {
      return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
    }
    return '<pre><code class="language-' + escape(lang) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
  }
  blockquote(quote) {
    return `<blockquote>
${quote}</blockquote>
`;
  }
  html(html, block2) {
    return html;
  }
  heading(text, level, raw) {
    return `<h${level}>${text}</h${level}>
`;
  }
  hr() {
    return "<hr>\n";
  }
  list(body, ordered, start) {
    const type = ordered ? "ol" : "ul";
    const startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
    return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
  }
  listitem(text, task, checked) {
    return `<li>${text}</li>
`;
  }
  checkbox(checked) {
    return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph(text) {
    return `<p>${text}</p>
`;
  }
  table(header, body) {
    if (body)
      body = `<tbody>${body}</tbody>`;
    return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
  }
  tablerow(content) {
    return `<tr>
${content}</tr>
`;
  }
  tablecell(content, flags) {
    const type = flags.header ? "th" : "td";
    const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
    return tag + content + `</${type}>
`;
  }
  /**
   * span level renderer
   */
  strong(text) {
    return `<strong>${text}</strong>`;
  }
  em(text) {
    return `<em>${text}</em>`;
  }
  codespan(text) {
    return `<code>${text}</code>`;
  }
  br() {
    return "<br>";
  }
  del(text) {
    return `<del>${text}</del>`;
  }
  link(href, title, text) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = '<a href="' + href + '"';
    if (title) {
      out += ' title="' + title + '"';
    }
    out += ">" + text + "</a>";
    return out;
  }
  image(href, title, text) {
    const cleanHref = cleanUrl(href);
    if (cleanHref === null) {
      return text;
    }
    href = cleanHref;
    let out = `<img src="${href}" alt="${text}"`;
    if (title) {
      out += ` title="${title}"`;
    }
    out += ">";
    return out;
  }
  text(text) {
    return text;
  }
};
var _TextRenderer = class {
  // no need for block level renderers
  strong(text) {
    return text;
  }
  em(text) {
    return text;
  }
  codespan(text) {
    return text;
  }
  del(text) {
    return text;
  }
  html(text) {
    return text;
  }
  text(text) {
    return text;
  }
  link(href, title, text) {
    return "" + text;
  }
  image(href, title, text) {
    return "" + text;
  }
  br() {
    return "";
  }
};
var _Parser = class __Parser {
  constructor(options2) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = options2 || _defaults;
    this.options.renderer = this.options.renderer || new _Renderer();
    this.renderer = this.options.renderer;
    this.renderer.options = this.options;
    this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parse(tokens);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(tokens, options2) {
    const parser2 = new __Parser(options2);
    return parser2.parseInline(tokens);
  }
  /**
   * Parse Loop
   */
  parse(tokens, top = true) {
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const genericToken = token;
        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);
        if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(genericToken.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "space": {
          continue;
        }
        case "hr": {
          out += this.renderer.hr();
          continue;
        }
        case "heading": {
          const headingToken = token;
          out += this.renderer.heading(this.parseInline(headingToken.tokens), headingToken.depth, unescape(this.parseInline(headingToken.tokens, this.textRenderer)));
          continue;
        }
        case "code": {
          const codeToken = token;
          out += this.renderer.code(codeToken.text, codeToken.lang, !!codeToken.escaped);
          continue;
        }
        case "table": {
          const tableToken = token;
          let header = "";
          let cell = "";
          for (let j = 0; j < tableToken.header.length; j++) {
            cell += this.renderer.tablecell(this.parseInline(tableToken.header[j].tokens), { header: true, align: tableToken.align[j] });
          }
          header += this.renderer.tablerow(cell);
          let body = "";
          for (let j = 0; j < tableToken.rows.length; j++) {
            const row = tableToken.rows[j];
            cell = "";
            for (let k = 0; k < row.length; k++) {
              cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: tableToken.align[k] });
            }
            body += this.renderer.tablerow(cell);
          }
          out += this.renderer.table(header, body);
          continue;
        }
        case "blockquote": {
          const blockquoteToken = token;
          const body = this.parse(blockquoteToken.tokens);
          out += this.renderer.blockquote(body);
          continue;
        }
        case "list": {
          const listToken = token;
          const ordered = listToken.ordered;
          const start = listToken.start;
          const loose = listToken.loose;
          let body = "";
          for (let j = 0; j < listToken.items.length; j++) {
            const item = listToken.items[j];
            const checked = item.checked;
            const task = item.task;
            let itemBody = "";
            if (item.task) {
              const checkbox = this.renderer.checkbox(!!checked);
              if (loose) {
                if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                  item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                  if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                    item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                  }
                } else {
                  item.tokens.unshift({
                    type: "text",
                    text: checkbox + " "
                  });
                }
              } else {
                itemBody += checkbox + " ";
              }
            }
            itemBody += this.parse(item.tokens, loose);
            body += this.renderer.listitem(itemBody, task, !!checked);
          }
          out += this.renderer.list(body, ordered, start);
          continue;
        }
        case "html": {
          const htmlToken = token;
          out += this.renderer.html(htmlToken.text, htmlToken.block);
          continue;
        }
        case "paragraph": {
          const paragraphToken = token;
          out += this.renderer.paragraph(this.parseInline(paragraphToken.tokens));
          continue;
        }
        case "text": {
          let textToken = token;
          let body = textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text;
          while (i + 1 < tokens.length && tokens[i + 1].type === "text") {
            textToken = tokens[++i];
            body += "\n" + (textToken.tokens ? this.parseInline(textToken.tokens) : textToken.text);
          }
          out += top ? this.renderer.paragraph(body) : body;
          continue;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(tokens, renderer) {
    renderer = renderer || this.renderer;
    let out = "";
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
        const ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
        if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
          out += ret || "";
          continue;
        }
      }
      switch (token.type) {
        case "escape": {
          const escapeToken = token;
          out += renderer.text(escapeToken.text);
          break;
        }
        case "html": {
          const tagToken = token;
          out += renderer.html(tagToken.text);
          break;
        }
        case "link": {
          const linkToken = token;
          out += renderer.link(linkToken.href, linkToken.title, this.parseInline(linkToken.tokens, renderer));
          break;
        }
        case "image": {
          const imageToken = token;
          out += renderer.image(imageToken.href, imageToken.title, imageToken.text);
          break;
        }
        case "strong": {
          const strongToken = token;
          out += renderer.strong(this.parseInline(strongToken.tokens, renderer));
          break;
        }
        case "em": {
          const emToken = token;
          out += renderer.em(this.parseInline(emToken.tokens, renderer));
          break;
        }
        case "codespan": {
          const codespanToken = token;
          out += renderer.codespan(codespanToken.text);
          break;
        }
        case "br": {
          out += renderer.br();
          break;
        }
        case "del": {
          const delToken = token;
          out += renderer.del(this.parseInline(delToken.tokens, renderer));
          break;
        }
        case "text": {
          const textToken = token;
          out += renderer.text(textToken.text);
          break;
        }
        default: {
          const errMsg = 'Token with "' + token.type + '" type was not found.';
          if (this.options.silent) {
            console.error(errMsg);
            return "";
          } else {
            throw new Error(errMsg);
          }
        }
      }
    }
    return out;
  }
};
var _Hooks = class {
  constructor(options2) {
    __publicField(this, "options");
    this.options = options2 || _defaults;
  }
  /**
   * Process markdown before marked
   */
  preprocess(markdown) {
    return markdown;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(html) {
    return html;
  }
};
__publicField(_Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
  "preprocess",
  "postprocess"
]));
var _parseMarkdown, parseMarkdown_fn, _onError, onError_fn;
var Marked = class {
  constructor(...args) {
    __privateAdd(this, _parseMarkdown);
    __privateAdd(this, _onError);
    __publicField(this, "defaults", _getDefaults());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lex, _Parser.parse));
    __publicField(this, "parseInline", __privateMethod(this, _parseMarkdown, parseMarkdown_fn).call(this, _Lexer.lexInline, _Parser.parseInline));
    __publicField(this, "Parser", _Parser);
    __publicField(this, "Renderer", _Renderer);
    __publicField(this, "TextRenderer", _TextRenderer);
    __publicField(this, "Lexer", _Lexer);
    __publicField(this, "Tokenizer", _Tokenizer);
    __publicField(this, "Hooks", _Hooks);
    this.use(...args);
  }
  /**
   * Run callback for every token
   */
  walkTokens(tokens, callback2) {
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback2.call(this, token));
      switch (token.type) {
        case "table": {
          const tableToken = token;
          for (const cell of tableToken.header) {
            values = values.concat(this.walkTokens(cell.tokens, callback2));
          }
          for (const row of tableToken.rows) {
            for (const cell of row) {
              values = values.concat(this.walkTokens(cell.tokens, callback2));
            }
          }
          break;
        }
        case "list": {
          const listToken = token;
          values = values.concat(this.walkTokens(listToken.items, callback2));
          break;
        }
        default: {
          const genericToken = token;
          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {
            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {
              values = values.concat(this.walkTokens(genericToken[childTokens], callback2));
            });
          } else if (genericToken.tokens) {
            values = values.concat(this.walkTokens(genericToken.tokens, callback2));
          }
        }
      }
    }
    return values;
  }
  use(...args) {
    const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack) => {
      const opts = { ...pack };
      opts.async = this.defaults.async || opts.async || false;
      if (pack.extensions) {
        pack.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if ("renderer" in ext) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if ("tokenizer" in ext) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            const extLevel = extensions[ext.level];
            if (extLevel) {
              extLevel.unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if ("childTokens" in ext && ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack.renderer) {
        const renderer = this.defaults.renderer || new _Renderer(this.defaults);
        for (const prop in pack.renderer) {
          const rendererFunc = pack.renderer[prop];
          const rendererKey = prop;
          const prevRenderer = renderer[rendererKey];
          renderer[rendererKey] = (...args2) => {
            let ret = rendererFunc.apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret || "";
          };
        }
        opts.renderer = renderer;
      }
      if (pack.tokenizer) {
        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const prop in pack.tokenizer) {
          const tokenizerFunc = pack.tokenizer[prop];
          const tokenizerKey = prop;
          const prevTokenizer = tokenizer[tokenizerKey];
          tokenizer[tokenizerKey] = (...args2) => {
            let ret = tokenizerFunc.apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack.hooks) {
        const hooks = this.defaults.hooks || new _Hooks();
        for (const prop in pack.hooks) {
          const hooksFunc = pack.hooks[prop];
          const hooksKey = prop;
          const prevHook = hooks[hooksKey];
          if (_Hooks.passThroughHooks.has(prop)) {
            hooks[hooksKey] = (arg) => {
              if (this.defaults.async) {
                return Promise.resolve(hooksFunc.call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = hooksFunc.call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[hooksKey] = (...args2) => {
              let ret = hooksFunc.apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack.walkTokens) {
        const walkTokens2 = this.defaults.walkTokens;
        const packWalktokens = pack.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(packWalktokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      this.defaults = { ...this.defaults, ...opts };
    });
    return this;
  }
  setOptions(opt) {
    this.defaults = { ...this.defaults, ...opt };
    return this;
  }
  lexer(src, options2) {
    return _Lexer.lex(src, options2 ?? this.defaults);
  }
  parser(tokens, options2) {
    return _Parser.parse(tokens, options2 ?? this.defaults);
  }
};
_parseMarkdown = new WeakSet();
parseMarkdown_fn = function(lexer2, parser2) {
  return (src, options2) => {
    const origOpt = { ...options2 };
    const opt = { ...this.defaults, ...origOpt };
    if (this.defaults.async === true && origOpt.async === false) {
      if (!opt.silent) {
        console.warn("marked(): The async option was set to true by an extension. The async: false option sent to parse will be ignored.");
      }
      opt.async = true;
    }
    const throwError = __privateMethod(this, _onError, onError_fn).call(this, !!opt.silent, !!opt.async);
    if (typeof src === "undefined" || src === null) {
      return throwError(new Error("marked(): input parameter is undefined or null"));
    }
    if (typeof src !== "string") {
      return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected"));
    }
    if (opt.hooks) {
      opt.hooks.options = opt;
    }
    if (opt.async) {
      return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src).then((src2) => lexer2(src2, opt)).then((tokens) => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
    }
    try {
      if (opt.hooks) {
        src = opt.hooks.preprocess(src);
      }
      const tokens = lexer2(src, opt);
      if (opt.walkTokens) {
        this.walkTokens(tokens, opt.walkTokens);
      }
      let html = parser2(tokens, opt);
      if (opt.hooks) {
        html = opt.hooks.postprocess(html);
      }
      return html;
    } catch (e) {
      return throwError(e);
    }
  };
};
_onError = new WeakSet();
onError_fn = function(silent, async) {
  return (e) => {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (silent) {
      const msg = "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
      if (async) {
        return Promise.resolve(msg);
      }
      return msg;
    }
    if (async) {
      return Promise.reject(e);
    }
    throw e;
  };
};
var markedInstance = new Marked();
function marked(src, opt) {
  return markedInstance.parse(src, opt);
}
marked.options = marked.setOptions = function(options2) {
  markedInstance.setOptions(options2);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...args) {
  markedInstance.use(...args);
  marked.defaults = markedInstance.defaults;
  changeDefaults(marked.defaults);
  return marked;
};
marked.walkTokens = function(tokens, callback2) {
  return markedInstance.walkTokens(tokens, callback2);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
var options = marked.options;
var setOptions = marked.setOptions;
var use = marked.use;
var walkTokens = marked.walkTokens;
var parseInline = marked.parseInline;
var parser = _Parser.parse;
var lexer = _Lexer.lex;

// node_modules/@kurkle/color/dist/color.esm.js
function round(v) {
  return v + 0.5 | 0;
}
var lim = (v, l, h) => Math.max(Math.min(v, h), l);
function p2b(v) {
  return lim(round(v * 2.55), 0, 255);
}
function n2b(v) {
  return lim(round(v * 255), 0, 255);
}
function b2n(v) {
  return lim(round(v / 2.55) / 100, 0, 1);
}
function n2p(v) {
  return lim(round(v * 100), 0, 100);
}
var map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
var hex = [..."0123456789ABCDEF"];
var h1 = (b) => hex[b & 15];
var h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
var eq = (b) => (b & 240) >> 4 === (b & 15);
var isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
function hexParse(str) {
  var len = str.length;
  var ret;
  if (str[0] === "#") {
    if (len === 4 || len === 5) {
      ret = {
        r: 255 & map$1[str[1]] * 17,
        g: 255 & map$1[str[2]] * 17,
        b: 255 & map$1[str[3]] * 17,
        a: len === 5 ? map$1[str[4]] * 17 : 255
      };
    } else if (len === 7 || len === 9) {
      ret = {
        r: map$1[str[1]] << 4 | map$1[str[2]],
        g: map$1[str[3]] << 4 | map$1[str[4]],
        b: map$1[str[5]] << 4 | map$1[str[6]],
        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
      };
    }
  }
  return ret;
}
var alpha = (a, f) => a < 255 ? f(a) : "";
function hexString(v) {
  var f = isShort(v) ? h1 : h2;
  return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
}
var HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function hsl2rgbn(h, s, l) {
  const a = s * Math.min(l, 1 - l);
  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0), f(8), f(4)];
}
function hsv2rgbn(h, s, v) {
  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}
function hwb2rgbn(h, w, b) {
  const rgb = hsl2rgbn(h, 1, 0.5);
  let i;
  if (w + b > 1) {
    i = 1 / (w + b);
    w *= i;
    b *= i;
  }
  for (i = 0; i < 3; i++) {
    rgb[i] *= 1 - w - b;
    rgb[i] += w;
  }
  return rgb;
}
function hueValue(r, g, b, d, max) {
  if (r === max) {
    return (g - b) / d + (g < b ? 6 : 0);
  }
  if (g === max) {
    return (b - r) / d + 2;
  }
  return (r - g) / d + 4;
}
function rgb2hsl(v) {
  const range = 255;
  const r = v.r / range;
  const g = v.g / range;
  const b = v.b / range;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const l = (max + min) / 2;
  let h, s, d;
  if (max !== min) {
    d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    h = hueValue(r, g, b, d, max);
    h = h * 60 + 0.5;
  }
  return [h | 0, s || 0, l];
}
function calln(f, a, b, c) {
  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
}
function hsl2rgb(h, s, l) {
  return calln(hsl2rgbn, h, s, l);
}
function hwb2rgb(h, w, b) {
  return calln(hwb2rgbn, h, w, b);
}
function hsv2rgb(h, s, v) {
  return calln(hsv2rgbn, h, s, v);
}
function hue(h) {
  return (h % 360 + 360) % 360;
}
function hueParse(str) {
  const m = HUE_RE.exec(str);
  let a = 255;
  let v;
  if (!m) {
    return;
  }
  if (m[5] !== v) {
    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
  }
  const h = hue(+m[2]);
  const p1 = +m[3] / 100;
  const p2 = +m[4] / 100;
  if (m[1] === "hwb") {
    v = hwb2rgb(h, p1, p2);
  } else if (m[1] === "hsv") {
    v = hsv2rgb(h, p1, p2);
  } else {
    v = hsl2rgb(h, p1, p2);
  }
  return {
    r: v[0],
    g: v[1],
    b: v[2],
    a
  };
}
function rotate(v, deg) {
  var h = rgb2hsl(v);
  h[0] = hue(h[0] + deg);
  h = hsl2rgb(h);
  v.r = h[0];
  v.g = h[1];
  v.b = h[2];
}
function hslString(v) {
  if (!v) {
    return;
  }
  const a = rgb2hsl(v);
  const h = a[0];
  const s = n2p(a[1]);
  const l = n2p(a[2]);
  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
}
var map = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
};
var names$1 = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function unpack() {
  const unpacked = {};
  const keys = Object.keys(names$1);
  const tkeys = Object.keys(map);
  let i, j, k, ok, nk;
  for (i = 0; i < keys.length; i++) {
    ok = nk = keys[i];
    for (j = 0; j < tkeys.length; j++) {
      k = tkeys[j];
      nk = nk.replace(k, map[k]);
    }
    k = parseInt(names$1[ok], 16);
    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
  }
  return unpacked;
}
var names;
function nameParse(str) {
  if (!names) {
    names = unpack();
    names.transparent = [0, 0, 0, 0];
  }
  const a = names[str.toLowerCase()];
  return a && {
    r: a[0],
    g: a[1],
    b: a[2],
    a: a.length === 4 ? a[3] : 255
  };
}
var RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function rgbParse(str) {
  const m = RGB_RE.exec(str);
  let a = 255;
  let r, g, b;
  if (!m) {
    return;
  }
  if (m[7] !== r) {
    const v = +m[7];
    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
  }
  r = +m[1];
  g = +m[3];
  b = +m[5];
  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
  return {
    r,
    g,
    b,
    a
  };
}
function rgbString(v) {
  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
}
var to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;
var from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
function interpolate(rgb1, rgb2, t) {
  const r = from(b2n(rgb1.r));
  const g = from(b2n(rgb1.g));
  const b = from(b2n(rgb1.b));
  return {
    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
    a: rgb1.a + t * (rgb2.a - rgb1.a)
  };
}
function modHSL(v, i, ratio) {
  if (v) {
    let tmp = rgb2hsl(v);
    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
    tmp = hsl2rgb(tmp);
    v.r = tmp[0];
    v.g = tmp[1];
    v.b = tmp[2];
  }
}
function clone(v, proto) {
  return v ? Object.assign(proto || {}, v) : v;
}
function fromObject(input) {
  var v = { r: 0, g: 0, b: 0, a: 255 };
  if (Array.isArray(input)) {
    if (input.length >= 3) {
      v = { r: input[0], g: input[1], b: input[2], a: 255 };
      if (input.length > 3) {
        v.a = n2b(input[3]);
      }
    }
  } else {
    v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
    v.a = n2b(v.a);
  }
  return v;
}
function functionParse(str) {
  if (str.charAt(0) === "r") {
    return rgbParse(str);
  }
  return hueParse(str);
}
var Color = class _Color {
  constructor(input) {
    if (input instanceof _Color) {
      return input;
    }
    const type = typeof input;
    let v;
    if (type === "object") {
      v = fromObject(input);
    } else if (type === "string") {
      v = hexParse(input) || nameParse(input) || functionParse(input);
    }
    this._rgb = v;
    this._valid = !!v;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var v = clone(this._rgb);
    if (v) {
      v.a = b2n(v.a);
    }
    return v;
  }
  set rgb(obj) {
    this._rgb = fromObject(obj);
  }
  rgbString() {
    return this._valid ? rgbString(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? hexString(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hslString(this._rgb) : void 0;
  }
  mix(color2, weight) {
    if (color2) {
      const c1 = this.rgb;
      const c2 = color2.rgb;
      let w2;
      const p = weight === w2 ? 0.5 : weight;
      const w = 2 * p - 1;
      const a = c1.a - c2.a;
      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
      w2 = 1 - w1;
      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
      c1.a = p * c1.a + (1 - p) * c2.a;
      this.rgb = c1;
    }
    return this;
  }
  interpolate(color2, t) {
    if (color2) {
      this._rgb = interpolate(this._rgb, color2._rgb, t);
    }
    return this;
  }
  clone() {
    return new _Color(this.rgb);
  }
  alpha(a) {
    this._rgb.a = n2b(a);
    return this;
  }
  clearer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 - ratio;
    return this;
  }
  greyscale() {
    const rgb = this._rgb;
    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
    rgb.r = rgb.g = rgb.b = val;
    return this;
  }
  opaquer(ratio) {
    const rgb = this._rgb;
    rgb.a *= 1 + ratio;
    return this;
  }
  negate() {
    const v = this._rgb;
    v.r = 255 - v.r;
    v.g = 255 - v.g;
    v.b = 255 - v.b;
    return this;
  }
  lighten(ratio) {
    modHSL(this._rgb, 2, ratio);
    return this;
  }
  darken(ratio) {
    modHSL(this._rgb, 2, -ratio);
    return this;
  }
  saturate(ratio) {
    modHSL(this._rgb, 1, ratio);
    return this;
  }
  desaturate(ratio) {
    modHSL(this._rgb, 1, -ratio);
    return this;
  }
  rotate(deg) {
    rotate(this._rgb, deg);
    return this;
  }
};

// node_modules/chart.js/dist/chunks/helpers.dataset.js
function noop() {
}
var uid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => id++;
})();
function isNullOrUndef(value) {
  return value === null || value === void 0;
}
function isArray(value) {
  if (Array.isArray && Array.isArray(value)) {
    return true;
  }
  const type = Object.prototype.toString.call(value);
  if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") {
    return true;
  }
  return false;
}
function isObject(value) {
  return value !== null && Object.prototype.toString.call(value) === "[object Object]";
}
function isNumberFinite(value) {
  return (typeof value === "number" || value instanceof Number) && isFinite(+value);
}
function finiteOrDefault(value, defaultValue) {
  return isNumberFinite(value) ? value : defaultValue;
}
function valueOrDefault(value, defaultValue) {
  return typeof value === "undefined" ? defaultValue : value;
}
var toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
var toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
function callback(fn, args, thisArg) {
  if (fn && typeof fn.call === "function") {
    return fn.apply(thisArg, args);
  }
}
function each(loopable, fn, thisArg, reverse) {
  let i, len, keys;
  if (isArray(loopable)) {
    len = loopable.length;
    if (reverse) {
      for (i = len - 1; i >= 0; i--) {
        fn.call(thisArg, loopable[i], i);
      }
    } else {
      for (i = 0; i < len; i++) {
        fn.call(thisArg, loopable[i], i);
      }
    }
  } else if (isObject(loopable)) {
    keys = Object.keys(loopable);
    len = keys.length;
    for (i = 0; i < len; i++) {
      fn.call(thisArg, loopable[keys[i]], keys[i]);
    }
  }
}
function _elementsEqual(a0, a1) {
  let i, ilen, v0, v1;
  if (!a0 || !a1 || a0.length !== a1.length) {
    return false;
  }
  for (i = 0, ilen = a0.length; i < ilen; ++i) {
    v0 = a0[i];
    v1 = a1[i];
    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
      return false;
    }
  }
  return true;
}
function clone2(source) {
  if (isArray(source)) {
    return source.map(clone2);
  }
  if (isObject(source)) {
    const target = /* @__PURE__ */ Object.create(null);
    const keys = Object.keys(source);
    const klen = keys.length;
    let k = 0;
    for (; k < klen; ++k) {
      target[keys[k]] = clone2(source[keys[k]]);
    }
    return target;
  }
  return source;
}
function isValidKey(key) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(key) === -1;
}
function _merger(key, target, source, options2) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    merge(tval, sval, options2);
  } else {
    target[key] = clone2(sval);
  }
}
function merge(target, source, options2) {
  const sources = isArray(source) ? source : [
    source
  ];
  const ilen = sources.length;
  if (!isObject(target)) {
    return target;
  }
  options2 = options2 || {};
  const merger = options2.merger || _merger;
  let current;
  for (let i = 0; i < ilen; ++i) {
    current = sources[i];
    if (!isObject(current)) {
      continue;
    }
    const keys = Object.keys(current);
    for (let k = 0, klen = keys.length; k < klen; ++k) {
      merger(keys[k], target, current, options2);
    }
  }
  return target;
}
function mergeIf(target, source) {
  return merge(target, source, {
    merger: _mergerIf
  });
}
function _mergerIf(key, target, source) {
  if (!isValidKey(key)) {
    return;
  }
  const tval = target[key];
  const sval = source[key];
  if (isObject(tval) && isObject(sval)) {
    mergeIf(tval, sval);
  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
    target[key] = clone2(sval);
  }
}
var keyResolvers = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (v) => v,
  // default resolvers
  x: (o) => o.x,
  y: (o) => o.y
};
function _splitKey(key) {
  const parts = key.split(".");
  const keys = [];
  let tmp = "";
  for (const part of parts) {
    tmp += part;
    if (tmp.endsWith("\\")) {
      tmp = tmp.slice(0, -1) + ".";
    } else {
      keys.push(tmp);
      tmp = "";
    }
  }
  return keys;
}
function _getKeyResolver(key) {
  const keys = _splitKey(key);
  return (obj) => {
    for (const k of keys) {
      if (k === "") {
        break;
      }
      obj = obj && obj[k];
    }
    return obj;
  };
}
function resolveObjectKey(obj, key) {
  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
  return resolver(obj);
}
function _capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var defined = (value) => typeof value !== "undefined";
var isFunction = (value) => typeof value === "function";
var setsEqual = (a, b) => {
  if (a.size !== b.size) {
    return false;
  }
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
};
function _isClickEvent(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
var PI = Math.PI;
var TAU = 2 * PI;
var PITAU = TAU + PI;
var INFINITY = Number.POSITIVE_INFINITY;
var RAD_PER_DEG = PI / 180;
var HALF_PI = PI / 2;
var QUARTER_PI = PI / 4;
var TWO_THIRDS_PI = PI * 2 / 3;
var log10 = Math.log10;
var sign = Math.sign;
function almostEquals(x, y, epsilon) {
  return Math.abs(x - y) < epsilon;
}
function niceNum(range) {
  const roundedRange = Math.round(range);
  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
  const niceRange = Math.pow(10, Math.floor(log10(range)));
  const fraction = range / niceRange;
  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
  return niceFraction * niceRange;
}
function _factorize(value) {
  const result = [];
  const sqrt = Math.sqrt(value);
  let i;
  for (i = 1; i < sqrt; i++) {
    if (value % i === 0) {
      result.push(i);
      result.push(value / i);
    }
  }
  if (sqrt === (sqrt | 0)) {
    result.push(sqrt);
  }
  result.sort((a, b) => a - b).pop();
  return result;
}
function isNonPrimitive(n) {
  return typeof n === "symbol" || typeof n === "object" && n !== null && !(Symbol.toPrimitive in n || "toString" in n || "valueOf" in n);
}
function isNumber(n) {
  return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
}
function almostWhole(x, epsilon) {
  const rounded = Math.round(x);
  return rounded - epsilon <= x && rounded + epsilon >= x;
}
function _setMinAndMaxByKey(array, target, property) {
  let i, ilen, value;
  for (i = 0, ilen = array.length; i < ilen; i++) {
    value = array[i][property];
    if (!isNaN(value)) {
      target.min = Math.min(target.min, value);
      target.max = Math.max(target.max, value);
    }
  }
}
function toRadians(degrees) {
  return degrees * (PI / 180);
}
function toDegrees(radians) {
  return radians * (180 / PI);
}
function _decimalPlaces(x) {
  if (!isNumberFinite(x)) {
    return;
  }
  let e = 1;
  let p = 0;
  while (Math.round(x * e) / e !== x) {
    e *= 10;
    p++;
  }
  return p;
}
function getAngleFromPoint(centrePoint, anglePoint) {
  const distanceFromXCenter = anglePoint.x - centrePoint.x;
  const distanceFromYCenter = anglePoint.y - centrePoint.y;
  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
  if (angle < -0.5 * PI) {
    angle += TAU;
  }
  return {
    angle,
    distance: radialDistanceFromCenter
  };
}
function distanceBetweenPoints(pt1, pt2) {
  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
}
function _angleDiff(a, b) {
  return (a - b + PITAU) % TAU - PI;
}
function _normalizeAngle(a) {
  return (a % TAU + TAU) % TAU;
}
function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
  const a = _normalizeAngle(angle);
  const s = _normalizeAngle(start);
  const e = _normalizeAngle(end);
  const angleToStart = _normalizeAngle(s - a);
  const angleToEnd = _normalizeAngle(e - a);
  const startToAngle = _normalizeAngle(a - s);
  const endToAngle = _normalizeAngle(a - e);
  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
}
function _limitValue(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function _int16Range(value) {
  return _limitValue(value, -32768, 32767);
}
function _isBetween(value, start, end, epsilon = 1e-6) {
  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
}
function _lookup(table, value, cmp) {
  cmp = cmp || ((index2) => table[index2] < value);
  let hi = table.length - 1;
  let lo = 0;
  let mid;
  while (hi - lo > 1) {
    mid = lo + hi >> 1;
    if (cmp(mid)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }
  return {
    lo,
    hi
  };
}
var _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {
  const ti = table[index2][key];
  return ti < value || ti === value && table[index2 + 1][key] === value;
} : (index2) => table[index2][key] < value);
var _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
function _filterBetween(values, min, max) {
  let start = 0;
  let end = values.length;
  while (start < end && values[start] < min) {
    start++;
  }
  while (end > start && values[end - 1] > max) {
    end--;
  }
  return start > 0 || end < values.length ? values.slice(start, end) : values;
}
var arrayEvents = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function listenArrayEvents(array, listener) {
  if (array._chartjs) {
    array._chartjs.listeners.push(listener);
    return;
  }
  Object.defineProperty(array, "_chartjs", {
    configurable: true,
    enumerable: false,
    value: {
      listeners: [
        listener
      ]
    }
  });
  arrayEvents.forEach((key) => {
    const method = "_onData" + _capitalize(key);
    const base = array[key];
    Object.defineProperty(array, key, {
      configurable: true,
      enumerable: false,
      value(...args) {
        const res = base.apply(this, args);
        array._chartjs.listeners.forEach((object) => {
          if (typeof object[method] === "function") {
            object[method](...args);
          }
        });
        return res;
      }
    });
  });
}
function unlistenArrayEvents(array, listener) {
  const stub = array._chartjs;
  if (!stub) {
    return;
  }
  const listeners = stub.listeners;
  const index2 = listeners.indexOf(listener);
  if (index2 !== -1) {
    listeners.splice(index2, 1);
  }
  if (listeners.length > 0) {
    return;
  }
  arrayEvents.forEach((key) => {
    delete array[key];
  });
  delete array._chartjs;
}
function _arrayUnique(items) {
  const set2 = new Set(items);
  if (set2.size === items.length) {
    return items;
  }
  return Array.from(set2);
}
var requestAnimFrame = function() {
  if (typeof window === "undefined") {
    return function(callback2) {
      return callback2();
    };
  }
  return window.requestAnimationFrame;
}();
function throttled(fn, thisArg) {
  let argsToUse = [];
  let ticking = false;
  return function(...args) {
    argsToUse = args;
    if (!ticking) {
      ticking = true;
      requestAnimFrame.call(window, () => {
        ticking = false;
        fn.apply(thisArg, argsToUse);
      });
    }
  };
}
function debounce(fn, delay) {
  let timeout;
  return function(...args) {
    if (delay) {
      clearTimeout(timeout);
      timeout = setTimeout(fn, delay, args);
    } else {
      fn.apply(this, args);
    }
    return delay;
  };
}
var _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
var _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
var _textX = (align, left, right, rtl) => {
  const check = rtl ? "left" : "right";
  return align === check ? right : align === "center" ? (left + right) / 2 : left;
};
function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
  const pointCount = points.length;
  let start = 0;
  let count = pointCount;
  if (meta._sorted) {
    const { iScale, vScale, _parsed } = meta;
    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;
    const axis = iScale.axis;
    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
    if (minDefined) {
      start = Math.min(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, axis, min).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
      );
      if (spanGaps) {
        const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        start -= Math.max(0, distanceToDefinedLo);
      }
      start = _limitValue(start, 0, pointCount - 1);
    }
    if (maxDefined) {
      let end = Math.max(
        // @ts-expect-error Need to type _parsed
        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1
      );
      if (spanGaps) {
        const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        end += Math.max(0, distanceToDefinedHi);
      }
      count = _limitValue(end, start, pointCount) - start;
    } else {
      count = pointCount - start;
    }
  }
  return {
    start,
    count
  };
}
function _scaleRangesChanged(meta) {
  const { xScale, yScale, _scaleRanges } = meta;
  const newRanges = {
    xmin: xScale.min,
    xmax: xScale.max,
    ymin: yScale.min,
    ymax: yScale.max
  };
  if (!_scaleRanges) {
    meta._scaleRanges = newRanges;
    return true;
  }
  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
  Object.assign(_scaleRanges, newRanges);
  return changed;
}
var atEdge = (t) => t === 0 || t === 1;
var elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));
var elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
var effects = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => -t * (t - 2),
  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => (t -= 1) * t * t + 1,
  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
  easeOutSine: (t) => Math.sin(t * HALF_PI),
  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
  easeInOutElastic(t) {
    const s = 0.1125;
    const p = 0.45;
    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
  },
  easeInBack(t) {
    const s = 1.70158;
    return t * t * ((s + 1) * t - s);
  },
  easeOutBack(t) {
    const s = 1.70158;
    return (t -= 1) * t * ((s + 1) * t + s) + 1;
  },
  easeInOutBack(t) {
    let s = 1.70158;
    if ((t /= 0.5) < 1) {
      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
    }
    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
  },
  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
  easeOutBounce(t) {
    const m = 7.5625;
    const d = 2.75;
    if (t < 1 / d) {
      return m * t * t;
    }
    if (t < 2 / d) {
      return m * (t -= 1.5 / d) * t + 0.75;
    }
    if (t < 2.5 / d) {
      return m * (t -= 2.25 / d) * t + 0.9375;
    }
    return m * (t -= 2.625 / d) * t + 0.984375;
  },
  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
};
function isPatternOrGradient(value) {
  if (value && typeof value === "object") {
    const type = value.toString();
    return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
  }
  return false;
}
function color(value) {
  return isPatternOrGradient(value) ? value : new Color(value);
}
function getHoverColor(value) {
  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();
}
var numbers = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
];
var colors = [
  "color",
  "borderColor",
  "backgroundColor"
];
function applyAnimationsDefaults(defaults2) {
  defaults2.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  });
  defaults2.describe("animation", {
    _fallback: false,
    _indexable: false,
    _scriptable: (name) => name !== "onProgress" && name !== "onComplete" && name !== "fn"
  });
  defaults2.set("animations", {
    colors: {
      type: "color",
      properties: colors
    },
    numbers: {
      type: "number",
      properties: numbers
    }
  });
  defaults2.describe("animations", {
    _fallback: "animation"
  });
  defaults2.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (v) => v | 0
        }
      }
    }
  });
}
function applyLayoutsDefaults(defaults2) {
  defaults2.set("layout", {
    autoPadding: true,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
var intlCache = /* @__PURE__ */ new Map();
function getNumberFormat(locale, options2) {
  options2 = options2 || {};
  const cacheKey = locale + JSON.stringify(options2);
  let formatter = intlCache.get(cacheKey);
  if (!formatter) {
    formatter = new Intl.NumberFormat(locale, options2);
    intlCache.set(cacheKey, formatter);
  }
  return formatter;
}
function formatNumber(num, locale, options2) {
  return getNumberFormat(locale, options2).format(num);
}
var formatters = {
  values(value) {
    return isArray(value) ? value : "" + value;
  },
  numeric(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const locale = this.chart.options.locale;
    let notation;
    let delta = tickValue;
    if (ticks.length > 1) {
      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
      if (maxTick < 1e-4 || maxTick > 1e15) {
        notation = "scientific";
      }
      delta = calculateDelta(tickValue, ticks);
    }
    const logDelta = log10(Math.abs(delta));
    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
    const options2 = {
      notation,
      minimumFractionDigits: numDecimal,
      maximumFractionDigits: numDecimal
    };
    Object.assign(options2, this.options.ticks.format);
    return formatNumber(tickValue, locale, options2);
  },
  logarithmic(tickValue, index2, ticks) {
    if (tickValue === 0) {
      return "0";
    }
    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
    if ([
      1,
      2,
      3,
      5,
      10,
      15
    ].includes(remain) || index2 > 0.8 * ticks.length) {
      return formatters.numeric.call(this, tickValue, index2, ticks);
    }
    return "";
  }
};
function calculateDelta(tickValue, ticks) {
  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
    delta = tickValue - Math.floor(tickValue);
  }
  return delta;
}
var Ticks = {
  formatters
};
function applyScaleDefaults(defaults2) {
  defaults2.set("scale", {
    display: true,
    offset: false,
    reverse: false,
    beginAtZero: false,
    bounds: "ticks",
    clip: true,
    grace: 0,
    grid: {
      display: true,
      lineWidth: 1,
      drawOnChartArea: true,
      drawTicks: true,
      tickLength: 8,
      tickWidth: (_ctx, options2) => options2.lineWidth,
      tickColor: (_ctx, options2) => options2.color,
      offset: false
    },
    border: {
      display: true,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: false,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: true,
      autoSkip: true,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: Ticks.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: false,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  });
  defaults2.route("scale.ticks", "color", "", "color");
  defaults2.route("scale.grid", "color", "", "borderColor");
  defaults2.route("scale.border", "color", "", "borderColor");
  defaults2.route("scale.title", "color", "", "color");
  defaults2.describe("scale", {
    _fallback: false,
    _scriptable: (name) => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
    _indexable: (name) => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
  });
  defaults2.describe("scales", {
    _fallback: "scale"
  });
  defaults2.describe("scale.ticks", {
    _scriptable: (name) => name !== "backdropPadding" && name !== "callback",
    _indexable: (name) => name !== "backdropPadding"
  });
}
var overrides = /* @__PURE__ */ Object.create(null);
var descriptors = /* @__PURE__ */ Object.create(null);
function getScope$1(node, key) {
  if (!key) {
    return node;
  }
  const keys = key.split(".");
  for (let i = 0, n = keys.length; i < n; ++i) {
    const k = keys[i];
    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));
  }
  return node;
}
function set(root, scope, values) {
  if (typeof scope === "string") {
    return merge(getScope$1(root, scope), values);
  }
  return merge(getScope$1(root, ""), scope);
}
var Defaults = class {
  constructor(_descriptors2, _appliers) {
    this.animation = void 0;
    this.backgroundColor = "rgba(0,0,0,0.1)";
    this.borderColor = "rgba(0,0,0,0.1)";
    this.color = "#666";
    this.datasets = {};
    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
    this.elements = {};
    this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ];
    this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    };
    this.hover = {};
    this.hoverBackgroundColor = (ctx, options2) => getHoverColor(options2.backgroundColor);
    this.hoverBorderColor = (ctx, options2) => getHoverColor(options2.borderColor);
    this.hoverColor = (ctx, options2) => getHoverColor(options2.color);
    this.indexAxis = "x";
    this.interaction = {
      mode: "nearest",
      intersect: true,
      includeInvisible: false
    };
    this.maintainAspectRatio = true;
    this.onHover = null;
    this.onClick = null;
    this.parsing = true;
    this.plugins = {};
    this.responsive = true;
    this.scale = void 0;
    this.scales = {};
    this.showLine = true;
    this.drawActiveElementsOnTop = true;
    this.describe(_descriptors2);
    this.apply(_appliers);
  }
  set(scope, values) {
    return set(this, scope, values);
  }
  get(scope) {
    return getScope$1(this, scope);
  }
  describe(scope, values) {
    return set(descriptors, scope, values);
  }
  override(scope, values) {
    return set(overrides, scope, values);
  }
  route(scope, name, targetScope, targetName) {
    const scopeObject = getScope$1(this, scope);
    const targetScopeObject = getScope$1(this, targetScope);
    const privateName = "_" + name;
    Object.defineProperties(scopeObject, {
      [privateName]: {
        value: scopeObject[name],
        writable: true
      },
      [name]: {
        enumerable: true,
        get() {
          const local = this[privateName];
          const target = targetScopeObject[targetName];
          if (isObject(local)) {
            return Object.assign({}, target, local);
          }
          return valueOrDefault(local, target);
        },
        set(value) {
          this[privateName] = value;
        }
      }
    });
  }
  apply(appliers) {
    appliers.forEach((apply) => apply(this));
  }
};
var defaults = /* @__PURE__ */ new Defaults({
  _scriptable: (name) => !name.startsWith("on"),
  _indexable: (name) => name !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: false,
    _indexable: false
  }
}, [
  applyAnimationsDefaults,
  applyLayoutsDefaults,
  applyScaleDefaults
]);
function toFontString(font) {
  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
    return null;
  }
  return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
}
function _measureText(ctx, data, gc, longest, string) {
  let textWidth = data[string];
  if (!textWidth) {
    textWidth = data[string] = ctx.measureText(string).width;
    gc.push(string);
  }
  if (textWidth > longest) {
    longest = textWidth;
  }
  return longest;
}
function _longestText(ctx, font, arrayOfThings, cache) {
  cache = cache || {};
  let data = cache.data = cache.data || {};
  let gc = cache.garbageCollect = cache.garbageCollect || [];
  if (cache.font !== font) {
    data = cache.data = {};
    gc = cache.garbageCollect = [];
    cache.font = font;
  }
  ctx.save();
  ctx.font = font;
  let longest = 0;
  const ilen = arrayOfThings.length;
  let i, j, jlen, thing, nestedThing;
  for (i = 0; i < ilen; i++) {
    thing = arrayOfThings[i];
    if (thing !== void 0 && thing !== null && !isArray(thing)) {
      longest = _measureText(ctx, data, gc, longest, thing);
    } else if (isArray(thing)) {
      for (j = 0, jlen = thing.length; j < jlen; j++) {
        nestedThing = thing[j];
        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
          longest = _measureText(ctx, data, gc, longest, nestedThing);
        }
      }
    }
  }
  ctx.restore();
  const gcLen = gc.length / 2;
  if (gcLen > arrayOfThings.length) {
    for (i = 0; i < gcLen; i++) {
      delete data[gc[i]];
    }
    gc.splice(0, gcLen);
  }
  return longest;
}
function _alignPixel(chart, pixel, width) {
  const devicePixelRatio = chart.currentDevicePixelRatio;
  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
}
function clearCanvas(canvas, ctx) {
  if (!ctx && !canvas) {
    return;
  }
  ctx = ctx || canvas.getContext("2d");
  ctx.save();
  ctx.resetTransform();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.restore();
}
function drawPoint(ctx, options2, x, y) {
  drawPointLegend(ctx, options2, x, y, null);
}
function drawPointLegend(ctx, options2, x, y, w) {
  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
  const style = options2.pointStyle;
  const rotation = options2.rotation;
  const radius = options2.radius;
  let rad = (rotation || 0) * RAD_PER_DEG;
  if (style && typeof style === "object") {
    type = style.toString();
    if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rad);
      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
      ctx.restore();
      return;
    }
  }
  if (isNaN(radius) || radius <= 0) {
    return;
  }
  ctx.beginPath();
  switch (style) {
    default:
      if (w) {
        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
      } else {
        ctx.arc(x, y, radius, 0, TAU);
      }
      ctx.closePath();
      break;
    case "triangle":
      width = w ? w / 2 : radius;
      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      rad += TWO_THIRDS_PI;
      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
      ctx.closePath();
      break;
    case "rectRounded":
      cornerRadius = radius * 0.516;
      size = radius - cornerRadius;
      xOffset = Math.cos(rad + QUARTER_PI) * size;
      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      yOffset = Math.sin(rad + QUARTER_PI) * size;
      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
      ctx.closePath();
      break;
    case "rect":
      if (!rotation) {
        size = Math.SQRT1_2 * radius;
        width = w ? w / 2 : size;
        ctx.rect(x - width, y - size, 2 * width, 2 * size);
        break;
      }
      rad += QUARTER_PI;
    case "rectRot":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      ctx.closePath();
      break;
    case "crossRot":
      rad += QUARTER_PI;
    case "cross":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "star":
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      rad += QUARTER_PI;
      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
      xOffset = Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
      ctx.moveTo(x - xOffsetW, y - yOffset);
      ctx.lineTo(x + xOffsetW, y + yOffset);
      ctx.moveTo(x + yOffsetW, y - xOffset);
      ctx.lineTo(x - yOffsetW, y + xOffset);
      break;
    case "line":
      xOffset = w ? w / 2 : Math.cos(rad) * radius;
      yOffset = Math.sin(rad) * radius;
      ctx.moveTo(x - xOffset, y - yOffset);
      ctx.lineTo(x + xOffset, y + yOffset);
      break;
    case "dash":
      ctx.moveTo(x, y);
      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
      break;
    case false:
      ctx.closePath();
      break;
  }
  ctx.fill();
  if (options2.borderWidth > 0) {
    ctx.stroke();
  }
}
function _isPointInArea(point, area, margin) {
  margin = margin || 0.5;
  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
}
function clipArea(ctx, area) {
  ctx.save();
  ctx.beginPath();
  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
  ctx.clip();
}
function unclipArea(ctx) {
  ctx.restore();
}
function _steppedLineTo(ctx, previous, target, flip, mode) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  if (mode === "middle") {
    const midpoint = (previous.x + target.x) / 2;
    ctx.lineTo(midpoint, previous.y);
    ctx.lineTo(midpoint, target.y);
  } else if (mode === "after" !== !!flip) {
    ctx.lineTo(previous.x, target.y);
  } else {
    ctx.lineTo(target.x, previous.y);
  }
  ctx.lineTo(target.x, target.y);
}
function _bezierCurveTo(ctx, previous, target, flip) {
  if (!previous) {
    return ctx.lineTo(target.x, target.y);
  }
  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
}
function setRenderOpts(ctx, opts) {
  if (opts.translation) {
    ctx.translate(opts.translation[0], opts.translation[1]);
  }
  if (!isNullOrUndef(opts.rotation)) {
    ctx.rotate(opts.rotation);
  }
  if (opts.color) {
    ctx.fillStyle = opts.color;
  }
  if (opts.textAlign) {
    ctx.textAlign = opts.textAlign;
  }
  if (opts.textBaseline) {
    ctx.textBaseline = opts.textBaseline;
  }
}
function decorateText(ctx, x, y, line, opts) {
  if (opts.strikethrough || opts.underline) {
    const metrics = ctx.measureText(line);
    const left = x - metrics.actualBoundingBoxLeft;
    const right = x + metrics.actualBoundingBoxRight;
    const top = y - metrics.actualBoundingBoxAscent;
    const bottom = y + metrics.actualBoundingBoxDescent;
    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
    ctx.strokeStyle = ctx.fillStyle;
    ctx.beginPath();
    ctx.lineWidth = opts.decorationWidth || 2;
    ctx.moveTo(left, yDecoration);
    ctx.lineTo(right, yDecoration);
    ctx.stroke();
  }
}
function drawBackdrop(ctx, opts) {
  const oldColor = ctx.fillStyle;
  ctx.fillStyle = opts.color;
  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
  ctx.fillStyle = oldColor;
}
function renderText(ctx, text, x, y, font, opts = {}) {
  const lines = isArray(text) ? text : [
    text
  ];
  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
  let i, line;
  ctx.save();
  ctx.font = font.string;
  setRenderOpts(ctx, opts);
  for (i = 0; i < lines.length; ++i) {
    line = lines[i];
    if (opts.backdrop) {
      drawBackdrop(ctx, opts.backdrop);
    }
    if (stroke) {
      if (opts.strokeColor) {
        ctx.strokeStyle = opts.strokeColor;
      }
      if (!isNullOrUndef(opts.strokeWidth)) {
        ctx.lineWidth = opts.strokeWidth;
      }
      ctx.strokeText(line, x, y, opts.maxWidth);
    }
    ctx.fillText(line, x, y, opts.maxWidth);
    decorateText(ctx, x, y, line, opts);
    y += Number(font.lineHeight);
  }
  ctx.restore();
}
function addRoundedRectPath(ctx, rect) {
  const { x, y, w, h, radius } = rect;
  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
  ctx.lineTo(x, y + h - radius.bottomLeft);
  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
  ctx.lineTo(x + w - radius.bottomRight, y + h);
  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
  ctx.lineTo(x + w, y + radius.topRight);
  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
  ctx.lineTo(x + radius.topLeft, y);
}
var LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
var FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function toLineHeight(value, size) {
  const matches = ("" + value).match(LINE_HEIGHT);
  if (!matches || matches[1] === "normal") {
    return size * 1.2;
  }
  value = +matches[2];
  switch (matches[3]) {
    case "px":
      return value;
    case "%":
      value /= 100;
      break;
  }
  return size * value;
}
var numberOrZero = (v) => +v || 0;
function _readValueToProps(value, props) {
  const ret = {};
  const objProps = isObject(props);
  const keys = objProps ? Object.keys(props) : props;
  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
  for (const prop of keys) {
    ret[prop] = numberOrZero(read(prop));
  }
  return ret;
}
function toTRBL(value) {
  return _readValueToProps(value, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function toTRBLCorners(value) {
  return _readValueToProps(value, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function toPadding(value) {
  const obj = toTRBL(value);
  obj.width = obj.left + obj.right;
  obj.height = obj.top + obj.bottom;
  return obj;
}
function toFont(options2, fallback) {
  options2 = options2 || {};
  fallback = fallback || defaults.font;
  let size = valueOrDefault(options2.size, fallback.size);
  if (typeof size === "string") {
    size = parseInt(size, 10);
  }
  let style = valueOrDefault(options2.style, fallback.style);
  if (style && !("" + style).match(FONT_STYLE)) {
    console.warn('Invalid font style specified: "' + style + '"');
    style = void 0;
  }
  const font = {
    family: valueOrDefault(options2.family, fallback.family),
    lineHeight: toLineHeight(valueOrDefault(options2.lineHeight, fallback.lineHeight), size),
    size,
    style,
    weight: valueOrDefault(options2.weight, fallback.weight),
    string: ""
  };
  font.string = toFontString(font);
  return font;
}
function resolve(inputs, context, index2, info) {
  let cacheable = true;
  let i, ilen, value;
  for (i = 0, ilen = inputs.length; i < ilen; ++i) {
    value = inputs[i];
    if (value === void 0) {
      continue;
    }
    if (context !== void 0 && typeof value === "function") {
      value = value(context);
      cacheable = false;
    }
    if (index2 !== void 0 && isArray(value)) {
      value = value[index2 % value.length];
      cacheable = false;
    }
    if (value !== void 0) {
      if (info && !cacheable) {
        info.cacheable = false;
      }
      return value;
    }
  }
}
function _addGrace(minmax, grace, beginAtZero) {
  const { min, max } = minmax;
  const change = toDimension(grace, (max - min) / 2);
  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
  return {
    min: keepZero(min, -Math.abs(change)),
    max: keepZero(max, change)
  };
}
function createContext(parentContext, context) {
  return Object.assign(Object.create(parentContext), context);
}
function _createResolver(scopes, prefixes = [
  ""
], rootScopes, fallback, getTarget = () => scopes[0]) {
  const finalRootScopes = rootScopes || scopes;
  if (typeof fallback === "undefined") {
    fallback = _resolve("_fallback", scopes);
  }
  const cache = {
    [Symbol.toStringTag]: "Object",
    _cacheable: true,
    _scopes: scopes,
    _rootScopes: finalRootScopes,
    _fallback: fallback,
    _getTarget: getTarget,
    override: (scope) => _createResolver([
      scope,
      ...scopes
    ], prefixes, finalRootScopes, fallback)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete target._keys;
      delete scopes[0][prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop) {
      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(scopes[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return getKeysFromAllScopes(target).includes(prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(target) {
      return getKeysFromAllScopes(target);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      const storage = target._storage || (target._storage = getTarget());
      target[prop] = storage[prop] = value;
      delete target._keys;
      return true;
    }
  });
}
function _attachContext(proxy, context, subProxy, descriptorDefaults) {
  const cache = {
    _cacheable: false,
    _proxy: proxy,
    _context: context,
    _subProxy: subProxy,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: _descriptors(proxy, descriptorDefaults),
    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
  };
  return new Proxy(cache, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(target, prop) {
      delete target[prop];
      delete proxy[prop];
      return true;
    },
    /**
    * A trap for getting property values.
    */
    get(target, prop, receiver) {
      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(target, prop) {
      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
        enumerable: true,
        configurable: true
      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(proxy);
    },
    /**
    * A trap for the in operator.
    */
    has(target, prop) {
      return Reflect.has(proxy, prop);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(proxy);
    },
    /**
    * A trap for setting property values.
    */
    set(target, prop, value) {
      proxy[prop] = value;
      delete target[prop];
      return true;
    }
  });
}
function _descriptors(proxy, defaults2 = {
  scriptable: true,
  indexable: true
}) {
  const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
  return {
    allKeys: _allKeys,
    scriptable: _scriptable,
    indexable: _indexable,
    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
  };
}
var readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
var needsSubResolver = (prop, value) => isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
function _cached(target, prop, resolve2) {
  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") {
    return target[prop];
  }
  const value = resolve2();
  target[prop] = value;
  return value;
}
function _resolveWithContext(target, prop, receiver) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  let value = _proxy[prop];
  if (isFunction(value) && descriptors2.isScriptable(prop)) {
    value = _resolveScriptable(prop, value, target, receiver);
  }
  if (isArray(value) && value.length) {
    value = _resolveArray(prop, value, target, descriptors2.isIndexable);
  }
  if (needsSubResolver(prop, value)) {
    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
  }
  return value;
}
function _resolveScriptable(prop, getValue, target, receiver) {
  const { _proxy, _context, _subProxy, _stack } = target;
  if (_stack.has(prop)) {
    throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
  }
  _stack.add(prop);
  let value = getValue(_context, _subProxy || receiver);
  _stack.delete(prop);
  if (needsSubResolver(prop, value)) {
    value = createSubResolver(_proxy._scopes, _proxy, prop, value);
  }
  return value;
}
function _resolveArray(prop, value, target, isIndexable) {
  const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
  if (typeof _context.index !== "undefined" && isIndexable(prop)) {
    return value[_context.index % value.length];
  } else if (isObject(value[0])) {
    const arr = value;
    const scopes = _proxy._scopes.filter((s) => s !== arr);
    value = [];
    for (const item of arr) {
      const resolver = createSubResolver(scopes, _proxy, prop, item);
      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
    }
  }
  return value;
}
function resolveFallback(fallback, prop, value) {
  return isFunction(fallback) ? fallback(prop, value) : fallback;
}
var getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
function addScopes(set2, parentScopes, key, parentFallback, value) {
  for (const parent of parentScopes) {
    const scope = getScope(key, parent);
    if (scope) {
      set2.add(scope);
      const fallback = resolveFallback(scope._fallback, key, value);
      if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) {
        return fallback;
      }
    } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) {
      return null;
    }
  }
  return false;
}
function createSubResolver(parentScopes, resolver, prop, value) {
  const rootScopes = resolver._rootScopes;
  const fallback = resolveFallback(resolver._fallback, prop, value);
  const allScopes = [
    ...parentScopes,
    ...rootScopes
  ];
  const set2 = /* @__PURE__ */ new Set();
  set2.add(value);
  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);
  if (key === null) {
    return false;
  }
  if (typeof fallback !== "undefined" && fallback !== prop) {
    key = addScopesFromKey(set2, allScopes, fallback, key, value);
    if (key === null) {
      return false;
    }
  }
  return _createResolver(Array.from(set2), [
    ""
  ], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
}
function addScopesFromKey(set2, allScopes, key, fallback, item) {
  while (key) {
    key = addScopes(set2, allScopes, key, fallback, item);
  }
  return key;
}
function subGetTarget(resolver, prop, value) {
  const parent = resolver._getTarget();
  if (!(prop in parent)) {
    parent[prop] = {};
  }
  const target = parent[prop];
  if (isArray(target) && isObject(value)) {
    return value;
  }
  return target || {};
}
function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
  let value;
  for (const prefix of prefixes) {
    value = _resolve(readKey(prefix, prop), scopes);
    if (typeof value !== "undefined") {
      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
    }
  }
}
function _resolve(key, scopes) {
  for (const scope of scopes) {
    if (!scope) {
      continue;
    }
    const value = scope[key];
    if (typeof value !== "undefined") {
      return value;
    }
  }
}
function getKeysFromAllScopes(target) {
  let keys = target._keys;
  if (!keys) {
    keys = target._keys = resolveKeysFromAllScopes(target._scopes);
  }
  return keys;
}
function resolveKeysFromAllScopes(scopes) {
  const set2 = /* @__PURE__ */ new Set();
  for (const scope of scopes) {
    for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
      set2.add(key);
    }
  }
  return Array.from(set2);
}
function _parseObjectDataRadialScale(meta, data, start, count) {
  const { iScale } = meta;
  const { key = "r" } = this._parsing;
  const parsed = new Array(count);
  let i, ilen, index2, item;
  for (i = 0, ilen = count; i < ilen; ++i) {
    index2 = i + start;
    item = data[index2];
    parsed[i] = {
      r: iScale.parse(resolveObjectKey(item, key), index2)
    };
  }
  return parsed;
}
var EPSILON = Number.EPSILON || 1e-14;
var getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
var getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
function splineCurve(firstPoint, middlePoint, afterPoint, t) {
  const previous = firstPoint.skip ? middlePoint : firstPoint;
  const current = middlePoint;
  const next = afterPoint.skip ? middlePoint : afterPoint;
  const d01 = distanceBetweenPoints(current, previous);
  const d12 = distanceBetweenPoints(next, current);
  let s01 = d01 / (d01 + d12);
  let s12 = d12 / (d01 + d12);
  s01 = isNaN(s01) ? 0 : s01;
  s12 = isNaN(s12) ? 0 : s12;
  const fa = t * s01;
  const fb = t * s12;
  return {
    previous: {
      x: current.x - fa * (next.x - previous.x),
      y: current.y - fa * (next.y - previous.y)
    },
    next: {
      x: current.x + fb * (next.x - previous.x),
      y: current.y + fb * (next.y - previous.y)
    }
  };
}
function monotoneAdjust(points, deltaK, mK) {
  const pointsLen = points.length;
  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen - 1; ++i) {
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent || !pointAfter) {
      continue;
    }
    if (almostEquals(deltaK[i], 0, EPSILON)) {
      mK[i] = mK[i + 1] = 0;
      continue;
    }
    alphaK = mK[i] / deltaK[i];
    betaK = mK[i + 1] / deltaK[i];
    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
    if (squaredMagnitude <= 9) {
      continue;
    }
    tauK = 3 / Math.sqrt(squaredMagnitude);
    mK[i] = alphaK * tauK * deltaK[i];
    mK[i + 1] = betaK * tauK * deltaK[i];
  }
}
function monotoneCompute(points, mK, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  let delta, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (let i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    const iPixel = pointCurrent[indexAxis];
    const vPixel = pointCurrent[valueAxis];
    if (pointBefore) {
      delta = (iPixel - pointBefore[indexAxis]) / 3;
      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
    }
    if (pointAfter) {
      delta = (pointAfter[indexAxis] - iPixel) / 3;
      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
    }
  }
}
function splineCurveMonotone(points, indexAxis = "x") {
  const valueAxis = getValueAxis(indexAxis);
  const pointsLen = points.length;
  const deltaK = Array(pointsLen).fill(0);
  const mK = Array(pointsLen);
  let i, pointBefore, pointCurrent;
  let pointAfter = getPoint(points, 0);
  for (i = 0; i < pointsLen; ++i) {
    pointBefore = pointCurrent;
    pointCurrent = pointAfter;
    pointAfter = getPoint(points, i + 1);
    if (!pointCurrent) {
      continue;
    }
    if (pointAfter) {
      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
    }
    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
  }
  monotoneAdjust(points, deltaK, mK);
  monotoneCompute(points, mK, indexAxis);
}
function capControlPoint(pt, min, max) {
  return Math.max(Math.min(pt, max), min);
}
function capBezierPoints(points, area) {
  let i, ilen, point, inArea, inAreaPrev;
  let inAreaNext = _isPointInArea(points[0], area);
  for (i = 0, ilen = points.length; i < ilen; ++i) {
    inAreaPrev = inArea;
    inArea = inAreaNext;
    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
    if (!inArea) {
      continue;
    }
    point = points[i];
    if (inAreaPrev) {
      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
    }
    if (inAreaNext) {
      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
    }
  }
}
function _updateBezierControlPoints(points, options2, area, loop, indexAxis) {
  let i, ilen, point, controlPoints;
  if (options2.spanGaps) {
    points = points.filter((pt) => !pt.skip);
  }
  if (options2.cubicInterpolationMode === "monotone") {
    splineCurveMonotone(points, indexAxis);
  } else {
    let prev = loop ? points[points.length - 1] : points[0];
    for (i = 0, ilen = points.length; i < ilen; ++i) {
      point = points[i];
      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options2.tension);
      point.cp1x = controlPoints.previous.x;
      point.cp1y = controlPoints.previous.y;
      point.cp2x = controlPoints.next.x;
      point.cp2y = controlPoints.next.y;
      prev = point;
    }
  }
  if (options2.capBezierPoints) {
    capBezierPoints(points, area);
  }
}
function _isDomSupported() {
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function _getParentNode(domNode) {
  let parent = domNode.parentNode;
  if (parent && parent.toString() === "[object ShadowRoot]") {
    parent = parent.host;
  }
  return parent;
}
function parseMaxStyle(styleValue, node, parentProperty) {
  let valueInPixels;
  if (typeof styleValue === "string") {
    valueInPixels = parseInt(styleValue, 10);
    if (styleValue.indexOf("%") !== -1) {
      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
    }
  } else {
    valueInPixels = styleValue;
  }
  return valueInPixels;
}
var getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);
function getStyle(el, property) {
  return getComputedStyle(el).getPropertyValue(property);
}
var positions = [
  "top",
  "right",
  "bottom",
  "left"
];
function getPositionedStyle(styles, style, suffix) {
  const result = {};
  suffix = suffix ? "-" + suffix : "";
  for (let i = 0; i < 4; i++) {
    const pos = positions[i];
    result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
  }
  result.width = result.left + result.right;
  result.height = result.top + result.bottom;
  return result;
}
var useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
function getCanvasPosition(e, canvas) {
  const touches = e.touches;
  const source = touches && touches.length ? touches[0] : e;
  const { offsetX, offsetY } = source;
  let box = false;
  let x, y;
  if (useOffsetPos(offsetX, offsetY, e.target)) {
    x = offsetX;
    y = offsetY;
  } else {
    const rect = canvas.getBoundingClientRect();
    x = source.clientX - rect.left;
    y = source.clientY - rect.top;
    box = true;
  }
  return {
    x,
    y,
    box
  };
}
function getRelativePosition(event, chart) {
  if ("native" in event) {
    return event;
  }
  const { canvas, currentDevicePixelRatio } = chart;
  const style = getComputedStyle(canvas);
  const borderBox = style.boxSizing === "border-box";
  const paddings = getPositionedStyle(style, "padding");
  const borders = getPositionedStyle(style, "border", "width");
  const { x, y, box } = getCanvasPosition(event, canvas);
  const xOffset = paddings.left + (box && borders.left);
  const yOffset = paddings.top + (box && borders.top);
  let { width, height } = chart;
  if (borderBox) {
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  return {
    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
  };
}
function getContainerSize(canvas, width, height) {
  let maxWidth, maxHeight;
  if (width === void 0 || height === void 0) {
    const container = canvas && _getParentNode(canvas);
    if (!container) {
      width = canvas.clientWidth;
      height = canvas.clientHeight;
    } else {
      const rect = container.getBoundingClientRect();
      const containerStyle = getComputedStyle(container);
      const containerBorder = getPositionedStyle(containerStyle, "border", "width");
      const containerPadding = getPositionedStyle(containerStyle, "padding");
      width = rect.width - containerPadding.width - containerBorder.width;
      height = rect.height - containerPadding.height - containerBorder.height;
      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
    }
  }
  return {
    width,
    height,
    maxWidth: maxWidth || INFINITY,
    maxHeight: maxHeight || INFINITY
  };
}
var round1 = (v) => Math.round(v * 10) / 10;
function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
  const style = getComputedStyle(canvas);
  const margins = getPositionedStyle(style, "margin");
  const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
  const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
  let { width, height } = containerSize;
  if (style.boxSizing === "content-box") {
    const borders = getPositionedStyle(style, "border", "width");
    const paddings = getPositionedStyle(style, "padding");
    width -= paddings.width + borders.width;
    height -= paddings.height + borders.height;
  }
  width = Math.max(0, width - margins.width);
  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
  if (width && !height) {
    height = round1(width / 2);
  }
  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
    height = containerSize.height;
    width = round1(Math.floor(height * aspectRatio));
  }
  return {
    width,
    height
  };
}
function retinaScale(chart, forceRatio, forceStyle) {
  const pixelRatio = forceRatio || 1;
  const deviceHeight = Math.floor(chart.height * pixelRatio);
  const deviceWidth = Math.floor(chart.width * pixelRatio);
  chart.height = Math.floor(chart.height);
  chart.width = Math.floor(chart.width);
  const canvas = chart.canvas;
  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
    canvas.style.height = `${chart.height}px`;
    canvas.style.width = `${chart.width}px`;
  }
  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
    chart.currentDevicePixelRatio = pixelRatio;
    canvas.height = deviceHeight;
    canvas.width = deviceWidth;
    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    return true;
  }
  return false;
}
var supportsEventListenerOptions = function() {
  let passiveSupported = false;
  try {
    const options2 = {
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    if (_isDomSupported()) {
      window.addEventListener("test", null, options2);
      window.removeEventListener("test", null, options2);
    }
  } catch (e) {
  }
  return passiveSupported;
}();
function readUsedSize(element, property) {
  const value = getStyle(element, property);
  const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
  return matches ? +matches[1] : void 0;
}
function _pointInLine(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: p1.y + t * (p2.y - p1.y)
  };
}
function _steppedInterpolation(p1, p2, t, mode) {
  return {
    x: p1.x + t * (p2.x - p1.x),
    y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
  };
}
function _bezierInterpolation(p1, p2, t, mode) {
  const cp1 = {
    x: p1.cp2x,
    y: p1.cp2y
  };
  const cp2 = {
    x: p2.cp1x,
    y: p2.cp1y
  };
  const a = _pointInLine(p1, cp1, t);
  const b = _pointInLine(cp1, cp2, t);
  const c = _pointInLine(cp2, p2, t);
  const d = _pointInLine(a, b, t);
  const e = _pointInLine(b, c, t);
  return _pointInLine(d, e, t);
}
var getRightToLeftAdapter = function(rectX, width) {
  return {
    x(x) {
      return rectX + rectX + width - x;
    },
    setWidth(w) {
      width = w;
    },
    textAlign(align) {
      if (align === "center") {
        return align;
      }
      return align === "right" ? "left" : "right";
    },
    xPlus(x, value) {
      return x - value;
    },
    leftForLtr(x, itemWidth) {
      return x - itemWidth;
    }
  };
};
var getLeftToRightAdapter = function() {
  return {
    x(x) {
      return x;
    },
    setWidth(w) {
    },
    textAlign(align) {
      return align;
    },
    xPlus(x, value) {
      return x + value;
    },
    leftForLtr(x, _itemWidth) {
      return x;
    }
  };
};
function getRtlAdapter(rtl, rectX, width) {
  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
}
function overrideTextDirection(ctx, direction) {
  let style, original;
  if (direction === "ltr" || direction === "rtl") {
    style = ctx.canvas.style;
    original = [
      style.getPropertyValue("direction"),
      style.getPropertyPriority("direction")
    ];
    style.setProperty("direction", direction, "important");
    ctx.prevTextDirection = original;
  }
}
function restoreTextDirection(ctx, original) {
  if (original !== void 0) {
    delete ctx.prevTextDirection;
    ctx.canvas.style.setProperty("direction", original[0], original[1]);
  }
}
function propertyFn(property) {
  if (property === "angle") {
    return {
      between: _angleBetween,
      compare: _angleDiff,
      normalize: _normalizeAngle
    };
  }
  return {
    between: _isBetween,
    compare: (a, b) => a - b,
    normalize: (x) => x
  };
}
function normalizeSegment({ start, end, count, loop, style }) {
  return {
    start: start % count,
    end: end % count,
    loop: loop && (end - start + 1) % count === 0,
    style
  };
}
function getSegment(segment, points, bounds) {
  const { property, start: startBound, end: endBound } = bounds;
  const { between, normalize } = propertyFn(property);
  const count = points.length;
  let { start, end, loop } = segment;
  let i, ilen;
  if (loop) {
    start += count;
    end += count;
    for (i = 0, ilen = count; i < ilen; ++i) {
      if (!between(normalize(points[start % count][property]), startBound, endBound)) {
        break;
      }
      start--;
      end--;
    }
    start %= count;
    end %= count;
  }
  if (end < start) {
    end += count;
  }
  return {
    start,
    end,
    loop,
    style: segment.style
  };
}
function _boundSegment(segment, points, bounds) {
  if (!bounds) {
    return [
      segment
    ];
  }
  const { property, start: startBound, end: endBound } = bounds;
  const count = points.length;
  const { compare, between, normalize } = propertyFn(property);
  const { start, end, loop, style } = getSegment(segment, points, bounds);
  const result = [];
  let inside = false;
  let subStart = null;
  let value, point, prevValue;
  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
  const shouldStart = () => inside || startIsBefore();
  const shouldStop = () => !inside || endIsBefore();
  for (let i = start, prev = start; i <= end; ++i) {
    point = points[i % count];
    if (point.skip) {
      continue;
    }
    value = normalize(point[property]);
    if (value === prevValue) {
      continue;
    }
    inside = between(value, startBound, endBound);
    if (subStart === null && shouldStart()) {
      subStart = compare(value, startBound) === 0 ? i : prev;
    }
    if (subStart !== null && shouldStop()) {
      result.push(normalizeSegment({
        start: subStart,
        end: i,
        loop,
        count,
        style
      }));
      subStart = null;
    }
    prev = i;
    prevValue = value;
  }
  if (subStart !== null) {
    result.push(normalizeSegment({
      start: subStart,
      end,
      loop,
      count,
      style
    }));
  }
  return result;
}
function _boundSegments(line, bounds) {
  const result = [];
  const segments = line.segments;
  for (let i = 0; i < segments.length; i++) {
    const sub = _boundSegment(segments[i], line.points, bounds);
    if (sub.length) {
      result.push(...sub);
    }
  }
  return result;
}
function findStartAndEnd(points, count, loop, spanGaps) {
  let start = 0;
  let end = count - 1;
  if (loop && !spanGaps) {
    while (start < count && !points[start].skip) {
      start++;
    }
  }
  while (start < count && points[start].skip) {
    start++;
  }
  start %= count;
  if (loop) {
    end += start;
  }
  while (end > start && points[end % count].skip) {
    end--;
  }
  end %= count;
  return {
    start,
    end
  };
}
function solidSegments(points, start, max, loop) {
  const count = points.length;
  const result = [];
  let last = start;
  let prev = points[start];
  let end;
  for (end = start + 1; end <= max; ++end) {
    const cur = points[end % count];
    if (cur.skip || cur.stop) {
      if (!prev.skip) {
        loop = false;
        result.push({
          start: start % count,
          end: (end - 1) % count,
          loop
        });
        start = last = cur.stop ? end : null;
      }
    } else {
      last = end;
      if (prev.skip) {
        start = end;
      }
    }
    prev = cur;
  }
  if (last !== null) {
    result.push({
      start: start % count,
      end: last % count,
      loop
    });
  }
  return result;
}
function _computeSegments(line, segmentOptions) {
  const points = line.points;
  const spanGaps = line.options.spanGaps;
  const count = points.length;
  if (!count) {
    return [];
  }
  const loop = !!line._loop;
  const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
  if (spanGaps === true) {
    return splitByStyles(line, [
      {
        start,
        end,
        loop
      }
    ], points, segmentOptions);
  }
  const max = end < start ? end + count : end;
  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
}
function splitByStyles(line, segments, points, segmentOptions) {
  if (!segmentOptions || !segmentOptions.setContext || !points) {
    return segments;
  }
  return doSplitByStyles(line, segments, points, segmentOptions);
}
function doSplitByStyles(line, segments, points, segmentOptions) {
  const chartContext = line._chart.getContext();
  const baseStyle = readStyle(line.options);
  const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;
  const count = points.length;
  const result = [];
  let prevStyle = baseStyle;
  let start = segments[0].start;
  let i = start;
  function addStyle(s, e, l, st) {
    const dir = spanGaps ? -1 : 1;
    if (s === e) {
      return;
    }
    s += count;
    while (points[s % count].skip) {
      s -= dir;
    }
    while (points[e % count].skip) {
      e += dir;
    }
    if (s % count !== e % count) {
      result.push({
        start: s % count,
        end: e % count,
        loop: l,
        style: st
      });
      prevStyle = st;
      start = e % count;
    }
  }
  for (const segment of segments) {
    start = spanGaps ? start : segment.start;
    let prev = points[start % count];
    let style;
    for (i = start + 1; i <= segment.end; i++) {
      const pt = points[i % count];
      style = readStyle(segmentOptions.setContext(createContext(chartContext, {
        type: "segment",
        p0: prev,
        p1: pt,
        p0DataIndex: (i - 1) % count,
        p1DataIndex: i % count,
        datasetIndex
      })));
      if (styleChanged(style, prevStyle)) {
        addStyle(start, i - 1, segment.loop, prevStyle);
      }
      prev = pt;
      prevStyle = style;
    }
    if (start < i - 1) {
      addStyle(start, i - 1, segment.loop, prevStyle);
    }
  }
  return result;
}
function readStyle(options2) {
  return {
    backgroundColor: options2.backgroundColor,
    borderCapStyle: options2.borderCapStyle,
    borderDash: options2.borderDash,
    borderDashOffset: options2.borderDashOffset,
    borderJoinStyle: options2.borderJoinStyle,
    borderWidth: options2.borderWidth,
    borderColor: options2.borderColor
  };
}
function styleChanged(style, prevStyle) {
  if (!prevStyle) {
    return false;
  }
  const cache = [];
  const replacer = function(key, value) {
    if (!isPatternOrGradient(value)) {
      return value;
    }
    if (!cache.includes(value)) {
      cache.push(value);
    }
    return cache.indexOf(value);
  };
  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
}
function getSizeForArea(scale, chartArea, field) {
  return scale.options.clip ? scale[field] : chartArea[field];
}
function getDatasetArea(meta, chartArea) {
  const { xScale, yScale } = meta;
  if (xScale && yScale) {
    return {
      left: getSizeForArea(xScale, chartArea, "left"),
      right: getSizeForArea(xScale, chartArea, "right"),
      top: getSizeForArea(yScale, chartArea, "top"),
      bottom: getSizeForArea(yScale, chartArea, "bottom")
    };
  }
  return chartArea;
}
function getDatasetClipArea(chart, meta) {
  const clip = meta._clip;
  if (clip.disabled) {
    return false;
  }
  const area = getDatasetArea(meta, chart.chartArea);
  return {
    left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),
    right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),
    top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),
    bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)
  };
}

// node_modules/chart.js/dist/chart.js
var Animator = class {
  constructor() {
    this._request = null;
    this._charts = /* @__PURE__ */ new Map();
    this._running = false;
    this._lastDate = void 0;
  }
  _notify(chart, anims, date, type) {
    const callbacks = anims.listeners[type];
    const numSteps = anims.duration;
    callbacks.forEach((fn) => fn({
      chart,
      initial: anims.initial,
      numSteps,
      currentStep: Math.min(date - anims.start, numSteps)
    }));
  }
  _refresh() {
    if (this._request) {
      return;
    }
    this._running = true;
    this._request = requestAnimFrame.call(window, () => {
      this._update();
      this._request = null;
      if (this._running) {
        this._refresh();
      }
    });
  }
  _update(date = Date.now()) {
    let remaining = 0;
    this._charts.forEach((anims, chart) => {
      if (!anims.running || !anims.items.length) {
        return;
      }
      const items = anims.items;
      let i = items.length - 1;
      let draw2 = false;
      let item;
      for (; i >= 0; --i) {
        item = items[i];
        if (item._active) {
          if (item._total > anims.duration) {
            anims.duration = item._total;
          }
          item.tick(date);
          draw2 = true;
        } else {
          items[i] = items[items.length - 1];
          items.pop();
        }
      }
      if (draw2) {
        chart.draw();
        this._notify(chart, anims, date, "progress");
      }
      if (!items.length) {
        anims.running = false;
        this._notify(chart, anims, date, "complete");
        anims.initial = false;
      }
      remaining += items.length;
    });
    this._lastDate = date;
    if (remaining === 0) {
      this._running = false;
    }
  }
  _getAnims(chart) {
    const charts = this._charts;
    let anims = charts.get(chart);
    if (!anims) {
      anims = {
        running: false,
        initial: true,
        items: [],
        listeners: {
          complete: [],
          progress: []
        }
      };
      charts.set(chart, anims);
    }
    return anims;
  }
  listen(chart, event, cb) {
    this._getAnims(chart).listeners[event].push(cb);
  }
  add(chart, items) {
    if (!items || !items.length) {
      return;
    }
    this._getAnims(chart).items.push(...items);
  }
  has(chart) {
    return this._getAnims(chart).items.length > 0;
  }
  start(chart) {
    const anims = this._charts.get(chart);
    if (!anims) {
      return;
    }
    anims.running = true;
    anims.start = Date.now();
    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
    this._refresh();
  }
  running(chart) {
    if (!this._running) {
      return false;
    }
    const anims = this._charts.get(chart);
    if (!anims || !anims.running || !anims.items.length) {
      return false;
    }
    return true;
  }
  stop(chart) {
    const anims = this._charts.get(chart);
    if (!anims || !anims.items.length) {
      return;
    }
    const items = anims.items;
    let i = items.length - 1;
    for (; i >= 0; --i) {
      items[i].cancel();
    }
    anims.items = [];
    this._notify(chart, anims, Date.now(), "complete");
  }
  remove(chart) {
    return this._charts.delete(chart);
  }
};
var animator = /* @__PURE__ */ new Animator();
var transparent = "transparent";
var interpolators = {
  boolean(from2, to2, factor) {
    return factor > 0.5 ? to2 : from2;
  },
  color(from2, to2, factor) {
    const c0 = color(from2 || transparent);
    const c1 = c0.valid && color(to2 || transparent);
    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;
  },
  number(from2, to2, factor) {
    return from2 + (to2 - from2) * factor;
  }
};
var Animation = class {
  constructor(cfg, target, prop, to2) {
    const currentValue = target[prop];
    to2 = resolve([
      cfg.to,
      to2,
      currentValue,
      cfg.from
    ]);
    const from2 = resolve([
      cfg.from,
      currentValue,
      to2
    ]);
    this._active = true;
    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];
    this._easing = effects[cfg.easing] || effects.linear;
    this._start = Math.floor(Date.now() + (cfg.delay || 0));
    this._duration = this._total = Math.floor(cfg.duration);
    this._loop = !!cfg.loop;
    this._target = target;
    this._prop = prop;
    this._from = from2;
    this._to = to2;
    this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(cfg, to2, date) {
    if (this._active) {
      this._notify(false);
      const currentValue = this._target[this._prop];
      const elapsed = date - this._start;
      const remain = this._duration - elapsed;
      this._start = date;
      this._duration = Math.floor(Math.max(remain, cfg.duration));
      this._total += elapsed;
      this._loop = !!cfg.loop;
      this._to = resolve([
        cfg.to,
        to2,
        currentValue,
        cfg.from
      ]);
      this._from = resolve([
        cfg.from,
        currentValue,
        to2
      ]);
    }
  }
  cancel() {
    if (this._active) {
      this.tick(Date.now());
      this._active = false;
      this._notify(false);
    }
  }
  tick(date) {
    const elapsed = date - this._start;
    const duration = this._duration;
    const prop = this._prop;
    const from2 = this._from;
    const loop = this._loop;
    const to2 = this._to;
    let factor;
    this._active = from2 !== to2 && (loop || elapsed < duration);
    if (!this._active) {
      this._target[prop] = to2;
      this._notify(true);
      return;
    }
    if (elapsed < 0) {
      this._target[prop] = from2;
      return;
    }
    factor = elapsed / duration % 2;
    factor = loop && factor > 1 ? 2 - factor : factor;
    factor = this._easing(Math.min(1, Math.max(0, factor)));
    this._target[prop] = this._fn(from2, to2, factor);
  }
  wait() {
    const promises = this._promises || (this._promises = []);
    return new Promise((res, rej) => {
      promises.push({
        res,
        rej
      });
    });
  }
  _notify(resolved) {
    const method = resolved ? "res" : "rej";
    const promises = this._promises || [];
    for (let i = 0; i < promises.length; i++) {
      promises[i][method]();
    }
  }
};
var Animations = class {
  constructor(chart, config) {
    this._chart = chart;
    this._properties = /* @__PURE__ */ new Map();
    this.configure(config);
  }
  configure(config) {
    if (!isObject(config)) {
      return;
    }
    const animationOptions = Object.keys(defaults.animation);
    const animatedProps = this._properties;
    Object.getOwnPropertyNames(config).forEach((key) => {
      const cfg = config[key];
      if (!isObject(cfg)) {
        return;
      }
      const resolved = {};
      for (const option of animationOptions) {
        resolved[option] = cfg[option];
      }
      (isArray(cfg.properties) && cfg.properties || [
        key
      ]).forEach((prop) => {
        if (prop === key || !animatedProps.has(prop)) {
          animatedProps.set(prop, resolved);
        }
      });
    });
  }
  _animateOptions(target, values) {
    const newOptions = values.options;
    const options2 = resolveTargetOptions(target, newOptions);
    if (!options2) {
      return [];
    }
    const animations = this._createAnimations(options2, newOptions);
    if (newOptions.$shared) {
      awaitAll(target.options.$animations, newOptions).then(() => {
        target.options = newOptions;
      }, () => {
      });
    }
    return animations;
  }
  _createAnimations(target, values) {
    const animatedProps = this._properties;
    const animations = [];
    const running = target.$animations || (target.$animations = {});
    const props = Object.keys(values);
    const date = Date.now();
    let i;
    for (i = props.length - 1; i >= 0; --i) {
      const prop = props[i];
      if (prop.charAt(0) === "$") {
        continue;
      }
      if (prop === "options") {
        animations.push(...this._animateOptions(target, values));
        continue;
      }
      const value = values[prop];
      let animation = running[prop];
      const cfg = animatedProps.get(prop);
      if (animation) {
        if (cfg && animation.active()) {
          animation.update(cfg, value, date);
          continue;
        } else {
          animation.cancel();
        }
      }
      if (!cfg || !cfg.duration) {
        target[prop] = value;
        continue;
      }
      running[prop] = animation = new Animation(cfg, target, prop, value);
      animations.push(animation);
    }
    return animations;
  }
  update(target, values) {
    if (this._properties.size === 0) {
      Object.assign(target, values);
      return;
    }
    const animations = this._createAnimations(target, values);
    if (animations.length) {
      animator.add(this._chart, animations);
      return true;
    }
  }
};
function awaitAll(animations, properties) {
  const running = [];
  const keys = Object.keys(properties);
  for (let i = 0; i < keys.length; i++) {
    const anim = animations[keys[i]];
    if (anim && anim.active()) {
      running.push(anim.wait());
    }
  }
  return Promise.all(running);
}
function resolveTargetOptions(target, newOptions) {
  if (!newOptions) {
    return;
  }
  let options2 = target.options;
  if (!options2) {
    target.options = newOptions;
    return;
  }
  if (options2.$shared) {
    target.options = options2 = Object.assign({}, options2, {
      $shared: false,
      $animations: {}
    });
  }
  return options2;
}
function scaleClip(scale, allowedOverflow) {
  const opts = scale && scale.options || {};
  const reverse = opts.reverse;
  const min = opts.min === void 0 ? allowedOverflow : 0;
  const max = opts.max === void 0 ? allowedOverflow : 0;
  return {
    start: reverse ? max : min,
    end: reverse ? min : max
  };
}
function defaultClip(xScale, yScale, allowedOverflow) {
  if (allowedOverflow === false) {
    return false;
  }
  const x = scaleClip(xScale, allowedOverflow);
  const y = scaleClip(yScale, allowedOverflow);
  return {
    top: y.end,
    right: x.end,
    bottom: y.start,
    left: x.start
  };
}
function toClip(value) {
  let t, r, b, l;
  if (isObject(value)) {
    t = value.top;
    r = value.right;
    b = value.bottom;
    l = value.left;
  } else {
    t = r = b = l = value;
  }
  return {
    top: t,
    right: r,
    bottom: b,
    left: l,
    disabled: value === false
  };
}
function getSortedDatasetIndices(chart, filterVisible) {
  const keys = [];
  const metasets = chart._getSortedDatasetMetas(filterVisible);
  let i, ilen;
  for (i = 0, ilen = metasets.length; i < ilen; ++i) {
    keys.push(metasets[i].index);
  }
  return keys;
}
function applyStack(stack, value, dsIndex, options2 = {}) {
  const keys = stack.keys;
  const singleMode = options2.mode === "single";
  let i, ilen, datasetIndex, otherValue;
  if (value === null) {
    return;
  }
  let found = false;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    datasetIndex = +keys[i];
    if (datasetIndex === dsIndex) {
      found = true;
      if (options2.all) {
        continue;
      }
      break;
    }
    otherValue = stack.values[datasetIndex];
    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {
      value += otherValue;
    }
  }
  if (!found && !options2.all) {
    return 0;
  }
  return value;
}
function convertObjectDataToArray(data, meta) {
  const { iScale, vScale } = meta;
  const iAxisKey = iScale.axis === "x" ? "x" : "y";
  const vAxisKey = vScale.axis === "x" ? "x" : "y";
  const keys = Object.keys(data);
  const adata = new Array(keys.length);
  let i, ilen, key;
  for (i = 0, ilen = keys.length; i < ilen; ++i) {
    key = keys[i];
    adata[i] = {
      [iAxisKey]: key,
      [vAxisKey]: data[key]
    };
  }
  return adata;
}
function isStacked(scale, meta) {
  const stacked = scale && scale.options.stacked;
  return stacked || stacked === void 0 && meta.stack !== void 0;
}
function getStackKey(indexScale, valueScale, meta) {
  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
}
function getUserBounds(scale) {
  const { min, max, minDefined, maxDefined } = scale.getUserBounds();
  return {
    min: minDefined ? min : Number.NEGATIVE_INFINITY,
    max: maxDefined ? max : Number.POSITIVE_INFINITY
  };
}
function getOrCreateStack(stacks, stackKey, indexValue) {
  const subStack = stacks[stackKey] || (stacks[stackKey] = {});
  return subStack[indexValue] || (subStack[indexValue] = {});
}
function getLastIndexInStack(stack, vScale, positive, type) {
  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
    const value = stack[meta.index];
    if (positive && value > 0 || !positive && value < 0) {
      return meta.index;
    }
  }
  return null;
}
function updateStacks(controller, parsed) {
  const { chart, _cachedMeta: meta } = controller;
  const stacks = chart._stacks || (chart._stacks = {});
  const { iScale, vScale, index: datasetIndex } = meta;
  const iAxis = iScale.axis;
  const vAxis = vScale.axis;
  const key = getStackKey(iScale, vScale, meta);
  const ilen = parsed.length;
  let stack;
  for (let i = 0; i < ilen; ++i) {
    const item = parsed[i];
    const { [iAxis]: index2, [vAxis]: value } = item;
    const itemStacks = item._stacks || (item._stacks = {});
    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
    stack[datasetIndex] = value;
    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
    const visualValues = stack._visualValues || (stack._visualValues = {});
    visualValues[datasetIndex] = value;
  }
}
function getFirstScaleId(chart, axis) {
  const scales2 = chart.scales;
  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
}
function createDatasetContext(parent, index2) {
  return createContext(parent, {
    active: false,
    dataset: void 0,
    datasetIndex: index2,
    index: index2,
    mode: "default",
    type: "dataset"
  });
}
function createDataContext(parent, index2, element) {
  return createContext(parent, {
    active: false,
    dataIndex: index2,
    parsed: void 0,
    raw: void 0,
    element,
    index: index2,
    mode: "default",
    type: "data"
  });
}
function clearStacks(meta, items) {
  const datasetIndex = meta.controller.index;
  const axis = meta.vScale && meta.vScale.axis;
  if (!axis) {
    return;
  }
  items = items || meta._parsed;
  for (const parsed of items) {
    const stacks = parsed._stacks;
    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
      return;
    }
    delete stacks[axis][datasetIndex];
    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {
      delete stacks[axis]._visualValues[datasetIndex];
    }
  }
}
var isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
var cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
var createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
  keys: getSortedDatasetIndices(chart, true),
  values: null
};
var DatasetController = class {
  constructor(chart, datasetIndex) {
    this.chart = chart;
    this._ctx = chart.ctx;
    this.index = datasetIndex;
    this._cachedDataOpts = {};
    this._cachedMeta = this.getMeta();
    this._type = this._cachedMeta.type;
    this.options = void 0;
    this._parsing = false;
    this._data = void 0;
    this._objectData = void 0;
    this._sharedOptions = void 0;
    this._drawStart = void 0;
    this._drawCount = void 0;
    this.enableOptionSharing = false;
    this.supportsDecimation = false;
    this.$context = void 0;
    this._syncList = [];
    this.datasetElementType = new.target.datasetElementType;
    this.dataElementType = new.target.dataElementType;
    this.initialize();
  }
  initialize() {
    const meta = this._cachedMeta;
    this.configure();
    this.linkScales();
    meta._stacked = isStacked(meta.vScale, meta);
    this.addElements();
    if (this.options.fill && !this.chart.isPluginEnabled("filler")) {
      console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
    }
  }
  updateIndex(datasetIndex) {
    if (this.index !== datasetIndex) {
      clearStacks(this._cachedMeta);
    }
    this.index = datasetIndex;
  }
  linkScales() {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
    const indexAxis = meta.indexAxis;
    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
    meta.xScale = this.getScaleForId(xid);
    meta.yScale = this.getScaleForId(yid);
    meta.rScale = this.getScaleForId(rid);
    meta.iScale = this.getScaleForId(iid);
    meta.vScale = this.getScaleForId(vid);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(scaleID) {
    return this.chart.scales[scaleID];
  }
  _getOtherScale(scale) {
    const meta = this._cachedMeta;
    return scale === meta.iScale ? meta.vScale : meta.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const meta = this._cachedMeta;
    if (this._data) {
      unlistenArrayEvents(this._data, this);
    }
    if (meta._stacked) {
      clearStacks(meta);
    }
  }
  _dataCheck() {
    const dataset = this.getDataset();
    const data = dataset.data || (dataset.data = []);
    const _data = this._data;
    if (isObject(data)) {
      const meta = this._cachedMeta;
      this._data = convertObjectDataToArray(data, meta);
    } else if (_data !== data) {
      if (_data) {
        unlistenArrayEvents(_data, this);
        const meta = this._cachedMeta;
        clearStacks(meta);
        meta._parsed = [];
      }
      if (data && Object.isExtensible(data)) {
        listenArrayEvents(data, this);
      }
      this._syncList = [];
      this._data = data;
    }
  }
  addElements() {
    const meta = this._cachedMeta;
    this._dataCheck();
    if (this.datasetElementType) {
      meta.dataset = new this.datasetElementType();
    }
  }
  buildOrUpdateElements(resetNewElements) {
    const meta = this._cachedMeta;
    const dataset = this.getDataset();
    let stackChanged = false;
    this._dataCheck();
    const oldStacked = meta._stacked;
    meta._stacked = isStacked(meta.vScale, meta);
    if (meta.stack !== dataset.stack) {
      stackChanged = true;
      clearStacks(meta);
      meta.stack = dataset.stack;
    }
    this._resyncElements(resetNewElements);
    if (stackChanged || oldStacked !== meta._stacked) {
      updateStacks(this, meta._parsed);
      meta._stacked = isStacked(meta.vScale, meta);
    }
  }
  configure() {
    const config = this.chart.config;
    const scopeKeys = config.datasetScopeKeys(this._type);
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
    this.options = config.createResolver(scopes, this.getContext());
    this._parsing = this.options.parsing;
    this._cachedDataOpts = {};
  }
  parse(start, count) {
    const { _cachedMeta: meta, _data: data } = this;
    const { iScale, _stacked } = meta;
    const iAxis = iScale.axis;
    let sorted = start === 0 && count === data.length ? true : meta._sorted;
    let prev = start > 0 && meta._parsed[start - 1];
    let i, cur, parsed;
    if (this._parsing === false) {
      meta._parsed = data;
      meta._sorted = true;
      parsed = data;
    } else {
      if (isArray(data[start])) {
        parsed = this.parseArrayData(meta, data, start, count);
      } else if (isObject(data[start])) {
        parsed = this.parseObjectData(meta, data, start, count);
      } else {
        parsed = this.parsePrimitiveData(meta, data, start, count);
      }
      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
      for (i = 0; i < count; ++i) {
        meta._parsed[i + start] = cur = parsed[i];
        if (sorted) {
          if (isNotInOrderComparedToPrev()) {
            sorted = false;
          }
          prev = cur;
        }
      }
      meta._sorted = sorted;
    }
    if (_stacked) {
      updateStacks(this, parsed);
    }
  }
  parsePrimitiveData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const labels = iScale.getLabels();
    const singleScale = iScale === vScale;
    const parsed = new Array(count);
    let i, ilen, index2;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      parsed[i] = {
        [iAxis]: singleScale || iScale.parse(labels[index2], index2),
        [vAxis]: vScale.parse(data[index2], index2)
      };
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(item[0], index2),
        y: yScale.parse(item[1], index2)
      };
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const { xScale, yScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const parsed = new Array(count);
    let i, ilen, index2, item;
    for (i = 0, ilen = count; i < ilen; ++i) {
      index2 = i + start;
      item = data[index2];
      parsed[i] = {
        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
      };
    }
    return parsed;
  }
  getParsed(index2) {
    return this._cachedMeta._parsed[index2];
  }
  getDataElement(index2) {
    return this._cachedMeta.data[index2];
  }
  applyStack(scale, parsed, mode) {
    const chart = this.chart;
    const meta = this._cachedMeta;
    const value = parsed[scale.axis];
    const stack = {
      keys: getSortedDatasetIndices(chart, true),
      values: parsed._stacks[scale.axis]._visualValues
    };
    return applyStack(stack, value, meta.index, {
      mode
    });
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    const parsedValue = parsed[scale.axis];
    let value = parsedValue === null ? NaN : parsedValue;
    const values = stack && parsed._stacks[scale.axis];
    if (stack && values) {
      stack.values = values;
      value = applyStack(stack, parsedValue, this._cachedMeta.index);
    }
    range.min = Math.min(range.min, value);
    range.max = Math.max(range.max, value);
  }
  getMinMax(scale, canStack) {
    const meta = this._cachedMeta;
    const _parsed = meta._parsed;
    const sorted = meta._sorted && scale === meta.iScale;
    const ilen = _parsed.length;
    const otherScale = this._getOtherScale(scale);
    const stack = createStack(canStack, meta, this.chart);
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
    let i, parsed;
    function _skip() {
      parsed = _parsed[i];
      const otherValue = parsed[otherScale.axis];
      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
    }
    for (i = 0; i < ilen; ++i) {
      if (_skip()) {
        continue;
      }
      this.updateRangeFromParsed(range, scale, parsed, stack);
      if (sorted) {
        break;
      }
    }
    if (sorted) {
      for (i = ilen - 1; i >= 0; --i) {
        if (_skip()) {
          continue;
        }
        this.updateRangeFromParsed(range, scale, parsed, stack);
        break;
      }
    }
    return range;
  }
  getAllParsedValues(scale) {
    const parsed = this._cachedMeta._parsed;
    const values = [];
    let i, ilen, value;
    for (i = 0, ilen = parsed.length; i < ilen; ++i) {
      value = parsed[i][scale.axis];
      if (isNumberFinite(value)) {
        values.push(value);
      }
    }
    return values;
  }
  getMaxOverflow() {
    return false;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const vScale = meta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
      value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
    };
  }
  _update(mode) {
    const meta = this._cachedMeta;
    this.update(mode || "default");
    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
  }
  update(mode) {
  }
  draw() {
    const ctx = this._ctx;
    const chart = this.chart;
    const meta = this._cachedMeta;
    const elements2 = meta.data || [];
    const area = chart.chartArea;
    const active = [];
    const start = this._drawStart || 0;
    const count = this._drawCount || elements2.length - start;
    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
    let i;
    if (meta.dataset) {
      meta.dataset.draw(ctx, area, start, count);
    }
    for (i = start; i < start + count; ++i) {
      const element = elements2[i];
      if (element.hidden) {
        continue;
      }
      if (element.active && drawActiveElementsOnTop) {
        active.push(element);
      } else {
        element.draw(ctx, area);
      }
    }
    for (i = 0; i < active.length; ++i) {
      active[i].draw(ctx, area);
    }
  }
  getStyle(index2, active) {
    const mode = active ? "active" : "default";
    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
  }
  getContext(index2, active, mode) {
    const dataset = this.getDataset();
    let context;
    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {
      const element = this._cachedMeta.data[index2];
      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));
      context.parsed = this.getParsed(index2);
      context.raw = dataset.data[index2];
      context.index = context.dataIndex = index2;
    } else {
      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
      context.dataset = dataset;
      context.index = context.datasetIndex = this.index;
    }
    context.active = !!active;
    context.mode = mode;
    return context;
  }
  resolveDatasetElementOptions(mode) {
    return this._resolveElementOptions(this.datasetElementType.id, mode);
  }
  resolveDataElementOptions(index2, mode) {
    return this._resolveElementOptions(this.dataElementType.id, mode, index2);
  }
  _resolveElementOptions(elementType, mode = "default", index2) {
    const active = mode === "active";
    const cache = this._cachedDataOpts;
    const cacheKey = elementType + "-" + mode;
    const cached = cache[cacheKey];
    const sharing = this.enableOptionSharing && defined(index2);
    if (cached) {
      return cloneIfNotShared(cached, sharing);
    }
    const config = this.chart.config;
    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
    const prefixes = active ? [
      `${elementType}Hover`,
      "hover",
      elementType,
      ""
    ] : [
      elementType,
      ""
    ];
    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
    const names2 = Object.keys(defaults.elements[elementType]);
    const context = () => this.getContext(index2, active, mode);
    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);
    if (values.$shared) {
      values.$shared = sharing;
      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
    }
    return values;
  }
  _resolveAnimations(index2, transition, active) {
    const chart = this.chart;
    const cache = this._cachedDataOpts;
    const cacheKey = `animation-${transition}`;
    const cached = cache[cacheKey];
    if (cached) {
      return cached;
    }
    let options2;
    if (chart.options.animation !== false) {
      const config = this.chart.config;
      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
      options2 = config.createResolver(scopes, this.getContext(index2, active, transition));
    }
    const animations = new Animations(chart, options2 && options2.animations);
    if (options2 && options2._cacheable) {
      cache[cacheKey] = Object.freeze(animations);
    }
    return animations;
  }
  getSharedOptions(options2) {
    if (!options2.$shared) {
      return;
    }
    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options2));
  }
  includeOptions(mode, sharedOptions) {
    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
  }
  _getSharedOptions(start, mode) {
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const previouslySharedOptions = this._sharedOptions;
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
    return {
      sharedOptions,
      includeOptions
    };
  }
  updateElement(element, index2, properties, mode) {
    if (isDirectUpdateMode(mode)) {
      Object.assign(element, properties);
    } else {
      this._resolveAnimations(index2, mode).update(element, properties);
    }
  }
  updateSharedOptions(sharedOptions, mode, newOptions) {
    if (sharedOptions && !isDirectUpdateMode(mode)) {
      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
    }
  }
  _setStyle(element, index2, mode, active) {
    element.active = active;
    const options2 = this.getStyle(index2, active);
    this._resolveAnimations(index2, mode, active).update(element, {
      options: !active && this.getSharedOptions(options2) || options2
    });
  }
  removeHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", false);
  }
  setHoverStyle(element, datasetIndex, index2) {
    this._setStyle(element, index2, "active", true);
  }
  _removeDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", false);
    }
  }
  _setDatasetHoverStyle() {
    const element = this._cachedMeta.dataset;
    if (element) {
      this._setStyle(element, void 0, "active", true);
    }
  }
  _resyncElements(resetNewElements) {
    const data = this._data;
    const elements2 = this._cachedMeta.data;
    for (const [method, arg1, arg2] of this._syncList) {
      this[method](arg1, arg2);
    }
    this._syncList = [];
    const numMeta = elements2.length;
    const numData = data.length;
    const count = Math.min(numData, numMeta);
    if (count) {
      this.parse(0, count);
    }
    if (numData > numMeta) {
      this._insertElements(numMeta, numData - numMeta, resetNewElements);
    } else if (numData < numMeta) {
      this._removeElements(numData, numMeta - numData);
    }
  }
  _insertElements(start, count, resetNewElements = true) {
    const meta = this._cachedMeta;
    const data = meta.data;
    const end = start + count;
    let i;
    const move = (arr) => {
      arr.length += count;
      for (i = arr.length - 1; i >= end; i--) {
        arr[i] = arr[i - count];
      }
    };
    move(data);
    for (i = start; i < end; ++i) {
      data[i] = new this.dataElementType();
    }
    if (this._parsing) {
      move(meta._parsed);
    }
    this.parse(start, count);
    if (resetNewElements) {
      this.updateElements(data, start, count, "reset");
    }
  }
  updateElements(element, start, count, mode) {
  }
  _removeElements(start, count) {
    const meta = this._cachedMeta;
    if (this._parsing) {
      const removed = meta._parsed.splice(start, count);
      if (meta._stacked) {
        clearStacks(meta, removed);
      }
    }
    meta.data.splice(start, count);
  }
  _sync(args) {
    if (this._parsing) {
      this._syncList.push(args);
    } else {
      const [method, arg1, arg2] = args;
      this[method](arg1, arg2);
    }
    this.chart._dataChanges.push([
      this.index,
      ...args
    ]);
  }
  _onDataPush() {
    const count = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - count,
      count
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(start, count) {
    if (count) {
      this._sync([
        "_removeElements",
        start,
        count
      ]);
    }
    const newCount = arguments.length - 2;
    if (newCount) {
      this._sync([
        "_insertElements",
        start,
        newCount
      ]);
    }
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
};
__publicField(DatasetController, "defaults", {});
__publicField(DatasetController, "datasetElementType", null);
__publicField(DatasetController, "dataElementType", null);
function getAllScaleValues(scale, type) {
  if (!scale._cache.$bar) {
    const visibleMetas = scale.getMatchingVisibleMetas(type);
    let values = [];
    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
    }
    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
  }
  return scale._cache.$bar;
}
function computeMinSampleSize(meta) {
  const scale = meta.iScale;
  const values = getAllScaleValues(scale, meta.type);
  let min = scale._length;
  let i, ilen, curr, prev;
  const updateMinAndPrev = () => {
    if (curr === 32767 || curr === -32768) {
      return;
    }
    if (defined(prev)) {
      min = Math.min(min, Math.abs(curr - prev) || min);
    }
    prev = curr;
  };
  for (i = 0, ilen = values.length; i < ilen; ++i) {
    curr = scale.getPixelForValue(values[i]);
    updateMinAndPrev();
  }
  prev = void 0;
  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
    curr = scale.getPixelForTick(i);
    updateMinAndPrev();
  }
  return min;
}
function computeFitCategoryTraits(index2, ruler, options2, stackCount) {
  const thickness = options2.barThickness;
  let size, ratio;
  if (isNullOrUndef(thickness)) {
    size = ruler.min * options2.categoryPercentage;
    ratio = options2.barPercentage;
  } else {
    size = thickness * stackCount;
    ratio = 1;
  }
  return {
    chunk: size / stackCount,
    ratio,
    start: ruler.pixels[index2] - size / 2
  };
}
function computeFlexCategoryTraits(index2, ruler, options2, stackCount) {
  const pixels = ruler.pixels;
  const curr = pixels[index2];
  let prev = index2 > 0 ? pixels[index2 - 1] : null;
  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
  const percent = options2.categoryPercentage;
  if (prev === null) {
    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
  }
  if (next === null) {
    next = curr + curr - prev;
  }
  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
  const size = Math.abs(next - prev) / 2 * percent;
  return {
    chunk: size / stackCount,
    ratio: options2.barPercentage,
    start
  };
}
function parseFloatBar(entry, item, vScale, i) {
  const startValue = vScale.parse(entry[0], i);
  const endValue = vScale.parse(entry[1], i);
  const min = Math.min(startValue, endValue);
  const max = Math.max(startValue, endValue);
  let barStart = min;
  let barEnd = max;
  if (Math.abs(min) > Math.abs(max)) {
    barStart = max;
    barEnd = min;
  }
  item[vScale.axis] = barEnd;
  item._custom = {
    barStart,
    barEnd,
    start: startValue,
    end: endValue,
    min,
    max
  };
}
function parseValue(entry, item, vScale, i) {
  if (isArray(entry)) {
    parseFloatBar(entry, item, vScale, i);
  } else {
    item[vScale.axis] = vScale.parse(entry, i);
  }
  return item;
}
function parseArrayOrPrimitive(meta, data, start, count) {
  const iScale = meta.iScale;
  const vScale = meta.vScale;
  const labels = iScale.getLabels();
  const singleScale = iScale === vScale;
  const parsed = [];
  let i, ilen, item, entry;
  for (i = start, ilen = start + count; i < ilen; ++i) {
    entry = data[i];
    item = {};
    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
    parsed.push(parseValue(entry, item, vScale, i));
  }
  return parsed;
}
function isFloatBar(custom2) {
  return custom2 && custom2.barStart !== void 0 && custom2.barEnd !== void 0;
}
function barSign(size, vScale, actualBase) {
  if (size !== 0) {
    return sign(size);
  }
  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
}
function borderProps(properties) {
  let reverse, start, end, top, bottom;
  if (properties.horizontal) {
    reverse = properties.base > properties.x;
    start = "left";
    end = "right";
  } else {
    reverse = properties.base < properties.y;
    start = "bottom";
    end = "top";
  }
  if (reverse) {
    top = "end";
    bottom = "start";
  } else {
    top = "start";
    bottom = "end";
  }
  return {
    start,
    end,
    reverse,
    top,
    bottom
  };
}
function setBorderSkipped(properties, options2, stack, index2) {
  let edge = options2.borderSkipped;
  const res = {};
  if (!edge) {
    properties.borderSkipped = res;
    return;
  }
  if (edge === true) {
    properties.borderSkipped = {
      top: true,
      right: true,
      bottom: true,
      left: true
    };
    return;
  }
  const { start, end, reverse, top, bottom } = borderProps(properties);
  if (edge === "middle" && stack) {
    properties.enableBorderRadius = true;
    if ((stack._top || 0) === index2) {
      edge = top;
    } else if ((stack._bottom || 0) === index2) {
      edge = bottom;
    } else {
      res[parseEdge(bottom, start, end, reverse)] = true;
      edge = top;
    }
  }
  res[parseEdge(edge, start, end, reverse)] = true;
  properties.borderSkipped = res;
}
function parseEdge(edge, a, b, reverse) {
  if (reverse) {
    edge = swap(edge, a, b);
    edge = startEnd(edge, b, a);
  } else {
    edge = startEnd(edge, a, b);
  }
  return edge;
}
function swap(orig, v1, v2) {
  return orig === v1 ? v2 : orig === v2 ? v1 : orig;
}
function startEnd(v, start, end) {
  return v === "start" ? start : v === "end" ? end : v;
}
function setInflateAmount(properties, { inflateAmount }, ratio) {
  properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? 0.33 : 0 : inflateAmount;
}
var BarController = class extends DatasetController {
  parsePrimitiveData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseArrayData(meta, data, start, count) {
    return parseArrayOrPrimitive(meta, data, start, count);
  }
  parseObjectData(meta, data, start, count) {
    const { iScale, vScale } = meta;
    const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
    const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
    const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
    const parsed = [];
    let i, ilen, item, obj;
    for (i = start, ilen = start + count; i < ilen; ++i) {
      obj = data[i];
      item = {};
      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
    }
    return parsed;
  }
  updateRangeFromParsed(range, scale, parsed, stack) {
    super.updateRangeFromParsed(range, scale, parsed, stack);
    const custom2 = parsed._custom;
    if (custom2 && scale === this._cachedMeta.vScale) {
      range.min = Math.min(range.min, custom2.min);
      range.max = Math.max(range.max, custom2.max);
    }
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const { iScale, vScale } = meta;
    const parsed = this.getParsed(index2);
    const custom2 = parsed._custom;
    const value = isFloatBar(custom2) ? "[" + custom2.start + ", " + custom2.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
    return {
      label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
      value
    };
  }
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
    const meta = this._cachedMeta;
    meta.stack = this.getDataset().stack;
  }
  update(mode) {
    const meta = this._cachedMeta;
    this.updateElements(meta.data, 0, meta.data.length, mode);
  }
  updateElements(bars, start, count, mode) {
    const reset = mode === "reset";
    const { index: index2, _cachedMeta: { vScale } } = this;
    const base = vScale.getBasePixel();
    const horizontal = vScale.isHorizontal();
    const ruler = this._getRuler();
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    for (let i = start; i < start + count; i++) {
      const parsed = this.getParsed(i);
      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
        base,
        head: base
      } : this._calculateBarValuePixels(i);
      const ipixels = this._calculateBarIndexPixels(i, ruler);
      const stack = (parsed._stacks || {})[vScale.axis];
      const properties = {
        horizontal,
        base: vpixels.base,
        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,
        x: horizontal ? vpixels.head : ipixels.center,
        y: horizontal ? ipixels.center : vpixels.head,
        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
      }
      const options2 = properties.options || bars[i].options;
      setBorderSkipped(properties, options2, stack, index2);
      setInflateAmount(properties, options2, ruler.ratio);
      this.updateElement(bars[i], i, properties, mode);
    }
  }
  _getStacks(last, dataIndex) {
    const { iScale } = this._cachedMeta;
    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);
    const stacked = iScale.options.stacked;
    const stacks = [];
    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
    const iScaleValue = currentParsed && currentParsed[iScale.axis];
    const skipNull = (meta) => {
      const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);
      const val = parsed && parsed[meta.vScale.axis];
      if (isNullOrUndef(val) || isNaN(val)) {
        return true;
      }
    };
    for (const meta of metasets) {
      if (dataIndex !== void 0 && skipNull(meta)) {
        continue;
      }
      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {
        stacks.push(meta.stack);
      }
      if (meta.index === last) {
        break;
      }
    }
    if (!stacks.length) {
      stacks.push(void 0);
    }
    return stacks;
  }
  _getStackCount(index2) {
    return this._getStacks(void 0, index2).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const scales2 = this.chart.scales;
    const indexScaleId = this.chart.options.indexAxis;
    return Object.keys(scales2).filter((key) => scales2[key].axis === indexScaleId).shift();
  }
  _getAxis() {
    const axis = {};
    const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();
    for (const dataset of this.chart.data.datasets) {
      axis[valueOrDefault(this.chart.options.indexAxis === "x" ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;
    }
    return Object.keys(axis);
  }
  _getStackIndex(datasetIndex, name, dataIndex) {
    const stacks = this._getStacks(datasetIndex, dataIndex);
    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;
    return index2 === -1 ? stacks.length - 1 : index2;
  }
  _getRuler() {
    const opts = this.options;
    const meta = this._cachedMeta;
    const iScale = meta.iScale;
    const pixels = [];
    let i, ilen;
    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
    }
    const barThickness = opts.barThickness;
    const min = barThickness || computeMinSampleSize(meta);
    return {
      min,
      pixels,
      start: iScale._startPixel,
      end: iScale._endPixel,
      stackCount: this._getStackCount(),
      scale: iScale,
      grouped: opts.grouped,
      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
    };
  }
  _calculateBarValuePixels(index2) {
    const { _cachedMeta: { vScale, _stacked, index: datasetIndex }, options: { base: baseValue, minBarLength } } = this;
    const actualBase = baseValue || 0;
    const parsed = this.getParsed(index2);
    const custom2 = parsed._custom;
    const floating = isFloatBar(custom2);
    let value = parsed[vScale.axis];
    let start = 0;
    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
    let head, size;
    if (length !== value) {
      start = length - value;
      length = value;
    }
    if (floating) {
      value = custom2.barStart;
      length = custom2.barEnd - custom2.barStart;
      if (value !== 0 && sign(value) !== sign(custom2.barEnd)) {
        start = 0;
      }
      start += value;
    }
    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
    let base = vScale.getPixelForValue(startValue);
    if (this.chart.getDataVisibility(index2)) {
      head = vScale.getPixelForValue(start + length);
    } else {
      head = base;
    }
    size = head - base;
    if (Math.abs(size) < minBarLength) {
      size = barSign(size, vScale, actualBase) * minBarLength;
      if (value === actualBase) {
        base -= size / 2;
      }
      const startPixel = vScale.getPixelForDecimal(0);
      const endPixel = vScale.getPixelForDecimal(1);
      const min = Math.min(startPixel, endPixel);
      const max = Math.max(startPixel, endPixel);
      base = Math.max(Math.min(base, max), min);
      head = base + size;
      if (_stacked && !floating) {
        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
      }
    }
    if (base === vScale.getPixelForValue(actualBase)) {
      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
      base += halfGrid;
      size -= halfGrid;
    }
    return {
      size,
      base,
      head,
      center: head + size / 2
    };
  }
  _calculateBarIndexPixels(index2, ruler) {
    const scale = ruler.scale;
    const options2 = this.options;
    const skipNull = options2.skipNull;
    const maxBarThickness = valueOrDefault(options2.maxBarThickness, Infinity);
    let center, size;
    const axisCount = this._getAxisCount();
    if (ruler.grouped) {
      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;
      const range = options2.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options2, stackCount * axisCount) : computeFitCategoryTraits(index2, ruler, options2, stackCount * axisCount);
      const axisID = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID;
      const axisNumber = this._getAxis().indexOf(valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));
      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0) + axisNumber;
      center = range.start + range.chunk * stackIndex + range.chunk / 2;
      size = Math.min(maxBarThickness, range.chunk * range.ratio);
    } else {
      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);
      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
    }
    return {
      base: center - size / 2,
      head: center + size / 2,
      center,
      size
    };
  }
  draw() {
    const meta = this._cachedMeta;
    const vScale = meta.vScale;
    const rects = meta.data;
    const ilen = rects.length;
    let i = 0;
    for (; i < ilen; ++i) {
      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
        rects[i].draw(this._ctx);
      }
    }
  }
};
__publicField(BarController, "id", "bar");
__publicField(BarController, "defaults", {
  datasetElementType: false,
  dataElementType: "bar",
  categoryPercentage: 0.8,
  barPercentage: 0.9,
  grouped: true,
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "base",
        "width",
        "height"
      ]
    }
  }
});
__publicField(BarController, "overrides", {
  scales: {
    _index_: {
      type: "category",
      offset: true,
      grid: {
        offset: true
      }
    },
    _value_: {
      type: "linear",
      beginAtZero: true
    }
  }
});
var BubbleController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    super.initialize();
  }
  parsePrimitiveData(meta, data, start, count) {
    const parsed = super.parsePrimitiveData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
    }
    return parsed;
  }
  parseArrayData(meta, data, start, count) {
    const parsed = super.parseArrayData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  parseObjectData(meta, data, start, count) {
    const parsed = super.parseObjectData(meta, data, start, count);
    for (let i = 0; i < parsed.length; i++) {
      const item = data[start + i];
      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
    }
    return parsed;
  }
  getMaxOverflow() {
    const data = this._cachedMeta.data;
    let max = 0;
    for (let i = data.length - 1; i >= 0; --i) {
      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
    }
    return max > 0 && max;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    const r = parsed._custom;
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
    };
  }
  update(mode) {
    const points = this._cachedMeta.data;
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const parsed = !reset && this.getParsed(i);
      const properties = {};
      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
      properties.skip = isNaN(iPixel) || isNaN(vPixel);
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
        if (reset) {
          properties.options.radius = 0;
        }
      }
      this.updateElement(point, i, properties, mode);
    }
  }
  resolveDataElementOptions(index2, mode) {
    const parsed = this.getParsed(index2);
    let values = super.resolveDataElementOptions(index2, mode);
    if (values.$shared) {
      values = Object.assign({}, values, {
        $shared: false
      });
    }
    const radius = values.radius;
    if (mode !== "active") {
      values.radius = 0;
    }
    values.radius += valueOrDefault(parsed && parsed._custom, radius);
    return values;
  }
};
__publicField(BubbleController, "id", "bubble");
__publicField(BubbleController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "borderWidth",
        "radius"
      ]
    }
  }
});
__publicField(BubbleController, "overrides", {
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
function getRatioAndOffset(rotation, circumference, cutout) {
  let ratioX = 1;
  let ratioY = 1;
  let offsetX = 0;
  let offsetY = 0;
  if (circumference < TAU) {
    const startAngle = rotation;
    const endAngle = startAngle + circumference;
    const startX = Math.cos(startAngle);
    const startY = Math.sin(startAngle);
    const endX = Math.cos(endAngle);
    const endY = Math.sin(endAngle);
    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
    const maxX = calcMax(0, startX, endX);
    const maxY = calcMax(HALF_PI, startY, endY);
    const minX = calcMin(PI, startX, endX);
    const minY = calcMin(PI + HALF_PI, startY, endY);
    ratioX = (maxX - minX) / 2;
    ratioY = (maxY - minY) / 2;
    offsetX = -(maxX + minX) / 2;
    offsetY = -(maxY + minY) / 2;
  }
  return {
    ratioX,
    ratioY,
    offsetX,
    offsetY
  };
}
var DoughnutController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.enableOptionSharing = true;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.offsetX = void 0;
    this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(start, count) {
    const data = this.getDataset().data;
    const meta = this._cachedMeta;
    if (this._parsing === false) {
      meta._parsed = data;
    } else {
      let getter = (i2) => +data[i2];
      if (isObject(data[start])) {
        const { key = "value" } = this._parsing;
        getter = (i2) => +resolveObjectKey(data[i2], key);
      }
      let i, ilen;
      for (i = start, ilen = start + count; i < ilen; ++i) {
        meta._parsed[i] = getter(i);
      }
    }
  }
  _getRotation() {
    return toRadians(this.options.rotation - 90);
  }
  _getCircumference() {
    return toRadians(this.options.circumference);
  }
  _getRotationExtents() {
    let min = TAU;
    let max = -TAU;
    for (let i = 0; i < this.chart.data.datasets.length; ++i) {
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const controller = this.chart.getDatasetMeta(i).controller;
        const rotation = controller._getRotation();
        const circumference = controller._getCircumference();
        min = Math.min(min, rotation);
        max = Math.max(max, rotation + circumference);
      }
    }
    return {
      rotation: min,
      circumference: max - min
    };
  }
  update(mode) {
    const chart = this.chart;
    const { chartArea } = chart;
    const meta = this._cachedMeta;
    const arcs = meta.data;
    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
    const chartWeight = this._getRingWeight(this.index);
    const { circumference, rotation } = this._getRotationExtents();
    const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
    const maxWidth = (chartArea.width - spacing) / ratioX;
    const maxHeight = (chartArea.height - spacing) / ratioY;
    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
    const outerRadius = toDimension(this.options.radius, maxRadius);
    const innerRadius = Math.max(outerRadius * cutout, 0);
    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
    this.offsetX = offsetX * outerRadius;
    this.offsetY = offsetY * outerRadius;
    meta.total = this.calculateTotal();
    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  _circumference(i, reset) {
    const opts = this.options;
    const meta = this._cachedMeta;
    const circumference = this._getCircumference();
    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
      return 0;
    }
    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const centerX = (chartArea.left + chartArea.right) / 2;
    const centerY = (chartArea.top + chartArea.bottom) / 2;
    const animateScale = reset && animationOpts.animateScale;
    const innerRadius = animateScale ? 0 : this.innerRadius;
    const outerRadius = animateScale ? 0 : this.outerRadius;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    let startAngle = this._getRotation();
    let i;
    for (i = 0; i < start; ++i) {
      startAngle += this._circumference(i, reset);
    }
    for (i = start; i < start + count; ++i) {
      const circumference = this._circumference(i, reset);
      const arc = arcs[i];
      const properties = {
        x: centerX + this.offsetX,
        y: centerY + this.offsetY,
        startAngle,
        endAngle: startAngle + circumference,
        circumference,
        outerRadius,
        innerRadius
      };
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
      }
      startAngle += circumference;
      this.updateElement(arc, i, properties, mode);
    }
  }
  calculateTotal() {
    const meta = this._cachedMeta;
    const metaData = meta.data;
    let total = 0;
    let i;
    for (i = 0; i < metaData.length; i++) {
      const value = meta._parsed[i];
      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
        total += Math.abs(value);
      }
    }
    return total;
  }
  calculateCircumference(value) {
    const total = this._cachedMeta.total;
    if (total > 0 && !isNaN(value)) {
      return TAU * (Math.abs(value) / total);
    }
    return 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2], chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  getMaxBorderWidth(arcs) {
    let max = 0;
    const chart = this.chart;
    let i, ilen, meta, controller, options2;
    if (!arcs) {
      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);
          arcs = meta.data;
          controller = meta.controller;
          break;
        }
      }
    }
    if (!arcs) {
      return 0;
    }
    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
      options2 = controller.resolveDataElementOptions(i);
      if (options2.borderAlign !== "inner") {
        max = Math.max(max, options2.borderWidth || 0, options2.hoverBorderWidth || 0);
      }
    }
    return max;
  }
  getMaxOffset(arcs) {
    let max = 0;
    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
      const options2 = this.resolveDataElementOptions(i);
      max = Math.max(max, options2.offset || 0, options2.hoverOffset || 0);
    }
    return max;
  }
  _getRingWeightOffset(datasetIndex) {
    let ringWeightOffset = 0;
    for (let i = 0; i < datasetIndex; ++i) {
      if (this.chart.isDatasetVisible(i)) {
        ringWeightOffset += this._getRingWeight(i);
      }
    }
    return ringWeightOffset;
  }
  _getRingWeight(datasetIndex) {
    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
};
__publicField(DoughnutController, "id", "doughnut");
__publicField(DoughnutController, "defaults", {
  datasetElementType: false,
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: false
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "circumference",
        "endAngle",
        "innerRadius",
        "outerRadius",
        "startAngle",
        "x",
        "y",
        "offset",
        "borderWidth",
        "spacing"
      ]
    }
  },
  cutout: "50%",
  rotation: 0,
  circumference: 360,
  radius: "100%",
  spacing: 0,
  indexAxis: "r"
});
__publicField(DoughnutController, "descriptors", {
  _scriptable: (name) => name !== "spacing",
  _indexable: (name) => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
});
__publicField(DoughnutController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  }
});
var LineController = class extends DatasetController {
  initialize() {
    this.enableOptionSharing = true;
    this.supportsDecimation = true;
    super.initialize();
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { dataset: line, data: points = [], _dataset } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    line._chart = this.chart;
    line._datasetIndex = this.index;
    line._decimated = !!_dataset._decimated;
    line.points = points;
    const options2 = this.resolveDatasetElementOptions(mode);
    if (!this.options.showLine) {
      options2.borderWidth = 0;
    }
    options2.segment = this.options.segment;
    this.updateElement(line, void 0, {
      animated: !animationsDisabled,
      options: options2
    }, mode);
    this.updateElements(points, start, count, mode);
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    const end = start + count;
    const pointsCount = points.length;
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = 0; i < pointsCount; ++i) {
      const point = points[i];
      const properties = directUpdate ? point : {};
      if (i < start || i >= end) {
        properties.skip = true;
        continue;
      }
      const parsed = this.getParsed(i);
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    const data = meta.data || [];
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
  draw() {
    const meta = this._cachedMeta;
    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
    super.draw();
  }
};
__publicField(LineController, "id", "line");
__publicField(LineController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  showLine: true,
  spanGaps: false
});
__publicField(LineController, "overrides", {
  scales: {
    _index_: {
      type: "category"
    },
    _value_: {
      type: "linear"
    }
  }
});
var PolarAreaController = class extends DatasetController {
  constructor(chart, datasetIndex) {
    super(chart, datasetIndex);
    this.innerRadius = void 0;
    this.outerRadius = void 0;
  }
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const chart = this.chart;
    const labels = chart.data.labels || [];
    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
    return {
      label: labels[index2] || "",
      value
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const arcs = this._cachedMeta.data;
    this._updateRadius();
    this.updateElements(arcs, 0, arcs.length, mode);
  }
  getMinMax() {
    const meta = this._cachedMeta;
    const range = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    };
    meta.data.forEach((element, index2) => {
      const parsed = this.getParsed(index2).r;
      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {
        if (parsed < range.min) {
          range.min = parsed;
        }
        if (parsed > range.max) {
          range.max = parsed;
        }
      }
    });
    return range;
  }
  _updateRadius() {
    const chart = this.chart;
    const chartArea = chart.chartArea;
    const opts = chart.options;
    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
    const outerRadius = Math.max(minSize / 2, 0);
    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
    this.outerRadius = outerRadius - radiusLength * this.index;
    this.innerRadius = this.outerRadius - radiusLength;
  }
  updateElements(arcs, start, count, mode) {
    const reset = mode === "reset";
    const chart = this.chart;
    const opts = chart.options;
    const animationOpts = opts.animation;
    const scale = this._cachedMeta.rScale;
    const centerX = scale.xCenter;
    const centerY = scale.yCenter;
    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
    let angle = datasetStartAngle;
    let i;
    const defaultAngle = 360 / this.countVisibleElements();
    for (i = 0; i < start; ++i) {
      angle += this._computeAngle(i, mode, defaultAngle);
    }
    for (i = start; i < start + count; i++) {
      const arc = arcs[i];
      let startAngle = angle;
      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
      angle = endAngle;
      if (reset) {
        if (animationOpts.animateScale) {
          outerRadius = 0;
        }
        if (animationOpts.animateRotate) {
          startAngle = endAngle = datasetStartAngle;
        }
      }
      const properties = {
        x: centerX,
        y: centerY,
        innerRadius: 0,
        outerRadius,
        startAngle,
        endAngle,
        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
      };
      this.updateElement(arc, i, properties, mode);
    }
  }
  countVisibleElements() {
    const meta = this._cachedMeta;
    let count = 0;
    meta.data.forEach((element, index2) => {
      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {
        count++;
      }
    });
    return count;
  }
  _computeAngle(index2, mode, defaultAngle) {
    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
  }
};
__publicField(PolarAreaController, "id", "polarArea");
__publicField(PolarAreaController, "defaults", {
  dataElementType: "arc",
  animation: {
    animateRotate: true,
    animateScale: true
  },
  animations: {
    numbers: {
      type: "number",
      properties: [
        "x",
        "y",
        "startAngle",
        "endAngle",
        "innerRadius",
        "outerRadius"
      ]
    }
  },
  indexAxis: "r",
  startAngle: 0
});
__publicField(PolarAreaController, "overrides", {
  aspectRatio: 1,
  plugins: {
    legend: {
      labels: {
        generateLabels(chart) {
          const data = chart.data;
          if (data.labels.length && data.datasets.length) {
            const { labels: { pointStyle, color: color2 } } = chart.legend.options;
            return data.labels.map((label, i) => {
              const meta = chart.getDatasetMeta(0);
              const style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                fontColor: color2,
                lineWidth: style.borderWidth,
                pointStyle,
                hidden: !chart.getDataVisibility(i),
                index: i
              };
            });
          }
          return [];
        }
      },
      onClick(e, legendItem, legend) {
        legend.chart.toggleDataVisibility(legendItem.index);
        legend.chart.update();
      }
    }
  },
  scales: {
    r: {
      type: "radialLinear",
      angleLines: {
        display: false
      },
      beginAtZero: true,
      grid: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      startAngle: 0
    }
  }
});
var PieController = class extends DoughnutController {
};
__publicField(PieController, "id", "pie");
__publicField(PieController, "defaults", {
  cutout: 0,
  rotation: 0,
  circumference: 360,
  radius: "100%"
});
var RadarController = class extends DatasetController {
  getLabelAndValue(index2) {
    const vScale = this._cachedMeta.vScale;
    const parsed = this.getParsed(index2);
    return {
      label: vScale.getLabels()[index2],
      value: "" + vScale.getLabelForValue(parsed[vScale.axis])
    };
  }
  parseObjectData(meta, data, start, count) {
    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
  }
  update(mode) {
    const meta = this._cachedMeta;
    const line = meta.dataset;
    const points = meta.data || [];
    const labels = meta.iScale.getLabels();
    line.points = points;
    if (mode !== "resize") {
      const options2 = this.resolveDatasetElementOptions(mode);
      if (!this.options.showLine) {
        options2.borderWidth = 0;
      }
      const properties = {
        _loop: true,
        _fullLoop: labels.length === points.length,
        options: options2
      };
      this.updateElement(line, void 0, properties, mode);
    }
    this.updateElements(points, 0, points.length, mode);
  }
  updateElements(points, start, count, mode) {
    const scale = this._cachedMeta.rScale;
    const reset = mode === "reset";
    for (let i = start; i < start + count; i++) {
      const point = points[i];
      const options2 = this.resolveDataElementOptions(i, point.active ? "active" : mode);
      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
      const x = reset ? scale.xCenter : pointPosition.x;
      const y = reset ? scale.yCenter : pointPosition.y;
      const properties = {
        x,
        y,
        angle: pointPosition.angle,
        skip: isNaN(x) || isNaN(y),
        options: options2
      };
      this.updateElement(point, i, properties, mode);
    }
  }
};
__publicField(RadarController, "id", "radar");
__publicField(RadarController, "defaults", {
  datasetElementType: "line",
  dataElementType: "point",
  indexAxis: "r",
  showLine: true,
  elements: {
    line: {
      fill: "start"
    }
  }
});
__publicField(RadarController, "overrides", {
  aspectRatio: 1,
  scales: {
    r: {
      type: "radialLinear"
    }
  }
});
var ScatterController = class extends DatasetController {
  getLabelAndValue(index2) {
    const meta = this._cachedMeta;
    const labels = this.chart.data.labels || [];
    const { xScale, yScale } = meta;
    const parsed = this.getParsed(index2);
    const x = xScale.getLabelForValue(parsed.x);
    const y = yScale.getLabelForValue(parsed.y);
    return {
      label: labels[index2] || "",
      value: "(" + x + ", " + y + ")"
    };
  }
  update(mode) {
    const meta = this._cachedMeta;
    const { data: points = [] } = meta;
    const animationsDisabled = this.chart._animationsDisabled;
    let { start, count } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
    this._drawStart = start;
    this._drawCount = count;
    if (_scaleRangesChanged(meta)) {
      start = 0;
      count = points.length;
    }
    if (this.options.showLine) {
      if (!this.datasetElementType) {
        this.addElements();
      }
      const { dataset: line, _dataset } = meta;
      line._chart = this.chart;
      line._datasetIndex = this.index;
      line._decimated = !!_dataset._decimated;
      line.points = points;
      const options2 = this.resolveDatasetElementOptions(mode);
      options2.segment = this.options.segment;
      this.updateElement(line, void 0, {
        animated: !animationsDisabled,
        options: options2
      }, mode);
    } else if (this.datasetElementType) {
      delete meta.dataset;
      this.datasetElementType = false;
    }
    this.updateElements(points, start, count, mode);
  }
  addElements() {
    const { showLine } = this.options;
    if (!this.datasetElementType && showLine) {
      this.datasetElementType = this.chart.registry.getElement("line");
    }
    super.addElements();
  }
  updateElements(points, start, count, mode) {
    const reset = mode === "reset";
    const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
    const firstOpts = this.resolveDataElementOptions(start, mode);
    const sharedOptions = this.getSharedOptions(firstOpts);
    const includeOptions = this.includeOptions(mode, sharedOptions);
    const iAxis = iScale.axis;
    const vAxis = vScale.axis;
    const { spanGaps, segment } = this.options;
    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
    const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
    let prevParsed = start > 0 && this.getParsed(start - 1);
    for (let i = start; i < start + count; ++i) {
      const point = points[i];
      const parsed = this.getParsed(i);
      const properties = directUpdate ? point : {};
      const nullData = isNullOrUndef(parsed[vAxis]);
      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
      if (segment) {
        properties.parsed = parsed;
        properties.raw = _dataset.data[i];
      }
      if (includeOptions) {
        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
      }
      if (!directUpdate) {
        this.updateElement(point, i, properties, mode);
      }
      prevParsed = parsed;
    }
    this.updateSharedOptions(sharedOptions, mode, firstOpts);
  }
  getMaxOverflow() {
    const meta = this._cachedMeta;
    const data = meta.data || [];
    if (!this.options.showLine) {
      let max = 0;
      for (let i = data.length - 1; i >= 0; --i) {
        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
      }
      return max > 0 && max;
    }
    const dataset = meta.dataset;
    const border = dataset.options && dataset.options.borderWidth || 0;
    if (!data.length) {
      return border;
    }
    const firstPoint = data[0].size(this.resolveDataElementOptions(0));
    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
    return Math.max(border, firstPoint, lastPoint) / 2;
  }
};
__publicField(ScatterController, "id", "scatter");
__publicField(ScatterController, "defaults", {
  datasetElementType: false,
  dataElementType: "point",
  showLine: false,
  fill: false
});
__publicField(ScatterController, "overrides", {
  interaction: {
    mode: "point"
  },
  scales: {
    x: {
      type: "linear"
    },
    y: {
      type: "linear"
    }
  }
});
var controllers = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BarController,
  BubbleController,
  DoughnutController,
  LineController,
  PieController,
  PolarAreaController,
  RadarController,
  ScatterController
});
function abstract() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
var DateAdapterBase = class _DateAdapterBase {
  constructor(options2) {
    __publicField(this, "options");
    this.options = options2 || {};
  }
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(members) {
    Object.assign(_DateAdapterBase.prototype, members);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return abstract();
  }
  parse() {
    return abstract();
  }
  format() {
    return abstract();
  }
  add() {
    return abstract();
  }
  diff() {
    return abstract();
  }
  startOf() {
    return abstract();
  }
  endOf() {
    return abstract();
  }
};
var adapters = {
  _date: DateAdapterBase
};
function binarySearch(metaset, axis, value, intersect) {
  const { controller, data, _sorted } = metaset;
  const iScale = controller._cachedMeta.iScale;
  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;
  if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
    if (!intersect) {
      const result = lookupMethod(data, axis, value);
      if (spanGaps) {
        const { vScale } = controller._cachedMeta;
        const { _parsed } = metaset;
        const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.lo -= Math.max(0, distanceToDefinedLo);
        const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));
        result.hi += Math.max(0, distanceToDefinedHi);
      }
      return result;
    } else if (controller._sharedOptions) {
      const el = data[0];
      const range = typeof el.getRange === "function" && el.getRange(axis);
      if (range) {
        const start = lookupMethod(data, axis, value - range);
        const end = lookupMethod(data, axis, value + range);
        return {
          lo: start.lo,
          hi: end.hi
        };
      }
    }
  }
  return {
    lo: 0,
    hi: data.length - 1
  };
}
function evaluateInteractionItems(chart, axis, position, handler, intersect) {
  const metasets = chart.getSortedVisibleDatasetMetas();
  const value = position[axis];
  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
    const { index: index2, data } = metasets[i];
    const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
    for (let j = lo; j <= hi; ++j) {
      const element = data[j];
      if (!element.skip) {
        handler(element, index2, j);
      }
    }
  }
}
function getDistanceMetricForAxis(axis) {
  const useX = axis.indexOf("x") !== -1;
  const useY = axis.indexOf("y") !== -1;
  return function(pt1, pt2) {
    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
  };
}
function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
  const items = [];
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return items;
  }
  const evaluationFunc = function(element, datasetIndex, index2) {
    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {
      return;
    }
    if (element.inRange(position.x, position.y, useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  };
  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
  return items;
}
function getNearestRadialItems(chart, position, axis, useFinalPosition) {
  let items = [];
  function evaluationFunc(element, datasetIndex, index2) {
    const { startAngle, endAngle } = element.getProps([
      "startAngle",
      "endAngle"
    ], useFinalPosition);
    const { angle } = getAngleFromPoint(element, {
      x: position.x,
      y: position.y
    });
    if (_angleBetween(angle, startAngle, endAngle)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  let items = [];
  const distanceMetric = getDistanceMetricForAxis(axis);
  let minDistance = Number.POSITIVE_INFINITY;
  function evaluationFunc(element, datasetIndex, index2) {
    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);
    if (intersect && !inRange2) {
      return;
    }
    const center = element.getCenterPoint(useFinalPosition);
    const pointInArea = !!includeInvisible || chart.isPointInArea(center);
    if (!pointInArea && !inRange2) {
      return;
    }
    const distance = distanceMetric(position, center);
    if (distance < minDistance) {
      items = [
        {
          element,
          datasetIndex,
          index: index2
        }
      ];
      minDistance = distance;
    } else if (distance === minDistance) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
    }
  }
  evaluateInteractionItems(chart, axis, position, evaluationFunc);
  return items;
}
function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
  if (!includeInvisible && !chart.isPointInArea(position)) {
    return [];
  }
  return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
}
function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
  const items = [];
  const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
  let intersectsItem = false;
  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {
    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
      items.push({
        element,
        datasetIndex,
        index: index2
      });
      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
    }
  });
  if (intersect && !intersectsItem) {
    return [];
  }
  return items;
}
var Interaction = {
  evaluateInteractionItems,
  modes: {
    index(chart, e, options2, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options2.axis || "x";
      const includeInvisible = options2.includeInvisible || false;
      const items = options2.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      const elements2 = [];
      if (!items.length) {
        return [];
      }
      chart.getSortedVisibleDatasetMetas().forEach((meta) => {
        const index2 = items[0].index;
        const element = meta.data[index2];
        if (element && !element.skip) {
          elements2.push({
            element,
            datasetIndex: meta.index,
            index: index2
          });
        }
      });
      return elements2;
    },
    dataset(chart, e, options2, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options2.axis || "xy";
      const includeInvisible = options2.includeInvisible || false;
      let items = options2.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
      if (items.length > 0) {
        const datasetIndex = items[0].datasetIndex;
        const data = chart.getDatasetMeta(datasetIndex).data;
        items = [];
        for (let i = 0; i < data.length; ++i) {
          items.push({
            element: data[i],
            datasetIndex,
            index: i
          });
        }
      }
      return items;
    },
    point(chart, e, options2, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options2.axis || "xy";
      const includeInvisible = options2.includeInvisible || false;
      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
    },
    nearest(chart, e, options2, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      const axis = options2.axis || "xy";
      const includeInvisible = options2.includeInvisible || false;
      return getNearestItems(chart, position, axis, options2.intersect, useFinalPosition, includeInvisible);
    },
    x(chart, e, options2, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "x", options2.intersect, useFinalPosition);
    },
    y(chart, e, options2, useFinalPosition) {
      const position = getRelativePosition(e, chart);
      return getAxisItems(chart, position, "y", options2.intersect, useFinalPosition);
    }
  }
};
var STATIC_POSITIONS = [
  "left",
  "top",
  "right",
  "bottom"
];
function filterByPosition(array, position) {
  return array.filter((v) => v.pos === position);
}
function filterDynamicPositionByAxis(array, axis) {
  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
}
function sortByWeight(array, reverse) {
  return array.sort((a, b) => {
    const v0 = reverse ? b : a;
    const v1 = reverse ? a : b;
    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
  });
}
function wrapBoxes(boxes) {
  const layoutBoxes = [];
  let i, ilen, box, pos, stack, stackWeight;
  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
    box = boxes[i];
    ({ position: pos, options: { stack, stackWeight = 1 } } = box);
    layoutBoxes.push({
      index: i,
      box,
      pos,
      horizontal: box.isHorizontal(),
      weight: box.weight,
      stack: stack && pos + stack,
      stackWeight
    });
  }
  return layoutBoxes;
}
function buildStacks(layouts2) {
  const stacks = {};
  for (const wrap of layouts2) {
    const { stack, pos, stackWeight } = wrap;
    if (!stack || !STATIC_POSITIONS.includes(pos)) {
      continue;
    }
    const _stack = stacks[stack] || (stacks[stack] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    _stack.count++;
    _stack.weight += stackWeight;
  }
  return stacks;
}
function setLayoutDims(layouts2, params) {
  const stacks = buildStacks(layouts2);
  const { vBoxMaxWidth, hBoxMaxHeight } = params;
  let i, ilen, layout;
  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
    layout = layouts2[i];
    const { fullSize } = layout.box;
    const stack = stacks[layout.stack];
    const factor = stack && layout.stackWeight / stack.weight;
    if (layout.horizontal) {
      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
      layout.height = hBoxMaxHeight;
    } else {
      layout.width = vBoxMaxWidth;
      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
    }
  }
  return stacks;
}
function buildLayoutBoxes(boxes) {
  const layoutBoxes = wrapBoxes(boxes);
  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
  const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
  const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
  const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
  const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
  return {
    fullSize,
    leftAndTop: left.concat(top),
    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
    chartArea: filterByPosition(layoutBoxes, "chartArea"),
    vertical: left.concat(right).concat(centerVertical),
    horizontal: top.concat(bottom).concat(centerHorizontal)
  };
}
function getCombinedMax(maxPadding, chartArea, a, b) {
  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
}
function updateMaxPadding(maxPadding, boxPadding) {
  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
}
function updateDims(chartArea, params, layout, stacks) {
  const { pos, box } = layout;
  const maxPadding = chartArea.maxPadding;
  if (!isObject(pos)) {
    if (layout.size) {
      chartArea[pos] -= layout.size;
    }
    const stack = stacks[layout.stack] || {
      size: 0,
      count: 1
    };
    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
    layout.size = stack.size / stack.count;
    chartArea[pos] += layout.size;
  }
  if (box.getPadding) {
    updateMaxPadding(maxPadding, box.getPadding());
  }
  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
  const widthChanged = newWidth !== chartArea.w;
  const heightChanged = newHeight !== chartArea.h;
  chartArea.w = newWidth;
  chartArea.h = newHeight;
  return layout.horizontal ? {
    same: widthChanged,
    other: heightChanged
  } : {
    same: heightChanged,
    other: widthChanged
  };
}
function handleMaxPadding(chartArea) {
  const maxPadding = chartArea.maxPadding;
  function updatePos(pos) {
    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
    chartArea[pos] += change;
    return change;
  }
  chartArea.y += updatePos("top");
  chartArea.x += updatePos("left");
  updatePos("right");
  updatePos("bottom");
}
function getMargins(horizontal, chartArea) {
  const maxPadding = chartArea.maxPadding;
  function marginForPositions(positions2) {
    const margin = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    positions2.forEach((pos) => {
      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
    });
    return margin;
  }
  return horizontal ? marginForPositions([
    "left",
    "right"
  ]) : marginForPositions([
    "top",
    "bottom"
  ]);
}
function fitBoxes(boxes, chartArea, params, stacks) {
  const refitBoxes = [];
  let i, ilen, layout, box, refit, changed;
  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
    layout = boxes[i];
    box = layout.box;
    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
    const { same, other } = updateDims(chartArea, params, layout, stacks);
    refit |= same && refitBoxes.length;
    changed = changed || other;
    if (!box.fullSize) {
      refitBoxes.push(layout);
    }
  }
  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
}
function setBoxDims(box, left, top, width, height) {
  box.top = top;
  box.left = left;
  box.right = left + width;
  box.bottom = top + height;
  box.width = width;
  box.height = height;
}
function placeBoxes(boxes, chartArea, params, stacks) {
  const userPadding = params.padding;
  let { x, y } = chartArea;
  for (const layout of boxes) {
    const box = layout.box;
    const stack = stacks[layout.stack] || {
      count: 1,
      placed: 0,
      weight: 1
    };
    const weight = layout.stackWeight / stack.weight || 1;
    if (layout.horizontal) {
      const width = chartArea.w * weight;
      const height = stack.size || box.height;
      if (defined(stack.start)) {
        y = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
      } else {
        setBoxDims(box, chartArea.left + stack.placed, y, width, height);
      }
      stack.start = y;
      stack.placed += width;
      y = box.bottom;
    } else {
      const height = chartArea.h * weight;
      const width = stack.size || box.width;
      if (defined(stack.start)) {
        x = stack.start;
      }
      if (box.fullSize) {
        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
      } else {
        setBoxDims(box, x, chartArea.top + stack.placed, width, height);
      }
      stack.start = x;
      stack.placed += height;
      x = box.right;
    }
  }
  chartArea.x = x;
  chartArea.y = y;
}
var layouts = {
  addBox(chart, item) {
    if (!chart.boxes) {
      chart.boxes = [];
    }
    item.fullSize = item.fullSize || false;
    item.position = item.position || "top";
    item.weight = item.weight || 0;
    item._layers = item._layers || function() {
      return [
        {
          z: 0,
          draw(chartArea) {
            item.draw(chartArea);
          }
        }
      ];
    };
    chart.boxes.push(item);
  },
  removeBox(chart, layoutItem) {
    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
    if (index2 !== -1) {
      chart.boxes.splice(index2, 1);
    }
  },
  configure(chart, item, options2) {
    item.fullSize = options2.fullSize;
    item.position = options2.position;
    item.weight = options2.weight;
  },
  update(chart, width, height, minPadding) {
    if (!chart) {
      return;
    }
    const padding = toPadding(chart.options.layout.padding);
    const availableWidth = Math.max(width - padding.width, 0);
    const availableHeight = Math.max(height - padding.height, 0);
    const boxes = buildLayoutBoxes(chart.boxes);
    const verticalBoxes = boxes.vertical;
    const horizontalBoxes = boxes.horizontal;
    each(chart.boxes, (box) => {
      if (typeof box.beforeLayout === "function") {
        box.beforeLayout();
      }
    });
    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
    const params = Object.freeze({
      outerWidth: width,
      outerHeight: height,
      padding,
      availableWidth,
      availableHeight,
      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
      hBoxMaxHeight: availableHeight / 2
    });
    const maxPadding = Object.assign({}, padding);
    updateMaxPadding(maxPadding, toPadding(minPadding));
    const chartArea = Object.assign({
      maxPadding,
      w: availableWidth,
      h: availableHeight,
      x: padding.left,
      y: padding.top
    }, padding);
    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
    fitBoxes(boxes.fullSize, chartArea, params, stacks);
    fitBoxes(verticalBoxes, chartArea, params, stacks);
    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
      fitBoxes(verticalBoxes, chartArea, params, stacks);
    }
    handleMaxPadding(chartArea);
    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
    chartArea.x += chartArea.w;
    chartArea.y += chartArea.h;
    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
    chart.chartArea = {
      left: chartArea.left,
      top: chartArea.top,
      right: chartArea.left + chartArea.w,
      bottom: chartArea.top + chartArea.h,
      height: chartArea.h,
      width: chartArea.w
    };
    each(boxes.chartArea, (layout) => {
      const box = layout.box;
      Object.assign(box, chart.chartArea);
      box.update(chartArea.w, chartArea.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
var BasePlatform = class {
  acquireContext(canvas, aspectRatio) {
  }
  releaseContext(context) {
    return false;
  }
  addEventListener(chart, type, listener) {
  }
  removeEventListener(chart, type, listener) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(element, width, height, aspectRatio) {
    width = Math.max(0, width || element.width);
    height = height || element.height;
    return {
      width,
      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
    };
  }
  isAttached(canvas) {
    return true;
  }
  updateConfig(config) {
  }
};
var BasicPlatform = class extends BasePlatform {
  acquireContext(item) {
    return item && item.getContext && item.getContext("2d") || null;
  }
  updateConfig(config) {
    config.options.animation = false;
  }
};
var EXPANDO_KEY = "$chartjs";
var EVENT_TYPES = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
};
var isNullOrEmpty = (value) => value === null || value === "";
function initCanvas(canvas, aspectRatio) {
  const style = canvas.style;
  const renderHeight = canvas.getAttribute("height");
  const renderWidth = canvas.getAttribute("width");
  canvas[EXPANDO_KEY] = {
    initial: {
      height: renderHeight,
      width: renderWidth,
      style: {
        display: style.display,
        height: style.height,
        width: style.width
      }
    }
  };
  style.display = style.display || "block";
  style.boxSizing = style.boxSizing || "border-box";
  if (isNullOrEmpty(renderWidth)) {
    const displayWidth = readUsedSize(canvas, "width");
    if (displayWidth !== void 0) {
      canvas.width = displayWidth;
    }
  }
  if (isNullOrEmpty(renderHeight)) {
    if (canvas.style.height === "") {
      canvas.height = canvas.width / (aspectRatio || 2);
    } else {
      const displayHeight = readUsedSize(canvas, "height");
      if (displayHeight !== void 0) {
        canvas.height = displayHeight;
      }
    }
  }
  return canvas;
}
var eventListenerOptions = supportsEventListenerOptions ? {
  passive: true
} : false;
function addListener(node, type, listener) {
  if (node) {
    node.addEventListener(type, listener, eventListenerOptions);
  }
}
function removeListener(chart, type, listener) {
  if (chart && chart.canvas) {
    chart.canvas.removeEventListener(type, listener, eventListenerOptions);
  }
}
function fromNativeEvent(event, chart) {
  const type = EVENT_TYPES[event.type] || event.type;
  const { x, y } = getRelativePosition(event, chart);
  return {
    type,
    chart,
    native: event,
    x: x !== void 0 ? x : null,
    y: y !== void 0 ? y : null
  };
}
function nodeListContains(nodeList, canvas) {
  for (const node of nodeList) {
    if (node === canvas || node.contains(canvas)) {
      return true;
    }
  }
}
function createAttachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.addedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
function createDetachObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const observer = new MutationObserver((entries) => {
    let trigger = false;
    for (const entry of entries) {
      trigger = trigger || nodeListContains(entry.removedNodes, canvas);
      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
    }
    if (trigger) {
      listener();
    }
  });
  observer.observe(document, {
    childList: true,
    subtree: true
  });
  return observer;
}
var drpListeningCharts = /* @__PURE__ */ new Map();
var oldDevicePixelRatio = 0;
function onWindowResize() {
  const dpr = window.devicePixelRatio;
  if (dpr === oldDevicePixelRatio) {
    return;
  }
  oldDevicePixelRatio = dpr;
  drpListeningCharts.forEach((resize, chart) => {
    if (chart.currentDevicePixelRatio !== dpr) {
      resize();
    }
  });
}
function listenDevicePixelRatioChanges(chart, resize) {
  if (!drpListeningCharts.size) {
    window.addEventListener("resize", onWindowResize);
  }
  drpListeningCharts.set(chart, resize);
}
function unlistenDevicePixelRatioChanges(chart) {
  drpListeningCharts.delete(chart);
  if (!drpListeningCharts.size) {
    window.removeEventListener("resize", onWindowResize);
  }
}
function createResizeObserver(chart, type, listener) {
  const canvas = chart.canvas;
  const container = canvas && _getParentNode(canvas);
  if (!container) {
    return;
  }
  const resize = throttled((width, height) => {
    const w = container.clientWidth;
    listener(width, height);
    if (w < container.clientWidth) {
      listener();
    }
  }, window);
  const observer = new ResizeObserver((entries) => {
    const entry = entries[0];
    const width = entry.contentRect.width;
    const height = entry.contentRect.height;
    if (width === 0 && height === 0) {
      return;
    }
    resize(width, height);
  });
  observer.observe(container);
  listenDevicePixelRatioChanges(chart, resize);
  return observer;
}
function releaseObserver(chart, type, observer) {
  if (observer) {
    observer.disconnect();
  }
  if (type === "resize") {
    unlistenDevicePixelRatioChanges(chart);
  }
}
function createProxyAndListen(chart, type, listener) {
  const canvas = chart.canvas;
  const proxy = throttled((event) => {
    if (chart.ctx !== null) {
      listener(fromNativeEvent(event, chart));
    }
  }, chart);
  addListener(canvas, type, proxy);
  return proxy;
}
var DomPlatform = class extends BasePlatform {
  acquireContext(canvas, aspectRatio) {
    const context = canvas && canvas.getContext && canvas.getContext("2d");
    if (context && context.canvas === canvas) {
      initCanvas(canvas, aspectRatio);
      return context;
    }
    return null;
  }
  releaseContext(context) {
    const canvas = context.canvas;
    if (!canvas[EXPANDO_KEY]) {
      return false;
    }
    const initial = canvas[EXPANDO_KEY].initial;
    [
      "height",
      "width"
    ].forEach((prop) => {
      const value = initial[prop];
      if (isNullOrUndef(value)) {
        canvas.removeAttribute(prop);
      } else {
        canvas.setAttribute(prop, value);
      }
    });
    const style = initial.style || {};
    Object.keys(style).forEach((key) => {
      canvas.style[key] = style[key];
    });
    canvas.width = canvas.width;
    delete canvas[EXPANDO_KEY];
    return true;
  }
  addEventListener(chart, type, listener) {
    this.removeEventListener(chart, type);
    const proxies = chart.$proxies || (chart.$proxies = {});
    const handlers = {
      attach: createAttachObserver,
      detach: createDetachObserver,
      resize: createResizeObserver
    };
    const handler = handlers[type] || createProxyAndListen;
    proxies[type] = handler(chart, type, listener);
  }
  removeEventListener(chart, type) {
    const proxies = chart.$proxies || (chart.$proxies = {});
    const proxy = proxies[type];
    if (!proxy) {
      return;
    }
    const handlers = {
      attach: releaseObserver,
      detach: releaseObserver,
      resize: releaseObserver
    };
    const handler = handlers[type] || removeListener;
    handler(chart, type, proxy);
    proxies[type] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(canvas, width, height, aspectRatio) {
    return getMaximumSize(canvas, width, height, aspectRatio);
  }
  isAttached(canvas) {
    const container = canvas && _getParentNode(canvas);
    return !!(container && container.isConnected);
  }
};
function _detectPlatform(canvas) {
  if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
    return BasicPlatform;
  }
  return DomPlatform;
}
var Element = class {
  constructor() {
    __publicField(this, "x");
    __publicField(this, "y");
    __publicField(this, "active", false);
    __publicField(this, "options");
    __publicField(this, "$animations");
  }
  tooltipPosition(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  hasValue() {
    return isNumber(this.x) && isNumber(this.y);
  }
  getProps(props, final) {
    const anims = this.$animations;
    if (!final || !anims) {
      return this;
    }
    const ret = {};
    props.forEach((prop) => {
      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
    });
    return ret;
  }
};
__publicField(Element, "defaults", {});
__publicField(Element, "defaultRoutes");
function autoSkip(scale, ticks) {
  const tickOpts = scale.options.ticks;
  const determinedMaxTicks = determineMaxTicks(scale);
  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
  const numMajorIndices = majorIndices.length;
  const first = majorIndices[0];
  const last = majorIndices[numMajorIndices - 1];
  const newTicks = [];
  if (numMajorIndices > ticksLimit) {
    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
    return newTicks;
  }
  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
  if (numMajorIndices > 0) {
    let i, ilen;
    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
    }
    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
    return newTicks;
  }
  skip(ticks, newTicks, spacing);
  return newTicks;
}
function determineMaxTicks(scale) {
  const offset = scale.options.offset;
  const tickLength = scale._tickSize();
  const maxScale = scale._length / tickLength + (offset ? 0 : 1);
  const maxChart = scale._maxLength / tickLength;
  return Math.floor(Math.min(maxScale, maxChart));
}
function calculateSpacing(majorIndices, ticks, ticksLimit) {
  const evenMajorSpacing = getEvenSpacing(majorIndices);
  const spacing = ticks.length / ticksLimit;
  if (!evenMajorSpacing) {
    return Math.max(spacing, 1);
  }
  const factors = _factorize(evenMajorSpacing);
  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
    const factor = factors[i];
    if (factor > spacing) {
      return factor;
    }
  }
  return Math.max(spacing, 1);
}
function getMajorIndices(ticks) {
  const result = [];
  let i, ilen;
  for (i = 0, ilen = ticks.length; i < ilen; i++) {
    if (ticks[i].major) {
      result.push(i);
    }
  }
  return result;
}
function skipMajors(ticks, newTicks, majorIndices, spacing) {
  let count = 0;
  let next = majorIndices[0];
  let i;
  spacing = Math.ceil(spacing);
  for (i = 0; i < ticks.length; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = majorIndices[count * spacing];
    }
  }
}
function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
  const start = valueOrDefault(majorStart, 0);
  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
  let count = 0;
  let length, i, next;
  spacing = Math.ceil(spacing);
  if (majorEnd) {
    length = majorEnd - majorStart;
    spacing = length / Math.floor(length / spacing);
  }
  next = start;
  while (next < 0) {
    count++;
    next = Math.round(start + count * spacing);
  }
  for (i = Math.max(start, 0); i < end; i++) {
    if (i === next) {
      newTicks.push(ticks[i]);
      count++;
      next = Math.round(start + count * spacing);
    }
  }
}
function getEvenSpacing(arr) {
  const len = arr.length;
  let i, diff;
  if (len < 2) {
    return false;
  }
  for (diff = arr[0], i = 1; i < len; ++i) {
    if (arr[i] - arr[i - 1] !== diff) {
      return false;
    }
  }
  return diff;
}
var reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
var offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
var getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
function sample(arr, numItems) {
  const result = [];
  const increment = arr.length / numItems;
  const len = arr.length;
  let i = 0;
  for (; i < len; i += increment) {
    result.push(arr[Math.floor(i)]);
  }
  return result;
}
function getPixelForGridLine(scale, index2, offsetGridLines) {
  const length = scale.ticks.length;
  const validIndex2 = Math.min(index2, length - 1);
  const start = scale._startPixel;
  const end = scale._endPixel;
  const epsilon = 1e-6;
  let lineValue = scale.getPixelForTick(validIndex2);
  let offset;
  if (offsetGridLines) {
    if (length === 1) {
      offset = Math.max(lineValue - start, end - lineValue);
    } else if (index2 === 0) {
      offset = (scale.getPixelForTick(1) - lineValue) / 2;
    } else {
      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
    }
    lineValue += validIndex2 < index2 ? offset : -offset;
    if (lineValue < start - epsilon || lineValue > end + epsilon) {
      return;
    }
  }
  return lineValue;
}
function garbageCollect(caches, length) {
  each(caches, (cache) => {
    const gc = cache.gc;
    const gcLen = gc.length / 2;
    let i;
    if (gcLen > length) {
      for (i = 0; i < gcLen; ++i) {
        delete cache.data[gc[i]];
      }
      gc.splice(0, gcLen);
    }
  });
}
function getTickMarkLength(options2) {
  return options2.drawTicks ? options2.tickLength : 0;
}
function getTitleHeight(options2, fallback) {
  if (!options2.display) {
    return 0;
  }
  const font = toFont(options2.font, fallback);
  const padding = toPadding(options2.padding);
  const lines = isArray(options2.text) ? options2.text.length : 1;
  return lines * font.lineHeight + padding.height;
}
function createScaleContext(parent, scale) {
  return createContext(parent, {
    scale,
    type: "scale"
  });
}
function createTickContext(parent, index2, tick) {
  return createContext(parent, {
    tick,
    index: index2,
    type: "tick"
  });
}
function titleAlign(align, position, reverse) {
  let ret = _toLeftRightCenter(align);
  if (reverse && position !== "right" || !reverse && position === "right") {
    ret = reverseAlign(ret);
  }
  return ret;
}
function titleArgs(scale, offset, position, align) {
  const { top, left, bottom, right, chart } = scale;
  const { chartArea, scales: scales2 } = chart;
  let rotation = 0;
  let maxWidth, titleX, titleY;
  const height = bottom - top;
  const width = right - left;
  if (scale.isHorizontal()) {
    titleX = _alignStartEnd(align, left, right);
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
    } else if (position === "center") {
      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
    } else {
      titleY = offsetFromEdge(scale, position, offset);
    }
    maxWidth = right - left;
  } else {
    if (isObject(position)) {
      const positionAxisID = Object.keys(position)[0];
      const value = position[positionAxisID];
      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
    } else if (position === "center") {
      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
    } else {
      titleX = offsetFromEdge(scale, position, offset);
    }
    titleY = _alignStartEnd(align, bottom, top);
    rotation = position === "left" ? -HALF_PI : HALF_PI;
  }
  return {
    titleX,
    titleY,
    maxWidth,
    rotation
  };
}
var Scale = class _Scale extends Element {
  constructor(cfg) {
    super();
    this.id = cfg.id;
    this.type = cfg.type;
    this.options = void 0;
    this.ctx = cfg.ctx;
    this.chart = cfg.chart;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    this.maxWidth = void 0;
    this.maxHeight = void 0;
    this.paddingTop = void 0;
    this.paddingBottom = void 0;
    this.paddingLeft = void 0;
    this.paddingRight = void 0;
    this.axis = void 0;
    this.labelRotation = void 0;
    this.min = void 0;
    this.max = void 0;
    this._range = void 0;
    this.ticks = [];
    this._gridLineItems = null;
    this._labelItems = null;
    this._labelSizes = null;
    this._length = 0;
    this._maxLength = 0;
    this._longestTextCache = {};
    this._startPixel = void 0;
    this._endPixel = void 0;
    this._reversePixels = false;
    this._userMax = void 0;
    this._userMin = void 0;
    this._suggestedMax = void 0;
    this._suggestedMin = void 0;
    this._ticksLength = 0;
    this._borderValue = 0;
    this._cache = {};
    this._dataLimitsCached = false;
    this.$context = void 0;
  }
  init(options2) {
    this.options = options2.setContext(this.getContext());
    this.axis = options2.axis;
    this._userMin = this.parse(options2.min);
    this._userMax = this.parse(options2.max);
    this._suggestedMin = this.parse(options2.suggestedMin);
    this._suggestedMax = this.parse(options2.suggestedMax);
  }
  parse(raw, index2) {
    return raw;
  }
  getUserBounds() {
    let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
    return {
      min: finiteOrDefault(_userMin, _suggestedMin),
      max: finiteOrDefault(_userMax, _suggestedMax),
      minDefined: isNumberFinite(_userMin),
      maxDefined: isNumberFinite(_userMax)
    };
  }
  getMinMax(canStack) {
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    let range;
    if (minDefined && maxDefined) {
      return {
        min,
        max
      };
    }
    const metas = this.getMatchingVisibleMetas();
    for (let i = 0, ilen = metas.length; i < ilen; ++i) {
      range = metas[i].controller.getMinMax(this, canStack);
      if (!minDefined) {
        min = Math.min(min, range.min);
      }
      if (!maxDefined) {
        max = Math.max(max, range.max);
      }
    }
    min = maxDefined && min > max ? max : min;
    max = minDefined && min > max ? min : max;
    return {
      min: finiteOrDefault(min, finiteOrDefault(max, min)),
      max: finiteOrDefault(max, finiteOrDefault(min, max))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const data = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
  }
  getLabelItems(chartArea = this.chart.chartArea) {
    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
    return items;
  }
  beforeLayout() {
    this._cache = {};
    this._dataLimitsCached = false;
  }
  beforeUpdate() {
    callback(this.options.beforeUpdate, [
      this
    ]);
  }
  update(maxWidth, maxHeight, margins) {
    const { beginAtZero, grace, ticks: tickOpts } = this.options;
    const sampleSize = tickOpts.sampleSize;
    this.beforeUpdate();
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, margins);
    this.ticks = null;
    this._labelSizes = null;
    this._gridLineItems = null;
    this._labelItems = null;
    this.beforeSetDimensions();
    this.setDimensions();
    this.afterSetDimensions();
    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
    if (!this._dataLimitsCached) {
      this.beforeDataLimits();
      this.determineDataLimits();
      this.afterDataLimits();
      this._range = _addGrace(this, grace, beginAtZero);
      this._dataLimitsCached = true;
    }
    this.beforeBuildTicks();
    this.ticks = this.buildTicks() || [];
    this.afterBuildTicks();
    const samplingEnabled = sampleSize < this.ticks.length;
    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
    this.configure();
    this.beforeCalculateLabelRotation();
    this.calculateLabelRotation();
    this.afterCalculateLabelRotation();
    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
      this.ticks = autoSkip(this, this.ticks);
      this._labelSizes = null;
      this.afterAutoSkip();
    }
    if (samplingEnabled) {
      this._convertTicksToLabels(this.ticks);
    }
    this.beforeFit();
    this.fit();
    this.afterFit();
    this.afterUpdate();
  }
  configure() {
    let reversePixels = this.options.reverse;
    let startPixel, endPixel;
    if (this.isHorizontal()) {
      startPixel = this.left;
      endPixel = this.right;
    } else {
      startPixel = this.top;
      endPixel = this.bottom;
      reversePixels = !reversePixels;
    }
    this._startPixel = startPixel;
    this._endPixel = endPixel;
    this._reversePixels = reversePixels;
    this._length = endPixel - startPixel;
    this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    callback(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    callback(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = 0;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = 0;
      this.bottom = this.height;
    }
    this.paddingLeft = 0;
    this.paddingTop = 0;
    this.paddingRight = 0;
    this.paddingBottom = 0;
  }
  afterSetDimensions() {
    callback(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(name) {
    this.chart.notifyPlugins(name, this.getContext());
    callback(this.options[name], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    callback(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(ticks) {
    const tickOpts = this.options.ticks;
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      tick = ticks[i];
      tick.label = callback(tickOpts.callback, [
        tick.value,
        i,
        ticks
      ], this);
    }
  }
  afterTickToLabelConversion() {
    callback(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    callback(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const options2 = this.options;
    const tickOpts = options2.ticks;
    const numTicks = getTicksLimit(this.ticks.length, options2.ticks.maxTicksLimit);
    const minRotation = tickOpts.minRotation || 0;
    const maxRotation = tickOpts.maxRotation;
    let labelRotation = minRotation;
    let tickWidth, maxHeight, maxLabelDiagonal;
    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
      this.labelRotation = minRotation;
      return;
    }
    const labelSizes = this._getLabelSizes();
    const maxLabelWidth = labelSizes.widest.width;
    const maxLabelHeight = labelSizes.highest.height;
    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
    tickWidth = options2.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
    if (maxLabelWidth + 6 > tickWidth) {
      tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
      maxHeight = this.maxHeight - getTickMarkLength(options2.grid) - tickOpts.padding - getTitleHeight(options2.title, this.chart.options.font);
      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
    }
    this.labelRotation = labelRotation;
  }
  afterCalculateLabelRotation() {
    callback(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    callback(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const minSize = {
      width: 0,
      height: 0
    };
    const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;
    const display = this._isVisible();
    const isHorizontal = this.isHorizontal();
    if (display) {
      const titleHeight = getTitleHeight(titleOpts, chart.options.font);
      if (isHorizontal) {
        minSize.width = this.maxWidth;
        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
      } else {
        minSize.height = this.maxHeight;
        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
      }
      if (tickOpts.display && this.ticks.length) {
        const { first, last, widest, highest } = this._getLabelSizes();
        const tickPadding = tickOpts.padding * 2;
        const angleRadians = toRadians(this.labelRotation);
        const cos = Math.cos(angleRadians);
        const sin = Math.sin(angleRadians);
        if (isHorizontal) {
          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
        } else {
          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
        }
        this._calculatePadding(first, last, sin, cos);
      }
    }
    this._handleMargins();
    if (isHorizontal) {
      this.width = this._length = chart.width - this._margins.left - this._margins.right;
      this.height = minSize.height;
    } else {
      this.width = minSize.width;
      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
    }
  }
  _calculatePadding(first, last, sin, cos) {
    const { ticks: { align, padding }, position } = this.options;
    const isRotated = this.labelRotation !== 0;
    const labelsBelowTicks = position !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const offsetLeft = this.getPixelForTick(0) - this.left;
      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
      let paddingLeft = 0;
      let paddingRight = 0;
      if (isRotated) {
        if (labelsBelowTicks) {
          paddingLeft = cos * first.width;
          paddingRight = sin * last.height;
        } else {
          paddingLeft = sin * first.height;
          paddingRight = cos * last.width;
        }
      } else if (align === "start") {
        paddingRight = last.width;
      } else if (align === "end") {
        paddingLeft = first.width;
      } else if (align !== "inner") {
        paddingLeft = first.width / 2;
        paddingRight = last.width / 2;
      }
      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
    } else {
      let paddingTop = last.height / 2;
      let paddingBottom = first.height / 2;
      if (align === "start") {
        paddingTop = 0;
        paddingBottom = first.height;
      } else if (align === "end") {
        paddingTop = last.height;
        paddingBottom = 0;
      }
      this.paddingTop = paddingTop + padding;
      this.paddingBottom = paddingBottom + padding;
    }
  }
  _handleMargins() {
    if (this._margins) {
      this._margins.left = Math.max(this.paddingLeft, this._margins.left);
      this._margins.top = Math.max(this.paddingTop, this._margins.top);
      this._margins.right = Math.max(this.paddingRight, this._margins.right);
      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
    }
  }
  afterFit() {
    callback(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis, position } = this.options;
    return position === "top" || position === "bottom" || axis === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(ticks) {
    this.beforeTickToLabelConversion();
    this.generateTickLabels(ticks);
    let i, ilen;
    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (isNullOrUndef(ticks[i].label)) {
        ticks.splice(i, 1);
        ilen--;
        i--;
      }
    }
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let labelSizes = this._labelSizes;
    if (!labelSizes) {
      const sampleSize = this.options.ticks.sampleSize;
      let ticks = this.ticks;
      if (sampleSize < ticks.length) {
        ticks = sample(ticks, sampleSize);
      }
      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
    }
    return labelSizes;
  }
  _computeLabelSizes(ticks, length, maxTicksLimit) {
    const { ctx, _longestTextCache: caches } = this;
    const widths = [];
    const heights = [];
    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
    let widestLabelSize = 0;
    let highestLabelSize = 0;
    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
    for (i = 0; i < length; i += increment) {
      label = ticks[i].label;
      tickFont = this._resolveTickFontOptions(i);
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0;
      if (!isNullOrUndef(label) && !isArray(label)) {
        width = _measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j];
          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }
      widths.push(width);
      heights.push(height);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }
    garbageCollect(caches, length);
    const widest = widths.indexOf(widestLabelSize);
    const highest = heights.indexOf(highestLabelSize);
    const valueAt = (idx) => ({
      width: widths[idx] || 0,
      height: heights[idx] || 0
    });
    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest),
      widths,
      heights
    };
  }
  getLabelForValue(value) {
    return value;
  }
  getPixelForValue(value, index2) {
    return NaN;
  }
  getValueForPixel(pixel) {
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getPixelForDecimal(decimal) {
    if (this._reversePixels) {
      decimal = 1 - decimal;
    }
    const pixel = this._startPixel + decimal * this._length;
    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
  }
  getDecimalForPixel(pixel) {
    const decimal = (pixel - this._startPixel) / this._length;
    return this._reversePixels ? 1 - decimal : decimal;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min, max } = this;
    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
  }
  getContext(index2) {
    const ticks = this.ticks || [];
    if (index2 >= 0 && index2 < ticks.length) {
      const tick = ticks[index2];
      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));
    }
    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
  }
  _tickSize() {
    const optionTicks = this.options.ticks;
    const rot = toRadians(this.labelRotation);
    const cos = Math.abs(Math.cos(rot));
    const sin = Math.abs(Math.sin(rot));
    const labelSizes = this._getLabelSizes();
    const padding = optionTicks.autoSkipPadding || 0;
    const w = labelSizes ? labelSizes.widest.width + padding : 0;
    const h = labelSizes ? labelSizes.highest.height + padding : 0;
    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
  }
  _isVisible() {
    const display = this.options.display;
    if (display !== "auto") {
      return !!display;
    }
    return this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(chartArea) {
    const axis = this.axis;
    const chart = this.chart;
    const options2 = this.options;
    const { grid, position, border } = options2;
    const offset = grid.offset;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const ticksLength = ticks.length + (offset ? 1 : 0);
    const tl = getTickMarkLength(grid);
    const items = [];
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = borderOpts.display ? borderOpts.width : 0;
    const axisHalfWidth = axisWidth / 2;
    const alignBorderValue = function(pixel) {
      return _alignPixel(chart, pixel, axisWidth);
    };
    let borderValue, i, lineValue, alignedLineValue;
    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
    if (position === "top") {
      borderValue = alignBorderValue(this.bottom);
      ty1 = this.bottom - tl;
      ty2 = borderValue - axisHalfWidth;
      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
      y2 = chartArea.bottom;
    } else if (position === "bottom") {
      borderValue = alignBorderValue(this.top);
      y1 = chartArea.top;
      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
      ty1 = borderValue + axisHalfWidth;
      ty2 = this.top + tl;
    } else if (position === "left") {
      borderValue = alignBorderValue(this.right);
      tx1 = this.right - tl;
      tx2 = borderValue - axisHalfWidth;
      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
      x2 = chartArea.right;
    } else if (position === "right") {
      borderValue = alignBorderValue(this.left);
      x1 = chartArea.left;
      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
      tx1 = borderValue + axisHalfWidth;
      tx2 = this.left + tl;
    } else if (axis === "x") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      y1 = chartArea.top;
      y2 = chartArea.bottom;
      ty1 = borderValue + axisHalfWidth;
      ty2 = ty1 + tl;
    } else if (axis === "y") {
      if (position === "center") {
        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
      }
      tx1 = borderValue - axisHalfWidth;
      tx2 = tx1 - tl;
      x1 = chartArea.left;
      x2 = chartArea.right;
    }
    const limit = valueOrDefault(options2.ticks.maxTicksLimit, ticksLength);
    const step = Math.max(1, Math.ceil(ticksLength / limit));
    for (i = 0; i < ticksLength; i += step) {
      const context = this.getContext(i);
      const optsAtIndex = grid.setContext(context);
      const optsAtIndexBorder = border.setContext(context);
      const lineWidth = optsAtIndex.lineWidth;
      const lineColor = optsAtIndex.color;
      const borderDash = optsAtIndexBorder.dash || [];
      const borderDashOffset = optsAtIndexBorder.dashOffset;
      const tickWidth = optsAtIndex.tickWidth;
      const tickColor = optsAtIndex.tickColor;
      const tickBorderDash = optsAtIndex.tickBorderDash || [];
      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
      lineValue = getPixelForGridLine(this, i, offset);
      if (lineValue === void 0) {
        continue;
      }
      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
      if (isHorizontal) {
        tx1 = tx2 = x1 = x2 = alignedLineValue;
      } else {
        ty1 = ty2 = y1 = y2 = alignedLineValue;
      }
      items.push({
        tx1,
        ty1,
        tx2,
        ty2,
        x1,
        y1,
        x2,
        y2,
        width: lineWidth,
        color: lineColor,
        borderDash,
        borderDashOffset,
        tickWidth,
        tickColor,
        tickBorderDash,
        tickBorderDashOffset
      });
    }
    this._ticksLength = ticksLength;
    this._borderValue = borderValue;
    return items;
  }
  _computeLabelItems(chartArea) {
    const axis = this.axis;
    const options2 = this.options;
    const { position, ticks: optionTicks } = options2;
    const isHorizontal = this.isHorizontal();
    const ticks = this.ticks;
    const { align, crossAlign, padding, mirror } = optionTicks;
    const tl = getTickMarkLength(options2.grid);
    const tickAndPadding = tl + padding;
    const hTickAndPadding = mirror ? -padding : tickAndPadding;
    const rotation = -toRadians(this.labelRotation);
    const items = [];
    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
    let textBaseline = "middle";
    if (position === "top") {
      y = this.bottom - hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "bottom") {
      y = this.top + hTickAndPadding;
      textAlign = this._getXAxisLabelAlignment();
    } else if (position === "left") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (position === "right") {
      const ret = this._getYAxisLabelAlignment(tl);
      textAlign = ret.textAlign;
      x = ret.x;
    } else if (axis === "x") {
      if (position === "center") {
        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
      }
      textAlign = this._getXAxisLabelAlignment();
    } else if (axis === "y") {
      if (position === "center") {
        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
      } else if (isObject(position)) {
        const positionAxisID = Object.keys(position)[0];
        const value = position[positionAxisID];
        x = this.chart.scales[positionAxisID].getPixelForValue(value);
      }
      textAlign = this._getYAxisLabelAlignment(tl).textAlign;
    }
    if (axis === "y") {
      if (align === "start") {
        textBaseline = "top";
      } else if (align === "end") {
        textBaseline = "bottom";
      }
    }
    const labelSizes = this._getLabelSizes();
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      label = tick.label;
      const optsAtIndex = optionTicks.setContext(this.getContext(i));
      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
      font = this._resolveTickFontOptions(i);
      lineHeight = font.lineHeight;
      lineCount = isArray(label) ? label.length : 1;
      const halfCount = lineCount / 2;
      const color2 = optsAtIndex.color;
      const strokeColor = optsAtIndex.textStrokeColor;
      const strokeWidth = optsAtIndex.textStrokeWidth;
      let tickTextAlign = textAlign;
      if (isHorizontal) {
        x = pixel;
        if (textAlign === "inner") {
          if (i === ilen - 1) {
            tickTextAlign = !this.options.reverse ? "right" : "left";
          } else if (i === 0) {
            tickTextAlign = !this.options.reverse ? "left" : "right";
          } else {
            tickTextAlign = "center";
          }
        }
        if (position === "top") {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = -lineCount * lineHeight + lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
          } else {
            textOffset = -labelSizes.highest.height + lineHeight / 2;
          }
        } else {
          if (crossAlign === "near" || rotation !== 0) {
            textOffset = lineHeight / 2;
          } else if (crossAlign === "center") {
            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
          } else {
            textOffset = labelSizes.highest.height - lineCount * lineHeight;
          }
        }
        if (mirror) {
          textOffset *= -1;
        }
        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
          x += lineHeight / 2 * Math.sin(rotation);
        }
      } else {
        y = pixel;
        textOffset = (1 - lineCount) * lineHeight / 2;
      }
      let backdrop;
      if (optsAtIndex.showLabelBackdrop) {
        const labelPadding = toPadding(optsAtIndex.backdropPadding);
        const height = labelSizes.heights[i];
        const width = labelSizes.widths[i];
        let top = textOffset - labelPadding.top;
        let left = 0 - labelPadding.left;
        switch (textBaseline) {
          case "middle":
            top -= height / 2;
            break;
          case "bottom":
            top -= height;
            break;
        }
        switch (textAlign) {
          case "center":
            left -= width / 2;
            break;
          case "right":
            left -= width;
            break;
          case "inner":
            if (i === ilen - 1) {
              left -= width;
            } else if (i > 0) {
              left -= width / 2;
            }
            break;
        }
        backdrop = {
          left,
          top,
          width: width + labelPadding.width,
          height: height + labelPadding.height,
          color: optsAtIndex.backdropColor
        };
      }
      items.push({
        label,
        font,
        textOffset,
        options: {
          rotation,
          color: color2,
          strokeColor,
          strokeWidth,
          textAlign: tickTextAlign,
          textBaseline,
          translation: [
            x,
            y
          ],
          backdrop
        }
      });
    }
    return items;
  }
  _getXAxisLabelAlignment() {
    const { position, ticks } = this.options;
    const rotation = -toRadians(this.labelRotation);
    if (rotation) {
      return position === "top" ? "left" : "right";
    }
    let align = "center";
    if (ticks.align === "start") {
      align = "left";
    } else if (ticks.align === "end") {
      align = "right";
    } else if (ticks.align === "inner") {
      align = "inner";
    }
    return align;
  }
  _getYAxisLabelAlignment(tl) {
    const { position, ticks: { crossAlign, mirror, padding } } = this.options;
    const labelSizes = this._getLabelSizes();
    const tickAndPadding = tl + padding;
    const widest = labelSizes.widest.width;
    let textAlign;
    let x;
    if (position === "left") {
      if (mirror) {
        x = this.right + padding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x += widest;
        }
      } else {
        x = this.right - tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x = this.left;
        }
      }
    } else if (position === "right") {
      if (mirror) {
        x = this.left + padding;
        if (crossAlign === "near") {
          textAlign = "right";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x -= widest / 2;
        } else {
          textAlign = "left";
          x -= widest;
        }
      } else {
        x = this.left + tickAndPadding;
        if (crossAlign === "near") {
          textAlign = "left";
        } else if (crossAlign === "center") {
          textAlign = "center";
          x += widest / 2;
        } else {
          textAlign = "right";
          x = this.right;
        }
      }
    } else {
      textAlign = "right";
    }
    return {
      textAlign,
      x
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror) {
      return;
    }
    const chart = this.chart;
    const position = this.options.position;
    if (position === "left" || position === "right") {
      return {
        top: 0,
        left: this.left,
        bottom: chart.height,
        right: this.right
      };
    }
    if (position === "top" || position === "bottom") {
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: chart.width
      };
    }
  }
  drawBackground() {
    const { ctx, options: { backgroundColor }, left, top, width, height } = this;
    if (backgroundColor) {
      ctx.save();
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(left, top, width, height);
      ctx.restore();
    }
  }
  getLineWidthForValue(value) {
    const grid = this.options.grid;
    if (!this._isVisible() || !grid.display) {
      return 0;
    }
    const ticks = this.ticks;
    const index2 = ticks.findIndex((t) => t.value === value);
    if (index2 >= 0) {
      const opts = grid.setContext(this.getContext(index2));
      return opts.lineWidth;
    }
    return 0;
  }
  drawGrid(chartArea) {
    const grid = this.options.grid;
    const ctx = this.ctx;
    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
    let i, ilen;
    const drawLine = (p1, p2, style) => {
      if (!style.width || !style.color) {
        return;
      }
      ctx.save();
      ctx.lineWidth = style.width;
      ctx.strokeStyle = style.color;
      ctx.setLineDash(style.borderDash || []);
      ctx.lineDashOffset = style.borderDashOffset;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
      ctx.restore();
    };
    if (grid.display) {
      for (i = 0, ilen = items.length; i < ilen; ++i) {
        const item = items[i];
        if (grid.drawOnChartArea) {
          drawLine({
            x: item.x1,
            y: item.y1
          }, {
            x: item.x2,
            y: item.y2
          }, item);
        }
        if (grid.drawTicks) {
          drawLine({
            x: item.tx1,
            y: item.ty1
          }, {
            x: item.tx2,
            y: item.ty2
          }, {
            color: item.tickColor,
            width: item.tickWidth,
            borderDash: item.tickBorderDash,
            borderDashOffset: item.tickBorderDashOffset
          });
        }
      }
    }
  }
  drawBorder() {
    const { chart, ctx, options: { border, grid } } = this;
    const borderOpts = border.setContext(this.getContext());
    const axisWidth = border.display ? borderOpts.width : 0;
    if (!axisWidth) {
      return;
    }
    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
    const borderValue = this._borderValue;
    let x1, x2, y1, y2;
    if (this.isHorizontal()) {
      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
      y1 = y2 = borderValue;
    } else {
      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
      x1 = x2 = borderValue;
    }
    ctx.save();
    ctx.lineWidth = borderOpts.width;
    ctx.strokeStyle = borderOpts.color;
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.restore();
  }
  drawLabels(chartArea) {
    const optionTicks = this.options.ticks;
    if (!optionTicks.display) {
      return;
    }
    const ctx = this.ctx;
    const area = this._computeLabelArea();
    if (area) {
      clipArea(ctx, area);
    }
    const items = this.getLabelItems(chartArea);
    for (const item of items) {
      const renderTextOptions = item.options;
      const tickFont = item.font;
      const label = item.label;
      const y = item.textOffset;
      renderText(ctx, label, 0, y, tickFont, renderTextOptions);
    }
    if (area) {
      unclipArea(ctx);
    }
  }
  drawTitle() {
    const { ctx, options: { position, title, reverse } } = this;
    if (!title.display) {
      return;
    }
    const font = toFont(title.font);
    const padding = toPadding(title.padding);
    const align = title.align;
    let offset = font.lineHeight / 2;
    if (position === "bottom" || position === "center" || isObject(position)) {
      offset += padding.bottom;
      if (isArray(title.text)) {
        offset += font.lineHeight * (title.text.length - 1);
      }
    } else {
      offset += padding.top;
    }
    const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
    renderText(ctx, title.text, 0, 0, font, {
      color: title.color,
      maxWidth,
      rotation,
      textAlign: titleAlign(align, position, reverse),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
  draw(chartArea) {
    if (!this._isVisible()) {
      return;
    }
    this.drawBackground();
    this.drawGrid(chartArea);
    this.drawBorder();
    this.drawTitle();
    this.drawLabels(chartArea);
  }
  _layers() {
    const opts = this.options;
    const tz = opts.ticks && opts.ticks.z || 0;
    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
    const bz = valueOrDefault(opts.border && opts.border.z, 0);
    if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {
      return [
        {
          z: tz,
          draw: (chartArea) => {
            this.draw(chartArea);
          }
        }
      ];
    }
    return [
      {
        z: gz,
        draw: (chartArea) => {
          this.drawBackground();
          this.drawGrid(chartArea);
          this.drawTitle();
        }
      },
      {
        z: bz,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: tz,
        draw: (chartArea) => {
          this.drawLabels(chartArea);
        }
      }
    ];
  }
  getMatchingVisibleMetas(type) {
    const metas = this.chart.getSortedVisibleDatasetMetas();
    const axisID = this.axis + "AxisID";
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      const meta = metas[i];
      if (meta[axisID] === this.id && (!type || meta.type === type)) {
        result.push(meta);
      }
    }
    return result;
  }
  _resolveTickFontOptions(index2) {
    const opts = this.options.ticks.setContext(this.getContext(index2));
    return toFont(opts.font);
  }
  _maxDigits() {
    const fontSize = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / fontSize;
  }
};
var TypedRegistry = class {
  constructor(type, scope, override) {
    this.type = type;
    this.scope = scope;
    this.override = override;
    this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(type) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
  }
  register(item) {
    const proto = Object.getPrototypeOf(item);
    let parentScope;
    if (isIChartComponent(proto)) {
      parentScope = this.register(proto);
    }
    const items = this.items;
    const id = item.id;
    const scope = this.scope + "." + id;
    if (!id) {
      throw new Error("class does not have id: " + item);
    }
    if (id in items) {
      return scope;
    }
    items[id] = item;
    registerDefaults(item, scope, parentScope);
    if (this.override) {
      defaults.override(item.id, item.overrides);
    }
    return scope;
  }
  get(id) {
    return this.items[id];
  }
  unregister(item) {
    const items = this.items;
    const id = item.id;
    const scope = this.scope;
    if (id in items) {
      delete items[id];
    }
    if (scope && id in defaults[scope]) {
      delete defaults[scope][id];
      if (this.override) {
        delete overrides[id];
      }
    }
  }
};
function registerDefaults(item, scope, parentScope) {
  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [
    parentScope ? defaults.get(parentScope) : {},
    defaults.get(scope),
    item.defaults
  ]);
  defaults.set(scope, itemDefaults);
  if (item.defaultRoutes) {
    routeDefaults(scope, item.defaultRoutes);
  }
  if (item.descriptors) {
    defaults.describe(scope, item.descriptors);
  }
}
function routeDefaults(scope, routes) {
  Object.keys(routes).forEach((property) => {
    const propertyParts = property.split(".");
    const sourceName = propertyParts.pop();
    const sourceScope = [
      scope
    ].concat(propertyParts).join(".");
    const parts = routes[property].split(".");
    const targetName = parts.pop();
    const targetScope = parts.join(".");
    defaults.route(sourceScope, sourceName, targetScope, targetName);
  });
}
function isIChartComponent(proto) {
  return "id" in proto && "defaults" in proto;
}
var Registry = class {
  constructor() {
    this.controllers = new TypedRegistry(DatasetController, "datasets", true);
    this.elements = new TypedRegistry(Element, "elements");
    this.plugins = new TypedRegistry(Object, "plugins");
    this.scales = new TypedRegistry(Scale, "scales");
    this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...args) {
    this._each("register", args);
  }
  remove(...args) {
    this._each("unregister", args);
  }
  addControllers(...args) {
    this._each("register", args, this.controllers);
  }
  addElements(...args) {
    this._each("register", args, this.elements);
  }
  addPlugins(...args) {
    this._each("register", args, this.plugins);
  }
  addScales(...args) {
    this._each("register", args, this.scales);
  }
  getController(id) {
    return this._get(id, this.controllers, "controller");
  }
  getElement(id) {
    return this._get(id, this.elements, "element");
  }
  getPlugin(id) {
    return this._get(id, this.plugins, "plugin");
  }
  getScale(id) {
    return this._get(id, this.scales, "scale");
  }
  removeControllers(...args) {
    this._each("unregister", args, this.controllers);
  }
  removeElements(...args) {
    this._each("unregister", args, this.elements);
  }
  removePlugins(...args) {
    this._each("unregister", args, this.plugins);
  }
  removeScales(...args) {
    this._each("unregister", args, this.scales);
  }
  _each(method, args, typedRegistry) {
    [
      ...args
    ].forEach((arg) => {
      const reg = typedRegistry || this._getRegistryForType(arg);
      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {
        this._exec(method, reg, arg);
      } else {
        each(arg, (item) => {
          const itemReg = typedRegistry || this._getRegistryForType(item);
          this._exec(method, itemReg, item);
        });
      }
    });
  }
  _exec(method, registry2, component) {
    const camelMethod = _capitalize(method);
    callback(component["before" + camelMethod], [], component);
    registry2[method](component);
    callback(component["after" + camelMethod], [], component);
  }
  _getRegistryForType(type) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const reg = this._typedRegistries[i];
      if (reg.isForType(type)) {
        return reg;
      }
    }
    return this.plugins;
  }
  _get(id, typedRegistry, type) {
    const item = typedRegistry.get(id);
    if (item === void 0) {
      throw new Error('"' + id + '" is not a registered ' + type + ".");
    }
    return item;
  }
};
var registry = /* @__PURE__ */ new Registry();
var PluginService = class {
  constructor() {
    this._init = [];
  }
  notify(chart, hook, args, filter) {
    if (hook === "beforeInit") {
      this._init = this._createDescriptors(chart, true);
      this._notify(this._init, chart, "install");
    }
    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
    const result = this._notify(descriptors2, chart, hook, args);
    if (hook === "afterDestroy") {
      this._notify(descriptors2, chart, "stop");
      this._notify(this._init, chart, "uninstall");
    }
    return result;
  }
  _notify(descriptors2, chart, hook, args) {
    args = args || {};
    for (const descriptor of descriptors2) {
      const plugin = descriptor.plugin;
      const method = plugin[hook];
      const params = [
        chart,
        args,
        descriptor.options
      ];
      if (callback(method, params, plugin) === false && args.cancelable) {
        return false;
      }
    }
    return true;
  }
  invalidate() {
    if (!isNullOrUndef(this._cache)) {
      this._oldCache = this._cache;
      this._cache = void 0;
    }
  }
  _descriptors(chart) {
    if (this._cache) {
      return this._cache;
    }
    const descriptors2 = this._cache = this._createDescriptors(chart);
    this._notifyStateChanges(chart);
    return descriptors2;
  }
  _createDescriptors(chart, all) {
    const config = chart && chart.config;
    const options2 = valueOrDefault(config.options && config.options.plugins, {});
    const plugins2 = allPlugins(config);
    return options2 === false && !all ? [] : createDescriptors(chart, plugins2, options2, all);
  }
  _notifyStateChanges(chart) {
    const previousDescriptors = this._oldCache || [];
    const descriptors2 = this._cache;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
    this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
    this._notify(diff(descriptors2, previousDescriptors), chart, "start");
  }
};
function allPlugins(config) {
  const localIds = {};
  const plugins2 = [];
  const keys = Object.keys(registry.plugins.items);
  for (let i = 0; i < keys.length; i++) {
    plugins2.push(registry.getPlugin(keys[i]));
  }
  const local = config.plugins || [];
  for (let i = 0; i < local.length; i++) {
    const plugin = local[i];
    if (plugins2.indexOf(plugin) === -1) {
      plugins2.push(plugin);
      localIds[plugin.id] = true;
    }
  }
  return {
    plugins: plugins2,
    localIds
  };
}
function getOpts(options2, all) {
  if (!all && options2 === false) {
    return null;
  }
  if (options2 === true) {
    return {};
  }
  return options2;
}
function createDescriptors(chart, { plugins: plugins2, localIds }, options2, all) {
  const result = [];
  const context = chart.getContext();
  for (const plugin of plugins2) {
    const id = plugin.id;
    const opts = getOpts(options2[id], all);
    if (opts === null) {
      continue;
    }
    result.push({
      plugin,
      options: pluginOpts(chart.config, {
        plugin,
        local: localIds[id]
      }, opts, context)
    });
  }
  return result;
}
function pluginOpts(config, { plugin, local }, opts, context) {
  const keys = config.pluginScopeKeys(plugin);
  const scopes = config.getOptionScopes(opts, keys);
  if (local && plugin.defaults) {
    scopes.push(plugin.defaults);
  }
  return config.createResolver(scopes, context, [
    ""
  ], {
    scriptable: false,
    indexable: false,
    allKeys: true
  });
}
function getIndexAxis(type, options2) {
  const datasetDefaults = defaults.datasets[type] || {};
  const datasetOptions = (options2.datasets || {})[type] || {};
  return datasetOptions.indexAxis || options2.indexAxis || datasetDefaults.indexAxis || "x";
}
function getAxisFromDefaultScaleID(id, indexAxis) {
  let axis = id;
  if (id === "_index_") {
    axis = indexAxis;
  } else if (id === "_value_") {
    axis = indexAxis === "x" ? "y" : "x";
  }
  return axis;
}
function getDefaultScaleIDFromAxis(axis, indexAxis) {
  return axis === indexAxis ? "_index_" : "_value_";
}
function idMatchesAxis(id) {
  if (id === "x" || id === "y" || id === "r") {
    return id;
  }
}
function axisFromPosition(position) {
  if (position === "top" || position === "bottom") {
    return "x";
  }
  if (position === "left" || position === "right") {
    return "y";
  }
}
function determineAxis(id, ...scaleOptions) {
  if (idMatchesAxis(id)) {
    return id;
  }
  for (const opts of scaleOptions) {
    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
    if (axis) {
      return axis;
    }
  }
  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
}
function getAxisFromDataset(id, axis, dataset) {
  if (dataset[axis + "AxisID"] === id) {
    return {
      axis
    };
  }
}
function retrieveAxisFromDatasets(id, config) {
  if (config.data && config.data.datasets) {
    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);
    if (boundDs.length) {
      return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
    }
  }
  return {};
}
function mergeScaleConfig(config, options2) {
  const chartDefaults = overrides[config.type] || {
    scales: {}
  };
  const configScales = options2.scales || {};
  const chartIndexAxis = getIndexAxis(config.type, options2);
  const scales2 = /* @__PURE__ */ Object.create(null);
  Object.keys(configScales).forEach((id) => {
    const scaleConf = configScales[id];
    if (!isObject(scaleConf)) {
      return console.error(`Invalid scale configuration for scale: ${id}`);
    }
    if (scaleConf._proxy) {
      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
    }
    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
    const defaultScaleOptions = chartDefaults.scales || {};
    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [
      {
        axis
      },
      scaleConf,
      defaultScaleOptions[axis],
      defaultScaleOptions[defaultId]
    ]);
  });
  config.data.datasets.forEach((dataset) => {
    const type = dataset.type || config.type;
    const indexAxis = dataset.indexAxis || getIndexAxis(type, options2);
    const datasetDefaults = overrides[type] || {};
    const defaultScaleOptions = datasetDefaults.scales || {};
    Object.keys(defaultScaleOptions).forEach((defaultID) => {
      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
      const id = dataset[axis + "AxisID"] || axis;
      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);
      mergeIf(scales2[id], [
        {
          axis
        },
        configScales[id],
        defaultScaleOptions[defaultID]
      ]);
    });
  });
  Object.keys(scales2).forEach((key) => {
    const scale = scales2[key];
    mergeIf(scale, [
      defaults.scales[scale.type],
      defaults.scale
    ]);
  });
  return scales2;
}
function initOptions(config) {
  const options2 = config.options || (config.options = {});
  options2.plugins = valueOrDefault(options2.plugins, {});
  options2.scales = mergeScaleConfig(config, options2);
}
function initData(data) {
  data = data || {};
  data.datasets = data.datasets || [];
  data.labels = data.labels || [];
  return data;
}
function initConfig(config) {
  config = config || {};
  config.data = initData(config.data);
  initOptions(config);
  return config;
}
var keyCache = /* @__PURE__ */ new Map();
var keysCached = /* @__PURE__ */ new Set();
function cachedKeys(cacheKey, generate) {
  let keys = keyCache.get(cacheKey);
  if (!keys) {
    keys = generate();
    keyCache.set(cacheKey, keys);
    keysCached.add(keys);
  }
  return keys;
}
var addIfFound = (set2, obj, key) => {
  const opts = resolveObjectKey(obj, key);
  if (opts !== void 0) {
    set2.add(opts);
  }
};
var Config = class {
  constructor(config) {
    this._config = initConfig(config);
    this._scopeCache = /* @__PURE__ */ new Map();
    this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(type) {
    this._config.type = type;
  }
  get data() {
    return this._config.data;
  }
  set data(data) {
    this._config.data = initData(data);
  }
  get options() {
    return this._config.options;
  }
  set options(options2) {
    this._config.options = options2;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const config = this._config;
    this.clearCache();
    initOptions(config);
  }
  clearCache() {
    this._scopeCache.clear();
    this._resolverCache.clear();
  }
  datasetScopeKeys(datasetType) {
    return cachedKeys(datasetType, () => [
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(datasetType, transition) {
    return cachedKeys(`${datasetType}.transition.${transition}`, () => [
      [
        `datasets.${datasetType}.transitions.${transition}`,
        `transitions.${transition}`
      ],
      [
        `datasets.${datasetType}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(datasetType, elementType) {
    return cachedKeys(`${datasetType}-${elementType}`, () => [
      [
        `datasets.${datasetType}.elements.${elementType}`,
        `datasets.${datasetType}`,
        `elements.${elementType}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(plugin) {
    const id = plugin.id;
    const type = this.type;
    return cachedKeys(`${type}-plugin-${id}`, () => [
      [
        `plugins.${id}`,
        ...plugin.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(mainScope, resetCache) {
    const _scopeCache = this._scopeCache;
    let cache = _scopeCache.get(mainScope);
    if (!cache || resetCache) {
      cache = /* @__PURE__ */ new Map();
      _scopeCache.set(mainScope, cache);
    }
    return cache;
  }
  getOptionScopes(mainScope, keyLists, resetCache) {
    const { options: options2, type } = this;
    const cache = this._cachedScopes(mainScope, resetCache);
    const cached = cache.get(keyLists);
    if (cached) {
      return cached;
    }
    const scopes = /* @__PURE__ */ new Set();
    keyLists.forEach((keys) => {
      if (mainScope) {
        scopes.add(mainScope);
        keys.forEach((key) => addIfFound(scopes, mainScope, key));
      }
      keys.forEach((key) => addIfFound(scopes, options2, key));
      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
      keys.forEach((key) => addIfFound(scopes, defaults, key));
      keys.forEach((key) => addIfFound(scopes, descriptors, key));
    });
    const array = Array.from(scopes);
    if (array.length === 0) {
      array.push(/* @__PURE__ */ Object.create(null));
    }
    if (keysCached.has(keyLists)) {
      cache.set(keyLists, array);
    }
    return array;
  }
  chartOptionScopes() {
    const { options: options2, type } = this;
    return [
      options2,
      overrides[type] || {},
      defaults.datasets[type] || {},
      {
        type
      },
      defaults,
      descriptors
    ];
  }
  resolveNamedOptions(scopes, names2, context, prefixes = [
    ""
  ]) {
    const result = {
      $shared: true
    };
    const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
    let options2 = resolver;
    if (needContext(resolver, names2)) {
      result.$shared = false;
      context = isFunction(context) ? context() : context;
      const subResolver = this.createResolver(scopes, context, subPrefixes);
      options2 = _attachContext(resolver, context, subResolver);
    }
    for (const prop of names2) {
      result[prop] = options2[prop];
    }
    return result;
  }
  createResolver(scopes, context, prefixes = [
    ""
  ], descriptorDefaults) {
    const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
  }
};
function getResolver(resolverCache, scopes, prefixes) {
  let cache = resolverCache.get(scopes);
  if (!cache) {
    cache = /* @__PURE__ */ new Map();
    resolverCache.set(scopes, cache);
  }
  const cacheKey = prefixes.join();
  let cached = cache.get(cacheKey);
  if (!cached) {
    const resolver = _createResolver(scopes, prefixes);
    cached = {
      resolver,
      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
    };
    cache.set(cacheKey, cached);
  }
  return cached;
}
var hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));
function needContext(proxy, names2) {
  const { isScriptable, isIndexable } = _descriptors(proxy);
  for (const prop of names2) {
    const scriptable = isScriptable(prop);
    const indexable = isIndexable(prop);
    const value = (indexable || scriptable) && proxy[prop];
    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {
      return true;
    }
  }
  return false;
}
var version = "4.5.0";
var KNOWN_POSITIONS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function positionIsHorizontal(position, axis) {
  return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
}
function compare2Level(l1, l2) {
  return function(a, b) {
    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
  };
}
function onAnimationsComplete(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  chart.notifyPlugins("afterRender");
  callback(animationOptions && animationOptions.onComplete, [
    context
  ], chart);
}
function onAnimationProgress(context) {
  const chart = context.chart;
  const animationOptions = chart.options.animation;
  callback(animationOptions && animationOptions.onProgress, [
    context
  ], chart);
}
function getCanvas(item) {
  if (_isDomSupported() && typeof item === "string") {
    item = document.getElementById(item);
  } else if (item && item.length) {
    item = item[0];
  }
  if (item && item.canvas) {
    item = item.canvas;
  }
  return item;
}
var instances = {};
var getChart = (key) => {
  const canvas = getCanvas(key);
  return Object.values(instances).filter((c) => c.canvas === canvas).pop();
};
function moveNumericKeys(obj, start, move) {
  const keys = Object.keys(obj);
  for (const key of keys) {
    const intKey = +key;
    if (intKey >= start) {
      const value = obj[key];
      delete obj[key];
      if (move > 0 || intKey > start) {
        obj[intKey + move] = value;
      }
    }
  }
}
function determineLastEvent(e, lastEvent, inChartArea, isClick) {
  if (!inChartArea || e.type === "mouseout") {
    return null;
  }
  if (isClick) {
    return lastEvent;
  }
  return e;
}
var Chart = class {
  static register(...items) {
    registry.add(...items);
    invalidatePlugins();
  }
  static unregister(...items) {
    registry.remove(...items);
    invalidatePlugins();
  }
  constructor(item, userConfig) {
    const config = this.config = new Config(userConfig);
    const initialCanvas = getCanvas(item);
    const existingChart = getChart(initialCanvas);
    if (existingChart) {
      throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
    }
    const options2 = config.createResolver(config.chartOptionScopes(), this.getContext());
    this.platform = new (config.platform || _detectPlatform(initialCanvas))();
    this.platform.updateConfig(config);
    const context = this.platform.acquireContext(initialCanvas, options2.aspectRatio);
    const canvas = context && context.canvas;
    const height = canvas && canvas.height;
    const width = canvas && canvas.width;
    this.id = uid();
    this.ctx = context;
    this.canvas = canvas;
    this.width = width;
    this.height = height;
    this._options = options2;
    this._aspectRatio = this.aspectRatio;
    this._layers = [];
    this._metasets = [];
    this._stacks = void 0;
    this.boxes = [];
    this.currentDevicePixelRatio = void 0;
    this.chartArea = void 0;
    this._active = [];
    this._lastEvent = void 0;
    this._listeners = {};
    this._responsiveListeners = void 0;
    this._sortedMetasets = [];
    this.scales = {};
    this._plugins = new PluginService();
    this.$proxies = {};
    this._hiddenIndices = {};
    this.attached = false;
    this._animationsDisabled = void 0;
    this.$context = void 0;
    this._doResize = debounce((mode) => this.update(mode), options2.resizeDelay || 0);
    this._dataChanges = [];
    instances[this.id] = this;
    if (!context || !canvas) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    animator.listen(this, "complete", onAnimationsComplete);
    animator.listen(this, "progress", onAnimationProgress);
    this._initialize();
    if (this.attached) {
      this.update();
    }
  }
  get aspectRatio() {
    const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
    if (!isNullOrUndef(aspectRatio)) {
      return aspectRatio;
    }
    if (maintainAspectRatio && _aspectRatio) {
      return _aspectRatio;
    }
    return height ? width / height : null;
  }
  get data() {
    return this.config.data;
  }
  set data(data) {
    this.config.data = data;
  }
  get options() {
    return this._options;
  }
  set options(options2) {
    this.config.options = options2;
  }
  get registry() {
    return registry;
  }
  _initialize() {
    this.notifyPlugins("beforeInit");
    if (this.options.responsive) {
      this.resize();
    } else {
      retinaScale(this, this.options.devicePixelRatio);
    }
    this.bindEvents();
    this.notifyPlugins("afterInit");
    return this;
  }
  clear() {
    clearCanvas(this.canvas, this.ctx);
    return this;
  }
  stop() {
    animator.stop(this);
    return this;
  }
  resize(width, height) {
    if (!animator.running(this)) {
      this._resize(width, height);
    } else {
      this._resizeBeforeDraw = {
        width,
        height
      };
    }
  }
  _resize(width, height) {
    const options2 = this.options;
    const canvas = this.canvas;
    const aspectRatio = options2.maintainAspectRatio && this.aspectRatio;
    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
    const newRatio = options2.devicePixelRatio || this.platform.getDevicePixelRatio();
    const mode = this.width ? "resize" : "attach";
    this.width = newSize.width;
    this.height = newSize.height;
    this._aspectRatio = this.aspectRatio;
    if (!retinaScale(this, newRatio, true)) {
      return;
    }
    this.notifyPlugins("resize", {
      size: newSize
    });
    callback(options2.onResize, [
      this,
      newSize
    ], this);
    if (this.attached) {
      if (this._doResize(mode)) {
        this.render();
      }
    }
  }
  ensureScalesHaveIDs() {
    const options2 = this.options;
    const scalesOptions = options2.scales || {};
    each(scalesOptions, (axisOptions, axisID) => {
      axisOptions.id = axisID;
    });
  }
  buildOrUpdateScales() {
    const options2 = this.options;
    const scaleOpts = options2.scales;
    const scales2 = this.scales;
    const updated = Object.keys(scales2).reduce((obj, id) => {
      obj[id] = false;
      return obj;
    }, {});
    let items = [];
    if (scaleOpts) {
      items = items.concat(Object.keys(scaleOpts).map((id) => {
        const scaleOptions = scaleOpts[id];
        const axis = determineAxis(id, scaleOptions);
        const isRadial = axis === "r";
        const isHorizontal = axis === "x";
        return {
          options: scaleOptions,
          dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
          dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
        };
      }));
    }
    each(items, (item) => {
      const scaleOptions = item.options;
      const id = scaleOptions.id;
      const axis = determineAxis(id, scaleOptions);
      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
        scaleOptions.position = item.dposition;
      }
      updated[id] = true;
      let scale = null;
      if (id in scales2 && scales2[id].type === scaleType) {
        scale = scales2[id];
      } else {
        const scaleClass = registry.getScale(scaleType);
        scale = new scaleClass({
          id,
          type: scaleType,
          ctx: this.ctx,
          chart: this
        });
        scales2[scale.id] = scale;
      }
      scale.init(scaleOptions, options2);
    });
    each(updated, (hasUpdated, id) => {
      if (!hasUpdated) {
        delete scales2[id];
      }
    });
    each(scales2, (scale) => {
      layouts.configure(this, scale, scale.options);
      layouts.addBox(this, scale);
    });
  }
  _updateMetasets() {
    const metasets = this._metasets;
    const numData = this.data.datasets.length;
    const numMeta = metasets.length;
    metasets.sort((a, b) => a.index - b.index);
    if (numMeta > numData) {
      for (let i = numData; i < numMeta; ++i) {
        this._destroyDatasetMeta(i);
      }
      metasets.splice(numData, numMeta - numData);
    }
    this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: metasets, data: { datasets } } = this;
    if (metasets.length > datasets.length) {
      delete this._stacks;
    }
    metasets.forEach((meta, index2) => {
      if (datasets.filter((x) => x === meta._dataset).length === 0) {
        this._destroyDatasetMeta(index2);
      }
    });
  }
  buildOrUpdateControllers() {
    const newControllers = [];
    const datasets = this.data.datasets;
    let i, ilen;
    this._removeUnreferencedMetasets();
    for (i = 0, ilen = datasets.length; i < ilen; i++) {
      const dataset = datasets[i];
      let meta = this.getDatasetMeta(i);
      const type = dataset.type || this.config.type;
      if (meta.type && meta.type !== type) {
        this._destroyDatasetMeta(i);
        meta = this.getDatasetMeta(i);
      }
      meta.type = type;
      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
      meta.order = dataset.order || 0;
      meta.index = i;
      meta.label = "" + dataset.label;
      meta.visible = this.isDatasetVisible(i);
      if (meta.controller) {
        meta.controller.updateIndex(i);
        meta.controller.linkScales();
      } else {
        const ControllerClass = registry.getController(type);
        const { datasetElementType, dataElementType } = defaults.datasets[type];
        Object.assign(ControllerClass, {
          dataElementType: registry.getElement(dataElementType),
          datasetElementType: datasetElementType && registry.getElement(datasetElementType)
        });
        meta.controller = new ControllerClass(this, i);
        newControllers.push(meta.controller);
      }
    }
    this._updateMetasets();
    return newControllers;
  }
  _resetElements() {
    each(this.data.datasets, (dataset, datasetIndex) => {
      this.getDatasetMeta(datasetIndex).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements();
    this.notifyPlugins("reset");
  }
  update(mode) {
    const config = this.config;
    config.update();
    const options2 = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
    const animsDisabled = this._animationsDisabled = !options2.animation;
    this._updateScales();
    this._checkEventBindings();
    this._updateHiddenIndices();
    this._plugins.invalidate();
    if (this.notifyPlugins("beforeUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    const newControllers = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let minPadding = 0;
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
      const { controller } = this.getDatasetMeta(i);
      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
      controller.buildOrUpdateElements(reset);
      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
    }
    minPadding = this._minPadding = options2.layout.autoPadding ? minPadding : 0;
    this._updateLayout(minPadding);
    if (!animsDisabled) {
      each(newControllers, (controller) => {
        controller.reset();
      });
    }
    this._updateDatasets(mode);
    this.notifyPlugins("afterUpdate", {
      mode
    });
    this._layers.sort(compare2Level("z", "_idx"));
    const { _active, _lastEvent } = this;
    if (_lastEvent) {
      this._eventHandler(_lastEvent, true);
    } else if (_active.length) {
      this._updateHoverStyles(_active, _active, true);
    }
    this.render();
  }
  _updateScales() {
    each(this.scales, (scale) => {
      layouts.removeBox(this, scale);
    });
    this.ensureScalesHaveIDs();
    this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const options2 = this.options;
    const existingEvents = new Set(Object.keys(this._listeners));
    const newEvents = new Set(options2.events);
    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options2.responsive) {
      this.unbindEvents();
      this.bindEvents();
    }
  }
  _updateHiddenIndices() {
    const { _hiddenIndices } = this;
    const changes = this._getUniformDataChanges() || [];
    for (const { method, start, count } of changes) {
      const move = method === "_removeElements" ? -count : count;
      moveNumericKeys(_hiddenIndices, start, move);
    }
  }
  _getUniformDataChanges() {
    const _dataChanges = this._dataChanges;
    if (!_dataChanges || !_dataChanges.length) {
      return;
    }
    this._dataChanges = [];
    const datasetCount = this.data.datasets.length;
    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + "," + c.splice(1).join(",")));
    const changeSet = makeSet(0);
    for (let i = 1; i < datasetCount; i++) {
      if (!setsEqual(changeSet, makeSet(i))) {
        return;
      }
    }
    return Array.from(changeSet).map((c) => c.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(minPadding) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: true
    }) === false) {
      return;
    }
    layouts.update(this, this.width, this.height, minPadding);
    const area = this.chartArea;
    const noArea = area.width <= 0 || area.height <= 0;
    this._layers = [];
    each(this.boxes, (box) => {
      if (noArea && box.position === "chartArea") {
        return;
      }
      if (box.configure) {
        box.configure();
      }
      this._layers.push(...box._layers());
    }, this);
    this._layers.forEach((item, index2) => {
      item._idx = index2;
    });
    this.notifyPlugins("afterLayout");
  }
  _updateDatasets(mode) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode,
      cancelable: true
    }) === false) {
      return;
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this.getDatasetMeta(i).controller.configure();
    }
    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._updateDataset(i, isFunction(mode) ? mode({
        datasetIndex: i
      }) : mode);
    }
    this.notifyPlugins("afterDatasetsUpdate", {
      mode
    });
  }
  _updateDataset(index2, mode) {
    const meta = this.getDatasetMeta(index2);
    const args = {
      meta,
      index: index2,
      mode,
      cancelable: true
    };
    if (this.notifyPlugins("beforeDatasetUpdate", args) === false) {
      return;
    }
    meta.controller._update(mode);
    args.cancelable = false;
    this.notifyPlugins("afterDatasetUpdate", args);
  }
  render() {
    if (this.notifyPlugins("beforeRender", {
      cancelable: true
    }) === false) {
      return;
    }
    if (animator.has(this)) {
      if (this.attached && !animator.running(this)) {
        animator.start(this);
      }
    } else {
      this.draw();
      onAnimationsComplete({
        chart: this
      });
    }
  }
  draw() {
    let i;
    if (this._resizeBeforeDraw) {
      const { width, height } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null;
      this._resize(width, height);
    }
    this.clear();
    if (this.width <= 0 || this.height <= 0) {
      return;
    }
    if (this.notifyPlugins("beforeDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const layers = this._layers;
    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
      layers[i].draw(this.chartArea);
    }
    this._drawDatasets();
    for (; i < layers.length; ++i) {
      layers[i].draw(this.chartArea);
    }
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(filterVisible) {
    const metasets = this._sortedMetasets;
    const result = [];
    let i, ilen;
    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      const meta = metasets[i];
      if (!filterVisible || meta.visible) {
        result.push(meta);
      }
    }
    return result;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(true);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: true
    }) === false) {
      return;
    }
    const metasets = this.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      this._drawDataset(metasets[i]);
    }
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(meta) {
    const ctx = this.ctx;
    const args = {
      meta,
      index: meta.index,
      cancelable: true
    };
    const clip = getDatasetClipArea(this, meta);
    if (this.notifyPlugins("beforeDatasetDraw", args) === false) {
      return;
    }
    if (clip) {
      clipArea(ctx, clip);
    }
    meta.controller.draw();
    if (clip) {
      unclipArea(ctx);
    }
    args.cancelable = false;
    this.notifyPlugins("afterDatasetDraw", args);
  }
  isPointInArea(point) {
    return _isPointInArea(point, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(e, mode, options2, useFinalPosition) {
    const method = Interaction.modes[mode];
    if (typeof method === "function") {
      return method(this, e, options2, useFinalPosition);
    }
    return [];
  }
  getDatasetMeta(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    const metasets = this._metasets;
    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
    if (!meta) {
      meta = {
        type: null,
        data: [],
        dataset: null,
        controller: null,
        hidden: null,
        xAxisID: null,
        yAxisID: null,
        order: dataset && dataset.order || 0,
        index: datasetIndex,
        _dataset: dataset,
        _parsed: [],
        _sorted: false
      };
      metasets.push(meta);
    }
    return meta;
  }
  getContext() {
    return this.$context || (this.$context = createContext(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(datasetIndex) {
    const dataset = this.data.datasets[datasetIndex];
    if (!dataset) {
      return false;
    }
    const meta = this.getDatasetMeta(datasetIndex);
    return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
  }
  setDatasetVisibility(datasetIndex, visible) {
    const meta = this.getDatasetMeta(datasetIndex);
    meta.hidden = !visible;
  }
  toggleDataVisibility(index2) {
    this._hiddenIndices[index2] = !this._hiddenIndices[index2];
  }
  getDataVisibility(index2) {
    return !this._hiddenIndices[index2];
  }
  _updateVisibility(datasetIndex, dataIndex, visible) {
    const mode = visible ? "show" : "hide";
    const meta = this.getDatasetMeta(datasetIndex);
    const anims = meta.controller._resolveAnimations(void 0, mode);
    if (defined(dataIndex)) {
      meta.data[dataIndex].hidden = !visible;
      this.update();
    } else {
      this.setDatasetVisibility(datasetIndex, visible);
      anims.update(meta, {
        visible
      });
      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
    }
  }
  hide(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, false);
  }
  show(datasetIndex, dataIndex) {
    this._updateVisibility(datasetIndex, dataIndex, true);
  }
  _destroyDatasetMeta(datasetIndex) {
    const meta = this._metasets[datasetIndex];
    if (meta && meta.controller) {
      meta.controller._destroy();
    }
    delete this._metasets[datasetIndex];
  }
  _stop() {
    let i, ilen;
    this.stop();
    animator.remove(this);
    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
      this._destroyDatasetMeta(i);
    }
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas, ctx } = this;
    this._stop();
    this.config.clearCache();
    if (canvas) {
      this.unbindEvents();
      clearCanvas(canvas, ctx);
      this.platform.releaseContext(ctx);
      this.canvas = null;
      this.ctx = null;
    }
    delete instances[this.id];
    this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...args) {
    return this.canvas.toDataURL(...args);
  }
  bindEvents() {
    this.bindUserEvents();
    if (this.options.responsive) {
      this.bindResponsiveEvents();
    } else {
      this.attached = true;
    }
  }
  bindUserEvents() {
    const listeners = this._listeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const listener = (e, x, y) => {
      e.offsetX = x;
      e.offsetY = y;
      this._eventHandler(e);
    };
    each(this.options.events, (type) => _add(type, listener));
  }
  bindResponsiveEvents() {
    if (!this._responsiveListeners) {
      this._responsiveListeners = {};
    }
    const listeners = this._responsiveListeners;
    const platform = this.platform;
    const _add = (type, listener2) => {
      platform.addEventListener(this, type, listener2);
      listeners[type] = listener2;
    };
    const _remove = (type, listener2) => {
      if (listeners[type]) {
        platform.removeEventListener(this, type, listener2);
        delete listeners[type];
      }
    };
    const listener = (width, height) => {
      if (this.canvas) {
        this.resize(width, height);
      }
    };
    let detached;
    const attached = () => {
      _remove("attach", attached);
      this.attached = true;
      this.resize();
      _add("resize", listener);
      _add("detach", detached);
    };
    detached = () => {
      this.attached = false;
      _remove("resize", listener);
      this._stop();
      this._resize(0, 0);
      _add("attach", attached);
    };
    if (platform.isAttached(this.canvas)) {
      attached();
    } else {
      detached();
    }
  }
  unbindEvents() {
    each(this._listeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._listeners = {};
    each(this._responsiveListeners, (listener, type) => {
      this.platform.removeEventListener(this, type, listener);
    });
    this._responsiveListeners = void 0;
  }
  updateHoverStyle(items, mode, enabled) {
    const prefix = enabled ? "set" : "remove";
    let meta, item, i, ilen;
    if (mode === "dataset") {
      meta = this.getDatasetMeta(items[0].datasetIndex);
      meta.controller["_" + prefix + "DatasetHoverStyle"]();
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];
      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
      if (controller) {
        controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
      }
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements) {
    const lastActive = this._active || [];
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("No dataset found at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(active, lastActive);
    if (changed) {
      this._active = active;
      this._lastEvent = null;
      this._updateHoverStyles(active, lastActive);
    }
  }
  notifyPlugins(hook, args, filter) {
    return this._plugins.notify(this, hook, args, filter);
  }
  isPluginEnabled(pluginId) {
    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;
  }
  _updateHoverStyles(active, lastActive, replay) {
    const hoverOptions = this.options.hover;
    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
    const deactivated = diff(lastActive, active);
    const activated = replay ? active : diff(active, lastActive);
    if (deactivated.length) {
      this.updateHoverStyle(deactivated, hoverOptions.mode, false);
    }
    if (activated.length && hoverOptions.mode) {
      this.updateHoverStyle(activated, hoverOptions.mode, true);
    }
  }
  _eventHandler(e, replay) {
    const args = {
      event: e,
      replay,
      cancelable: true,
      inChartArea: this.isPointInArea(e)
    };
    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);
    if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) {
      return;
    }
    const changed = this._handleEvent(e, replay, args.inChartArea);
    args.cancelable = false;
    this.notifyPlugins("afterEvent", args, eventFilter);
    if (changed || args.changed) {
      this.render();
    }
    return this;
  }
  _handleEvent(e, replay, inChartArea) {
    const { _active: lastActive = [], options: options2 } = this;
    const useFinalPosition = replay;
    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
    const isClick = _isClickEvent(e);
    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
    if (inChartArea) {
      this._lastEvent = null;
      callback(options2.onHover, [
        e,
        active,
        this
      ], this);
      if (isClick) {
        callback(options2.onClick, [
          e,
          active,
          this
        ], this);
      }
    }
    const changed = !_elementsEqual(active, lastActive);
    if (changed || replay) {
      this._active = active;
      this._updateHoverStyles(active, lastActive, replay);
    }
    this._lastEvent = lastEvent;
    return changed;
  }
  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive;
    }
    const hoverOptions = this.options.hover;
    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
  }
};
__publicField(Chart, "defaults", defaults);
__publicField(Chart, "instances", instances);
__publicField(Chart, "overrides", overrides);
__publicField(Chart, "registry", registry);
__publicField(Chart, "version", version);
__publicField(Chart, "getChart", getChart);
function invalidatePlugins() {
  return each(Chart.instances, (chart) => chart._plugins.invalidate());
}
function clipSelf(ctx, element, endAngle) {
  const { startAngle, x, y, outerRadius, innerRadius, options: options2 } = element;
  const { borderWidth, borderJoinStyle } = options2;
  const outerAngleClip = Math.min(borderWidth / outerRadius, _normalizeAngle(startAngle - endAngle));
  ctx.beginPath();
  ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);
  if (innerRadius > 0) {
    const innerAngleClip = Math.min(borderWidth / innerRadius, _normalizeAngle(startAngle - endAngle));
    ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);
  } else {
    const clipWidth = Math.min(borderWidth / 2, outerRadius * _normalizeAngle(startAngle - endAngle));
    if (borderJoinStyle === "round") {
      ctx.arc(x, y, clipWidth, endAngle - PI / 2, startAngle + PI / 2, true);
    } else if (borderJoinStyle === "bevel") {
      const r = 2 * clipWidth * clipWidth;
      const endX = -r * Math.cos(endAngle + PI / 2) + x;
      const endY = -r * Math.sin(endAngle + PI / 2) + y;
      const startX = r * Math.cos(startAngle + PI / 2) + x;
      const startY = r * Math.sin(startAngle + PI / 2) + y;
      ctx.lineTo(endX, endY);
      ctx.lineTo(startX, startY);
    }
  }
  ctx.closePath();
  ctx.moveTo(0, 0);
  ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.clip("evenodd");
}
function clipArc(ctx, element, endAngle) {
  const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
  let angleMargin = pixelMargin / outerRadius;
  ctx.beginPath();
  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
  if (innerRadius > pixelMargin) {
    angleMargin = pixelMargin / innerRadius;
    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
  } else {
    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
  }
  ctx.closePath();
  ctx.clip();
}
function toRadiusCorners(value) {
  return _readValueToProps(value, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
  const o = toRadiusCorners(arc.options.borderRadius);
  const halfThickness = (outerRadius - innerRadius) / 2;
  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
  const computeOuterLimit = (val) => {
    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
  };
  return {
    outerStart: computeOuterLimit(o.outerStart),
    outerEnd: computeOuterLimit(o.outerEnd),
    innerStart: _limitValue(o.innerStart, 0, innerLimit),
    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
  };
}
function rThetaToXY(r, theta, x, y) {
  return {
    x: x + r * Math.cos(theta),
    y: y + r * Math.sin(theta)
  };
}
function pathArc(ctx, element, offset, spacing, end, circular) {
  const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;
  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
  let spacingOffset = 0;
  const alpha2 = end - start;
  if (spacing) {
    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;
    spacingOffset = (alpha2 - adjustedAngle) / 2;
  }
  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;
  const angleOffset = (alpha2 - beta) / 2;
  const startAngle = start + angleOffset + spacingOffset;
  const endAngle = end - angleOffset - spacingOffset;
  const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
  const outerStartAdjustedRadius = outerRadius - outerStart;
  const outerEndAdjustedRadius = outerRadius - outerEnd;
  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
  const innerStartAdjustedRadius = innerRadius + innerStart;
  const innerEndAdjustedRadius = innerRadius + innerEnd;
  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
  ctx.beginPath();
  if (circular) {
    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
    if (outerEnd > 0) {
      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
    }
    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
    ctx.lineTo(p4.x, p4.y);
    if (innerEnd > 0) {
      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
    }
    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
    if (innerStart > 0) {
      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
    }
    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
    ctx.lineTo(p8.x, p8.y);
    if (outerStart > 0) {
      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
    }
  } else {
    ctx.moveTo(x, y);
    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerStartX, outerStartY);
    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
    ctx.lineTo(outerEndX, outerEndY);
  }
  ctx.closePath();
}
function drawArc(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference } = element;
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.fill();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  pathArc(ctx, element, offset, spacing, endAngle, circular);
  ctx.fill();
  return endAngle;
}
function drawBorder(ctx, element, offset, spacing, circular) {
  const { fullCircles, startAngle, circumference, options: options2 } = element;
  const { borderWidth, borderJoinStyle, borderDash, borderDashOffset, borderRadius } = options2;
  const inner = options2.borderAlign === "inner";
  if (!borderWidth) {
    return;
  }
  ctx.setLineDash(borderDash || []);
  ctx.lineDashOffset = borderDashOffset;
  if (inner) {
    ctx.lineWidth = borderWidth * 2;
    ctx.lineJoin = borderJoinStyle || "round";
  } else {
    ctx.lineWidth = borderWidth;
    ctx.lineJoin = borderJoinStyle || "bevel";
  }
  let endAngle = element.endAngle;
  if (fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    for (let i = 0; i < fullCircles; ++i) {
      ctx.stroke();
    }
    if (!isNaN(circumference)) {
      endAngle = startAngle + (circumference % TAU || TAU);
    }
  }
  if (inner) {
    clipArc(ctx, element, endAngle);
  }
  if (options2.selfJoin && endAngle - startAngle >= PI && borderRadius === 0 && borderJoinStyle !== "miter") {
    clipSelf(ctx, element, endAngle);
  }
  if (!fullCircles) {
    pathArc(ctx, element, offset, spacing, endAngle, circular);
    ctx.stroke();
  }
}
var ArcElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "circumference");
    __publicField(this, "endAngle");
    __publicField(this, "fullCircles");
    __publicField(this, "innerRadius");
    __publicField(this, "outerRadius");
    __publicField(this, "pixelMargin");
    __publicField(this, "startAngle");
    this.options = void 0;
    this.circumference = void 0;
    this.startAngle = void 0;
    this.endAngle = void 0;
    this.innerRadius = void 0;
    this.outerRadius = void 0;
    this.pixelMargin = 0;
    this.fullCircles = 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(chartX, chartY, useFinalPosition) {
    const point = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    const { angle, distance } = getAngleFromPoint(point, {
      x: chartX,
      y: chartY
    });
    const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], useFinalPosition);
    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
    const _circumference = valueOrDefault(circumference, endAngle - startAngle);
    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
    const betweenAngles = _circumference >= TAU || nonZeroBetween;
    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
    return betweenAngles && withinRadius;
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], useFinalPosition);
    const { offset, spacing } = this.options;
    const halfAngle = (startAngle + endAngle) / 2;
    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
    return {
      x: x + Math.cos(halfAngle) * halfRadius,
      y: y + Math.sin(halfAngle) * halfRadius
    };
  }
  tooltipPosition(useFinalPosition) {
    return this.getCenterPoint(useFinalPosition);
  }
  draw(ctx) {
    const { options: options2, circumference } = this;
    const offset = (options2.offset || 0) / 4;
    const spacing = (options2.spacing || 0) / 2;
    const circular = options2.circular;
    this.pixelMargin = options2.borderAlign === "inner" ? 0.33 : 0;
    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {
      return;
    }
    ctx.save();
    const halfAngle = (this.startAngle + this.endAngle) / 2;
    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
    const radiusOffset = offset * fix;
    ctx.fillStyle = options2.backgroundColor;
    ctx.strokeStyle = options2.borderColor;
    drawArc(ctx, this, radiusOffset, spacing, circular);
    drawBorder(ctx, this, radiusOffset, spacing, circular);
    ctx.restore();
  }
};
__publicField(ArcElement, "id", "arc");
__publicField(ArcElement, "defaults", {
  borderAlign: "center",
  borderColor: "#fff",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: void 0,
  borderRadius: 0,
  borderWidth: 2,
  offset: 0,
  spacing: 0,
  angle: void 0,
  circular: true,
  selfJoin: false
});
__publicField(ArcElement, "defaultRoutes", {
  backgroundColor: "backgroundColor"
});
__publicField(ArcElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash"
});
function setStyle(ctx, options2, style = options2) {
  ctx.lineCap = valueOrDefault(style.borderCapStyle, options2.borderCapStyle);
  ctx.setLineDash(valueOrDefault(style.borderDash, options2.borderDash));
  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options2.borderDashOffset);
  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options2.borderJoinStyle);
  ctx.lineWidth = valueOrDefault(style.borderWidth, options2.borderWidth);
  ctx.strokeStyle = valueOrDefault(style.borderColor, options2.borderColor);
}
function lineTo(ctx, previous, target) {
  ctx.lineTo(target.x, target.y);
}
function getLineMethod(options2) {
  if (options2.stepped) {
    return _steppedLineTo;
  }
  if (options2.tension || options2.cubicInterpolationMode === "monotone") {
    return _bezierCurveTo;
  }
  return lineTo;
}
function pathVars(points, segment, params = {}) {
  const count = points.length;
  const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
  const { start: segmentStart, end: segmentEnd } = segment;
  const start = Math.max(paramsStart, segmentStart);
  const end = Math.min(paramsEnd, segmentEnd);
  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
  return {
    count,
    start,
    loop: segment.loop,
    ilen: end < start && !outside ? count + end - start : end - start
  };
}
function pathSegment(ctx, line, segment, params) {
  const { points, options: options2 } = line;
  const { count, start, loop, ilen } = pathVars(points, segment, params);
  const lineMethod = getLineMethod(options2);
  let { move = true, reverse } = params || {};
  let i, point, prev;
  for (i = 0; i <= ilen; ++i) {
    point = points[(start + (reverse ? ilen - i : i)) % count];
    if (point.skip) {
      continue;
    } else if (move) {
      ctx.moveTo(point.x, point.y);
      move = false;
    } else {
      lineMethod(ctx, prev, point, reverse, options2.stepped);
    }
    prev = point;
  }
  if (loop) {
    point = points[(start + (reverse ? ilen : 0)) % count];
    lineMethod(ctx, prev, point, reverse, options2.stepped);
  }
  return !!loop;
}
function fastPathSegment(ctx, line, segment, params) {
  const points = line.points;
  const { count, start, ilen } = pathVars(points, segment, params);
  const { move = true, reverse } = params || {};
  let avgX = 0;
  let countX = 0;
  let i, point, prevX, minY, maxY, lastY;
  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;
  const drawX = () => {
    if (minY !== maxY) {
      ctx.lineTo(avgX, maxY);
      ctx.lineTo(avgX, minY);
      ctx.lineTo(avgX, lastY);
    }
  };
  if (move) {
    point = points[pointIndex(0)];
    ctx.moveTo(point.x, point.y);
  }
  for (i = 0; i <= ilen; ++i) {
    point = points[pointIndex(i)];
    if (point.skip) {
      continue;
    }
    const x = point.x;
    const y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
      avgX = (countX * avgX + x) / ++countX;
    } else {
      drawX();
      ctx.lineTo(x, y);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
    }
    lastY = y;
  }
  drawX();
}
function _getSegmentMethod(line) {
  const opts = line.options;
  const borderDash = opts.borderDash && opts.borderDash.length;
  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
  return useFastPath ? fastPathSegment : pathSegment;
}
function _getInterpolationMethod(options2) {
  if (options2.stepped) {
    return _steppedInterpolation;
  }
  if (options2.tension || options2.cubicInterpolationMode === "monotone") {
    return _bezierInterpolation;
  }
  return _pointInLine;
}
function strokePathWithCache(ctx, line, start, count) {
  let path = line._path;
  if (!path) {
    path = line._path = new Path2D();
    if (line.path(path, start, count)) {
      path.closePath();
    }
  }
  setStyle(ctx, line.options);
  ctx.stroke(path);
}
function strokePathDirect(ctx, line, start, count) {
  const { segments, options: options2 } = line;
  const segmentMethod = _getSegmentMethod(line);
  for (const segment of segments) {
    setStyle(ctx, options2, segment.style);
    ctx.beginPath();
    if (segmentMethod(ctx, line, segment, {
      start,
      end: start + count - 1
    })) {
      ctx.closePath();
    }
    ctx.stroke();
  }
}
var usePath2D = typeof Path2D === "function";
function draw(ctx, line, start, count) {
  if (usePath2D && !line.options.segment) {
    strokePathWithCache(ctx, line, start, count);
  } else {
    strokePathDirect(ctx, line, start, count);
  }
}
var LineElement = class extends Element {
  constructor(cfg) {
    super();
    this.animated = true;
    this.options = void 0;
    this._chart = void 0;
    this._loop = void 0;
    this._fullLoop = void 0;
    this._path = void 0;
    this._points = void 0;
    this._segments = void 0;
    this._decimated = false;
    this._pointsUpdated = false;
    this._datasetIndex = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  updateControlPoints(chartArea, indexAxis) {
    const options2 = this.options;
    if ((options2.tension || options2.cubicInterpolationMode === "monotone") && !options2.stepped && !this._pointsUpdated) {
      const loop = options2.spanGaps ? this._loop : this._fullLoop;
      _updateBezierControlPoints(this._points, options2, chartArea, loop, indexAxis);
      this._pointsUpdated = true;
    }
  }
  set points(points) {
    this._points = points;
    delete this._segments;
    delete this._path;
    this._pointsUpdated = false;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = _computeSegments(this, this.options.segment));
  }
  first() {
    const segments = this.segments;
    const points = this.points;
    return segments.length && points[segments[0].start];
  }
  last() {
    const segments = this.segments;
    const points = this.points;
    const count = segments.length;
    return count && points[segments[count - 1].end];
  }
  interpolate(point, property) {
    const options2 = this.options;
    const value = point[property];
    const points = this.points;
    const segments = _boundSegments(this, {
      property,
      start: value,
      end: value
    });
    if (!segments.length) {
      return;
    }
    const result = [];
    const _interpolate = _getInterpolationMethod(options2);
    let i, ilen;
    for (i = 0, ilen = segments.length; i < ilen; ++i) {
      const { start, end } = segments[i];
      const p1 = points[start];
      const p2 = points[end];
      if (p1 === p2) {
        result.push(p1);
        continue;
      }
      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
      const interpolated = _interpolate(p1, p2, t, options2.stepped);
      interpolated[property] = point[property];
      result.push(interpolated);
    }
    return result.length === 1 ? result[0] : result;
  }
  pathSegment(ctx, segment, params) {
    const segmentMethod = _getSegmentMethod(this);
    return segmentMethod(ctx, this, segment, params);
  }
  path(ctx, start, count) {
    const segments = this.segments;
    const segmentMethod = _getSegmentMethod(this);
    let loop = this._loop;
    start = start || 0;
    count = count || this.points.length - start;
    for (const segment of segments) {
      loop &= segmentMethod(ctx, this, segment, {
        start,
        end: start + count - 1
      });
    }
    return !!loop;
  }
  draw(ctx, chartArea, start, count) {
    const options2 = this.options || {};
    const points = this.points || [];
    if (points.length && options2.borderWidth) {
      ctx.save();
      draw(ctx, this, start, count);
      ctx.restore();
    }
    if (this.animated) {
      this._pointsUpdated = false;
      this._path = void 0;
    }
  }
};
__publicField(LineElement, "id", "line");
__publicField(LineElement, "defaults", {
  borderCapStyle: "butt",
  borderDash: [],
  borderDashOffset: 0,
  borderJoinStyle: "miter",
  borderWidth: 3,
  capBezierPoints: true,
  cubicInterpolationMode: "default",
  fill: false,
  spanGaps: false,
  stepped: false,
  tension: 0
});
__publicField(LineElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
__publicField(LineElement, "descriptors", {
  _scriptable: true,
  _indexable: (name) => name !== "borderDash" && name !== "fill"
});
function inRange$1(el, pos, axis, useFinalPosition) {
  const options2 = el.options;
  const { [axis]: value } = el.getProps([
    axis
  ], useFinalPosition);
  return Math.abs(pos - value) < options2.radius + options2.hitRadius;
}
var PointElement = class extends Element {
  constructor(cfg) {
    super();
    __publicField(this, "parsed");
    __publicField(this, "skip");
    __publicField(this, "stop");
    this.options = void 0;
    this.parsed = void 0;
    this.skip = void 0;
    this.stop = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    const options2 = this.options;
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options2.hitRadius + options2.radius, 2);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange$1(this, mouseX, "x", useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange$1(this, mouseY, "y", useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y } = this.getProps([
      "x",
      "y"
    ], useFinalPosition);
    return {
      x,
      y
    };
  }
  size(options2) {
    options2 = options2 || this.options || {};
    let radius = options2.radius || 0;
    radius = Math.max(radius, radius && options2.hoverRadius || 0);
    const borderWidth = radius && options2.borderWidth || 0;
    return (radius + borderWidth) * 2;
  }
  draw(ctx, area) {
    const options2 = this.options;
    if (this.skip || options2.radius < 0.1 || !_isPointInArea(this, area, this.size(options2) / 2)) {
      return;
    }
    ctx.strokeStyle = options2.borderColor;
    ctx.lineWidth = options2.borderWidth;
    ctx.fillStyle = options2.backgroundColor;
    drawPoint(ctx, options2, this.x, this.y);
  }
  getRange() {
    const options2 = this.options || {};
    return options2.radius + options2.hitRadius;
  }
};
__publicField(PointElement, "id", "point");
/**
* @type {any}
*/
__publicField(PointElement, "defaults", {
  borderWidth: 1,
  hitRadius: 1,
  hoverBorderWidth: 1,
  hoverRadius: 4,
  pointStyle: "circle",
  radius: 3,
  rotation: 0
});
/**
* @type {any}
*/
__publicField(PointElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
function getBarBounds(bar, useFinalPosition) {
  const { x, y, base, width, height } = bar.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], useFinalPosition);
  let left, right, top, bottom, half;
  if (bar.horizontal) {
    half = height / 2;
    left = Math.min(x, base);
    right = Math.max(x, base);
    top = y - half;
    bottom = y + half;
  } else {
    half = width / 2;
    left = x - half;
    right = x + half;
    top = Math.min(y, base);
    bottom = Math.max(y, base);
  }
  return {
    left,
    top,
    right,
    bottom
  };
}
function skipOrLimit(skip2, value, min, max) {
  return skip2 ? 0 : _limitValue(value, min, max);
}
function parseBorderWidth(bar, maxW, maxH) {
  const value = bar.options.borderWidth;
  const skip2 = bar.borderSkipped;
  const o = toTRBL(value);
  return {
    t: skipOrLimit(skip2.top, o.top, 0, maxH),
    r: skipOrLimit(skip2.right, o.right, 0, maxW),
    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
    l: skipOrLimit(skip2.left, o.left, 0, maxW)
  };
}
function parseBorderRadius(bar, maxW, maxH) {
  const { enableBorderRadius } = bar.getProps([
    "enableBorderRadius"
  ]);
  const value = bar.options.borderRadius;
  const o = toTRBLCorners(value);
  const maxR = Math.min(maxW, maxH);
  const skip2 = bar.borderSkipped;
  const enableBorder = enableBorderRadius || isObject(value);
  return {
    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
  };
}
function boundingRects(bar) {
  const bounds = getBarBounds(bar);
  const width = bounds.right - bounds.left;
  const height = bounds.bottom - bounds.top;
  const border = parseBorderWidth(bar, width / 2, height / 2);
  const radius = parseBorderRadius(bar, width / 2, height / 2);
  return {
    outer: {
      x: bounds.left,
      y: bounds.top,
      w: width,
      h: height,
      radius
    },
    inner: {
      x: bounds.left + border.l,
      y: bounds.top + border.t,
      w: width - border.l - border.r,
      h: height - border.t - border.b,
      radius: {
        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
      }
    }
  };
}
function inRange(bar, x, y, useFinalPosition) {
  const skipX = x === null;
  const skipY = y === null;
  const skipBoth = skipX && skipY;
  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
}
function hasRadius(radius) {
  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
}
function addNormalRectPath(ctx, rect) {
  ctx.rect(rect.x, rect.y, rect.w, rect.h);
}
function inflateRect(rect, amount, refRect = {}) {
  const x = rect.x !== refRect.x ? -amount : 0;
  const y = rect.y !== refRect.y ? -amount : 0;
  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
  return {
    x: rect.x + x,
    y: rect.y + y,
    w: rect.w + w,
    h: rect.h + h,
    radius: rect.radius
  };
}
var BarElement = class extends Element {
  constructor(cfg) {
    super();
    this.options = void 0;
    this.horizontal = void 0;
    this.base = void 0;
    this.width = void 0;
    this.height = void 0;
    this.inflateAmount = void 0;
    if (cfg) {
      Object.assign(this, cfg);
    }
  }
  draw(ctx) {
    const { inflateAmount, options: { borderColor, backgroundColor } } = this;
    const { inner, outer } = boundingRects(this);
    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
    ctx.save();
    if (outer.w !== inner.w || outer.h !== inner.h) {
      ctx.beginPath();
      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
      ctx.clip();
      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
      ctx.fillStyle = borderColor;
      ctx.fill("evenodd");
    }
    ctx.beginPath();
    addRectPath(ctx, inflateRect(inner, inflateAmount));
    ctx.fillStyle = backgroundColor;
    ctx.fill();
    ctx.restore();
  }
  inRange(mouseX, mouseY, useFinalPosition) {
    return inRange(this, mouseX, mouseY, useFinalPosition);
  }
  inXRange(mouseX, useFinalPosition) {
    return inRange(this, mouseX, null, useFinalPosition);
  }
  inYRange(mouseY, useFinalPosition) {
    return inRange(this, null, mouseY, useFinalPosition);
  }
  getCenterPoint(useFinalPosition) {
    const { x, y, base, horizontal } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], useFinalPosition);
    return {
      x: horizontal ? (x + base) / 2 : x,
      y: horizontal ? y : (y + base) / 2
    };
  }
  getRange(axis) {
    return axis === "x" ? this.width / 2 : this.height / 2;
  }
};
__publicField(BarElement, "id", "bar");
__publicField(BarElement, "defaults", {
  borderSkipped: "start",
  borderWidth: 0,
  borderRadius: 0,
  inflateAmount: "auto",
  pointStyle: void 0
});
__publicField(BarElement, "defaultRoutes", {
  backgroundColor: "backgroundColor",
  borderColor: "borderColor"
});
var elements = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcElement,
  BarElement,
  LineElement,
  PointElement
});
var BORDER_COLORS = [
  "rgb(54, 162, 235)",
  "rgb(255, 99, 132)",
  "rgb(255, 159, 64)",
  "rgb(255, 205, 86)",
  "rgb(75, 192, 192)",
  "rgb(153, 102, 255)",
  "rgb(201, 203, 207)"
  // grey
];
var BACKGROUND_COLORS = /* @__PURE__ */ BORDER_COLORS.map((color2) => color2.replace("rgb(", "rgba(").replace(")", ", 0.5)"));
function getBorderColor(i) {
  return BORDER_COLORS[i % BORDER_COLORS.length];
}
function getBackgroundColor(i) {
  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
}
function colorizeDefaultDataset(dataset, i) {
  dataset.borderColor = getBorderColor(i);
  dataset.backgroundColor = getBackgroundColor(i);
  return ++i;
}
function colorizeDoughnutDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
  return i;
}
function colorizePolarAreaDataset(dataset, i) {
  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));
  return i;
}
function getColorizer(chart) {
  let i = 0;
  return (dataset, datasetIndex) => {
    const controller = chart.getDatasetMeta(datasetIndex).controller;
    if (controller instanceof DoughnutController) {
      i = colorizeDoughnutDataset(dataset, i);
    } else if (controller instanceof PolarAreaController) {
      i = colorizePolarAreaDataset(dataset, i);
    } else if (controller) {
      i = colorizeDefaultDataset(dataset, i);
    }
  };
}
function containsColorsDefinitions(descriptors2) {
  let k;
  for (k in descriptors2) {
    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {
      return true;
    }
  }
  return false;
}
function containsColorsDefinition(descriptor) {
  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
}
function containsDefaultColorsDefenitions() {
  return defaults.borderColor !== "rgba(0,0,0,0.1)" || defaults.backgroundColor !== "rgba(0,0,0,0.1)";
}
var plugin_colors = {
  id: "colors",
  defaults: {
    enabled: true,
    forceOverride: false
  },
  beforeLayout(chart, _args, options2) {
    if (!options2.enabled) {
      return;
    }
    const { data: { datasets }, options: chartOptions } = chart.config;
    const { elements: elements2 } = chartOptions;
    const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2) || containsDefaultColorsDefenitions();
    if (!options2.forceOverride && containsColorDefenition) {
      return;
    }
    const colorizer = getColorizer(chart);
    datasets.forEach(colorizer);
  }
};
function lttbDecimation(data, start, count, availableWidth, options2) {
  const samples = options2.samples || availableWidth;
  if (samples >= count) {
    return data.slice(start, start + count);
  }
  const decimated = [];
  const bucketWidth = (count - 2) / (samples - 2);
  let sampledIndex = 0;
  const endIndex = start + count - 1;
  let a = start;
  let i, maxAreaPoint, maxArea, area, nextA;
  decimated[sampledIndex++] = data[a];
  for (i = 0; i < samples - 2; i++) {
    let avgX = 0;
    let avgY = 0;
    let j;
    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
    const avgRangeLength = avgRangeEnd - avgRangeStart;
    for (j = avgRangeStart; j < avgRangeEnd; j++) {
      avgX += data[j].x;
      avgY += data[j].y;
    }
    avgX /= avgRangeLength;
    avgY /= avgRangeLength;
    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
    const { x: pointAx, y: pointAy } = data[a];
    maxArea = area = -1;
    for (j = rangeOffs; j < rangeTo; j++) {
      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
      if (area > maxArea) {
        maxArea = area;
        maxAreaPoint = data[j];
        nextA = j;
      }
    }
    decimated[sampledIndex++] = maxAreaPoint;
    a = nextA;
  }
  decimated[sampledIndex++] = data[endIndex];
  return decimated;
}
function minMaxDecimation(data, start, count, availableWidth) {
  let avgX = 0;
  let countX = 0;
  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
  const decimated = [];
  const endIndex = start + count - 1;
  const xMin = data[start].x;
  const xMax = data[endIndex].x;
  const dx = xMax - xMin;
  for (i = start; i < start + count; ++i) {
    point = data[i];
    x = (point.x - xMin) / dx * availableWidth;
    y = point.y;
    const truncX = x | 0;
    if (truncX === prevX) {
      if (y < minY) {
        minY = y;
        minIndex = i;
      } else if (y > maxY) {
        maxY = y;
        maxIndex = i;
      }
      avgX = (countX * avgX + point.x) / ++countX;
    } else {
      const lastIndex = i - 1;
      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
        const intermediateIndex1 = Math.min(minIndex, maxIndex);
        const intermediateIndex2 = Math.max(minIndex, maxIndex);
        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex1],
            x: avgX
          });
        }
        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
          decimated.push({
            ...data[intermediateIndex2],
            x: avgX
          });
        }
      }
      if (i > 0 && lastIndex !== startIndex) {
        decimated.push(data[lastIndex]);
      }
      decimated.push(point);
      prevX = truncX;
      countX = 0;
      minY = maxY = y;
      minIndex = maxIndex = startIndex = i;
    }
  }
  return decimated;
}
function cleanDecimatedDataset(dataset) {
  if (dataset._decimated) {
    const data = dataset._data;
    delete dataset._decimated;
    delete dataset._data;
    Object.defineProperty(dataset, "data", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: data
    });
  }
}
function cleanDecimatedData(chart) {
  chart.data.datasets.forEach((dataset) => {
    cleanDecimatedDataset(dataset);
  });
}
function getStartAndCountOfVisiblePointsSimplified(meta, points) {
  const pointCount = points.length;
  let start = 0;
  let count;
  const { iScale } = meta;
  const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
  if (minDefined) {
    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
  }
  if (maxDefined) {
    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;
  } else {
    count = pointCount - start;
  }
  return {
    start,
    count
  };
}
var plugin_decimation = {
  id: "decimation",
  defaults: {
    algorithm: "min-max",
    enabled: false
  },
  beforeElementsUpdate: (chart, args, options2) => {
    if (!options2.enabled) {
      cleanDecimatedData(chart);
      return;
    }
    const availableWidth = chart.width;
    chart.data.datasets.forEach((dataset, datasetIndex) => {
      const { _data, indexAxis } = dataset;
      const meta = chart.getDatasetMeta(datasetIndex);
      const data = _data || dataset.data;
      if (resolve([
        indexAxis,
        chart.options.indexAxis
      ]) === "y") {
        return;
      }
      if (!meta.controller.supportsDecimation) {
        return;
      }
      const xAxis = chart.scales[meta.xAxisID];
      if (xAxis.type !== "linear" && xAxis.type !== "time") {
        return;
      }
      if (chart.options.parsing) {
        return;
      }
      let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
      const threshold = options2.threshold || 4 * availableWidth;
      if (count <= threshold) {
        cleanDecimatedDataset(dataset);
        return;
      }
      if (isNullOrUndef(_data)) {
        dataset._data = data;
        delete dataset.data;
        Object.defineProperty(dataset, "data", {
          configurable: true,
          enumerable: true,
          get: function() {
            return this._decimated;
          },
          set: function(d) {
            this._data = d;
          }
        });
      }
      let decimated;
      switch (options2.algorithm) {
        case "lttb":
          decimated = lttbDecimation(data, start, count, availableWidth, options2);
          break;
        case "min-max":
          decimated = minMaxDecimation(data, start, count, availableWidth);
          break;
        default:
          throw new Error(`Unsupported decimation algorithm '${options2.algorithm}'`);
      }
      dataset._decimated = decimated;
    });
  },
  destroy(chart) {
    cleanDecimatedData(chart);
  }
};
function _segments(line, target, property) {
  const segments = line.segments;
  const points = line.points;
  const tpoints = target.points;
  const parts = [];
  for (const segment of segments) {
    let { start, end } = segment;
    end = _findSegmentEnd(start, end, points);
    const bounds = _getBounds(property, points[start], points[end], segment.loop);
    if (!target.segments) {
      parts.push({
        source: segment,
        target: bounds,
        start: points[start],
        end: points[end]
      });
      continue;
    }
    const targetSegments = _boundSegments(target, bounds);
    for (const tgt of targetSegments) {
      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
      const fillSources = _boundSegment(segment, points, subBounds);
      for (const fillSource of fillSources) {
        parts.push({
          source: fillSource,
          target: tgt,
          start: {
            [property]: _getEdge(bounds, subBounds, "start", Math.max)
          },
          end: {
            [property]: _getEdge(bounds, subBounds, "end", Math.min)
          }
        });
      }
    }
  }
  return parts;
}
function _getBounds(property, first, last, loop) {
  if (loop) {
    return;
  }
  let start = first[property];
  let end = last[property];
  if (property === "angle") {
    start = _normalizeAngle(start);
    end = _normalizeAngle(end);
  }
  return {
    property,
    start,
    end
  };
}
function _pointsFromSegments(boundary, line) {
  const { x = null, y = null } = boundary || {};
  const linePoints = line.points;
  const points = [];
  line.segments.forEach(({ start, end }) => {
    end = _findSegmentEnd(start, end, linePoints);
    const first = linePoints[start];
    const last = linePoints[end];
    if (y !== null) {
      points.push({
        x: first.x,
        y
      });
      points.push({
        x: last.x,
        y
      });
    } else if (x !== null) {
      points.push({
        x,
        y: first.y
      });
      points.push({
        x,
        y: last.y
      });
    }
  });
  return points;
}
function _findSegmentEnd(start, end, points) {
  for (; end > start; end--) {
    const point = points[end];
    if (!isNaN(point.x) && !isNaN(point.y)) {
      break;
    }
  }
  return end;
}
function _getEdge(a, b, prop, fn) {
  if (a && b) {
    return fn(a[prop], b[prop]);
  }
  return a ? a[prop] : b ? b[prop] : 0;
}
function _createBoundaryLine(boundary, line) {
  let points = [];
  let _loop = false;
  if (isArray(boundary)) {
    _loop = true;
    points = boundary;
  } else {
    points = _pointsFromSegments(boundary, line);
  }
  return points.length ? new LineElement({
    points,
    options: {
      tension: 0
    },
    _loop,
    _fullLoop: _loop
  }) : null;
}
function _shouldApplyFill(source) {
  return source && source.fill !== false;
}
function _resolveTarget(sources, index2, propagate) {
  const source = sources[index2];
  let fill2 = source.fill;
  const visited = [
    index2
  ];
  let target;
  if (!propagate) {
    return fill2;
  }
  while (fill2 !== false && visited.indexOf(fill2) === -1) {
    if (!isNumberFinite(fill2)) {
      return fill2;
    }
    target = sources[fill2];
    if (!target) {
      return false;
    }
    if (target.visible) {
      return fill2;
    }
    visited.push(fill2);
    fill2 = target.fill;
  }
  return false;
}
function _decodeFill(line, index2, count) {
  const fill2 = parseFillOption(line);
  if (isObject(fill2)) {
    return isNaN(fill2.value) ? false : fill2;
  }
  let target = parseFloat(fill2);
  if (isNumberFinite(target) && Math.floor(target) === target) {
    return decodeTargetIndex(fill2[0], index2, target, count);
  }
  return [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(fill2) >= 0 && fill2;
}
function decodeTargetIndex(firstCh, index2, target, count) {
  if (firstCh === "-" || firstCh === "+") {
    target = index2 + target;
  }
  if (target === index2 || target < 0 || target >= count) {
    return false;
  }
  return target;
}
function _getTargetPixel(fill2, scale) {
  let pixel = null;
  if (fill2 === "start") {
    pixel = scale.bottom;
  } else if (fill2 === "end") {
    pixel = scale.top;
  } else if (isObject(fill2)) {
    pixel = scale.getPixelForValue(fill2.value);
  } else if (scale.getBasePixel) {
    pixel = scale.getBasePixel();
  }
  return pixel;
}
function _getTargetValue(fill2, scale, startValue) {
  let value;
  if (fill2 === "start") {
    value = startValue;
  } else if (fill2 === "end") {
    value = scale.options.reverse ? scale.min : scale.max;
  } else if (isObject(fill2)) {
    value = fill2.value;
  } else {
    value = scale.getBaseValue();
  }
  return value;
}
function parseFillOption(line) {
  const options2 = line.options;
  const fillOption = options2.fill;
  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);
  if (fill2 === void 0) {
    fill2 = !!options2.backgroundColor;
  }
  if (fill2 === false || fill2 === null) {
    return false;
  }
  if (fill2 === true) {
    return "origin";
  }
  return fill2;
}
function _buildStackLine(source) {
  const { scale, index: index2, line } = source;
  const points = [];
  const segments = line.segments;
  const sourcePoints = line.points;
  const linesBelow = getLinesBelow(scale, index2);
  linesBelow.push(_createBoundaryLine({
    x: null,
    y: scale.bottom
  }, line));
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    for (let j = segment.start; j <= segment.end; j++) {
      addPointsBelow(points, sourcePoints[j], linesBelow);
    }
  }
  return new LineElement({
    points,
    options: {}
  });
}
function getLinesBelow(scale, index2) {
  const below = [];
  const metas = scale.getMatchingVisibleMetas("line");
  for (let i = 0; i < metas.length; i++) {
    const meta = metas[i];
    if (meta.index === index2) {
      break;
    }
    if (!meta.hidden) {
      below.unshift(meta.dataset);
    }
  }
  return below;
}
function addPointsBelow(points, sourcePoint, linesBelow) {
  const postponed = [];
  for (let j = 0; j < linesBelow.length; j++) {
    const line = linesBelow[j];
    const { first, last, point } = findPoint(line, sourcePoint, "x");
    if (!point || first && last) {
      continue;
    }
    if (first) {
      postponed.unshift(point);
    } else {
      points.push(point);
      if (!last) {
        break;
      }
    }
  }
  points.push(...postponed);
}
function findPoint(line, sourcePoint, property) {
  const point = line.interpolate(sourcePoint, property);
  if (!point) {
    return {};
  }
  const pointValue = point[property];
  const segments = line.segments;
  const linePoints = line.points;
  let first = false;
  let last = false;
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const firstValue = linePoints[segment.start][property];
    const lastValue = linePoints[segment.end][property];
    if (_isBetween(pointValue, firstValue, lastValue)) {
      first = pointValue === firstValue;
      last = pointValue === lastValue;
      break;
    }
  }
  return {
    first,
    last,
    point
  };
}
var simpleArc = class {
  constructor(opts) {
    this.x = opts.x;
    this.y = opts.y;
    this.radius = opts.radius;
  }
  pathSegment(ctx, bounds, opts) {
    const { x, y, radius } = this;
    bounds = bounds || {
      start: 0,
      end: TAU
    };
    ctx.arc(x, y, radius, bounds.end, bounds.start, true);
    return !opts.bounds;
  }
  interpolate(point) {
    const { x, y, radius } = this;
    const angle = point.angle;
    return {
      x: x + Math.cos(angle) * radius,
      y: y + Math.sin(angle) * radius,
      angle
    };
  }
};
function _getTarget(source) {
  const { chart, fill: fill2, line } = source;
  if (isNumberFinite(fill2)) {
    return getLineByIndex(chart, fill2);
  }
  if (fill2 === "stack") {
    return _buildStackLine(source);
  }
  if (fill2 === "shape") {
    return true;
  }
  const boundary = computeBoundary(source);
  if (boundary instanceof simpleArc) {
    return boundary;
  }
  return _createBoundaryLine(boundary, line);
}
function getLineByIndex(chart, index2) {
  const meta = chart.getDatasetMeta(index2);
  const visible = meta && chart.isDatasetVisible(index2);
  return visible ? meta.dataset : null;
}
function computeBoundary(source) {
  const scale = source.scale || {};
  if (scale.getPointPositionForValue) {
    return computeCircularBoundary(source);
  }
  return computeLinearBoundary(source);
}
function computeLinearBoundary(source) {
  const { scale = {}, fill: fill2 } = source;
  const pixel = _getTargetPixel(fill2, scale);
  if (isNumberFinite(pixel)) {
    const horizontal = scale.isHorizontal();
    return {
      x: horizontal ? pixel : null,
      y: horizontal ? null : pixel
    };
  }
  return null;
}
function computeCircularBoundary(source) {
  const { scale, fill: fill2 } = source;
  const options2 = scale.options;
  const length = scale.getLabels().length;
  const start = options2.reverse ? scale.max : scale.min;
  const value = _getTargetValue(fill2, scale, start);
  const target = [];
  if (options2.grid.circular) {
    const center = scale.getPointPositionForValue(0, start);
    return new simpleArc({
      x: center.x,
      y: center.y,
      radius: scale.getDistanceFromCenterForValue(value)
    });
  }
  for (let i = 0; i < length; ++i) {
    target.push(scale.getPointPositionForValue(i, value));
  }
  return target;
}
function _drawfill(ctx, source, area) {
  const target = _getTarget(source);
  const { chart, index: index2, line, scale, axis } = source;
  const lineOpts = line.options;
  const fillOption = lineOpts.fill;
  const color2 = lineOpts.backgroundColor;
  const { above = color2, below = color2 } = fillOption || {};
  const meta = chart.getDatasetMeta(index2);
  const clip = getDatasetClipArea(chart, meta);
  if (target && line.points.length) {
    clipArea(ctx, area);
    doFill(ctx, {
      line,
      target,
      above,
      below,
      area,
      scale,
      axis,
      clip
    });
    unclipArea(ctx);
  }
}
function doFill(ctx, cfg) {
  const { line, target, above, below, area, scale, clip } = cfg;
  const property = line._loop ? "angle" : cfg.axis;
  ctx.save();
  let fillColor = below;
  if (below !== above) {
    if (property === "x") {
      clipVertical(ctx, target, area.top);
      fill(ctx, {
        line,
        target,
        color: above,
        scale,
        property,
        clip
      });
      ctx.restore();
      ctx.save();
      clipVertical(ctx, target, area.bottom);
    } else if (property === "y") {
      clipHorizontal(ctx, target, area.left);
      fill(ctx, {
        line,
        target,
        color: below,
        scale,
        property,
        clip
      });
      ctx.restore();
      ctx.save();
      clipHorizontal(ctx, target, area.right);
      fillColor = above;
    }
  }
  fill(ctx, {
    line,
    target,
    color: fillColor,
    scale,
    property,
    clip
  });
  ctx.restore();
}
function clipVertical(ctx, target, clipY) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(firstPoint.x, clipY);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(lastPoint.x, clipY);
    }
  }
  ctx.lineTo(target.first().x, clipY);
  ctx.closePath();
  ctx.clip();
}
function clipHorizontal(ctx, target, clipX) {
  const { segments, points } = target;
  let first = true;
  let lineLoop = false;
  ctx.beginPath();
  for (const segment of segments) {
    const { start, end } = segment;
    const firstPoint = points[start];
    const lastPoint = points[_findSegmentEnd(start, end, points)];
    if (first) {
      ctx.moveTo(firstPoint.x, firstPoint.y);
      first = false;
    } else {
      ctx.lineTo(clipX, firstPoint.y);
      ctx.lineTo(firstPoint.x, firstPoint.y);
    }
    lineLoop = !!target.pathSegment(ctx, segment, {
      move: lineLoop
    });
    if (lineLoop) {
      ctx.closePath();
    } else {
      ctx.lineTo(clipX, lastPoint.y);
    }
  }
  ctx.lineTo(clipX, target.first().y);
  ctx.closePath();
  ctx.clip();
}
function fill(ctx, cfg) {
  const { line, target, property, color: color2, scale, clip } = cfg;
  const segments = _segments(line, target, property);
  for (const { source: src, target: tgt, start, end } of segments) {
    const { style: { backgroundColor = color2 } = {} } = src;
    const notShape = target !== true;
    ctx.save();
    ctx.fillStyle = backgroundColor;
    clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));
    ctx.beginPath();
    const lineLoop = !!line.pathSegment(ctx, src);
    let loop;
    if (notShape) {
      if (lineLoop) {
        ctx.closePath();
      } else {
        interpolatedLineTo(ctx, target, end, property);
      }
      const targetLoop = !!target.pathSegment(ctx, tgt, {
        move: lineLoop,
        reverse: true
      });
      loop = lineLoop && targetLoop;
      if (!loop) {
        interpolatedLineTo(ctx, target, start, property);
      }
    }
    ctx.closePath();
    ctx.fill(loop ? "evenodd" : "nonzero");
    ctx.restore();
  }
}
function clipBounds(ctx, scale, clip, bounds) {
  const chartArea = scale.chart.chartArea;
  const { property, start, end } = bounds || {};
  if (property === "x" || property === "y") {
    let left, top, right, bottom;
    if (property === "x") {
      left = start;
      top = chartArea.top;
      right = end;
      bottom = chartArea.bottom;
    } else {
      left = chartArea.left;
      top = start;
      right = chartArea.right;
      bottom = end;
    }
    ctx.beginPath();
    if (clip) {
      left = Math.max(left, clip.left);
      right = Math.min(right, clip.right);
      top = Math.max(top, clip.top);
      bottom = Math.min(bottom, clip.bottom);
    }
    ctx.rect(left, top, right - left, bottom - top);
    ctx.clip();
  }
}
function interpolatedLineTo(ctx, target, point, property) {
  const interpolatedPoint = target.interpolate(point, property);
  if (interpolatedPoint) {
    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
  }
}
var index = {
  id: "filler",
  afterDatasetsUpdate(chart, _args, options2) {
    const count = (chart.data.datasets || []).length;
    const sources = [];
    let meta, i, line, source;
    for (i = 0; i < count; ++i) {
      meta = chart.getDatasetMeta(i);
      line = meta.dataset;
      source = null;
      if (line && line.options && line instanceof LineElement) {
        source = {
          visible: chart.isDatasetVisible(i),
          index: i,
          fill: _decodeFill(line, i, count),
          chart,
          axis: meta.controller.options.indexAxis,
          scale: meta.vScale,
          line
        };
      }
      meta.$filler = source;
      sources.push(source);
    }
    for (i = 0; i < count; ++i) {
      source = sources[i];
      if (!source || source.fill === false) {
        continue;
      }
      source.fill = _resolveTarget(sources, i, options2.propagate);
    }
  },
  beforeDraw(chart, _args, options2) {
    const draw2 = options2.drawTime === "beforeDraw";
    const metasets = chart.getSortedVisibleDatasetMetas();
    const area = chart.chartArea;
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (!source) {
        continue;
      }
      source.line.updateControlPoints(area, source.axis);
      if (draw2 && source.fill) {
        _drawfill(chart.ctx, source, area);
      }
    }
  },
  beforeDatasetsDraw(chart, _args, options2) {
    if (options2.drawTime !== "beforeDatasetsDraw") {
      return;
    }
    const metasets = chart.getSortedVisibleDatasetMetas();
    for (let i = metasets.length - 1; i >= 0; --i) {
      const source = metasets[i].$filler;
      if (_shouldApplyFill(source)) {
        _drawfill(chart.ctx, source, chart.chartArea);
      }
    }
  },
  beforeDatasetDraw(chart, args, options2) {
    const source = args.meta.$filler;
    if (!_shouldApplyFill(source) || options2.drawTime !== "beforeDatasetDraw") {
      return;
    }
    _drawfill(chart.ctx, source, chart.chartArea);
  },
  defaults: {
    propagate: true,
    drawTime: "beforeDatasetDraw"
  }
};
var getBoxSize = (labelOpts, fontSize) => {
  let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
  if (labelOpts.usePointStyle) {
    boxHeight = Math.min(boxHeight, fontSize);
    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
  }
  return {
    boxWidth,
    boxHeight,
    itemHeight: Math.max(fontSize, boxHeight)
  };
};
var itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
var Legend = class extends Element {
  constructor(config) {
    super();
    this._added = false;
    this.legendHitBoxes = [];
    this._hoveredItem = null;
    this.doughnutMode = false;
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this.legendItems = void 0;
    this.columnSizes = void 0;
    this.lineWidths = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.height = void 0;
    this.width = void 0;
    this._margins = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight, margins) {
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this._margins = margins;
    this.setDimensions();
    this.buildLabels();
    this.fit();
  }
  setDimensions() {
    if (this.isHorizontal()) {
      this.width = this.maxWidth;
      this.left = this._margins.left;
      this.right = this.width;
    } else {
      this.height = this.maxHeight;
      this.top = this._margins.top;
      this.bottom = this.height;
    }
  }
  buildLabels() {
    const labelOpts = this.options.labels || {};
    let legendItems = callback(labelOpts.generateLabels, [
      this.chart
    ], this) || [];
    if (labelOpts.filter) {
      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));
    }
    if (labelOpts.sort) {
      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));
    }
    if (this.options.reverse) {
      legendItems.reverse();
    }
    this.legendItems = legendItems;
  }
  fit() {
    const { options: options2, ctx } = this;
    if (!options2.display) {
      this.width = this.height = 0;
      return;
    }
    const labelOpts = options2.labels;
    const labelFont = toFont(labelOpts.font);
    const fontSize = labelFont.size;
    const titleHeight = this._computeTitleHeight();
    const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
    let width, height;
    ctx.font = labelFont.string;
    if (this.isHorizontal()) {
      width = this.maxWidth;
      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
    } else {
      height = this.maxHeight;
      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
    }
    this.width = Math.min(width, options2.maxWidth || this.maxWidth);
    this.height = Math.min(height, options2.maxHeight || this.maxHeight);
  }
  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
    const { ctx, maxWidth, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const lineWidths = this.lineWidths = [
      0
    ];
    const lineHeight = itemHeight + padding;
    let totalHeight = titleHeight;
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    let row = -1;
    let top = -lineHeight;
    this.legendItems.forEach((legendItem, i) => {
      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
        totalHeight += lineHeight;
        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
        top += lineHeight;
        row++;
      }
      hitboxes[i] = {
        left: 0,
        top,
        row,
        width: itemWidth,
        height: itemHeight
      };
      lineWidths[lineWidths.length - 1] += itemWidth + padding;
    });
    return totalHeight;
  }
  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
    const { ctx, maxHeight, options: { labels: { padding } } } = this;
    const hitboxes = this.legendHitBoxes = [];
    const columnSizes = this.columnSizes = [];
    const heightLimit = maxHeight - titleHeight;
    let totalWidth = padding;
    let currentColWidth = 0;
    let currentColHeight = 0;
    let left = 0;
    let col = 0;
    this.legendItems.forEach((legendItem, i) => {
      const { itemWidth, itemHeight } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
        totalWidth += currentColWidth + padding;
        columnSizes.push({
          width: currentColWidth,
          height: currentColHeight
        });
        left += currentColWidth + padding;
        col++;
        currentColWidth = currentColHeight = 0;
      }
      hitboxes[i] = {
        left,
        top: currentColHeight,
        col,
        width: itemWidth,
        height: itemHeight
      };
      currentColWidth = Math.max(currentColWidth, itemWidth);
      currentColHeight += itemHeight + padding;
    });
    totalWidth += currentColWidth;
    columnSizes.push({
      width: currentColWidth,
      height: currentColHeight
    });
    return totalWidth;
  }
  adjustHitBoxes() {
    if (!this.options.display) {
      return;
    }
    const titleHeight = this._computeTitleHeight();
    const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;
    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
    if (this.isHorizontal()) {
      let row = 0;
      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
      for (const hitbox of hitboxes) {
        if (row !== hitbox.row) {
          row = hitbox.row;
          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
        }
        hitbox.top += this.top + titleHeight + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
        left += hitbox.width + padding;
      }
    } else {
      let col = 0;
      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
      for (const hitbox of hitboxes) {
        if (hitbox.col !== col) {
          col = hitbox.col;
          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
        }
        hitbox.top = top;
        hitbox.left += this.left + padding;
        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
        top += hitbox.height + padding;
      }
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const ctx = this.ctx;
      clipArea(ctx, this);
      this._draw();
      unclipArea(ctx);
    }
  }
  _draw() {
    const { options: opts, columnSizes, lineWidths, ctx } = this;
    const { align, labels: labelOpts } = opts;
    const defaultColor = defaults.color;
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const labelFont = toFont(labelOpts.font);
    const { padding } = labelOpts;
    const fontSize = labelFont.size;
    const halfFontSize = fontSize / 2;
    let cursor;
    this.drawTitle();
    ctx.textAlign = rtlHelper.textAlign("left");
    ctx.textBaseline = "middle";
    ctx.lineWidth = 0.5;
    ctx.font = labelFont.string;
    const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
    const drawLegendBox = function(x, y, legendItem) {
      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
        return;
      }
      ctx.save();
      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
      ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
      if (labelOpts.usePointStyle) {
        const drawOptions = {
          radius: boxHeight * Math.SQRT2 / 2,
          pointStyle: legendItem.pointStyle,
          rotation: legendItem.rotation,
          borderWidth: lineWidth
        };
        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
        const centerY = y + halfFontSize;
        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
      } else {
        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
        const borderRadius = toTRBLCorners(legendItem.borderRadius);
        ctx.beginPath();
        if (Object.values(borderRadius).some((v) => v !== 0)) {
          addRoundedRectPath(ctx, {
            x: xBoxLeft,
            y: yBoxTop,
            w: boxWidth,
            h: boxHeight,
            radius: borderRadius
          });
        } else {
          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
        }
        ctx.fill();
        if (lineWidth !== 0) {
          ctx.stroke();
        }
      }
      ctx.restore();
    };
    const fillText = function(x, y, legendItem) {
      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
        strikethrough: legendItem.hidden,
        textAlign: rtlHelper.textAlign(legendItem.textAlign)
      });
    };
    const isHorizontal = this.isHorizontal();
    const titleHeight = this._computeTitleHeight();
    if (isHorizontal) {
      cursor = {
        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
        y: this.top + padding + titleHeight,
        line: 0
      };
    } else {
      cursor = {
        x: this.left + padding,
        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
        line: 0
      };
    }
    overrideTextDirection(this.ctx, opts.textDirection);
    const lineHeight = itemHeight + padding;
    this.legendItems.forEach((legendItem, i) => {
      ctx.strokeStyle = legendItem.fontColor;
      ctx.fillStyle = legendItem.fontColor;
      const textWidth = ctx.measureText(legendItem.text).width;
      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
      const width = boxWidth + halfFontSize + textWidth;
      let x = cursor.x;
      let y = cursor.y;
      rtlHelper.setWidth(this.width);
      if (isHorizontal) {
        if (i > 0 && x + width + padding > this.right) {
          y = cursor.y += lineHeight;
          cursor.line++;
          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
        }
      } else if (i > 0 && y + lineHeight > this.bottom) {
        x = cursor.x = x + columnSizes[cursor.line].width + padding;
        cursor.line++;
        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
      }
      const realX = rtlHelper.x(x);
      drawLegendBox(realX, y, legendItem);
      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
      fillText(rtlHelper.x(x), y, legendItem);
      if (isHorizontal) {
        cursor.x += width + padding;
      } else if (typeof legendItem.text !== "string") {
        const fontLineHeight = labelFont.lineHeight;
        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
      } else {
        cursor.y += lineHeight;
      }
    });
    restoreTextDirection(this.ctx, opts.textDirection);
  }
  drawTitle() {
    const opts = this.options;
    const titleOpts = opts.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    if (!titleOpts.display) {
      return;
    }
    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
    const ctx = this.ctx;
    const position = titleOpts.position;
    const halfFontSize = titleFont.size / 2;
    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
    let y;
    let left = this.left;
    let maxWidth = this.width;
    if (this.isHorizontal()) {
      maxWidth = Math.max(...this.lineWidths);
      y = this.top + topPaddingPlusHalfFontSize;
      left = _alignStartEnd(opts.align, left, this.right - maxWidth);
    } else {
      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
    }
    const x = _alignStartEnd(position, left, left + maxWidth);
    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
    ctx.textBaseline = "middle";
    ctx.strokeStyle = titleOpts.color;
    ctx.fillStyle = titleOpts.color;
    ctx.font = titleFont.string;
    renderText(ctx, titleOpts.text, x, y, titleFont);
  }
  _computeTitleHeight() {
    const titleOpts = this.options.title;
    const titleFont = toFont(titleOpts.font);
    const titlePadding = toPadding(titleOpts.padding);
    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
  }
  _getLegendItemAt(x, y) {
    let i, hitBox, lh;
    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
      lh = this.legendHitBoxes;
      for (i = 0; i < lh.length; ++i) {
        hitBox = lh[i];
        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {
          return this.legendItems[i];
        }
      }
    }
    return null;
  }
  handleEvent(e) {
    const opts = this.options;
    if (!isListened(e.type, opts)) {
      return;
    }
    const hoveredItem = this._getLegendItemAt(e.x, e.y);
    if (e.type === "mousemove" || e.type === "mouseout") {
      const previous = this._hoveredItem;
      const sameItem = itemsEqual(previous, hoveredItem);
      if (previous && !sameItem) {
        callback(opts.onLeave, [
          e,
          previous,
          this
        ], this);
      }
      this._hoveredItem = hoveredItem;
      if (hoveredItem && !sameItem) {
        callback(opts.onHover, [
          e,
          hoveredItem,
          this
        ], this);
      }
    } else if (hoveredItem) {
      callback(opts.onClick, [
        e,
        hoveredItem,
        this
      ], this);
    }
  }
};
function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
  return {
    itemWidth,
    itemHeight
  };
}
function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
  let legendItemText = legendItem.text;
  if (legendItemText && typeof legendItemText !== "string") {
    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);
  }
  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
}
function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
  let itemHeight = _itemHeight;
  if (typeof legendItem.text !== "string") {
    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
  }
  return itemHeight;
}
function calculateLegendItemHeight(legendItem, fontLineHeight) {
  const labelHeight = legendItem.text ? legendItem.text.length : 0;
  return fontLineHeight * labelHeight;
}
function isListened(type, opts) {
  if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) {
    return true;
  }
  if (opts.onClick && (type === "click" || type === "mouseup")) {
    return true;
  }
  return false;
}
var plugin_legend = {
  id: "legend",
  _element: Legend,
  start(chart, _args, options2) {
    const legend = chart.legend = new Legend({
      ctx: chart.ctx,
      options: options2,
      chart
    });
    layouts.configure(chart, legend, options2);
    layouts.addBox(chart, legend);
  },
  stop(chart) {
    layouts.removeBox(chart, chart.legend);
    delete chart.legend;
  },
  beforeUpdate(chart, _args, options2) {
    const legend = chart.legend;
    layouts.configure(chart, legend, options2);
    legend.options = options2;
  },
  afterUpdate(chart) {
    const legend = chart.legend;
    legend.buildLabels();
    legend.adjustHitBoxes();
  },
  afterEvent(chart, args) {
    if (!args.replay) {
      chart.legend.handleEvent(args.event);
    }
  },
  defaults: {
    display: true,
    position: "top",
    align: "center",
    fullSize: true,
    reverse: false,
    weight: 1e3,
    onClick(e, legendItem, legend) {
      const index2 = legendItem.datasetIndex;
      const ci = legend.chart;
      if (ci.isDatasetVisible(index2)) {
        ci.hide(index2);
        legendItem.hidden = true;
      } else {
        ci.show(index2);
        legendItem.hidden = false;
      }
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (ctx) => ctx.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(chart) {
        const datasets = chart.data.datasets;
        const { labels: { usePointStyle, pointStyle, textAlign, color: color2, useBorderRadius, borderRadius } } = chart.legend.options;
        return chart._getSortedDatasetMetas().map((meta) => {
          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
          const borderWidth = toPadding(style.borderWidth);
          return {
            text: datasets[meta.index].label,
            fillStyle: style.backgroundColor,
            fontColor: color2,
            hidden: !meta.visible,
            lineCap: style.borderCapStyle,
            lineDash: style.borderDash,
            lineDashOffset: style.borderDashOffset,
            lineJoin: style.borderJoinStyle,
            lineWidth: (borderWidth.width + borderWidth.height) / 4,
            strokeStyle: style.borderColor,
            pointStyle: pointStyle || style.pointStyle,
            rotation: style.rotation,
            textAlign: textAlign || style.textAlign,
            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
            datasetIndex: meta.index
          };
        }, this);
      }
    },
    title: {
      color: (ctx) => ctx.chart.options.color,
      display: false,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (name) => !name.startsWith("on"),
    labels: {
      _scriptable: (name) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(name)
    }
  }
};
var Title = class extends Element {
  constructor(config) {
    super();
    this.chart = config.chart;
    this.options = config.options;
    this.ctx = config.ctx;
    this._padding = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.left = void 0;
    this.right = void 0;
    this.width = void 0;
    this.height = void 0;
    this.position = void 0;
    this.weight = void 0;
    this.fullSize = void 0;
  }
  update(maxWidth, maxHeight) {
    const opts = this.options;
    this.left = 0;
    this.top = 0;
    if (!opts.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = maxWidth;
    this.height = this.bottom = maxHeight;
    const lineCount = isArray(opts.text) ? opts.text.length : 1;
    this._padding = toPadding(opts.padding);
    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
    if (this.isHorizontal()) {
      this.height = textSize;
    } else {
      this.width = textSize;
    }
  }
  isHorizontal() {
    const pos = this.options.position;
    return pos === "top" || pos === "bottom";
  }
  _drawArgs(offset) {
    const { top, left, bottom, right, options: options2 } = this;
    const align = options2.align;
    let rotation = 0;
    let maxWidth, titleX, titleY;
    if (this.isHorizontal()) {
      titleX = _alignStartEnd(align, left, right);
      titleY = top + offset;
      maxWidth = right - left;
    } else {
      if (options2.position === "left") {
        titleX = left + offset;
        titleY = _alignStartEnd(align, bottom, top);
        rotation = PI * -0.5;
      } else {
        titleX = right - offset;
        titleY = _alignStartEnd(align, top, bottom);
        rotation = PI * 0.5;
      }
      maxWidth = bottom - top;
    }
    return {
      titleX,
      titleY,
      maxWidth,
      rotation
    };
  }
  draw() {
    const ctx = this.ctx;
    const opts = this.options;
    if (!opts.display) {
      return;
    }
    const fontOpts = toFont(opts.font);
    const lineHeight = fontOpts.lineHeight;
    const offset = lineHeight / 2 + this._padding.top;
    const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);
    renderText(ctx, opts.text, 0, 0, fontOpts, {
      color: opts.color,
      maxWidth,
      rotation,
      textAlign: _toLeftRightCenter(opts.align),
      textBaseline: "middle",
      translation: [
        titleX,
        titleY
      ]
    });
  }
};
function createTitle(chart, titleOpts) {
  const title = new Title({
    ctx: chart.ctx,
    options: titleOpts,
    chart
  });
  layouts.configure(chart, title, titleOpts);
  layouts.addBox(chart, title);
  chart.titleBlock = title;
}
var plugin_title = {
  id: "title",
  _element: Title,
  start(chart, _args, options2) {
    createTitle(chart, options2);
  },
  stop(chart) {
    const titleBlock = chart.titleBlock;
    layouts.removeBox(chart, titleBlock);
    delete chart.titleBlock;
  },
  beforeUpdate(chart, _args, options2) {
    const title = chart.titleBlock;
    layouts.configure(chart, title, options2);
    title.options = options2;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "bold"
    },
    fullSize: true,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var map2 = /* @__PURE__ */ new WeakMap();
var plugin_subtitle = {
  id: "subtitle",
  start(chart, _args, options2) {
    const title = new Title({
      ctx: chart.ctx,
      options: options2,
      chart
    });
    layouts.configure(chart, title, options2);
    layouts.addBox(chart, title);
    map2.set(chart, title);
  },
  stop(chart) {
    layouts.removeBox(chart, map2.get(chart));
    map2.delete(chart);
  },
  beforeUpdate(chart, _args, options2) {
    const title = map2.get(chart);
    layouts.configure(chart, title, options2);
    title.options = options2;
  },
  defaults: {
    align: "center",
    display: false,
    font: {
      weight: "normal"
    },
    fullSize: true,
    padding: 0,
    position: "top",
    text: "",
    weight: 1500
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: true,
    _indexable: false
  }
};
var positioners = {
  average(items) {
    if (!items.length) {
      return false;
    }
    let i, len;
    let xSet = /* @__PURE__ */ new Set();
    let y = 0;
    let count = 0;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const pos = el.tooltipPosition();
        xSet.add(pos.x);
        y += pos.y;
        ++count;
      }
    }
    if (count === 0 || xSet.size === 0) {
      return false;
    }
    const xAverage = [
      ...xSet
    ].reduce((a, b) => a + b) / xSet.size;
    return {
      x: xAverage,
      y: y / count
    };
  },
  nearest(items, eventPosition) {
    if (!items.length) {
      return false;
    }
    let x = eventPosition.x;
    let y = eventPosition.y;
    let minDistance = Number.POSITIVE_INFINITY;
    let i, len, nearestElement;
    for (i = 0, len = items.length; i < len; ++i) {
      const el = items[i].element;
      if (el && el.hasValue()) {
        const center = el.getCenterPoint();
        const d = distanceBetweenPoints(eventPosition, center);
        if (d < minDistance) {
          minDistance = d;
          nearestElement = el;
        }
      }
    }
    if (nearestElement) {
      const tp = nearestElement.tooltipPosition();
      x = tp.x;
      y = tp.y;
    }
    return {
      x,
      y
    };
  }
};
function pushOrConcat(base, toPush) {
  if (toPush) {
    if (isArray(toPush)) {
      Array.prototype.push.apply(base, toPush);
    } else {
      base.push(toPush);
    }
  }
  return base;
}
function splitNewlines(str) {
  if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
    return str.split("\n");
  }
  return str;
}
function createTooltipItem(chart, item) {
  const { element, datasetIndex, index: index2 } = item;
  const controller = chart.getDatasetMeta(datasetIndex).controller;
  const { label, value } = controller.getLabelAndValue(index2);
  return {
    chart,
    label,
    parsed: controller.getParsed(index2),
    raw: chart.data.datasets[datasetIndex].data[index2],
    formattedValue: value,
    dataset: controller.getDataset(),
    dataIndex: index2,
    datasetIndex,
    element
  };
}
function getTooltipSize(tooltip, options2) {
  const ctx = tooltip.chart.ctx;
  const { body, footer, title } = tooltip;
  const { boxWidth, boxHeight } = options2;
  const bodyFont = toFont(options2.bodyFont);
  const titleFont = toFont(options2.titleFont);
  const footerFont = toFont(options2.footerFont);
  const titleLineCount = title.length;
  const footerLineCount = footer.length;
  const bodyLineItemCount = body.length;
  const padding = toPadding(options2.padding);
  let height = padding.height;
  let width = 0;
  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
  if (titleLineCount) {
    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options2.titleSpacing + options2.titleMarginBottom;
  }
  if (combinedBodyLength) {
    const bodyLineHeight = options2.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options2.bodySpacing;
  }
  if (footerLineCount) {
    height += options2.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options2.footerSpacing;
  }
  let widthPadding = 0;
  const maxLineWidth = function(line) {
    width = Math.max(width, ctx.measureText(line).width + widthPadding);
  };
  ctx.save();
  ctx.font = titleFont.string;
  each(tooltip.title, maxLineWidth);
  ctx.font = bodyFont.string;
  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
  widthPadding = options2.displayColors ? boxWidth + 2 + options2.boxPadding : 0;
  each(body, (bodyItem) => {
    each(bodyItem.before, maxLineWidth);
    each(bodyItem.lines, maxLineWidth);
    each(bodyItem.after, maxLineWidth);
  });
  widthPadding = 0;
  ctx.font = footerFont.string;
  each(tooltip.footer, maxLineWidth);
  ctx.restore();
  width += padding.width;
  return {
    width,
    height
  };
}
function determineYAlign(chart, size) {
  const { y, height } = size;
  if (y < height / 2) {
    return "top";
  } else if (y > chart.height - height / 2) {
    return "bottom";
  }
  return "center";
}
function doesNotFitWithAlign(xAlign, chart, options2, size) {
  const { x, width } = size;
  const caret2 = options2.caretSize + options2.caretPadding;
  if (xAlign === "left" && x + width + caret2 > chart.width) {
    return true;
  }
  if (xAlign === "right" && x - width - caret2 < 0) {
    return true;
  }
}
function determineXAlign(chart, options2, size, yAlign) {
  const { x, width } = size;
  const { width: chartWidth, chartArea: { left, right } } = chart;
  let xAlign = "center";
  if (yAlign === "center") {
    xAlign = x <= (left + right) / 2 ? "left" : "right";
  } else if (x <= width / 2) {
    xAlign = "left";
  } else if (x >= chartWidth - width / 2) {
    xAlign = "right";
  }
  if (doesNotFitWithAlign(xAlign, chart, options2, size)) {
    xAlign = "center";
  }
  return xAlign;
}
function determineAlignment(chart, options2, size) {
  const yAlign = size.yAlign || options2.yAlign || determineYAlign(chart, size);
  return {
    xAlign: size.xAlign || options2.xAlign || determineXAlign(chart, options2, size, yAlign),
    yAlign
  };
}
function alignX(size, xAlign) {
  let { x, width } = size;
  if (xAlign === "right") {
    x -= width;
  } else if (xAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function alignY(size, yAlign, paddingAndSize) {
  let { y, height } = size;
  if (yAlign === "top") {
    y += paddingAndSize;
  } else if (yAlign === "bottom") {
    y -= height + paddingAndSize;
  } else {
    y -= height / 2;
  }
  return y;
}
function getBackgroundPoint(options2, size, alignment, chart) {
  const { caretSize, caretPadding, cornerRadius } = options2;
  const { xAlign, yAlign } = alignment;
  const paddingAndSize = caretSize + caretPadding;
  const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
  let x = alignX(size, xAlign);
  const y = alignY(size, yAlign, paddingAndSize);
  if (yAlign === "center") {
    if (xAlign === "left") {
      x += paddingAndSize;
    } else if (xAlign === "right") {
      x -= paddingAndSize;
    }
  } else if (xAlign === "left") {
    x -= Math.max(topLeft, bottomLeft) + caretSize;
  } else if (xAlign === "right") {
    x += Math.max(topRight, bottomRight) + caretSize;
  }
  return {
    x: _limitValue(x, 0, chart.width - size.width),
    y: _limitValue(y, 0, chart.height - size.height)
  };
}
function getAlignedX(tooltip, align, options2) {
  const padding = toPadding(options2.padding);
  return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
}
function getBeforeAfterBodyLines(callback2) {
  return pushOrConcat([], splitNewlines(callback2));
}
function createTooltipContext(parent, tooltip, tooltipItems) {
  return createContext(parent, {
    tooltip,
    tooltipItems,
    type: "tooltip"
  });
}
function overrideCallbacks(callbacks, context) {
  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
  return override ? callbacks.override(override) : callbacks;
}
var defaultCallbacks = {
  beforeTitle: noop,
  title(tooltipItems) {
    if (tooltipItems.length > 0) {
      const item = tooltipItems[0];
      const labels = item.chart.data.labels;
      const labelCount = labels ? labels.length : 0;
      if (this && this.options && this.options.mode === "dataset") {
        return item.dataset.label || "";
      } else if (item.label) {
        return item.label;
      } else if (labelCount > 0 && item.dataIndex < labelCount) {
        return labels[item.dataIndex];
      }
    }
    return "";
  },
  afterTitle: noop,
  beforeBody: noop,
  beforeLabel: noop,
  label(tooltipItem) {
    if (this && this.options && this.options.mode === "dataset") {
      return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
    }
    let label = tooltipItem.dataset.label || "";
    if (label) {
      label += ": ";
    }
    const value = tooltipItem.formattedValue;
    if (!isNullOrUndef(value)) {
      label += value;
    }
    return label;
  },
  labelColor(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options2 = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      borderColor: options2.borderColor,
      backgroundColor: options2.backgroundColor,
      borderWidth: options2.borderWidth,
      borderDash: options2.borderDash,
      borderDashOffset: options2.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(tooltipItem) {
    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
    const options2 = meta.controller.getStyle(tooltipItem.dataIndex);
    return {
      pointStyle: options2.pointStyle,
      rotation: options2.rotation
    };
  },
  afterLabel: noop,
  afterBody: noop,
  beforeFooter: noop,
  footer: noop,
  afterFooter: noop
};
function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
  const result = callbacks[name].call(ctx, arg);
  if (typeof result === "undefined") {
    return defaultCallbacks[name].call(ctx, arg);
  }
  return result;
}
var Tooltip = class extends Element {
  constructor(config) {
    super();
    this.opacity = 0;
    this._active = [];
    this._eventPosition = void 0;
    this._size = void 0;
    this._cachedAnimations = void 0;
    this._tooltipItems = [];
    this.$animations = void 0;
    this.$context = void 0;
    this.chart = config.chart;
    this.options = config.options;
    this.dataPoints = void 0;
    this.title = void 0;
    this.beforeBody = void 0;
    this.body = void 0;
    this.afterBody = void 0;
    this.footer = void 0;
    this.xAlign = void 0;
    this.yAlign = void 0;
    this.x = void 0;
    this.y = void 0;
    this.height = void 0;
    this.width = void 0;
    this.caretX = void 0;
    this.caretY = void 0;
    this.labelColors = void 0;
    this.labelPointStyles = void 0;
    this.labelTextColors = void 0;
  }
  initialize(options2) {
    this.options = options2;
    this._cachedAnimations = void 0;
    this.$context = void 0;
  }
  _resolveAnimations() {
    const cached = this._cachedAnimations;
    if (cached) {
      return cached;
    }
    const chart = this.chart;
    const options2 = this.options.setContext(this.getContext());
    const opts = options2.enabled && chart.options.animation && options2.animations;
    const animations = new Animations(this.chart, opts);
    if (opts._cacheable) {
      this._cachedAnimations = Object.freeze(animations);
    }
    return animations;
  }
  getContext() {
    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(context, options2) {
    const { callbacks } = options2;
    const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
    const title = invokeCallbackWithFallback(callbacks, "title", this, context);
    const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
    lines = pushOrConcat(lines, splitNewlines(title));
    lines = pushOrConcat(lines, splitNewlines(afterTitle));
    return lines;
  }
  getBeforeBody(tooltipItems, options2) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options2.callbacks, "beforeBody", this, tooltipItems));
  }
  getBody(tooltipItems, options2) {
    const { callbacks } = options2;
    const bodyItems = [];
    each(tooltipItems, (context) => {
      const bodyItem = {
        before: [],
        lines: [],
        after: []
      };
      const scoped = overrideCallbacks(callbacks, context);
      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
      bodyItems.push(bodyItem);
    });
    return bodyItems;
  }
  getAfterBody(tooltipItems, options2) {
    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options2.callbacks, "afterBody", this, tooltipItems));
  }
  getFooter(tooltipItems, options2) {
    const { callbacks } = options2;
    const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
    const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
    const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
    let lines = [];
    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
    lines = pushOrConcat(lines, splitNewlines(footer));
    lines = pushOrConcat(lines, splitNewlines(afterFooter));
    return lines;
  }
  _createItems(options2) {
    const active = this._active;
    const data = this.chart.data;
    const labelColors = [];
    const labelPointStyles = [];
    const labelTextColors = [];
    let tooltipItems = [];
    let i, len;
    for (i = 0, len = active.length; i < len; ++i) {
      tooltipItems.push(createTooltipItem(this.chart, active[i]));
    }
    if (options2.filter) {
      tooltipItems = tooltipItems.filter((element, index2, array) => options2.filter(element, index2, array, data));
    }
    if (options2.itemSort) {
      tooltipItems = tooltipItems.sort((a, b) => options2.itemSort(a, b, data));
    }
    each(tooltipItems, (context) => {
      const scoped = overrideCallbacks(options2.callbacks, context);
      labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
      labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
      labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
    });
    this.labelColors = labelColors;
    this.labelPointStyles = labelPointStyles;
    this.labelTextColors = labelTextColors;
    this.dataPoints = tooltipItems;
    return tooltipItems;
  }
  update(changed, replay) {
    const options2 = this.options.setContext(this.getContext());
    const active = this._active;
    let properties;
    let tooltipItems = [];
    if (!active.length) {
      if (this.opacity !== 0) {
        properties = {
          opacity: 0
        };
      }
    } else {
      const position = positioners[options2.position].call(this, active, this._eventPosition);
      tooltipItems = this._createItems(options2);
      this.title = this.getTitle(tooltipItems, options2);
      this.beforeBody = this.getBeforeBody(tooltipItems, options2);
      this.body = this.getBody(tooltipItems, options2);
      this.afterBody = this.getAfterBody(tooltipItems, options2);
      this.footer = this.getFooter(tooltipItems, options2);
      const size = this._size = getTooltipSize(this, options2);
      const positionAndSize = Object.assign({}, position, size);
      const alignment = determineAlignment(this.chart, options2, positionAndSize);
      const backgroundPoint = getBackgroundPoint(options2, positionAndSize, alignment, this.chart);
      this.xAlign = alignment.xAlign;
      this.yAlign = alignment.yAlign;
      properties = {
        opacity: 1,
        x: backgroundPoint.x,
        y: backgroundPoint.y,
        width: size.width,
        height: size.height,
        caretX: position.x,
        caretY: position.y
      };
    }
    this._tooltipItems = tooltipItems;
    this.$context = void 0;
    if (properties) {
      this._resolveAnimations().update(this, properties);
    }
    if (changed && options2.external) {
      options2.external.call(this, {
        chart: this.chart,
        tooltip: this,
        replay
      });
    }
  }
  drawCaret(tooltipPoint, ctx, size, options2) {
    const caretPosition = this.getCaretPosition(tooltipPoint, size, options2);
    ctx.lineTo(caretPosition.x1, caretPosition.y1);
    ctx.lineTo(caretPosition.x2, caretPosition.y2);
    ctx.lineTo(caretPosition.x3, caretPosition.y3);
  }
  getCaretPosition(tooltipPoint, size, options2) {
    const { xAlign, yAlign } = this;
    const { caretSize, cornerRadius } = options2;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(cornerRadius);
    const { x: ptX, y: ptY } = tooltipPoint;
    const { width, height } = size;
    let x1, x2, x3, y1, y2, y3;
    if (yAlign === "center") {
      y2 = ptY + height / 2;
      if (xAlign === "left") {
        x1 = ptX;
        x2 = x1 - caretSize;
        y1 = y2 + caretSize;
        y3 = y2 - caretSize;
      } else {
        x1 = ptX + width;
        x2 = x1 + caretSize;
        y1 = y2 - caretSize;
        y3 = y2 + caretSize;
      }
      x3 = x1;
    } else {
      if (xAlign === "left") {
        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
      } else if (xAlign === "right") {
        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
      } else {
        x2 = this.caretX;
      }
      if (yAlign === "top") {
        y1 = ptY;
        y2 = y1 - caretSize;
        x1 = x2 - caretSize;
        x3 = x2 + caretSize;
      } else {
        y1 = ptY + height;
        y2 = y1 + caretSize;
        x1 = x2 + caretSize;
        x3 = x2 - caretSize;
      }
      y3 = y1;
    }
    return {
      x1,
      x2,
      x3,
      y1,
      y2,
      y3
    };
  }
  drawTitle(pt, ctx, options2) {
    const title = this.title;
    const length = title.length;
    let titleFont, titleSpacing, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options2.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options2.titleAlign, options2);
      ctx.textAlign = rtlHelper.textAlign(options2.titleAlign);
      ctx.textBaseline = "middle";
      titleFont = toFont(options2.titleFont);
      titleSpacing = options2.titleSpacing;
      ctx.fillStyle = options2.titleColor;
      ctx.font = titleFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
        pt.y += titleFont.lineHeight + titleSpacing;
        if (i + 1 === length) {
          pt.y += options2.titleMarginBottom - titleSpacing;
        }
      }
    }
  }
  _drawColorBox(ctx, pt, i, rtlHelper, options2) {
    const labelColor = this.labelColors[i];
    const labelPointStyle = this.labelPointStyles[i];
    const { boxHeight, boxWidth } = options2;
    const bodyFont = toFont(options2.bodyFont);
    const colorX = getAlignedX(this, "left", options2);
    const rtlColorX = rtlHelper.x(colorX);
    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
    const colorY = pt.y + yOffSet;
    if (options2.usePointStyle) {
      const drawOptions = {
        radius: Math.min(boxWidth, boxHeight) / 2,
        pointStyle: labelPointStyle.pointStyle,
        rotation: labelPointStyle.rotation,
        borderWidth: 1
      };
      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
      const centerY = colorY + boxHeight / 2;
      ctx.strokeStyle = options2.multiKeyBackground;
      ctx.fillStyle = options2.multiKeyBackground;
      drawPoint(ctx, drawOptions, centerX, centerY);
      ctx.strokeStyle = labelColor.borderColor;
      ctx.fillStyle = labelColor.backgroundColor;
      drawPoint(ctx, drawOptions, centerX, centerY);
    } else {
      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
      ctx.strokeStyle = labelColor.borderColor;
      ctx.setLineDash(labelColor.borderDash || []);
      ctx.lineDashOffset = labelColor.borderDashOffset || 0;
      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
      const borderRadius = toTRBLCorners(labelColor.borderRadius);
      if (Object.values(borderRadius).some((v) => v !== 0)) {
        ctx.beginPath();
        ctx.fillStyle = options2.multiKeyBackground;
        addRoundedRectPath(ctx, {
          x: outerX,
          y: colorY,
          w: boxWidth,
          h: boxHeight,
          radius: borderRadius
        });
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.beginPath();
        addRoundedRectPath(ctx, {
          x: innerX,
          y: colorY + 1,
          w: boxWidth - 2,
          h: boxHeight - 2,
          radius: borderRadius
        });
        ctx.fill();
      } else {
        ctx.fillStyle = options2.multiKeyBackground;
        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
        ctx.fillStyle = labelColor.backgroundColor;
        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
      }
    }
    ctx.fillStyle = this.labelTextColors[i];
  }
  drawBody(pt, ctx, options2) {
    const { body } = this;
    const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options2;
    const bodyFont = toFont(options2.bodyFont);
    let bodyLineHeight = bodyFont.lineHeight;
    let xLinePadding = 0;
    const rtlHelper = getRtlAdapter(options2.rtl, this.x, this.width);
    const fillLineOfText = function(line) {
      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
      pt.y += bodyLineHeight + bodySpacing;
    };
    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
    let bodyItem, textColor, lines, i, j, ilen, jlen;
    ctx.textAlign = bodyAlign;
    ctx.textBaseline = "middle";
    ctx.font = bodyFont.string;
    pt.x = getAlignedX(this, bodyAlignForCalculation, options2);
    ctx.fillStyle = options2.bodyColor;
    each(this.beforeBody, fillLineOfText);
    xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
    for (i = 0, ilen = body.length; i < ilen; ++i) {
      bodyItem = body[i];
      textColor = this.labelTextColors[i];
      ctx.fillStyle = textColor;
      each(bodyItem.before, fillLineOfText);
      lines = bodyItem.lines;
      if (displayColors && lines.length) {
        this._drawColorBox(ctx, pt, i, rtlHelper, options2);
        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
      }
      for (j = 0, jlen = lines.length; j < jlen; ++j) {
        fillLineOfText(lines[j]);
        bodyLineHeight = bodyFont.lineHeight;
      }
      each(bodyItem.after, fillLineOfText);
    }
    xLinePadding = 0;
    bodyLineHeight = bodyFont.lineHeight;
    each(this.afterBody, fillLineOfText);
    pt.y -= bodySpacing;
  }
  drawFooter(pt, ctx, options2) {
    const footer = this.footer;
    const length = footer.length;
    let footerFont, i;
    if (length) {
      const rtlHelper = getRtlAdapter(options2.rtl, this.x, this.width);
      pt.x = getAlignedX(this, options2.footerAlign, options2);
      pt.y += options2.footerMarginTop;
      ctx.textAlign = rtlHelper.textAlign(options2.footerAlign);
      ctx.textBaseline = "middle";
      footerFont = toFont(options2.footerFont);
      ctx.fillStyle = options2.footerColor;
      ctx.font = footerFont.string;
      for (i = 0; i < length; ++i) {
        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
        pt.y += footerFont.lineHeight + options2.footerSpacing;
      }
    }
  }
  drawBackground(pt, ctx, tooltipSize, options2) {
    const { xAlign, yAlign } = this;
    const { x, y } = pt;
    const { width, height } = tooltipSize;
    const { topLeft, topRight, bottomLeft, bottomRight } = toTRBLCorners(options2.cornerRadius);
    ctx.fillStyle = options2.backgroundColor;
    ctx.strokeStyle = options2.borderColor;
    ctx.lineWidth = options2.borderWidth;
    ctx.beginPath();
    ctx.moveTo(x + topLeft, y);
    if (yAlign === "top") {
      this.drawCaret(pt, ctx, tooltipSize, options2);
    }
    ctx.lineTo(x + width - topRight, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
    if (yAlign === "center" && xAlign === "right") {
      this.drawCaret(pt, ctx, tooltipSize, options2);
    }
    ctx.lineTo(x + width, y + height - bottomRight);
    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
    if (yAlign === "bottom") {
      this.drawCaret(pt, ctx, tooltipSize, options2);
    }
    ctx.lineTo(x + bottomLeft, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
    if (yAlign === "center" && xAlign === "left") {
      this.drawCaret(pt, ctx, tooltipSize, options2);
    }
    ctx.lineTo(x, y + topLeft);
    ctx.quadraticCurveTo(x, y, x + topLeft, y);
    ctx.closePath();
    ctx.fill();
    if (options2.borderWidth > 0) {
      ctx.stroke();
    }
  }
  _updateAnimationTarget(options2) {
    const chart = this.chart;
    const anims = this.$animations;
    const animX = anims && anims.x;
    const animY = anims && anims.y;
    if (animX || animY) {
      const position = positioners[options2.position].call(this, this._active, this._eventPosition);
      if (!position) {
        return;
      }
      const size = this._size = getTooltipSize(this, options2);
      const positionAndSize = Object.assign({}, position, this._size);
      const alignment = determineAlignment(chart, options2, positionAndSize);
      const point = getBackgroundPoint(options2, positionAndSize, alignment, chart);
      if (animX._to !== point.x || animY._to !== point.y) {
        this.xAlign = alignment.xAlign;
        this.yAlign = alignment.yAlign;
        this.width = size.width;
        this.height = size.height;
        this.caretX = position.x;
        this.caretY = position.y;
        this._resolveAnimations().update(this, point);
      }
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(ctx) {
    const options2 = this.options.setContext(this.getContext());
    let opacity = this.opacity;
    if (!opacity) {
      return;
    }
    this._updateAnimationTarget(options2);
    const tooltipSize = {
      width: this.width,
      height: this.height
    };
    const pt = {
      x: this.x,
      y: this.y
    };
    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
    const padding = toPadding(options2.padding);
    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    if (options2.enabled && hasTooltipContent) {
      ctx.save();
      ctx.globalAlpha = opacity;
      this.drawBackground(pt, ctx, tooltipSize, options2);
      overrideTextDirection(ctx, options2.textDirection);
      pt.y += padding.top;
      this.drawTitle(pt, ctx, options2);
      this.drawBody(pt, ctx, options2);
      this.drawFooter(pt, ctx, options2);
      restoreTextDirection(ctx, options2.textDirection);
      ctx.restore();
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(activeElements, eventPosition) {
    const lastActive = this._active;
    const active = activeElements.map(({ datasetIndex, index: index2 }) => {
      const meta = this.chart.getDatasetMeta(datasetIndex);
      if (!meta) {
        throw new Error("Cannot find a dataset at index " + datasetIndex);
      }
      return {
        datasetIndex,
        element: meta.data[index2],
        index: index2
      };
    });
    const changed = !_elementsEqual(lastActive, active);
    const positionChanged = this._positionChanged(active, eventPosition);
    if (changed || positionChanged) {
      this._active = active;
      this._eventPosition = eventPosition;
      this._ignoreReplayEvents = true;
      this.update(true);
    }
  }
  handleEvent(e, replay, inChartArea = true) {
    if (replay && this._ignoreReplayEvents) {
      return false;
    }
    this._ignoreReplayEvents = false;
    const options2 = this.options;
    const lastActive = this._active || [];
    const active = this._getActiveElements(e, lastActive, replay, inChartArea);
    const positionChanged = this._positionChanged(active, e);
    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
    if (changed) {
      this._active = active;
      if (options2.enabled || options2.external) {
        this._eventPosition = {
          x: e.x,
          y: e.y
        };
        this.update(true, replay);
      }
    }
    return changed;
  }
  _getActiveElements(e, lastActive, replay, inChartArea) {
    const options2 = this.options;
    if (e.type === "mouseout") {
      return [];
    }
    if (!inChartArea) {
      return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);
    }
    const active = this.chart.getElementsAtEventForMode(e, options2.mode, options2, replay);
    if (options2.reverse) {
      active.reverse();
    }
    return active;
  }
  _positionChanged(active, e) {
    const { caretX, caretY, options: options2 } = this;
    const position = positioners[options2.position].call(this, active, e);
    return position !== false && (caretX !== position.x || caretY !== position.y);
  }
};
__publicField(Tooltip, "positioners", positioners);
var plugin_tooltip = {
  id: "tooltip",
  _element: Tooltip,
  positioners,
  afterInit(chart, _args, options2) {
    if (options2) {
      chart.tooltip = new Tooltip({
        chart,
        options: options2
      });
    }
  },
  beforeUpdate(chart, _args, options2) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options2);
    }
  },
  reset(chart, _args, options2) {
    if (chart.tooltip) {
      chart.tooltip.initialize(options2);
    }
  },
  afterDraw(chart) {
    const tooltip = chart.tooltip;
    if (tooltip && tooltip._willRender()) {
      const args = {
        tooltip
      };
      if (chart.notifyPlugins("beforeTooltipDraw", {
        ...args,
        cancelable: true
      }) === false) {
        return;
      }
      tooltip.draw(chart.ctx);
      chart.notifyPlugins("afterTooltipDraw", args);
    }
  },
  afterEvent(chart, args) {
    if (chart.tooltip) {
      const useFinalPosition = args.replay;
      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {
        args.changed = true;
      }
    }
  },
  defaults: {
    enabled: true,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (ctx, opts) => opts.bodyFont.size,
    boxWidth: (ctx, opts) => opts.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: true,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: defaultCallbacks
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (name) => name !== "filter" && name !== "itemSort" && name !== "external",
    _indexable: false,
    callbacks: {
      _scriptable: false,
      _indexable: false
    },
    animation: {
      _fallback: false
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
var plugins = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Colors: plugin_colors,
  Decimation: plugin_decimation,
  Filler: index,
  Legend: plugin_legend,
  SubTitle: plugin_subtitle,
  Title: plugin_title,
  Tooltip: plugin_tooltip
});
var addIfString = (labels, raw, index2, addedLabels) => {
  if (typeof raw === "string") {
    index2 = labels.push(raw) - 1;
    addedLabels.unshift({
      index: index2,
      label: raw
    });
  } else if (isNaN(raw)) {
    index2 = null;
  }
  return index2;
};
function findOrAddLabel(labels, raw, index2, addedLabels) {
  const first = labels.indexOf(raw);
  if (first === -1) {
    return addIfString(labels, raw, index2, addedLabels);
  }
  const last = labels.lastIndexOf(raw);
  return first !== last ? index2 : first;
}
var validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
function _getLabelForValue(value) {
  const labels = this.getLabels();
  if (value >= 0 && value < labels.length) {
    return labels[value];
  }
  return value;
}
var CategoryScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this._startValue = void 0;
    this._valueRange = 0;
    this._addedLabels = [];
  }
  init(scaleOptions) {
    const added = this._addedLabels;
    if (added.length) {
      const labels = this.getLabels();
      for (const { index: index2, label } of added) {
        if (labels[index2] === label) {
          labels.splice(index2, 1);
        }
      }
      this._addedLabels = [];
    }
    super.init(scaleOptions);
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    const labels = this.getLabels();
    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);
    return validIndex(index2, labels.length - 1);
  }
  determineDataLimits() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this.getMinMax(true);
    if (this.options.bounds === "ticks") {
      if (!minDefined) {
        min = 0;
      }
      if (!maxDefined) {
        max = this.getLabels().length - 1;
      }
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const min = this.min;
    const max = this.max;
    const offset = this.options.offset;
    const ticks = [];
    let labels = this.getLabels();
    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
    this._startValue = this.min - (offset ? 0.5 : 0);
    for (let value = min; value <= max; value++) {
      ticks.push({
        value
      });
    }
    return ticks;
  }
  getLabelForValue(value) {
    return _getLabelForValue.call(this, value);
  }
  configure() {
    super.configure();
    if (!this.isHorizontal()) {
      this._reversePixels = !this._reversePixels;
    }
  }
  getPixelForValue(value) {
    if (typeof value !== "number") {
      value = this.parse(value);
    }
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getPixelForTick(index2) {
    const ticks = this.ticks;
    if (index2 < 0 || index2 > ticks.length - 1) {
      return null;
    }
    return this.getPixelForValue(ticks[index2].value);
  }
  getValueForPixel(pixel) {
    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
};
__publicField(CategoryScale, "id", "category");
__publicField(CategoryScale, "defaults", {
  ticks: {
    callback: _getLabelForValue
  }
});
function generateTicks$1(generationOptions, dataRange) {
  const ticks = [];
  const MIN_SPACING = 1e-14;
  const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
  const unit = step || 1;
  const maxSpaces = maxTicks - 1;
  const { min: rmin, max: rmax } = dataRange;
  const minDefined = !isNullOrUndef(min);
  const maxDefined = !isNullOrUndef(max);
  const countDefined = !isNullOrUndef(count);
  const minSpacing = (rmax - rmin) / (maxDigits + 1);
  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
  let factor, niceMin, niceMax, numSpaces;
  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
    return [
      {
        value: rmin
      },
      {
        value: rmax
      }
    ];
  }
  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
  if (numSpaces > maxSpaces) {
    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
  }
  if (!isNullOrUndef(precision)) {
    factor = Math.pow(10, precision);
    spacing = Math.ceil(spacing * factor) / factor;
  }
  if (bounds === "ticks") {
    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing;
  } else {
    niceMin = rmin;
    niceMax = rmax;
  }
  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
    spacing = (max - min) / numSpaces;
    niceMin = min;
    niceMax = max;
  } else if (countDefined) {
    niceMin = minDefined ? min : niceMin;
    niceMax = maxDefined ? max : niceMax;
    numSpaces = count - 1;
    spacing = (niceMax - niceMin) / numSpaces;
  } else {
    numSpaces = (niceMax - niceMin) / spacing;
    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }
  }
  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
  niceMin = Math.round(niceMin * factor) / factor;
  niceMax = Math.round(niceMax * factor) / factor;
  let j = 0;
  if (minDefined) {
    if (includeBounds && niceMin !== min) {
      ticks.push({
        value: min
      });
      if (niceMin < min) {
        j++;
      }
      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
        j++;
      }
    } else if (niceMin < min) {
      j++;
    }
  }
  for (; j < numSpaces; ++j) {
    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
    if (maxDefined && tickValue > max) {
      break;
    }
    ticks.push({
      value: tickValue
    });
  }
  if (maxDefined && includeBounds && niceMax !== max) {
    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
      ticks[ticks.length - 1].value = max;
    } else {
      ticks.push({
        value: max
      });
    }
  } else if (!maxDefined || niceMax === max) {
    ticks.push({
      value: niceMax
    });
  }
  return ticks;
}
function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
  const rad = toRadians(minRotation);
  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
  const length = 0.75 * minSpacing * ("" + value).length;
  return Math.min(minSpacing / ratio, length);
}
var LinearScaleBase = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._endValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    if (isNullOrUndef(raw)) {
      return null;
    }
    if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
      return null;
    }
    return +raw;
  }
  handleTickRangeOptions() {
    const { beginAtZero } = this.options;
    const { minDefined, maxDefined } = this.getUserBounds();
    let { min, max } = this;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (beginAtZero) {
      const minSign = sign(min);
      const maxSign = sign(max);
      if (minSign < 0 && maxSign < 0) {
        setMax(0);
      } else if (minSign > 0 && maxSign > 0) {
        setMin(0);
      }
    }
    if (min === max) {
      let offset = max === 0 ? 1 : Math.abs(max * 0.05);
      setMax(max + offset);
      if (!beginAtZero) {
        setMin(min - offset);
      }
    }
    this.min = min;
    this.max = max;
  }
  getTickLimit() {
    const tickOpts = this.options.ticks;
    let { maxTicksLimit, stepSize } = tickOpts;
    let maxTicks;
    if (stepSize) {
      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
      if (maxTicks > 1e3) {
        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
        maxTicks = 1e3;
      }
    } else {
      maxTicks = this.computeTickLimit();
      maxTicksLimit = maxTicksLimit || 11;
    }
    if (maxTicksLimit) {
      maxTicks = Math.min(maxTicksLimit, maxTicks);
    }
    return maxTicks;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const opts = this.options;
    const tickOpts = opts.ticks;
    let maxTicks = this.getTickLimit();
    maxTicks = Math.max(2, maxTicks);
    const numericGeneratorOptions = {
      maxTicks,
      bounds: opts.bounds,
      min: opts.min,
      max: opts.max,
      precision: tickOpts.precision,
      step: tickOpts.stepSize,
      count: tickOpts.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: tickOpts.minRotation || 0,
      includeBounds: tickOpts.includeBounds !== false
    };
    const dataRange = this._range || this;
    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  configure() {
    const ticks = this.ticks;
    let start = this.min;
    let end = this.max;
    super.configure();
    if (this.options.offset && ticks.length) {
      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
      start -= offset;
      end += offset;
    }
    this._startValue = start;
    this._endValue = end;
    this._valueRange = end - start;
  }
  getLabelForValue(value) {
    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
};
var LinearScale = class extends LinearScaleBase {
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? min : 0;
    this.max = isNumberFinite(max) ? max : 1;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const horizontal = this.isHorizontal();
    const length = horizontal ? this.width : this.height;
    const minRotation = toRadians(this.options.ticks.minRotation);
    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
    const tickFont = this._resolveTickFontOptions(0);
    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
  }
  getPixelForValue(value) {
    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
  }
};
__publicField(LinearScale, "id", "linear");
__publicField(LinearScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.numeric
  }
});
var log10Floor = (v) => Math.floor(log10(v));
var changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
function isMajor(tickVal) {
  const remain = tickVal / Math.pow(10, log10Floor(tickVal));
  return remain === 1;
}
function steps(min, max, rangeExp) {
  const rangeStep = Math.pow(10, rangeExp);
  const start = Math.floor(min / rangeStep);
  const end = Math.ceil(max / rangeStep);
  return end - start;
}
function startExp(min, max) {
  const range = max - min;
  let rangeExp = log10Floor(range);
  while (steps(min, max, rangeExp) > 10) {
    rangeExp++;
  }
  while (steps(min, max, rangeExp) < 10) {
    rangeExp--;
  }
  return Math.min(rangeExp, log10Floor(min));
}
function generateTicks(generationOptions, { min, max }) {
  min = finiteOrDefault(generationOptions.min, min);
  const ticks = [];
  const minExp = log10Floor(min);
  let exp = startExp(min, max);
  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
  const stepSize = Math.pow(10, exp);
  const base = minExp > exp ? Math.pow(10, minExp) : 0;
  const start = Math.round((min - base) * precision) / precision;
  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
  let significand = Math.floor((start - offset) / Math.pow(10, exp));
  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
  while (value < max) {
    ticks.push({
      value,
      major: isMajor(value),
      significand
    });
    if (significand >= 10) {
      significand = significand < 15 ? 15 : 20;
    } else {
      significand++;
    }
    if (significand >= 20) {
      exp++;
      significand = 2;
      precision = exp >= 0 ? 1 : precision;
    }
    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
  }
  const lastTick = finiteOrDefault(generationOptions.max, value);
  ticks.push({
    value: lastTick,
    major: isMajor(lastTick),
    significand
  });
  return ticks;
}
var LogarithmicScale = class extends Scale {
  constructor(cfg) {
    super(cfg);
    this.start = void 0;
    this.end = void 0;
    this._startValue = void 0;
    this._valueRange = 0;
  }
  parse(raw, index2) {
    const value = LinearScaleBase.prototype.parse.apply(this, [
      raw,
      index2
    ]);
    if (value === 0) {
      this._zero = true;
      return void 0;
    }
    return isNumberFinite(value) && value > 0 ? value : null;
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(true);
    this.min = isNumberFinite(min) ? Math.max(0, min) : null;
    this.max = isNumberFinite(max) ? Math.max(0, max) : null;
    if (this.options.beginAtZero) {
      this._zero = true;
    }
    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {
      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
    }
    this.handleTickRangeOptions();
  }
  handleTickRangeOptions() {
    const { minDefined, maxDefined } = this.getUserBounds();
    let min = this.min;
    let max = this.max;
    const setMin = (v) => min = minDefined ? min : v;
    const setMax = (v) => max = maxDefined ? max : v;
    if (min === max) {
      if (min <= 0) {
        setMin(1);
        setMax(10);
      } else {
        setMin(changeExponent(min, -1));
        setMax(changeExponent(max, 1));
      }
    }
    if (min <= 0) {
      setMin(changeExponent(max, -1));
    }
    if (max <= 0) {
      setMax(changeExponent(min, 1));
    }
    this.min = min;
    this.max = max;
  }
  buildTicks() {
    const opts = this.options;
    const generationOptions = {
      min: this._userMin,
      max: this._userMax
    };
    const ticks = generateTicks(generationOptions, this);
    if (opts.bounds === "ticks") {
      _setMinAndMaxByKey(ticks, this, "value");
    }
    if (opts.reverse) {
      ticks.reverse();
      this.start = this.max;
      this.end = this.min;
    } else {
      this.start = this.min;
      this.end = this.max;
    }
    return ticks;
  }
  getLabelForValue(value) {
    return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
  }
  configure() {
    const start = this.min;
    super.configure();
    this._startValue = log10(start);
    this._valueRange = log10(this.max) - log10(start);
  }
  getPixelForValue(value) {
    if (value === void 0 || value === 0) {
      value = this.min;
    }
    if (value === null || isNaN(value)) {
      return NaN;
    }
    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
  }
  getValueForPixel(pixel) {
    const decimal = this.getDecimalForPixel(pixel);
    return Math.pow(10, this._startValue + decimal * this._valueRange);
  }
};
__publicField(LogarithmicScale, "id", "logarithmic");
__publicField(LogarithmicScale, "defaults", {
  ticks: {
    callback: Ticks.formatters.logarithmic,
    major: {
      enabled: true
    }
  }
});
function getTickBackdropHeight(opts) {
  const tickOpts = opts.ticks;
  if (tickOpts.display && opts.display) {
    const padding = toPadding(tickOpts.backdropPadding);
    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
  }
  return 0;
}
function measureLabelSize(ctx, font, label) {
  label = isArray(label) ? label : [
    label
  ];
  return {
    w: _longestText(ctx, font.string, label),
    h: label.length * font.lineHeight
  };
}
function determineLimits(angle, pos, size, min, max) {
  if (angle === min || angle === max) {
    return {
      start: pos - size / 2,
      end: pos + size / 2
    };
  } else if (angle < min || angle > max) {
    return {
      start: pos - size,
      end: pos
    };
  }
  return {
    start: pos,
    end: pos + size
  };
}
function fitWithPointLabels(scale) {
  const orig = {
    l: scale.left + scale._padding.left,
    r: scale.right - scale._padding.right,
    t: scale.top + scale._padding.top,
    b: scale.bottom - scale._padding.bottom
  };
  const limits = Object.assign({}, orig);
  const labelSizes = [];
  const padding = [];
  const valueCount = scale._pointLabels.length;
  const pointLabelOpts = scale.options.pointLabels;
  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
  for (let i = 0; i < valueCount; i++) {
    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
    padding[i] = opts.padding;
    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
    const plFont = toFont(opts.font);
    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
    labelSizes[i] = textSize;
    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
    const angle = Math.round(toDegrees(angleRadians));
    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
    updateLimits(limits, orig, angleRadians, hLimits, vLimits);
  }
  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
}
function updateLimits(limits, orig, angle, hLimits, vLimits) {
  const sin = Math.abs(Math.sin(angle));
  const cos = Math.abs(Math.cos(angle));
  let x = 0;
  let y = 0;
  if (hLimits.start < orig.l) {
    x = (orig.l - hLimits.start) / sin;
    limits.l = Math.min(limits.l, orig.l - x);
  } else if (hLimits.end > orig.r) {
    x = (hLimits.end - orig.r) / sin;
    limits.r = Math.max(limits.r, orig.r + x);
  }
  if (vLimits.start < orig.t) {
    y = (orig.t - vLimits.start) / cos;
    limits.t = Math.min(limits.t, orig.t - y);
  } else if (vLimits.end > orig.b) {
    y = (vLimits.end - orig.b) / cos;
    limits.b = Math.max(limits.b, orig.b + y);
  }
}
function createPointLabelItem(scale, index2, itemOpts) {
  const outerDistance = scale.drawingArea;
  const { extra, additionalAngle, padding, size } = itemOpts;
  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);
  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
  const y = yForAngle(pointLabelPosition.y, size.h, angle);
  const textAlign = getTextAlignForAngle(angle);
  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
  return {
    visible: true,
    x: pointLabelPosition.x,
    y,
    textAlign,
    left,
    top: y,
    right: left + size.w,
    bottom: y + size.h
  };
}
function isNotOverlapped(item, area) {
  if (!area) {
    return true;
  }
  const { left, top, right, bottom } = item;
  const apexesInArea = _isPointInArea({
    x: left,
    y: top
  }, area) || _isPointInArea({
    x: left,
    y: bottom
  }, area) || _isPointInArea({
    x: right,
    y: top
  }, area) || _isPointInArea({
    x: right,
    y: bottom
  }, area);
  return !apexesInArea;
}
function buildPointLabelItems(scale, labelSizes, padding) {
  const items = [];
  const valueCount = scale._pointLabels.length;
  const opts = scale.options;
  const { centerPointLabels, display } = opts.pointLabels;
  const itemOpts = {
    extra: getTickBackdropHeight(opts) / 2,
    additionalAngle: centerPointLabels ? PI / valueCount : 0
  };
  let area;
  for (let i = 0; i < valueCount; i++) {
    itemOpts.padding = padding[i];
    itemOpts.size = labelSizes[i];
    const item = createPointLabelItem(scale, i, itemOpts);
    items.push(item);
    if (display === "auto") {
      item.visible = isNotOverlapped(item, area);
      if (item.visible) {
        area = item;
      }
    }
  }
  return items;
}
function getTextAlignForAngle(angle) {
  if (angle === 0 || angle === 180) {
    return "center";
  } else if (angle < 180) {
    return "left";
  }
  return "right";
}
function leftForTextAlign(x, w, align) {
  if (align === "right") {
    x -= w;
  } else if (align === "center") {
    x -= w / 2;
  }
  return x;
}
function yForAngle(y, h, angle) {
  if (angle === 90 || angle === 270) {
    y -= h / 2;
  } else if (angle > 270 || angle < 90) {
    y -= h;
  }
  return y;
}
function drawPointLabelBox(ctx, opts, item) {
  const { left, top, right, bottom } = item;
  const { backdropColor } = opts;
  if (!isNullOrUndef(backdropColor)) {
    const borderRadius = toTRBLCorners(opts.borderRadius);
    const padding = toPadding(opts.backdropPadding);
    ctx.fillStyle = backdropColor;
    const backdropLeft = left - padding.left;
    const backdropTop = top - padding.top;
    const backdropWidth = right - left + padding.width;
    const backdropHeight = bottom - top + padding.height;
    if (Object.values(borderRadius).some((v) => v !== 0)) {
      ctx.beginPath();
      addRoundedRectPath(ctx, {
        x: backdropLeft,
        y: backdropTop,
        w: backdropWidth,
        h: backdropHeight,
        radius: borderRadius
      });
      ctx.fill();
    } else {
      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
    }
  }
}
function drawPointLabels(scale, labelCount) {
  const { ctx, options: { pointLabels } } = scale;
  for (let i = labelCount - 1; i >= 0; i--) {
    const item = scale._pointLabelItems[i];
    if (!item.visible) {
      continue;
    }
    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
    drawPointLabelBox(ctx, optsAtIndex, item);
    const plFont = toFont(optsAtIndex.font);
    const { x, y, textAlign } = item;
    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
      color: optsAtIndex.color,
      textAlign,
      textBaseline: "middle"
    });
  }
}
function pathRadiusLine(scale, radius, circular, labelCount) {
  const { ctx } = scale;
  if (circular) {
    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
  } else {
    let pointPosition = scale.getPointPosition(0, radius);
    ctx.moveTo(pointPosition.x, pointPosition.y);
    for (let i = 1; i < labelCount; i++) {
      pointPosition = scale.getPointPosition(i, radius);
      ctx.lineTo(pointPosition.x, pointPosition.y);
    }
  }
}
function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
  const ctx = scale.ctx;
  const circular = gridLineOpts.circular;
  const { color: color2, lineWidth } = gridLineOpts;
  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
    return;
  }
  ctx.save();
  ctx.strokeStyle = color2;
  ctx.lineWidth = lineWidth;
  ctx.setLineDash(borderOpts.dash || []);
  ctx.lineDashOffset = borderOpts.dashOffset;
  ctx.beginPath();
  pathRadiusLine(scale, radius, circular, labelCount);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function createPointLabelContext(parent, index2, label) {
  return createContext(parent, {
    label,
    index: index2,
    type: "pointLabel"
  });
}
var RadialLinearScale = class extends LinearScaleBase {
  constructor(cfg) {
    super(cfg);
    this.xCenter = void 0;
    this.yCenter = void 0;
    this.drawingArea = void 0;
    this._pointLabels = [];
    this._pointLabelItems = [];
  }
  setDimensions() {
    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
    const w = this.width = this.maxWidth - padding.width;
    const h = this.height = this.maxHeight - padding.height;
    this.xCenter = Math.floor(this.left + w / 2 + padding.left);
    this.yCenter = Math.floor(this.top + h / 2 + padding.top);
    this.drawingArea = Math.floor(Math.min(w, h) / 2);
  }
  determineDataLimits() {
    const { min, max } = this.getMinMax(false);
    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
    this.handleTickRangeOptions();
  }
  computeTickLimit() {
    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
  }
  generateTickLabels(ticks) {
    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
    this._pointLabels = this.getLabels().map((value, index2) => {
      const label = callback(this.options.pointLabels.callback, [
        value,
        index2
      ], this);
      return label || label === 0 ? label : "";
    }).filter((v, i) => this.chart.getDataVisibility(i));
  }
  fit() {
    const opts = this.options;
    if (opts.display && opts.pointLabels.display) {
      fitWithPointLabels(this);
    } else {
      this.setCenterPoint(0, 0, 0, 0);
    }
  }
  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
  }
  getIndexAngle(index2) {
    const angleMultiplier = TAU / (this._pointLabels.length || 1);
    const startAngle = this.options.startAngle || 0;
    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
  }
  getDistanceFromCenterForValue(value) {
    if (isNullOrUndef(value)) {
      return NaN;
    }
    const scalingFactor = this.drawingArea / (this.max - this.min);
    if (this.options.reverse) {
      return (this.max - value) * scalingFactor;
    }
    return (value - this.min) * scalingFactor;
  }
  getValueForDistanceFromCenter(distance) {
    if (isNullOrUndef(distance)) {
      return NaN;
    }
    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
  }
  getPointLabelContext(index2) {
    const pointLabels = this._pointLabels || [];
    if (index2 >= 0 && index2 < pointLabels.length) {
      const pointLabel = pointLabels[index2];
      return createPointLabelContext(this.getContext(), index2, pointLabel);
    }
  }
  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {
    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;
    return {
      x: Math.cos(angle) * distanceFromCenter + this.xCenter,
      y: Math.sin(angle) * distanceFromCenter + this.yCenter,
      angle
    };
  }
  getPointPositionForValue(index2, value) {
    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
  }
  getBasePosition(index2) {
    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
  }
  getPointLabelPosition(index2) {
    const { left, top, right, bottom } = this._pointLabelItems[index2];
    return {
      left,
      top,
      right,
      bottom
    };
  }
  drawBackground() {
    const { backgroundColor, grid: { circular } } = this.options;
    if (backgroundColor) {
      const ctx = this.ctx;
      ctx.save();
      ctx.beginPath();
      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
      ctx.closePath();
      ctx.fillStyle = backgroundColor;
      ctx.fill();
      ctx.restore();
    }
  }
  drawGrid() {
    const ctx = this.ctx;
    const opts = this.options;
    const { angleLines, grid, border } = opts;
    const labelCount = this._pointLabels.length;
    let i, offset, position;
    if (opts.pointLabels.display) {
      drawPointLabels(this, labelCount);
    }
    if (grid.display) {
      this.ticks.forEach((tick, index2) => {
        if (index2 !== 0 || index2 === 0 && this.min < 0) {
          offset = this.getDistanceFromCenterForValue(tick.value);
          const context = this.getContext(index2);
          const optsAtIndex = grid.setContext(context);
          const optsAtIndexBorder = border.setContext(context);
          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
        }
      });
    }
    if (angleLines.display) {
      ctx.save();
      for (i = labelCount - 1; i >= 0; i--) {
        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
        const { color: color2, lineWidth } = optsAtIndex;
        if (!lineWidth || !color2) {
          continue;
        }
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = color2;
        ctx.setLineDash(optsAtIndex.borderDash);
        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
        position = this.getPointPosition(i, offset);
        ctx.beginPath();
        ctx.moveTo(this.xCenter, this.yCenter);
        ctx.lineTo(position.x, position.y);
        ctx.stroke();
      }
      ctx.restore();
    }
  }
  drawBorder() {
  }
  drawLabels() {
    const ctx = this.ctx;
    const opts = this.options;
    const tickOpts = opts.ticks;
    if (!tickOpts.display) {
      return;
    }
    const startAngle = this.getIndexAngle(0);
    let offset, width;
    ctx.save();
    ctx.translate(this.xCenter, this.yCenter);
    ctx.rotate(startAngle);
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    this.ticks.forEach((tick, index2) => {
      if (index2 === 0 && this.min >= 0 && !opts.reverse) {
        return;
      }
      const optsAtIndex = tickOpts.setContext(this.getContext(index2));
      const tickFont = toFont(optsAtIndex.font);
      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);
      if (optsAtIndex.showLabelBackdrop) {
        ctx.font = tickFont.string;
        width = ctx.measureText(tick.label).width;
        ctx.fillStyle = optsAtIndex.backdropColor;
        const padding = toPadding(optsAtIndex.backdropPadding);
        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
      }
      renderText(ctx, tick.label, 0, -offset, tickFont, {
        color: optsAtIndex.color,
        strokeColor: optsAtIndex.textStrokeColor,
        strokeWidth: optsAtIndex.textStrokeWidth
      });
    });
    ctx.restore();
  }
  drawTitle() {
  }
};
__publicField(RadialLinearScale, "id", "radialLinear");
__publicField(RadialLinearScale, "defaults", {
  display: true,
  animate: true,
  position: "chartArea",
  angleLines: {
    display: true,
    lineWidth: 1,
    borderDash: [],
    borderDashOffset: 0
  },
  grid: {
    circular: false
  },
  startAngle: 0,
  ticks: {
    showLabelBackdrop: true,
    callback: Ticks.formatters.numeric
  },
  pointLabels: {
    backdropColor: void 0,
    backdropPadding: 2,
    display: true,
    font: {
      size: 10
    },
    callback(label) {
      return label;
    },
    padding: 5,
    centerPointLabels: false
  }
});
__publicField(RadialLinearScale, "defaultRoutes", {
  "angleLines.color": "borderColor",
  "pointLabels.color": "color",
  "ticks.color": "color"
});
__publicField(RadialLinearScale, "descriptors", {
  angleLines: {
    _fallback: "grid"
  }
});
var INTERVALS = {
  millisecond: {
    common: true,
    size: 1,
    steps: 1e3
  },
  second: {
    common: true,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: true,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: true,
    size: 36e5,
    steps: 24
  },
  day: {
    common: true,
    size: 864e5,
    steps: 30
  },
  week: {
    common: false,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: true,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: false,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: true,
    size: 3154e7
  }
};
var UNITS = /* @__PURE__ */ Object.keys(INTERVALS);
function sorter(a, b) {
  return a - b;
}
function parse(scale, input) {
  if (isNullOrUndef(input)) {
    return null;
  }
  const adapter = scale._adapter;
  const { parser: parser2, round: round2, isoWeekday } = scale._parseOpts;
  let value = input;
  if (typeof parser2 === "function") {
    value = parser2(value);
  }
  if (!isNumberFinite(value)) {
    value = typeof parser2 === "string" ? adapter.parse(value, parser2) : adapter.parse(value);
  }
  if (value === null) {
    return null;
  }
  if (round2) {
    value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
  }
  return +value;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
  const ilen = UNITS.length;
  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
    const interval = INTERVALS[UNITS[i]];
    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
      return UNITS[i];
    }
  }
  return UNITS[ilen - 1];
}
function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
    const unit = UNITS[i];
    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
      return unit;
    }
  }
  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
    if (INTERVALS[UNITS[i]].common) {
      return UNITS[i];
    }
  }
}
function addTick(ticks, time, timestamps) {
  if (!timestamps) {
    ticks[time] = true;
  } else if (timestamps.length) {
    const { lo, hi } = _lookup(timestamps, time);
    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
    ticks[timestamp] = true;
  }
}
function setMajorTicks(scale, ticks, map3, majorUnit) {
  const adapter = scale._adapter;
  const first = +adapter.startOf(ticks[0].value, majorUnit);
  const last = ticks[ticks.length - 1].value;
  let major, index2;
  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
    index2 = map3[major];
    if (index2 >= 0) {
      ticks[index2].major = true;
    }
  }
  return ticks;
}
function ticksFromTimestamps(scale, values, majorUnit) {
  const ticks = [];
  const map3 = {};
  const ilen = values.length;
  let i, value;
  for (i = 0; i < ilen; ++i) {
    value = values[i];
    map3[value] = i;
    ticks.push({
      value,
      major: false
    });
  }
  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);
}
var TimeScale = class extends Scale {
  constructor(props) {
    super(props);
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
    this._unit = "day";
    this._majorUnit = void 0;
    this._offsets = {};
    this._normalized = false;
    this._parseOpts = void 0;
  }
  init(scaleOpts, opts = {}) {
    const time = scaleOpts.time || (scaleOpts.time = {});
    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
    adapter.init(opts);
    mergeIf(time.displayFormats, adapter.formats());
    this._parseOpts = {
      parser: time.parser,
      round: time.round,
      isoWeekday: time.isoWeekday
    };
    super.init(scaleOpts);
    this._normalized = opts.normalized;
  }
  parse(raw, index2) {
    if (raw === void 0) {
      return null;
    }
    return parse(this, raw);
  }
  beforeLayout() {
    super.beforeLayout();
    this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const options2 = this.options;
    const adapter = this._adapter;
    const unit = options2.time.unit || "day";
    let { min, max, minDefined, maxDefined } = this.getUserBounds();
    function _applyBounds(bounds) {
      if (!minDefined && !isNaN(bounds.min)) {
        min = Math.min(min, bounds.min);
      }
      if (!maxDefined && !isNaN(bounds.max)) {
        max = Math.max(max, bounds.max);
      }
    }
    if (!minDefined || !maxDefined) {
      _applyBounds(this._getLabelBounds());
      if (options2.bounds !== "ticks" || options2.ticks.source !== "labels") {
        _applyBounds(this.getMinMax(false));
      }
    }
    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
    this.min = Math.min(min, max - 1);
    this.max = Math.max(min + 1, max);
  }
  _getLabelBounds() {
    const arr = this.getLabelTimestamps();
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    if (arr.length) {
      min = arr[0];
      max = arr[arr.length - 1];
    }
    return {
      min,
      max
    };
  }
  buildTicks() {
    const options2 = this.options;
    const timeOpts = options2.time;
    const tickOpts = options2.ticks;
    const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
    if (options2.bounds === "ticks" && timestamps.length) {
      this.min = this._userMin || timestamps[0];
      this.max = this._userMax || timestamps[timestamps.length - 1];
    }
    const min = this.min;
    const max = this.max;
    const ticks = _filterBetween(timestamps, min, max);
    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
    this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
    this.initOffsets(timestamps);
    if (options2.reverse) {
      ticks.reverse();
    }
    return ticksFromTimestamps(this, ticks, this._majorUnit);
  }
  afterAutoSkip() {
    if (this.options.offsetAfterAutoskip) {
      this.initOffsets(this.ticks.map((tick) => +tick.value));
    }
  }
  initOffsets(timestamps = []) {
    let start = 0;
    let end = 0;
    let first, last;
    if (this.options.offset && timestamps.length) {
      first = this.getDecimalForValue(timestamps[0]);
      if (timestamps.length === 1) {
        start = 1 - first;
      } else {
        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
      }
      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
      if (timestamps.length === 1) {
        end = last;
      } else {
        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
      }
    }
    const limit = timestamps.length < 3 ? 0.5 : 0.25;
    start = _limitValue(start, 0, limit);
    end = _limitValue(end, 0, limit);
    this._offsets = {
      start,
      end,
      factor: 1 / (start + 1 + end)
    };
  }
  _generate() {
    const adapter = this._adapter;
    const min = this.min;
    const max = this.max;
    const options2 = this.options;
    const timeOpts = options2.time;
    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
    const stepSize = valueOrDefault(options2.ticks.stepSize, 1);
    const weekday = minor === "week" ? timeOpts.isoWeekday : false;
    const hasWeekday = isNumber(weekday) || weekday === true;
    const ticks = {};
    let first = min;
    let time, count;
    if (hasWeekday) {
      first = +adapter.startOf(first, "isoWeek", weekday);
    }
    first = +adapter.startOf(first, hasWeekday ? "day" : minor);
    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
      throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
    }
    const timestamps = options2.ticks.source === "data" && this.getDataTimestamps();
    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
      addTick(ticks, time, timestamps);
    }
    if (time === max || options2.bounds === "ticks" || count === 1) {
      addTick(ticks, time, timestamps);
    }
    return Object.keys(ticks).sort(sorter).map((x) => +x);
  }
  getLabelForValue(value) {
    const adapter = this._adapter;
    const timeOpts = this.options.time;
    if (timeOpts.tooltipFormat) {
      return adapter.format(value, timeOpts.tooltipFormat);
    }
    return adapter.format(value, timeOpts.displayFormats.datetime);
  }
  format(value, format) {
    const options2 = this.options;
    const formats = options2.time.displayFormats;
    const unit = this._unit;
    const fmt = format || formats[unit];
    return this._adapter.format(value, fmt);
  }
  _tickFormatFunction(time, index2, ticks, format) {
    const options2 = this.options;
    const formatter = options2.ticks.callback;
    if (formatter) {
      return callback(formatter, [
        time,
        index2,
        ticks
      ], this);
    }
    const formats = options2.time.displayFormats;
    const unit = this._unit;
    const majorUnit = this._majorUnit;
    const minorFormat = unit && formats[unit];
    const majorFormat = majorUnit && formats[majorUnit];
    const tick = ticks[index2];
    const major = majorUnit && majorFormat && tick && tick.major;
    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
  }
  generateTickLabels(ticks) {
    let i, ilen, tick;
    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
      tick = ticks[i];
      tick.label = this._tickFormatFunction(tick.value, i, ticks);
    }
  }
  getDecimalForValue(value) {
    return value === null ? NaN : (value - this.min) / (this.max - this.min);
  }
  getPixelForValue(value) {
    const offsets = this._offsets;
    const pos = this.getDecimalForValue(value);
    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return this.min + pos * (this.max - this.min);
  }
  _getLabelSize(label) {
    const ticksOpts = this.options.ticks;
    const tickLabelWidth = this.ctx.measureText(label).width;
    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
    const cosRotation = Math.cos(angle);
    const sinRotation = Math.sin(angle);
    const tickFontSize = this._resolveTickFontOptions(0).size;
    return {
      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
    };
  }
  _getLabelCapacity(exampleTime) {
    const timeOpts = this.options.time;
    const displayFormats = timeOpts.displayFormats;
    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [
      exampleTime
    ], this._majorUnit), format);
    const size = this._getLabelSize(exampleLabel);
    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
    return capacity > 0 ? capacity : 1;
  }
  getDataTimestamps() {
    let timestamps = this._cache.data || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const metas = this.getMatchingVisibleMetas();
    if (this._normalized && metas.length) {
      return this._cache.data = metas[0].controller.getAllParsedValues(this);
    }
    for (i = 0, ilen = metas.length; i < ilen; ++i) {
      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
    }
    return this._cache.data = this.normalize(timestamps);
  }
  getLabelTimestamps() {
    const timestamps = this._cache.labels || [];
    let i, ilen;
    if (timestamps.length) {
      return timestamps;
    }
    const labels = this.getLabels();
    for (i = 0, ilen = labels.length; i < ilen; ++i) {
      timestamps.push(parse(this, labels[i]));
    }
    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
  }
  normalize(values) {
    return _arrayUnique(values.sort(sorter));
  }
};
__publicField(TimeScale, "id", "time");
__publicField(TimeScale, "defaults", {
  bounds: "data",
  adapters: {},
  time: {
    parser: false,
    unit: false,
    round: false,
    isoWeekday: false,
    minUnit: "millisecond",
    displayFormats: {}
  },
  ticks: {
    source: "auto",
    callback: false,
    major: {
      enabled: false
    }
  }
});
function interpolate2(table, val, reverse) {
  let lo = 0;
  let hi = table.length - 1;
  let prevSource, nextSource, prevTarget, nextTarget;
  if (reverse) {
    if (val >= table[lo].pos && val <= table[hi].pos) {
      ({ lo, hi } = _lookupByKey(table, "pos", val));
    }
    ({ pos: prevSource, time: prevTarget } = table[lo]);
    ({ pos: nextSource, time: nextTarget } = table[hi]);
  } else {
    if (val >= table[lo].time && val <= table[hi].time) {
      ({ lo, hi } = _lookupByKey(table, "time", val));
    }
    ({ time: prevSource, pos: prevTarget } = table[lo]);
    ({ time: nextSource, pos: nextTarget } = table[hi]);
  }
  const span = nextSource - prevSource;
  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
}
var TimeSeriesScale = class extends TimeScale {
  constructor(props) {
    super(props);
    this._table = [];
    this._minPos = void 0;
    this._tableRange = void 0;
  }
  initOffsets() {
    const timestamps = this._getTimestampsForTable();
    const table = this._table = this.buildLookupTable(timestamps);
    this._minPos = interpolate2(table, this.min);
    this._tableRange = interpolate2(table, this.max) - this._minPos;
    super.initOffsets(timestamps);
  }
  buildLookupTable(timestamps) {
    const { min, max } = this;
    const items = [];
    const table = [];
    let i, ilen, prev, curr, next;
    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];
      if (curr >= min && curr <= max) {
        items.push(curr);
      }
    }
    if (items.length < 2) {
      return [
        {
          time: min,
          pos: 0
        },
        {
          time: max,
          pos: 1
        }
      ];
    }
    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i];
      if (Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }
    return table;
  }
  _generate() {
    const min = this.min;
    const max = this.max;
    let timestamps = super.getDataTimestamps();
    if (!timestamps.includes(min) || !timestamps.length) {
      timestamps.splice(0, 0, min);
    }
    if (!timestamps.includes(max) || timestamps.length === 1) {
      timestamps.push(max);
    }
    return timestamps.sort((a, b) => a - b);
  }
  _getTimestampsForTable() {
    let timestamps = this._cache.all || [];
    if (timestamps.length) {
      return timestamps;
    }
    const data = this.getDataTimestamps();
    const label = this.getLabelTimestamps();
    if (data.length && label.length) {
      timestamps = this.normalize(data.concat(label));
    } else {
      timestamps = data.length ? data : label;
    }
    timestamps = this._cache.all = timestamps;
    return timestamps;
  }
  getDecimalForValue(value) {
    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;
  }
  getValueForPixel(pixel) {
    const offsets = this._offsets;
    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);
  }
};
__publicField(TimeSeriesScale, "id", "timeseries");
__publicField(TimeSeriesScale, "defaults", TimeScale.defaults);
var scales = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  CategoryScale,
  LinearScale,
  LogarithmicScale,
  RadialLinearScale,
  TimeScale,
  TimeSeriesScale
});
var registerables = [
  controllers,
  elements,
  plugins,
  scales
];

// src/dashboard.ts
Chart.register(...registerables);
var _DashboardView = class _DashboardView extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.widgets = /* @__PURE__ */ new Map();
    this.charts = /* @__PURE__ */ new Map();
    this.refreshIntervals = /* @__PURE__ */ new Map();
    this.isEditMode = false;
    this.initializeDefaultWidgets();
  }
  getViewType() {
    return _DashboardView.VIEW_TYPE;
  }
  getDisplayText() {
    return "AI MCP Dashboard";
  }
  getIcon() {
    return "layout-dashboard";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("ai-mcp-dashboard");
    await this.renderDashboard();
    this.startAutoRefresh();
  }
  async onClose() {
    this.stopAutoRefresh();
    this.destroyCharts();
  }
  initializeDefaultWidgets() {
    const defaultWidgets = [
      {
        id: "vault-overview",
        title: "Vault Overview",
        type: "metric",
        size: "medium",
        position: { x: 0, y: 0 },
        data: {},
        refreshInterval: 6e4
        // 1 minute
      },
      {
        id: "activity-chart",
        title: "Recent Activity",
        type: "chart",
        size: "large",
        position: { x: 1, y: 0 },
        data: { chartType: "line" },
        refreshInterval: 3e5
        // 5 minutes
      },
      {
        id: "top-tags",
        title: "Top Tags",
        type: "chart",
        size: "medium",
        position: { x: 0, y: 1 },
        data: { chartType: "doughnut" },
        refreshInterval: 3e5
      },
      {
        id: "ai-insights",
        title: "AI Insights",
        type: "ai-insights",
        size: "large",
        position: { x: 1, y: 1 },
        data: {},
        refreshInterval: 6e5
        // 10 minutes
      },
      {
        id: "quick-notes",
        title: "Quick Notes",
        type: "markdown",
        size: "medium",
        position: { x: 0, y: 2 },
        data: { content: "# Quick Notes\n\nAdd your quick notes here..." }
      },
      {
        id: "recent-files",
        title: "Recent Files",
        type: "list",
        size: "medium",
        position: { x: 1, y: 2 },
        data: {},
        refreshInterval: 6e4
      }
    ];
    defaultWidgets.forEach((widget) => {
      this.widgets.set(widget.id, widget);
    });
  }
  async renderDashboard() {
    const container = this.containerEl.children[1];
    container.empty();
    const header = container.createEl("div", { cls: "dashboard-header" });
    header.createEl("h1", {
      text: "AI MCP Dashboard",
      cls: "dashboard-title"
    });
    const headerActions = header.createEl("div", { cls: "dashboard-actions" });
    const editBtn = headerActions.createEl("button", {
      text: this.isEditMode ? "Save Layout" : "Edit Layout",
      cls: "dashboard-edit-btn"
    });
    editBtn.onclick = () => this.toggleEditMode();
    const refreshBtn = headerActions.createEl("button", {
      text: "Refresh",
      cls: "dashboard-refresh-btn"
    });
    refreshBtn.onclick = () => this.refreshAllWidgets();
    const addBtn = headerActions.createEl("button", {
      text: "Add Widget",
      cls: "dashboard-add-btn"
    });
    addBtn.onclick = () => this.showAddWidgetModal();
    const grid = container.createEl("div", { cls: "dashboard-grid" });
    if (this.isEditMode) {
      grid.addClass("edit-mode");
    }
    for (const [id, widget] of this.widgets) {
      await this.renderWidget(grid, widget);
    }
  }
  async renderWidget(container, widget) {
    const widgetEl = container.createEl("div", {
      cls: `dashboard-widget widget-${widget.type} widget-${widget.size}`,
      attr: {
        "data-widget-id": widget.id,
        "data-x": widget.position.x.toString(),
        "data-y": widget.position.y.toString()
      }
    });
    const header = widgetEl.createEl("div", { cls: "widget-header" });
    header.createEl("h3", { text: widget.title, cls: "widget-title" });
    if (this.isEditMode) {
      const actions = header.createEl("div", { cls: "widget-actions" });
      const deleteBtn = actions.createEl("button", {
        text: "\xD7",
        cls: "widget-delete-btn"
      });
      deleteBtn.onclick = () => this.deleteWidget(widget.id);
      const configBtn = actions.createEl("button", {
        text: "\u2699",
        cls: "widget-config-btn"
      });
      configBtn.onclick = () => this.configureWidget(widget.id);
    }
    const content = widgetEl.createEl("div", { cls: "widget-content" });
    try {
      await this.renderWidgetContent(content, widget);
    } catch (error) {
      console.error(`Failed to render widget ${widget.id}:`, error);
      content.createEl("div", {
        text: `Error loading widget: ${error.message}`,
        cls: "widget-error"
      });
    }
    if (this.isEditMode) {
      this.makeDraggable(widgetEl);
    }
  }
  async renderWidgetContent(container, widget) {
    switch (widget.type) {
      case "metric":
        await this.renderMetricWidget(container, widget);
        break;
      case "chart":
        await this.renderChartWidget(container, widget);
        break;
      case "list":
        await this.renderListWidget(container, widget);
        break;
      case "markdown":
        await this.renderMarkdownWidget(container, widget);
        break;
      case "ai-insights":
        await this.renderAIInsightsWidget(container, widget);
        break;
      default:
        container.createEl("div", { text: "Unknown widget type", cls: "widget-error" });
    }
  }
  async renderMetricWidget(container, widget) {
    const metrics = await this.collectVaultMetrics();
    const metricsGrid = container.createEl("div", { cls: "metrics-grid" });
    const metricItems = [
      { label: "Notes", value: metrics.totalNotes, icon: "\u{1F4DD}" },
      { label: "Words", value: metrics.totalWords.toLocaleString(), icon: "\u{1F4CA}" },
      { label: "Tags", value: metrics.totalTags, icon: "\u{1F3F7}\uFE0F" },
      { label: "Links", value: metrics.totalLinks, icon: "\u{1F517}" }
    ];
    metricItems.forEach((item) => {
      const metricEl = metricsGrid.createEl("div", { cls: "metric-item" });
      metricEl.createEl("div", { text: item.icon, cls: "metric-icon" });
      metricEl.createEl("div", { text: item.value.toString(), cls: "metric-value" });
      metricEl.createEl("div", { text: item.label, cls: "metric-label" });
    });
  }
  async renderChartWidget(container, widget) {
    const canvas = container.createEl("canvas", {
      attr: { width: "400", height: "300" }
    });
    const metrics = await this.collectVaultMetrics();
    let chartData;
    let chartOptions;
    switch (widget.data.chartType) {
      case "line":
        chartData = {
          labels: metrics.recentActivity.map((a) => a.date),
          datasets: [{
            label: "Daily Activity",
            data: metrics.recentActivity.map((a) => a.count),
            borderColor: "rgb(75, 192, 192)",
            backgroundColor: "rgba(75, 192, 192, 0.2)",
            tension: 0.1
          }]
        };
        chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: { beginAtZero: true }
          }
        };
        break;
      case "doughnut":
        chartData = {
          labels: metrics.topTags.map((t) => t.tag),
          datasets: [{
            data: metrics.topTags.map((t) => t.count),
            backgroundColor: [
              "#FF6384",
              "#36A2EB",
              "#FFCE56",
              "#4BC0C0",
              "#9966FF",
              "#FF9F40",
              "#FF6384",
              "#C9CBCF"
            ]
          }]
        };
        chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { position: "right" }
          }
        };
        break;
      default:
        container.createEl("div", { text: "Unknown chart type", cls: "widget-error" });
        return;
    }
    const chart = new Chart(canvas, {
      type: widget.data.chartType,
      data: chartData,
      options: chartOptions
    });
    this.charts.set(widget.id, chart);
  }
  async renderListWidget(container, widget) {
    const recentFiles = this.plugin.app.vault.getMarkdownFiles().sort((a, b) => b.stat.mtime - a.stat.mtime).slice(0, 10);
    const list = container.createEl("ul", { cls: "widget-list" });
    recentFiles.forEach((file) => {
      const item = list.createEl("li", { cls: "list-item" });
      const link = item.createEl("a", {
        text: file.basename,
        cls: "file-link"
      });
      link.onclick = async () => {
        const leaf = this.plugin.app.workspace.getLeaf("tab");
        await leaf.openFile(file);
      };
      const time = item.createEl("span", {
        text: new Date(file.stat.mtime).toLocaleDateString(),
        cls: "file-time"
      });
    });
  }
  async renderMarkdownWidget(container, widget) {
    const content = widget.data.content || "# Empty Widget\n\nAdd some content...";
    if (this.isEditMode) {
      const textarea = container.createEl("textarea", {
        value: content,
        cls: "markdown-editor"
      });
      textarea.onchange = () => {
        widget.data.content = textarea.value;
        this.saveWidgetConfig();
      };
    } else {
      const html = marked(content);
      container.innerHTML = html;
      container.addClass("markdown-content");
    }
  }
  async renderAIInsightsWidget(container, widget) {
    const loadingEl = container.createEl("div", {
      text: "Generating AI insights...",
      cls: "loading-message"
    });
    try {
      const insights = await this.generateAIInsights();
      loadingEl.remove();
      const insightsContainer = container.createEl("div", { cls: "ai-insights" });
      insights.forEach((insight) => {
        const insightEl = insightsContainer.createEl("div", { cls: "insight-item" });
        insightEl.createEl("h4", { text: insight.title, cls: "insight-title" });
        insightEl.createEl("p", { text: insight.description, cls: "insight-description" });
        if (insight.action) {
          const actionBtn = insightEl.createEl("button", {
            text: insight.action.label,
            cls: "insight-action-btn"
          });
          actionBtn.onclick = insight.action.callback;
        }
      });
    } catch (error) {
      loadingEl.setText(`Failed to generate insights: ${error.message}`);
      loadingEl.addClass("error-message");
    }
  }
  async collectVaultMetrics() {
    const files = this.plugin.app.vault.getMarkdownFiles();
    const cache = this.plugin.app.metadataCache;
    let totalWords = 0;
    const tags = /* @__PURE__ */ new Set();
    let totalLinks = 0;
    const recentActivity = [];
    for (const file of files) {
      const fileCache = cache.getFileCache(file);
      try {
        const content = await this.plugin.app.vault.read(file);
        totalWords += content.split(/\s+/).length;
      } catch (e) {
      }
      if (fileCache?.tags) {
        fileCache.tags.forEach((tag) => tags.add(tag.tag));
      }
      if (fileCache?.links) {
        totalLinks += fileCache.links.length;
      }
    }
    const last7Days = Array.from({ length: 7 }, (_, i) => {
      const date = /* @__PURE__ */ new Date();
      date.setDate(date.getDate() - i);
      return {
        date: date.toLocaleDateString(),
        action: "edit",
        file: "various",
        count: Math.floor(Math.random() * 10) + 1
      };
    }).reverse();
    const topTags = Array.from(tags).map((tag) => ({ tag, count: Math.floor(Math.random() * 20) + 1 })).sort((a, b) => b.count - a.count).slice(0, 8);
    const graph = await this.plugin.memoryGraph.load();
    return {
      totalNotes: files.length,
      totalWords,
      totalTags: tags.size,
      totalLinks,
      recentActivity: last7Days,
      topTags,
      knowledgeGraph: {
        nodes: graph.nodes.length,
        edges: graph.edges.length,
        clusters: Math.floor(graph.nodes.length / 10)
        // Simplified
      },
      aiUsage: {
        queriesThisWeek: Math.floor(Math.random() * 100) + 20,
        tokensUsed: Math.floor(Math.random() * 1e4) + 1e3,
        topQueries: [
          "How to improve my writing?",
          "Summarize this document",
          "Find related notes"
        ]
      }
    };
  }
  async generateAIInsights() {
    return [
      {
        title: "Knowledge Gaps Detected",
        description: "Found 3 topics mentioned frequently but lacking detailed notes.",
        action: {
          label: "Show Gaps",
          callback: () => new import_obsidian4.Notice("Knowledge gap analysis coming soon!")
        }
      },
      {
        title: "Suggested Connections",
        description: "5 notes could benefit from linking to related content.",
        action: {
          label: "Review",
          callback: () => new import_obsidian4.Notice("Connection suggestions coming soon!")
        }
      },
      {
        title: "Writing Patterns",
        description: "Your writing activity peaks on Tuesday and Thursday.",
        action: {
          label: "View Details",
          callback: () => new import_obsidian4.Notice("Detailed analytics coming soon!")
        }
      }
    ];
  }
  toggleEditMode() {
    this.isEditMode = !this.isEditMode;
    this.renderDashboard();
  }
  async refreshAllWidgets() {
    new import_obsidian4.Notice("Refreshing dashboard...");
    await this.renderDashboard();
    new import_obsidian4.Notice("Dashboard refreshed!");
  }
  showAddWidgetModal() {
    new AddWidgetModal(this.plugin.app, (widget) => {
      this.widgets.set(widget.id, widget);
      this.renderDashboard();
    }).open();
  }
  deleteWidget(widgetId) {
    if (confirm("Delete this widget?")) {
      this.widgets.delete(widgetId);
      this.charts.delete(widgetId);
      this.renderDashboard();
    }
  }
  configureWidget(widgetId) {
    const widget = this.widgets.get(widgetId);
    if (widget) {
      new ConfigureWidgetModal(this.plugin.app, widget, (updatedWidget) => {
        this.widgets.set(widgetId, updatedWidget);
        this.renderDashboard();
      }).open();
    }
  }
  makeDraggable(element) {
    element.draggable = true;
    element.addEventListener("dragstart", (e) => {
      e.dataTransfer?.setData("text/plain", element.dataset.widgetId || "");
    });
  }
  startAutoRefresh() {
    for (const [id, widget] of this.widgets) {
      if (widget.refreshInterval) {
        const interval = setInterval(() => {
          this.refreshWidget(id);
        }, widget.refreshInterval);
        this.refreshIntervals.set(id, interval);
      }
    }
  }
  stopAutoRefresh() {
    for (const interval of this.refreshIntervals.values()) {
      clearInterval(interval);
    }
    this.refreshIntervals.clear();
  }
  async refreshWidget(widgetId) {
    const widget = this.widgets.get(widgetId);
    if (!widget)
      return;
    const widgetEl = this.containerEl.querySelector(`[data-widget-id="${widgetId}"]`);
    if (!widgetEl)
      return;
    const content = widgetEl.querySelector(".widget-content");
    if (content) {
      content.empty();
      await this.renderWidgetContent(content, widget);
    }
  }
  destroyCharts() {
    for (const chart of this.charts.values()) {
      chart.destroy();
    }
    this.charts.clear();
  }
  saveWidgetConfig() {
    const widgetConfigs = Array.from(this.widgets.values());
    this.plugin.settings.dashboardWidgets = widgetConfigs;
    this.plugin.saveSettings();
  }
};
_DashboardView.VIEW_TYPE = "ai-mcp-dashboard";
var DashboardView = _DashboardView;
var AddWidgetModal = class extends import_obsidian4.Modal {
  constructor(app, onAdd) {
    super(app);
    this.onAdd = onAdd;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Add Widget" });
    const form = contentEl.createEl("form");
    let widgetType = "metric";
    let widgetTitle = "";
    let widgetSize = "medium";
    new import_obsidian4.Setting(form).setName("Widget Type").addDropdown((dropdown) => dropdown.addOption("metric", "Metrics").addOption("chart", "Chart").addOption("list", "List").addOption("markdown", "Markdown").addOption("ai-insights", "AI Insights").setValue(widgetType).onChange((value) => widgetType = value));
    new import_obsidian4.Setting(form).setName("Title").addText((text) => text.setValue(widgetTitle).onChange((value) => widgetTitle = value));
    new import_obsidian4.Setting(form).setName("Size").addDropdown((dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(widgetSize).onChange((value) => widgetSize = value));
    const buttonContainer = form.createEl("div", { cls: "modal-button-container" });
    buttonContainer.createEl("button", { text: "Add Widget", type: "submit" });
    buttonContainer.createEl("button", { text: "Cancel", type: "button" }).onclick = () => this.close();
    form.onsubmit = (e) => {
      e.preventDefault();
      if (!widgetTitle.trim()) {
        new import_obsidian4.Notice("Please enter a widget title");
        return;
      }
      const widget = {
        id: `widget-${Date.now()}`,
        title: widgetTitle,
        type: widgetType,
        size: widgetSize,
        position: { x: 0, y: 0 },
        data: {}
      };
      this.onAdd(widget);
      this.close();
    };
  }
};
var ConfigureWidgetModal = class extends import_obsidian4.Modal {
  constructor(app, widget, onSave) {
    super(app);
    this.widget = widget;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: `Configure ${this.widget.title}` });
    const form = contentEl.createEl("form");
    let title = this.widget.title;
    let size = this.widget.size;
    let refreshInterval = this.widget.refreshInterval || 0;
    new import_obsidian4.Setting(form).setName("Title").addText((text) => text.setValue(title).onChange((value) => title = value));
    new import_obsidian4.Setting(form).setName("Size").addDropdown((dropdown) => dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(size).onChange((value) => size = value));
    new import_obsidian4.Setting(form).setName("Refresh Interval (seconds)").setDesc("0 = no auto-refresh").addText((text) => text.setValue((refreshInterval / 1e3).toString()).onChange((value) => refreshInterval = parseInt(value) * 1e3));
    const buttonContainer = form.createEl("div", { cls: "modal-button-container" });
    buttonContainer.createEl("button", { text: "Save", type: "submit" });
    buttonContainer.createEl("button", { text: "Cancel", type: "button" }).onclick = () => this.close();
    form.onsubmit = (e) => {
      e.preventDefault();
      this.widget.title = title;
      this.widget.size = size;
      this.widget.refreshInterval = refreshInterval > 0 ? refreshInterval : void 0;
      this.onSave(this.widget);
      this.close();
    };
  }
};

// src/email-notifications.ts
var import_obsidian5 = require("obsidian");
var EmailService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.config = null;
    this.isConfigured = false;
  }
  async configure(config) {
    try {
      this.config = config;
      const testResult = await this.testConnection();
      if (testResult) {
        this.isConfigured = true;
        new import_obsidian5.Notice("Email service configured successfully");
        return true;
      } else {
        throw new Error("Connection test failed");
      }
    } catch (error) {
      console.error("Email configuration failed:", error);
      new import_obsidian5.Notice(`Email configuration failed: ${error.message}`);
      this.isConfigured = false;
      return false;
    }
  }
  async sendEmail(to2, subject, htmlContent, textContent, attachments) {
    if (!this.isConfigured || !this.config) {
      throw new Error("Email service not configured");
    }
    try {
      const recipients = Array.isArray(to2) ? to2 : [to2];
      console.log("Simulating email send:", {
        from: `"${this.config.fromName}" <${this.config.fromEmail}>`,
        to: recipients.join(", "),
        subject,
        html: htmlContent,
        text: textContent || this.htmlToText(htmlContent),
        attachments: attachments?.length || 0
      });
      new import_obsidian5.Notice(`Email sent to ${recipients.join(", ")}`);
      return true;
    } catch (error) {
      console.error("Failed to send email:", error);
      throw error;
    }
  }
  async sendTemplatedEmail(to2, templateId, variables, attachments) {
    const template = this.getTemplate(templateId);
    if (!template) {
      throw new Error(`Template ${templateId} not found`);
    }
    const subject = this.processTemplate(template.subject, variables);
    const htmlContent = this.processTemplate(template.htmlTemplate, variables);
    const textContent = this.processTemplate(template.textTemplate, variables);
    return await this.sendEmail(to2, subject, htmlContent, textContent, attachments);
  }
  processTemplate(template, variables) {
    let processed = template;
    for (const [key, value] of Object.entries(variables)) {
      const regex = new RegExp(`{{\\s*${key}\\s*}}`, "g");
      processed = processed.replace(regex, String(value));
    }
    return processed;
  }
  htmlToText(html) {
    return html.replace(/<br\s*\/?>/gi, "\n").replace(/<\/p>/gi, "\n\n").replace(/<[^>]*>/g, "").replace(/&nbsp;/g, " ").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").trim();
  }
  getTemplate(templateId) {
    const templates = this.plugin.settings.emailTemplates || [];
    return templates.find((t) => t.id === templateId) || null;
  }
  isReady() {
    return this.isConfigured;
  }
  async testConnection() {
    if (!this.config)
      return false;
    try {
      console.log("Testing email configuration:", {
        host: this.config.smtpHost,
        port: this.config.smtpPort,
        username: this.config.username
      });
      return true;
    } catch (error) {
      console.error("Email connection test failed:", error);
      return false;
    }
  }
};
var FileShareService = class {
  constructor(plugin, emailService) {
    this.plugin = plugin;
    this.emailService = emailService;
  }
  async shareFileViaEmail(file, recipients, message, includeMetadata = true) {
    try {
      const content = await this.plugin.app.vault.read(file);
      const attachments = [];
      attachments.push({
        filename: `${file.basename}.md`,
        content,
        contentType: "text/markdown"
      });
      if (includeMetadata) {
        const metadata = this.extractFileMetadata(file);
        attachments.push({
          filename: `${file.basename}_metadata.json`,
          content: JSON.stringify(metadata, null, 2),
          contentType: "application/json"
        });
      }
      const variables = {
        fileName: file.basename,
        filePath: file.path,
        fileSize: this.formatFileSize(content.length),
        shareDate: (/* @__PURE__ */ new Date()).toLocaleDateString(),
        shareTime: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
        message: message || "Shared from Obsidian AI MCP Plugin",
        vaultName: this.plugin.app.vault.getName()
      };
      await this.emailService.sendTemplatedEmail(
        recipients,
        "file_share",
        variables,
        attachments
      );
      new import_obsidian5.Notice(`File "${file.basename}" shared successfully`);
      return true;
    } catch (error) {
      console.error("File sharing failed:", error);
      new import_obsidian5.Notice(`Failed to share file: ${error.message}`);
      return false;
    }
  }
  async shareMultipleFiles(files, recipients, message, format = "individual") {
    try {
      if (format === "individual") {
        for (const file of files) {
          await this.shareFileViaEmail(file, recipients, message);
        }
      } else {
        const attachments = [];
        for (const file of files) {
          const content = await this.plugin.app.vault.read(file);
          attachments.push({
            filename: `${file.path.replace(/\//g, "_")}.md`,
            content,
            contentType: "text/markdown"
          });
        }
        const variables = {
          fileCount: files.length,
          fileNames: files.map((f) => f.basename).join(", "),
          shareDate: (/* @__PURE__ */ new Date()).toLocaleDateString(),
          shareTime: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
          message: message || "Multiple files shared from Obsidian",
          vaultName: this.plugin.app.vault.getName()
        };
        await this.emailService.sendTemplatedEmail(
          recipients,
          "multiple_files_share",
          variables,
          attachments
        );
      }
      new import_obsidian5.Notice(`${files.length} files shared successfully`);
      return true;
    } catch (error) {
      console.error("Multiple file sharing failed:", error);
      new import_obsidian5.Notice(`Failed to share files: ${error.message}`);
      return false;
    }
  }
  async shareVaultSummary(recipients, includeStats = true, includeRecentFiles = true) {
    try {
      const summary = await this.generateVaultSummary(includeStats, includeRecentFiles);
      const variables = {
        vaultName: this.plugin.app.vault.getName(),
        summaryDate: (/* @__PURE__ */ new Date()).toLocaleDateString(),
        ...summary
      };
      await this.emailService.sendTemplatedEmail(
        recipients,
        "vault_summary",
        variables
      );
      new import_obsidian5.Notice("Vault summary shared successfully");
      return true;
    } catch (error) {
      console.error("Vault summary sharing failed:", error);
      new import_obsidian5.Notice(`Failed to share vault summary: ${error.message}`);
      return false;
    }
  }
  extractFileMetadata(file) {
    const cache = this.plugin.app.metadataCache.getFileCache(file);
    return {
      name: file.basename,
      path: file.path,
      size: file.stat.size,
      created: new Date(file.stat.ctime).toISOString(),
      modified: new Date(file.stat.mtime).toISOString(),
      tags: cache?.tags?.map((t) => t.tag) || [],
      links: cache?.links?.map((l) => l.link) || [],
      headings: cache?.headings?.map((h) => ({
        level: h.level,
        heading: h.heading
      })) || [],
      frontmatter: cache?.frontmatter || {}
    };
  }
  formatFileSize(bytes) {
    const sizes = ["Bytes", "KB", "MB", "GB"];
    if (bytes === 0)
      return "0 Bytes";
    const i = Math.floor(Math.log(bytes) / Math.log(1024));
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + " " + sizes[i];
  }
  async generateVaultSummary(includeStats, includeRecentFiles) {
    const files = this.plugin.app.vault.getMarkdownFiles();
    const summary = {};
    if (includeStats) {
      let totalWords = 0;
      const tags = /* @__PURE__ */ new Set();
      for (const file of files) {
        try {
          const content = await this.plugin.app.vault.read(file);
          totalWords += content.split(/\s+/).length;
          const cache = this.plugin.app.metadataCache.getFileCache(file);
          if (cache?.tags) {
            cache.tags.forEach((tag) => tags.add(tag.tag));
          }
        } catch (e) {
        }
      }
      summary.stats = {
        totalFiles: files.length,
        totalWords,
        totalTags: tags.size,
        averageWordsPerFile: Math.round(totalWords / files.length)
      };
    }
    if (includeRecentFiles) {
      const recentFiles = files.sort((a, b) => b.stat.mtime - a.stat.mtime).slice(0, 10).map((file) => ({
        name: file.basename,
        path: file.path,
        modified: new Date(file.stat.mtime).toLocaleDateString()
      }));
      summary.recentFiles = recentFiles;
    }
    return summary;
  }
};
var NotificationManager = class {
  constructor(plugin, emailService, fileShareService) {
    this.plugin = plugin;
    this.emailService = emailService;
    this.fileShareService = fileShareService;
    this.rules = /* @__PURE__ */ new Map();
    this.scheduledJobs = /* @__PURE__ */ new Map();
    this.loadRules();
    this.setupFileWatchers();
  }
  addRule(rule) {
    this.rules.set(rule.id, rule);
    this.saveRules();
    if (rule.enabled && rule.conditions.timeSchedule) {
      this.scheduleRule(rule);
    }
  }
  removeRule(ruleId) {
    this.rules.delete(ruleId);
    this.unscheduleRule(ruleId);
    this.saveRules();
  }
  enableRule(ruleId) {
    const rule = this.rules.get(ruleId);
    if (rule) {
      rule.enabled = true;
      this.saveRules();
      if (rule.conditions.timeSchedule) {
        this.scheduleRule(rule);
      }
    }
  }
  disableRule(ruleId) {
    const rule = this.rules.get(ruleId);
    if (rule) {
      rule.enabled = false;
      this.unscheduleRule(ruleId);
      this.saveRules();
    }
  }
  async triggerRule(ruleId, context) {
    const rule = this.rules.get(ruleId);
    if (!rule || !rule.enabled)
      return;
    try {
      const variables = await this.prepareVariables(rule, context);
      await this.emailService.sendTemplatedEmail(
        rule.recipients,
        rule.templateId,
        variables
      );
      rule.lastTriggered = (/* @__PURE__ */ new Date()).toISOString();
      this.saveRules();
      console.log(`Notification rule "${rule.name}" triggered successfully`);
    } catch (error) {
      console.error(`Failed to trigger rule "${rule.name}":`, error);
    }
  }
  loadRules() {
    const savedRules = this.plugin.settings.notificationRules || [];
    savedRules.forEach((rule) => {
      this.rules.set(rule.id, rule);
      if (rule.enabled && rule.conditions.timeSchedule) {
        this.scheduleRule(rule);
      }
    });
  }
  saveRules() {
    this.plugin.settings.notificationRules = Array.from(this.rules.values());
    this.plugin.saveSettings();
  }
  setupFileWatchers() {
    this.plugin.registerEvent(
      this.plugin.app.vault.on("create", (file) => {
        if (file instanceof import_obsidian5.TFile) {
          this.handleFileEvent("file_created", file);
        }
      })
    );
    this.plugin.registerEvent(
      this.plugin.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian5.TFile) {
          this.handleFileEvent("file_modified", file);
        }
      })
    );
  }
  async handleFileEvent(trigger, file) {
    for (const rule of this.rules.values()) {
      if (rule.enabled && rule.trigger === trigger) {
        if (this.matchesFilePattern(file, rule.conditions.filePattern)) {
          await this.triggerRule(rule.id, { file });
        }
      }
    }
  }
  matchesFilePattern(file, pattern) {
    if (!pattern)
      return true;
    try {
      const regex = new RegExp(pattern, "i");
      return regex.test(file.path) || regex.test(file.basename);
    } catch (e) {
      return file.path.includes(pattern) || file.basename.includes(pattern);
    }
  }
  scheduleRule(rule) {
    if (!rule.conditions.timeSchedule)
      return;
    const schedule = rule.conditions.timeSchedule;
    let interval;
    if (schedule === "daily") {
      interval = 24 * 60 * 60 * 1e3;
    } else if (schedule === "weekly") {
      interval = 7 * 24 * 60 * 60 * 1e3;
    } else {
      return;
    }
    const timeout = setInterval(() => {
      this.triggerRule(rule.id);
    }, interval);
    this.scheduledJobs.set(rule.id, timeout);
  }
  unscheduleRule(ruleId) {
    const timeout = this.scheduledJobs.get(ruleId);
    if (timeout) {
      clearInterval(timeout);
      this.scheduledJobs.delete(ruleId);
    }
  }
  async prepareVariables(rule, context) {
    const variables = {
      ruleName: rule.name,
      triggerTime: (/* @__PURE__ */ new Date()).toLocaleString(),
      vaultName: this.plugin.app.vault.getName()
    };
    if (context?.file) {
      const file = context.file;
      variables.fileName = file.basename;
      variables.filePath = file.path;
      variables.fileSize = this.fileShareService["formatFileSize"](file.stat.size);
    }
    if (rule.trigger === "daily_summary" || rule.trigger === "weekly_report") {
      const summary = await this.fileShareService["generateVaultSummary"](true, true);
      Object.assign(variables, summary);
    }
    return variables;
  }
  destroy() {
    for (const timeout of this.scheduledJobs.values()) {
      clearInterval(timeout);
    }
    this.scheduledJobs.clear();
  }
};
var DEFAULT_EMAIL_TEMPLATES = [
  {
    id: "file_share",
    name: "File Share",
    subject: "Shared file: {{fileName}}",
    htmlTemplate: `
      <h2>File Shared from {{vaultName}}</h2>
      <p><strong>File:</strong> {{fileName}}</p>
      <p><strong>Size:</strong> {{fileSize}}</p>
      <p><strong>Shared on:</strong> {{shareDate}} at {{shareTime}}</p>
      <p><strong>Message:</strong></p>
      <blockquote>{{message}}</blockquote>
      <p>The file is attached to this email.</p>
    `,
    textTemplate: `
File Shared from {{vaultName}}

File: {{fileName}}
Size: {{fileSize}}
Shared on: {{shareDate}} at {{shareTime}}

Message:
{{message}}

The file is attached to this email.
    `,
    variables: ["fileName", "fileSize", "shareDate", "shareTime", "message", "vaultName"]
  },
  {
    id: "multiple_files_share",
    name: "Multiple Files Share",
    subject: "Shared {{fileCount}} files from {{vaultName}}",
    htmlTemplate: `
      <h2>Multiple Files Shared</h2>
      <p><strong>Files ({{fileCount}}):</strong> {{fileNames}}</p>
      <p><strong>Shared on:</strong> {{shareDate}} at {{shareTime}}</p>
      <p><strong>Message:</strong></p>
      <blockquote>{{message}}</blockquote>
      <p>All files are attached to this email.</p>
    `,
    textTemplate: `
Multiple Files Shared

Files ({{fileCount}}): {{fileNames}}
Shared on: {{shareDate}} at {{shareTime}}

Message:
{{message}}

All files are attached to this email.
    `,
    variables: ["fileCount", "fileNames", "shareDate", "shareTime", "message", "vaultName"]
  },
  {
    id: "vault_summary",
    name: "Vault Summary",
    subject: "Daily Summary: {{vaultName}}",
    htmlTemplate: `
      <h2>Vault Summary for {{vaultName}}</h2>
      <p><strong>Date:</strong> {{summaryDate}}</p>
      
      <h3>Statistics</h3>
      <ul>
        <li>Total Files: {{stats.totalFiles}}</li>
        <li>Total Words: {{stats.totalWords}}</li>
        <li>Total Tags: {{stats.totalTags}}</li>
        <li>Average Words per File: {{stats.averageWordsPerFile}}</li>
      </ul>
      
      <h3>Recent Files</h3>
      <ul>
        {{#each recentFiles}}
        <li>{{name}} ({{modified}})</li>
        {{/each}}
      </ul>
    `,
    textTemplate: `
Vault Summary for {{vaultName}}
Date: {{summaryDate}}

Statistics:
- Total Files: {{stats.totalFiles}}
- Total Words: {{stats.totalWords}}
- Total Tags: {{stats.totalTags}}
- Average Words per File: {{stats.averageWordsPerFile}}

Recent Files:
{{#each recentFiles}}
- {{name}} ({{modified}})
{{/each}}
    `,
    variables: ["vaultName", "summaryDate", "stats", "recentFiles"]
  }
];

// src/enhanced-search.ts
var EnhancedSearchEngine = class {
  // 5 minutes
  constructor(plugin, voyageAI, vercelAI) {
    this.plugin = plugin;
    this.voyageAI = voyageAI;
    this.vercelAI = vercelAI;
    this.searchHistory = [];
    this.savedSearches = /* @__PURE__ */ new Map();
    this.searchCache = /* @__PURE__ */ new Map();
    this.cacheTimeout = 5 * 60 * 1e3;
    this.loadSavedSearches();
  }
  async search(options2) {
    const cacheKey = this.generateCacheKey(options2);
    const cached = this.searchCache.get(cacheKey);
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      return cached.results;
    }
    try {
      let results = [];
      switch (options2.searchType) {
        case "semantic":
          results = await this.semanticSearch(options2);
          break;
        case "keyword":
          results = await this.keywordSearch(options2);
          break;
        case "hybrid":
          results = await this.hybridSearch(options2);
          break;
        case "ai_enhanced":
          results = await this.aiEnhancedSearch(options2);
          break;
        default:
          results = await this.hybridSearch(options2);
      }
      if (options2.useRerank && this.voyageAI.isReady()) {
        results = await this.rerankResults(options2.query, results, options2);
      }
      results = this.applyFilters(results, options2);
      results = this.sortResults(results, options2);
      results = results.slice(0, options2.maxResults);
      this.searchCache.set(cacheKey, {
        results,
        timestamp: Date.now()
      });
      this.addToHistory(options2.query, results.length);
      return results;
    } catch (error) {
      console.error("Enhanced search failed:", error);
      throw error;
    }
  }
  async semanticSearch(options2) {
    if (!this.plugin.embeddings) {
      throw new Error("Embeddings not available for semantic search");
    }
    const queryEmbedding = await this.plugin.embeddings.embedQuery(options2.query);
    const ragResults = await this.plugin.ragIntegrator.searchSimilar(queryEmbedding, options2.maxResults * 2);
    return ragResults.map((result, index2) => ({
      id: `semantic_${index2}`,
      title: this.extractTitle(result.text),
      content: result.text,
      score: result.score,
      metadata: {
        type: "node",
        source: "rag",
        highlights: this.extractHighlights(result.text, options2.query)
      }
    }));
  }
  async keywordSearch(options2) {
    const files = this.plugin.app.vault.getMarkdownFiles();
    const results = [];
    const queryWords = options2.query.toLowerCase().split(/\s+/);
    for (const file of files) {
      try {
        const content = await this.plugin.app.vault.read(file);
        const contentLower = content.toLowerCase();
        let score = 0;
        const highlights = [];
        for (const word of queryWords) {
          const matches = (contentLower.match(new RegExp(word, "g")) || []).length;
          score += matches;
          if (matches > 0) {
            highlights.push(...this.findWordContext(content, word));
          }
        }
        if (score > 0) {
          results.push({
            id: `keyword_${file.path}`,
            title: file.basename,
            content: options2.includeContent ? content : this.extractSummary(content),
            file,
            score: score / queryWords.length,
            metadata: {
              type: "file",
              source: "vault",
              path: file.path,
              created: new Date(file.stat.ctime).toISOString(),
              modified: new Date(file.stat.mtime).toISOString(),
              wordCount: content.split(/\s+/).length,
              highlights: highlights.slice(0, 3)
            }
          });
        }
      } catch (error) {
        console.error(`Failed to search file ${file.path}:`, error);
      }
    }
    return results.sort((a, b) => b.score - a.score);
  }
  async hybridSearch(options2) {
    const [semanticResults, keywordResults] = await Promise.all([
      this.semanticSearch(options2).catch(() => []),
      this.keywordSearch(options2)
    ]);
    const combinedResults = /* @__PURE__ */ new Map();
    semanticResults.forEach((result) => {
      combinedResults.set(result.id, {
        ...result,
        finalScore: result.score * 0.7
        // Weight semantic results
      });
    });
    keywordResults.forEach((result) => {
      const existing = combinedResults.get(result.id);
      if (existing) {
        existing.finalScore = (existing.finalScore || existing.score) + result.score * 0.3;
        existing.metadata.highlights = [
          ...existing.metadata.highlights || [],
          ...result.metadata.highlights || []
        ].slice(0, 5);
      } else {
        combinedResults.set(result.id, {
          ...result,
          finalScore: result.score * 0.3
          // Weight keyword results
        });
      }
    });
    return Array.from(combinedResults.values()).sort((a, b) => (b.finalScore || b.score) - (a.finalScore || a.score));
  }
  async aiEnhancedSearch(options2) {
    if (!this.vercelAI.isReady()) {
      return await this.hybridSearch(options2);
    }
    try {
      const provider = this.vercelAI.getProvider();
      const expandedQueries = await provider.generateQuestions(
        `Search query: ${options2.query}`,
        3
      );
      const allResults = [];
      for (const query of [options2.query, ...expandedQueries]) {
        const queryOptions = { ...options2, query };
        const results = await this.hybridSearch(queryOptions);
        allResults.push(...results);
      }
      const uniqueResults = this.deduplicateResults(allResults);
      const analyzedResults = await this.analyzeResultsWithAI(options2.query, uniqueResults);
      return analyzedResults;
    } catch (error) {
      console.error("AI enhanced search failed, falling back to hybrid:", error);
      return await this.hybridSearch(options2);
    }
  }
  async rerankResults(query, results, options2) {
    if (!this.voyageAI.isReady() || results.length === 0) {
      return results;
    }
    try {
      const documents = results.map((r) => r.content);
      const rerankResponse = await this.voyageAI.rerankOnly(query, documents, options2.maxResults);
      if (!rerankResponse)
        return results;
      const rerankedResults = rerankResponse.data.filter((item) => item.relevance_score >= options2.rerankThreshold).map((item) => {
        const originalResult = results[item.index];
        return {
          ...originalResult,
          rerankScore: item.relevance_score,
          finalScore: originalResult.score * 0.3 + item.relevance_score * 0.7
        };
      });
      return rerankedResults.sort((a, b) => (b.finalScore || b.score) - (a.finalScore || a.score));
    } catch (error) {
      console.error("Reranking failed:", error);
      return results;
    }
  }
  async analyzeResultsWithAI(query, results) {
    if (!this.vercelAI.isReady() || results.length === 0) {
      return results;
    }
    try {
      const provider = this.vercelAI.getProvider();
      const analyzedResults = await Promise.all(
        results.map(async (result) => {
          try {
            const analysis = await provider.generateText([
              {
                role: "system",
                content: "You are a search relevance analyzer. Rate the relevance of the given content to the search query on a scale of 0-1."
              },
              {
                role: "user",
                content: `Query: "${query}"

Content: "${result.content.substring(0, 500)}"

Relevance score (0-1):`
              }
            ], { maxTokens: 10 });
            const aiScore = parseFloat(analysis.trim()) || result.score;
            return {
              ...result,
              finalScore: result.score * 0.5 + aiScore * 0.5
            };
          } catch (error) {
            console.error("AI analysis failed for result:", error);
            return result;
          }
        })
      );
      return analyzedResults.sort((a, b) => (b.finalScore || b.score) - (a.finalScore || a.score));
    } catch (error) {
      console.error("AI result analysis failed:", error);
      return results;
    }
  }
  applyFilters(results, options2) {
    let filtered = results;
    if (options2.fileTypes.length > 0) {
      filtered = filtered.filter((result) => {
        if (!result.file)
          return true;
        return options2.fileTypes.includes(result.file.extension);
      });
    }
    if (options2.dateRange) {
      filtered = filtered.filter((result) => {
        if (!result.metadata.modified)
          return true;
        const modifiedDate = new Date(result.metadata.modified);
        return modifiedDate >= options2.dateRange.from && modifiedDate <= options2.dateRange.to;
      });
    }
    if (options2.tags && options2.tags.length > 0) {
      filtered = filtered.filter((result) => {
        if (!result.metadata.tags)
          return false;
        return options2.tags.some((tag) => result.metadata.tags.includes(tag));
      });
    }
    if (options2.folders && options2.folders.length > 0) {
      filtered = filtered.filter((result) => {
        if (!result.metadata.path)
          return false;
        return options2.folders.some((folder) => result.metadata.path.startsWith(folder));
      });
    }
    return filtered;
  }
  sortResults(results, options2) {
    const sorted = [...results];
    sorted.sort((a, b) => {
      let comparison = 0;
      switch (options2.sortBy) {
        case "relevance":
          comparison = (b.finalScore || b.score) - (a.finalScore || a.score);
          break;
        case "date":
          const aDate = new Date(a.metadata.modified || 0).getTime();
          const bDate = new Date(b.metadata.modified || 0).getTime();
          comparison = bDate - aDate;
          break;
        case "title":
          comparison = a.title.localeCompare(b.title);
          break;
        case "size":
          comparison = (b.metadata.wordCount || 0) - (a.metadata.wordCount || 0);
          break;
      }
      return options2.sortOrder === "desc" ? comparison : -comparison;
    });
    return sorted;
  }
  deduplicateResults(results) {
    const seen = /* @__PURE__ */ new Map();
    for (const result of results) {
      const key = result.file?.path || result.title;
      const existing = seen.get(key);
      if (!existing || (result.finalScore || result.score) > (existing.finalScore || existing.score)) {
        seen.set(key, result);
      }
    }
    return Array.from(seen.values());
  }
  // Utility methods
  extractTitle(content) {
    const lines = content.split("\n");
    const firstHeading = lines.find((line) => line.startsWith("#"));
    if (firstHeading) {
      return firstHeading.replace(/^#+\s*/, "");
    }
    return content.substring(0, 50).trim() + "...";
  }
  extractSummary(content, maxLength = 200) {
    const cleaned = content.replace(/#+\s*/g, "").replace(/\n+/g, " ").trim();
    return cleaned.length > maxLength ? cleaned.substring(0, maxLength) + "..." : cleaned;
  }
  extractHighlights(content, query) {
    const words = query.toLowerCase().split(/\s+/);
    const highlights = [];
    for (const word of words) {
      const contexts = this.findWordContext(content, word);
      highlights.push(...contexts);
    }
    return highlights.slice(0, 3);
  }
  findWordContext(content, word, contextLength = 50) {
    const regex = new RegExp(`\\b${word}\\b`, "gi");
    const matches = [];
    let match;
    while ((match = regex.exec(content)) !== null && matches.length < 2) {
      const start = Math.max(0, match.index - contextLength);
      const end = Math.min(content.length, match.index + word.length + contextLength);
      const context = content.substring(start, end);
      matches.push(context.trim());
    }
    return matches;
  }
  generateCacheKey(options2) {
    return JSON.stringify({
      query: options2.query,
      searchType: options2.searchType,
      useRerank: options2.useRerank,
      fileTypes: options2.fileTypes,
      tags: options2.tags,
      folders: options2.folders
    });
  }
  addToHistory(query, resultCount) {
    this.searchHistory.unshift({
      query,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      resultCount
    });
    this.searchHistory = this.searchHistory.slice(0, 100);
    this.saveSearchHistory();
  }
  // Saved searches management
  saveSearch(name, query, options2, filters = []) {
    const savedSearch = {
      id: `search_${Date.now()}`,
      name,
      query,
      options: options2,
      filters,
      created: (/* @__PURE__ */ new Date()).toISOString(),
      lastUsed: (/* @__PURE__ */ new Date()).toISOString(),
      useCount: 0
    };
    this.savedSearches.set(savedSearch.id, savedSearch);
    this.saveSavedSearches();
  }
  getSavedSearches() {
    return Array.from(this.savedSearches.values()).sort((a, b) => new Date(b.lastUsed).getTime() - new Date(a.lastUsed).getTime());
  }
  async executeSavedSearch(searchId) {
    const savedSearch = this.savedSearches.get(searchId);
    if (!savedSearch) {
      throw new Error("Saved search not found");
    }
    savedSearch.lastUsed = (/* @__PURE__ */ new Date()).toISOString();
    savedSearch.useCount++;
    this.saveSavedSearches();
    return await this.search(savedSearch.options);
  }
  deleteSavedSearch(searchId) {
    this.savedSearches.delete(searchId);
    this.saveSavedSearches();
  }
  getSearchHistory() {
    return this.searchHistory;
  }
  clearSearchHistory() {
    this.searchHistory = [];
    this.saveSearchHistory();
  }
  // Persistence methods
  loadSavedSearches() {
    const saved = this.plugin.settings.savedSearches || [];
    saved.forEach((search) => {
      this.savedSearches.set(search.id, search);
    });
  }
  saveSavedSearches() {
    this.plugin.settings.savedSearches = Array.from(this.savedSearches.values());
    this.plugin.saveSettings();
  }
  saveSearchHistory() {
    this.plugin.settings.searchHistory = this.searchHistory;
    this.plugin.saveSettings();
  }
  // Analytics
  getSearchAnalytics() {
    const queryCount = /* @__PURE__ */ new Map();
    let totalResults = 0;
    this.searchHistory.forEach((search) => {
      queryCount.set(search.query, (queryCount.get(search.query) || 0) + 1);
      totalResults += search.resultCount;
    });
    const topQueries = Array.from(queryCount.entries()).map(([query, count]) => ({ query, count })).sort((a, b) => b.count - a.count).slice(0, 10);
    return {
      totalSearches: this.searchHistory.length,
      topQueries,
      averageResults: this.searchHistory.length > 0 ? totalResults / this.searchHistory.length : 0,
      searchTypes: {
        semantic: 0,
        keyword: 0,
        hybrid: 0,
        ai_enhanced: 0
      }
    };
  }
  clearCache() {
    this.searchCache.clear();
  }
  destroy() {
    this.clearCache();
  }
};

// src/search-results-modal.ts
var import_obsidian6 = require("obsidian");
var SearchResultsModal = class extends import_obsidian6.Modal {
  constructor(app, results) {
    super(app);
    this.results = results;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: `Search Results (${this.results.length})` });
    if (this.results.length === 0) {
      contentEl.createEl("p", { text: "No results found." });
      return;
    }
    const resultsContainer = contentEl.createEl("div", { cls: "search-results-container" });
    this.results.forEach((result, index2) => {
      const resultEl = resultsContainer.createEl("div", { cls: "search-result-item" });
      const header = resultEl.createEl("div", { cls: "result-header" });
      const title = header.createEl("h3", { text: result.title, cls: "result-title" });
      if (result.file) {
        title.onclick = async () => {
          const leaf = this.app.workspace.getLeaf("tab");
          await leaf.openFile(result.file);
          this.close();
        };
        title.style.cursor = "pointer";
        title.style.color = "var(--text-accent)";
      }
      const scoreEl = header.createEl("span", { cls: "result-score" });
      if (result.rerankScore !== void 0) {
        scoreEl.setText(`Score: ${result.score.toFixed(3)} | Rerank: ${result.rerankScore.toFixed(3)}`);
      } else {
        scoreEl.setText(`Score: ${result.score.toFixed(3)}`);
      }
      const contentEl2 = resultEl.createEl("div", { cls: "result-content" });
      const preview = result.content.length > 200 ? result.content.substring(0, 200) + "..." : result.content;
      contentEl2.setText(preview);
      if (result.metadata.highlights && result.metadata.highlights.length > 0) {
        const highlightsEl = resultEl.createEl("div", { cls: "result-highlights" });
        highlightsEl.createEl("strong", { text: "Highlights: " });
        result.metadata.highlights.forEach((highlight) => {
          highlightsEl.createEl("span", {
            text: `"${highlight}" `,
            cls: "highlight-snippet"
          });
        });
      }
      if (result.metadata.path) {
        const pathEl = resultEl.createEl("div", { cls: "result-path" });
        pathEl.setText(`Path: ${result.metadata.path}`);
      }
    });
    const buttonContainer = contentEl.createEl("div", { cls: "modal-button-container" });
    buttonContainer.createEl("button", { text: "Close" }).onclick = () => this.close();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  projectInstructionsPath: "ai-mcp-instructions.json",
  mistralApiKey: "",
  qdrantUrl: "http://localhost:6333",
  qdrantApiKey: "",
  cloudflareAccountId: "",
  cloudflareApiToken: "",
  enableCloudflareRag: false,
  defaultRole: "assistant",
  customCloudEndpoint: "",
  customCloudApiKey: "",
  enableCustomCloudSync: false,
  // Voyage AI settings
  voyageApiKey: "",
  voyageModel: "voyage-large-2",
  enableVoyageRerank: false,
  // Vercel AI settings
  vercelProviders: [],
  defaultAIProvider: "mistral",
  // Email settings
  emailConfig: {
    smtpHost: "",
    smtpPort: 587,
    secure: false,
    username: "",
    password: "",
    fromEmail: "",
    fromName: "Obsidian AI MCP"
  },
  emailTemplates: DEFAULT_EMAIL_TEMPLATES,
  notificationRules: [],
  // Dashboard settings
  dashboardWidgets: [],
  // Enhanced search settings
  searchHistory: [],
  savedSearches: [],
  defaultSearchType: "hybrid",
  enableSearchRerank: false,
  rerankThreshold: 0.1
};
var DEFAULT_INSTRUCTIONS = {
  project_name: "Obsidian AI MCP Plugin",
  ai_behavior: {
    default_provider: "mistral",
    preferred_models: { mistral: ["mistral-embed"] },
    tone: "professional",
    language: "th, en",
    max_response_length: 2e3,
    context_sources: ["memory_graph", "rag_vault"],
    fallback_providers: ["local"],
    roles: {
      assistant: "Helpful assistant recalling vault context via graph.",
      planner: "Plan tasks using temporal edges in memory graph.",
      researcher: "Search meanings/similarities with Qdrant vectors."
    }
  },
  mcp_config: {
    memory_graph: {
      storage: "json",
      file_path: "memory-graph.json",
      schema_version: "1.0.0",
      max_nodes: 1e4,
      vault_integration: {
        enabled: true,
        scan_interval: 6e5,
        file_types: [".md"],
        max_file_size: 1048576
      }
    },
    encrypted_graph_sync: {
      enabled: true,
      encryption_key: "vault-derived",
      sync_protocol: "ws-encrypted",
      max_sync_batch: 100,
      conflict_resolution: "last-modified"
    },
    planning_agent: {
      task_format: "craft_clickup",
      max_tasks: 500
    }
  },
  rag_config: {
    vector_store: "qdrant",
    embedding_model: "mistral-embed",
    chunk_size: 500,
    top_k: 5,
    qdrant_config: {
      local_enabled: true,
      collection_name: "obsidian_rag"
    },
    cloudflare_config: {
      enabled: true,
      index_name: "obsidian-vectors",
      sync_only: true
    }
  },
  sync_config: {
    server_port: 8080,
    sync_interval: 3e5,
    data_types: ["vectors", "memory", "tasks"]
  }
};
var _ChatView = class _ChatView extends import_obsidian7.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.mode = "ask";
    this.contextNote = null;
    this.roles = {};
  }
  getViewType() {
    return _ChatView.VIEW_TYPE;
  }
  getDisplayText() {
    return "AI MCP Chat";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("ai-mcp-chat-container");
    this.roles = await this.plugin.loadRolesFromVault();
    container.createEl("div", { cls: "ai-mcp-header" }, (header) => {
      const select = header.createEl("select", {
        cls: "ai-mcp-mode-select",
        attr: { "aria-label": "Chat Mode" }
      });
      Object.keys(this.roles).forEach((role) => {
        const option = select.createEl("option", {
          text: role.charAt(0).toUpperCase() + role.slice(1),
          value: role
        });
        if (role === this.mode) {
          option.setAttribute("selected", "selected");
        }
      });
      select.onchange = (e) => this.setMode(e.target.value);
      header.createEl("button", {
        cls: "role-manage-btn",
        text: "\u2699\uFE0F",
        attr: { "aria-label": "Manage Roles" }
      }).onclick = () => this.openRoleManagementModal();
      if (import_obsidian7.Platform.isMobile) {
        header.createEl("button", {
          cls: "ai-mcp-context-toggle",
          text: "CTX"
        }).onclick = () => this.toggleContextPanel();
      }
    });
    const contextPanel = container.createEl("div", {
      cls: `ai-mcp-context-panel ${import_obsidian7.Platform.isMobile ? "mobile-hidden" : ""}`
    });
    const messagesContainer = container.createEl("div", { cls: "ai-mcp-messages" });
    container.createEl("div", { cls: "ai-mcp-input-area" }, (inputArea) => {
      const textarea = inputArea.createEl("textarea", {
        cls: "ai-mcp-input",
        attr: { placeholder: "Ask something..." }
      });
      const sendBtn = inputArea.createEl("button", {
        cls: "ai-mcp-send",
        text: "Send"
      });
      sendBtn.onclick = () => this.sendMessage();
      textarea.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          this.sendMessage();
        }
      });
    });
    container.createEl("div", { cls: "ai-mcp-suggestions" }, (suggestions) => {
      suggestions.createEl("div", {
        cls: "suggestion-item",
        text: "What's my next task?"
      }).onclick = () => this.fillInput("What's my next task?");
      suggestions.createEl("div", {
        cls: "suggestion-item",
        text: "Summarize this note"
      }).onclick = () => this.fillInput("Summarize this note");
      suggestions.createEl("div", {
        cls: "suggestion-item",
        text: "Search similar content"
      }).onclick = () => this.fillInput("Search similar content");
    });
    container.createEl("div", { cls: "ai-mcp-export-controls" }, (exportControls) => {
      exportControls.createEl("button", {
        text: "Export Graph",
        cls: "export-btn graph"
      }).onclick = () => this.plugin.exportData("graph");
      exportControls.createEl("button", {
        text: "Export Vectors",
        cls: "export-btn vectors"
      }).onclick = () => this.plugin.exportData("vectors");
      if (this.plugin.settings.enableCustomCloudSync) {
        exportControls.createEl("button", {
          text: "Sync to Cloud",
          cls: "export-btn cloud mod-cta"
        }).onclick = () => this.syncToUserCloud();
      }
    });
    await this.updateContextFromActiveNote();
  }
  fillInput(text) {
    const input = this.containerEl.querySelector(".ai-mcp-input");
    if (input) {
      input.value = text;
      input.focus();
    }
  }
  setMode(mode) {
    this.mode = mode;
    const systemPrompt = this.roles[mode] || this.plugin.projectInstructions.ai_behavior.roles[mode];
    new import_obsidian7.Notice(`Switched to ${mode} mode: ${systemPrompt.substring(0, 50)}...`);
  }
  toggleContextPanel() {
    const panel = this.containerEl.querySelector(".ai-mcp-context-panel");
    if (panel) {
      if (panel.hasClass("mobile-hidden")) {
        panel.removeClass("mobile-hidden");
      } else {
        panel.addClass("mobile-hidden");
      }
    }
  }
  openRoleManagementModal() {
    new RoleManagementModal(this.app, this.plugin, () => {
      this.refreshRoles();
    }).open();
  }
  async refreshRoles() {
    this.roles = await this.plugin.loadRolesFromVault();
    this.updateRoleDropdown();
  }
  updateRoleDropdown() {
    const select = this.containerEl.querySelector(".ai-mcp-mode-select");
    if (select) {
      select.innerHTML = "";
      Object.keys(this.roles).forEach((role) => {
        const option = select.createEl("option", {
          text: role.charAt(0).toUpperCase() + role.slice(1),
          value: role
        });
        if (role === this.mode) {
          option.setAttribute("selected", "selected");
        }
      });
    }
  }
  async updateContextFromActiveNote() {
    const activeFile = this.plugin.app.workspace.getActiveFile();
    if (activeFile) {
      this.contextNote = activeFile;
      const content = await this.plugin.app.vault.read(activeFile);
      const context = this.extractRelevantContext(content, activeFile);
      const contextPanel = this.containerEl.querySelector(".ai-mcp-context-panel");
      if (contextPanel) {
        contextPanel.empty();
        contextPanel.createEl("h4", { text: "Current Context:" });
        contextPanel.createEl("div", {
          cls: "context-content",
          text: context.substring(0, 200) + "..."
        });
      }
    }
  }
  extractRelevantContext(content, file) {
    const cache = this.plugin.app.metadataCache.getFileCache(file);
    const resolvedLinks = this.plugin.app.metadataCache.resolvedLinks;
    let context = content;
    if (resolvedLinks && resolvedLinks[file.path]) {
      const linkedFiles = Object.keys(resolvedLinks[file.path]).slice(0, 3);
      for (const linkedPath of linkedFiles) {
        const linkedFile = this.plugin.app.vault.getAbstractFileByPath(linkedPath);
        if (linkedFile instanceof import_obsidian7.TFile) {
          context += "\n\n[RELATED: " + linkedFile.name + "]\n" + content.substring(0, 200);
        }
      }
    }
    return context;
  }
  async sendMessage() {
    const input = this.containerEl.querySelector(".ai-mcp-input");
    if (!input?.value.trim())
      return;
    const messagesEl = this.containerEl.querySelector(".ai-mcp-messages");
    if (messagesEl) {
      messagesEl.createEl("div", { cls: "message user" }, (msg) => {
        msg.createEl("div", { cls: "message-content", text: input.value });
        msg.createEl("div", { cls: "message-time", text: (/* @__PURE__ */ new Date()).toLocaleTimeString() });
      });
      const userQuery = input.value;
      input.value = "";
      const botMsg = messagesEl.createEl("div", { cls: "message bot" }, (msg) => {
        msg.createEl("div", { cls: "message-content loading", text: "\u0E01\u0E33\u0E25\u0E31\u0E07\u0E04\u0E34\u0E14..." });
      });
      messagesEl.scrollTop = messagesEl.scrollHeight;
      try {
        const response = await this.getAIResponse(userQuery);
        const contentEl = botMsg.querySelector(".message-content");
        if (contentEl) {
          contentEl.removeClass("loading");
          contentEl.setText(response);
        }
        botMsg.createEl("div", { cls: "message-time", text: (/* @__PURE__ */ new Date()).toLocaleTimeString() });
      } catch (e) {
        const contentEl = botMsg.querySelector(".message-content");
        if (contentEl) {
          contentEl.removeClass("loading");
          contentEl.addClass("error");
          contentEl.setText("Error: " + e.message);
        }
      }
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }
  }
  async getAIResponse(query) {
    const context = this.contextNote ? await this.plugin.app.vault.read(this.contextNote) : "";
    switch (this.mode) {
      case "ask":
        if (this.plugin.embeddings) {
          const embedding = await this.plugin.embeddings.embedQuery(query);
          const results = await this.plugin.ragIntegrator.searchSimilar(embedding);
          return results.length > 0 ? `Based on your vault: ${results[0].text}` : "No relevant information found in your vault.";
        }
        return "Please configure Mistral API key first.";
      case "planning":
        return await this.plugin.planningAgent.planWithRole(this.mode, query);
      case "agent":
        return `As ${this.mode} agent analyzing: "${query}"

Context: ${context.substring(0, 200)}...

I'm processing your request using the full capabilities of your vault's knowledge graph.`;
      default:
        return "Unknown mode selected.";
    }
  }
  async syncToUserCloud() {
    try {
      await this.plugin.exportData("graph", true);
      await this.plugin.exportData("vectors", true);
      new import_obsidian7.Notice("Full data synced to your cloud service");
    } catch (e) {
      new import_obsidian7.Notice("Sync failed: " + e.message);
    }
  }
};
_ChatView.VIEW_TYPE = "ai-mcp-chat";
var ChatView = _ChatView;
var RoleManagementModal = class extends import_obsidian7.Modal {
  constructor(app, plugin, onRoleChange) {
    super(app);
    this.plugin = plugin;
    this.onRoleChange = onRoleChange;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Manage AI Roles" });
    this.displayRoles();
    contentEl.createEl("button", {
      text: "Add New Role",
      cls: "mod-cta"
    }).onclick = () => this.addNewRole();
  }
  async displayRoles() {
    const roles = await this.plugin.loadRolesFromVault();
    const rolesList = this.contentEl.createEl("div", { cls: "role-list" });
    Object.entries(roles).forEach(([name, prompt2]) => {
      const roleItem = rolesList.createEl("div", { cls: "role-item" });
      roleItem.createEl("h3", { text: name });
      roleItem.createEl("div", {
        cls: "prompt-preview",
        text: prompt2.substring(0, 100) + (prompt2.length > 100 ? "..." : "")
      });
      const actions = roleItem.createEl("div", { cls: "role-actions" });
      actions.createEl("button", { text: "Edit" }).onclick = () => this.editRole(name, prompt2);
      actions.createEl("button", { text: "Export" }).onclick = () => this.exportRole(name);
      actions.createEl("button", { text: "Delete" }).onclick = () => this.deleteRole(name);
    });
  }
  async addNewRole() {
    const name = prompt("Enter role name:");
    if (!name)
      return;
    const rolePrompt = prompt(
      "Enter system prompt for this role:",
      "You are a helpful AI assistant."
    );
    if (!rolePrompt)
      return;
    await this.plugin.app.vault.create(
      `AI Roles/${name}.md`,
      rolePrompt
    );
    this.onRoleChange();
    this.close();
  }
  async editRole(name, currentPrompt) {
    const newPrompt = prompt("Edit system prompt:", currentPrompt);
    if (!newPrompt || newPrompt === currentPrompt)
      return;
    const file = this.plugin.app.vault.getAbstractFileByPath(`AI Roles/${name}.md`);
    if (file instanceof import_obsidian7.TFile) {
      await this.plugin.app.vault.modify(file, newPrompt);
      this.onRoleChange();
      this.close();
    }
  }
  async exportRole(name) {
    const file = this.plugin.app.vault.getAbstractFileByPath(`AI Roles/${name}.md`);
    if (!file || !(file instanceof import_obsidian7.TFile))
      return;
    const content = await this.plugin.app.vault.read(file);
    const blob = new Blob([content], { type: "text/markdown" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${name}-role-template.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  async deleteRole(name) {
    if (!confirm(`Delete role "${name}"?`))
      return;
    const file = this.plugin.app.vault.getAbstractFileByPath(`AI Roles/${name}.md`);
    if (file instanceof import_obsidian7.TFile) {
      await this.plugin.app.vault.delete(file);
      this.onRoleChange();
      this.close();
    }
  }
};
var MemoryGraph = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async addNode(nodeData, embedding) {
    const node = {
      id: (0, import_uuid.v4)(),
      type: nodeData.type || "context",
      content: nodeData.content || "",
      summary: nodeData.summary || nodeData.content?.substring(0, 100) || "",
      timestamp: {
        created_at: (/* @__PURE__ */ new Date()).toISOString(),
        updated_at: (/* @__PURE__ */ new Date()).toISOString(),
        valid_from: (/* @__PURE__ */ new Date()).toISOString(),
        valid_until: null
      },
      confidence: nodeData.confidence || 0.8,
      sources: nodeData.sources || [],
      embeddings: embedding || [],
      attributes: nodeData.attributes || {},
      group_id: nodeData.group_id || "default",
      version: 1,
      properties: nodeData.properties || {}
    };
    const graph = await this.load();
    graph.nodes.push(node);
    await this.save(graph);
    return node.id;
  }
  async load() {
    const path = this.plugin.projectInstructions.mcp_config.memory_graph.file_path;
    try {
      if (await this.plugin.app.vault.adapter.exists(path)) {
        const content = await this.plugin.app.vault.adapter.read(path);
        return JSON.parse(content);
      }
    } catch (e) {
      console.error("Failed to load graph:", e);
    }
    return this.createEmptyGraph();
  }
  async save(graph) {
    const path = this.plugin.projectInstructions.mcp_config.memory_graph.file_path;
    graph.graph_metadata.last_sync = (/* @__PURE__ */ new Date()).toISOString();
    graph.graph_metadata.total_nodes = graph.nodes.length;
    graph.graph_metadata.total_edges = graph.edges.length;
    await this.plugin.app.vault.adapter.write(path, JSON.stringify(graph, null, 2));
  }
  createEmptyGraph() {
    return {
      schema_version: "1.0.0",
      graph_metadata: {
        total_nodes: 0,
        total_edges: 0,
        last_sync: (/* @__PURE__ */ new Date()).toISOString(),
        device_id: (0, import_uuid.v4)(),
        version: 1
      },
      nodes: [],
      edges: []
    };
  }
};
var RAGIntegrator = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async searchSimilar(queryEmbedding, limit = 5) {
    if (!this.plugin.qdrantClient)
      return [];
    try {
      const result = await this.plugin.qdrantClient.search(
        this.plugin.projectInstructions.rag_config.qdrant_config.collection_name,
        {
          vector: queryEmbedding,
          limit,
          with_payload: true
        }
      );
      return result.map((point) => ({
        text: point.payload?.text || "",
        score: point.score || 0
      }));
    } catch (e) {
      console.error("Search failed:", e);
      return [];
    }
  }
  async upsertToQdrant(id, vector, text) {
    if (!this.plugin.qdrantClient)
      return;
    try {
      await this.plugin.qdrantClient.upsert(
        this.plugin.projectInstructions.rag_config.qdrant_config.collection_name,
        {
          points: [{
            id,
            vector,
            payload: { text }
          }]
        }
      );
    } catch (e) {
      console.error("Upsert failed:", e);
    }
  }
  async exportVectors() {
    if (!this.plugin.qdrantClient)
      return [];
    try {
      const result = await this.plugin.qdrantClient.scroll(
        this.plugin.projectInstructions.rag_config.qdrant_config.collection_name,
        { limit: 1e4, with_payload: true, with_vector: true }
      );
      return result.points;
    } catch (e) {
      console.error("Export failed:", e);
      return [];
    }
  }
  async importVectors(points) {
    if (!this.plugin.qdrantClient)
      return;
    try {
      await this.plugin.qdrantClient.upsert(
        this.plugin.projectInstructions.rag_config.qdrant_config.collection_name,
        { points }
      );
    } catch (e) {
      console.error("Import failed:", e);
    }
  }
};
var PlanningAgent = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async planWithRole(role, query) {
    const graph = await this.plugin.memoryGraph.load();
    const systemPrompt = this.plugin.projectInstructions.ai_behavior.roles[role];
    const tasks = graph.nodes.filter((n) => n.type === "task").slice(0, this.plugin.projectInstructions.mcp_config.planning_agent.max_tasks);
    const plan = `Planning as ${role}:

Query: ${query || "General planning"}

System: ${systemPrompt}

Available tasks: ${tasks.map((t) => t.content).join("; ")}

Recommended next steps based on your vault's knowledge graph.`;
    const planFile = `plan-${role}-${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.md`;
    await this.plugin.app.vault.create(planFile, plan);
    return plan;
  }
};
var AIMCPPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.qdrantClient = null;
    this.lastHashes = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    this.memoryGraph = new MemoryGraph(this);
    this.ragIntegrator = new RAGIntegrator(this);
    this.planningAgent = new PlanningAgent(this);
    this.performanceOptimizer = new PerformanceOptimizer(this);
    this.advancedFeatures = new AdvancedFeatures(this);
    this.voyageAI = new VoyageAIIntegration(this);
    this.vercelAI = new VercelAIIntegration(this);
    this.emailService = new EmailService(this);
    this.fileShareService = new FileShareService(this, this.emailService);
    this.notificationManager = new NotificationManager(this, this.emailService, this.fileShareService);
    this.enhancedSearch = new EnhancedSearchEngine(this, this.voyageAI, this.vercelAI);
    await this.initializeIntegrations();
    await this.loadProjectInstructions();
    if (this.settings.mistralApiKey) {
      this.embeddings = new import_mistralai.MistralAIEmbeddings({
        apiKey: this.settings.mistralApiKey
      });
    }
    this.registerEvent(
      this.app.vault.on("modify", (file) => this.handleFileChange(file))
    );
    this.registerEvent(
      this.app.vault.on("create", (file) => this.handleFileChange(file))
    );
    this.registerView(
      ChatView.VIEW_TYPE,
      (leaf) => new ChatView(leaf, this)
    );
    this.registerView(
      DashboardView.VIEW_TYPE,
      (leaf) => new DashboardView(leaf, this)
    );
    this.addCommand({
      id: "open-ai-chat",
      name: "Open AI Chat Interface",
      callback: () => this.openRoleChat()
    });
    this.addCommand({
      id: "initialize-vault-memory",
      name: "Initialize Vault Memory (Full Scan)",
      callback: () => this.initializeVault()
    });
    this.addCommand({
      id: "add-markdown-context",
      name: "Add Markdown as Context to Graph",
      editorCallback: (editor) => this.addMarkdownContext(editor.getValue())
    });
    this.addCommand({
      id: "test-vault-recall",
      name: "Test Vault Recall",
      callback: () => this.testRecall()
    });
    this.addCommand({
      id: "export-graph",
      name: "Export Memory Graph",
      callback: () => this.exportData("graph")
    });
    this.addCommand({
      id: "import-graph",
      name: "Import Memory Graph",
      callback: () => this.importData("graph")
    });
    this.addCommand({
      id: "visualize-graph",
      name: "Visualize Memory Graph",
      callback: () => this.visualizeInGraphView()
    });
    this.addCommand({
      id: "plan-tasks",
      name: "Plan Tasks with Role",
      callback: () => this.planningAgent.planWithRole(this.settings.defaultRole)
    });
    this.addCommand({
      id: "import-role-template",
      name: "Import Role Template from Markdown",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file && file.extension === "md") {
          await this.importRoleFromMarkdown(file);
        } else {
          new import_obsidian7.Notice("Please open a markdown file first");
        }
      }
    });
    this.addCommand({
      id: "show-smart-suggestions",
      name: "Show Smart Suggestions",
      callback: async () => {
        const suggestions = await this.advancedFeatures.generateSmartSuggestions();
        new SmartSuggestionsModal(this, suggestions).open();
      }
    });
    this.addCommand({
      id: "auto-tag-current-note",
      name: "Auto-tag Current Note",
      callback: async () => {
        const file = this.app.workspace.getActiveFile();
        if (file && file.extension === "md") {
          const content = await this.app.vault.read(file);
          const tags = await this.advancedFeatures.autoTagContent(file, content);
          if (tags.length > 0) {
            const tagString = tags.map((tag) => `#${tag}`).join(" ");
            await this.app.vault.modify(file, content + "\n\n" + tagString);
            new import_obsidian7.Notice(`Added ${tags.length} tags to current note`);
          } else {
            new import_obsidian7.Notice("No suitable tags found");
          }
        } else {
          new import_obsidian7.Notice("Please open a markdown file first");
        }
      }
    });
    this.addCommand({
      id: "optimize-memory-usage",
      name: "Optimize Memory Usage",
      callback: async () => {
        await this.performanceOptimizer.optimizeMemoryUsage();
        const stats = this.performanceOptimizer.getCacheStats();
        new import_obsidian7.Notice(`Memory optimized. Cache: ${stats.size} items, Hit rate: ${(stats.hitRate * 100).toFixed(1)}%`);
      }
    });
    this.addCommand({
      id: "smart-search",
      name: "Smart Search",
      callback: () => {
        const query = prompt("Enter search query:");
        if (query) {
          this.performSmartSearch(query);
        }
      }
    });
    this.addCommand({
      id: "open-dashboard",
      name: "Open AI MCP Dashboard",
      callback: () => this.openDashboard()
    });
    this.addCommand({
      id: "enhanced-search",
      name: "Enhanced Search with Rerank",
      callback: () => this.openEnhancedSearch()
    });
    this.addCommand({
      id: "share-file-email",
      name: "Share Current File via Email",
      callback: () => this.shareCurrentFileViaEmail()
    });
    this.addCommand({
      id: "send-vault-summary",
      name: "Send Vault Summary via Email",
      callback: () => this.sendVaultSummaryEmail()
    });
    this.addCommand({
      id: "test-ai-providers",
      name: "Test AI Providers",
      callback: () => this.testAIProviders()
    });
    this.addRibbonIcon("brain", "AI Chat with Role", () => this.openRoleChat());
    this.addRibbonIcon("layout-dashboard", "AI MCP Dashboard", () => this.openDashboard());
    this.addSettingTab(new AIMCPSettingTab(this.app, this));
    new import_obsidian7.Notice("AI MCP Plugin loaded! \u{1F9E0}");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadProjectInstructions() {
    try {
      const path = this.settings.projectInstructionsPath;
      if (await this.app.vault.adapter.exists(path)) {
        const content = await this.app.vault.adapter.read(path);
        this.projectInstructions = JSON.parse(content);
      } else {
        await this.app.vault.adapter.write(
          path,
          JSON.stringify(DEFAULT_INSTRUCTIONS, null, 2)
        );
        this.projectInstructions = DEFAULT_INSTRUCTIONS;
      }
      this.initQdrant();
    } catch (e) {
      console.error("Failed to load instructions:", e);
      this.projectInstructions = DEFAULT_INSTRUCTIONS;
    }
  }
  initQdrant() {
    if (!this.settings.qdrantUrl)
      return;
    this.qdrantClient = new import_js_client_rest.QdrantClient({
      url: this.settings.qdrantUrl,
      apiKey: this.settings.qdrantApiKey || void 0
    });
    const config = this.projectInstructions.rag_config.qdrant_config;
    this.qdrantClient.createCollection(config.collection_name, {
      vectors: { size: 1024, distance: "Cosine" }
    }).catch(() => {
    });
  }
  async loadRolesFromVault() {
    const roleFolder = "AI Roles";
    const roles = {};
    if (!await this.app.vault.adapter.exists(roleFolder)) {
      await this.app.vault.createFolder(roleFolder);
    }
    try {
      const files = await this.app.vault.adapter.list(roleFolder);
      for (const file of files.files) {
        if (file.endsWith(".md")) {
          const roleName = file.split("/").pop()?.replace(".md", "") || "";
          const content = await this.app.vault.adapter.read(file);
          roles[roleName] = content;
        }
      }
    } catch (e) {
      console.error("Failed to load roles:", e);
    }
    if (Object.keys(roles).length === 0) {
      const defaultRoles = {
        "assistant": "Helpful assistant recalling vault context via graph.",
        "planner": "Plan tasks using temporal edges in memory graph.",
        "researcher": "Search meanings/similarities with Qdrant vectors."
      };
      for (const [name, prompt2] of Object.entries(defaultRoles)) {
        await this.app.vault.create(`${roleFolder}/${name}.md`, prompt2);
        roles[name] = prompt2;
      }
    }
    return roles;
  }
  async handleFileChange(file) {
    if (file.extension !== "md")
      return;
    if (!this.embeddings)
      return;
    this.performanceOptimizer.debounceFileProcessing(file);
  }
  hashContent(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString();
  }
  async initializeVault() {
    if (!this.embeddings) {
      new import_obsidian7.Notice("Please set Mistral API key first");
      return;
    }
    const files = this.app.vault.getMarkdownFiles().filter((f) => f.stat.size <= this.projectInstructions.mcp_config.memory_graph.vault_integration.max_file_size);
    let processed = 0;
    for (const file of files) {
      try {
        const content = await this.app.vault.read(file);
        await this.ingestFileToRAG(file, content);
        processed++;
        if (processed % 10 === 0) {
          new import_obsidian7.Notice(`Processed ${processed}/${files.length} files...`);
        }
      } catch (e) {
        console.error(`Failed to process ${file.path}:`, e);
      }
    }
    new import_obsidian7.Notice(`Initialized ${processed} files to RAG/Graph.`);
  }
  async ingestFileToRAG(file, content) {
    if (!this.embeddings)
      return;
    const chunks = this.chunkText(content, this.projectInstructions.rag_config.chunk_size);
    for (const chunk of chunks) {
      try {
        const embedding = await this.embeddings.embedQuery(chunk);
        const nodeId = await this.memoryGraph.addNode({
          type: "markdown",
          content: chunk,
          sources: [{
            type: "rag_vault",
            id: file.path,
            description: file.name
          }]
        }, embedding);
        await this.ragIntegrator.upsertToQdrant(nodeId, embedding, chunk);
      } catch (e) {
        console.error(`Failed to process chunk from ${file.path}:`, e);
      }
    }
  }
  chunkText(text, size) {
    const chunks = [];
    for (let i = 0; i < text.length; i += size) {
      chunks.push(text.substring(i, i + size));
    }
    return chunks;
  }
  async addMarkdownContext(markdown) {
    if (!this.embeddings) {
      new import_obsidian7.Notice("Please set Mistral API key first");
      return;
    }
    try {
      const embedding = await this.embeddings.embedQuery(markdown);
      const nodeId = await this.memoryGraph.addNode({
        type: "context",
        content: markdown,
        sources: [{
          type: "user_input",
          id: "manual",
          description: "Manual Markdown"
        }]
      }, embedding);
      new import_obsidian7.Notice(`Added Markdown context as node ${nodeId}.`);
    } catch (e) {
      new import_obsidian7.Notice("Failed to add context: " + e.message);
    }
  }
  async testRecall() {
    if (!this.embeddings) {
      new import_obsidian7.Notice("Please set Mistral API key first");
      return;
    }
    const graph = await this.memoryGraph.load();
    if (graph.nodes.length === 0) {
      new import_obsidian7.Notice("No nodes. Initialize first.");
      return;
    }
    const randomNode = graph.nodes[Math.floor(Math.random() * graph.nodes.length)];
    const queryEmbedding = await this.embeddings.embedQuery(
      randomNode.content.substring(0, 50)
    );
    const results = await this.ragIntegrator.searchSimilar(queryEmbedding, 1);
    const score = results[0]?.score || 0;
    const pass = score > 0.7;
    console.log({
      groundTruth: randomNode.content,
      score,
      pass
    });
    new import_obsidian7.Notice(`Recall Test: ${pass ? "PASS" : "FAIL"} (Score: ${score.toFixed(2)})`);
  }
  async exportData(type, toCloud = false) {
    if (toCloud && this.settings.enableCustomCloudSync) {
      return await this.exportToCustomCloud(type);
    }
    const data = type === "graph" ? await this.memoryGraph.load() : await this.ragIntegrator.exportVectors();
    const blob = new Blob([JSON.stringify(data, null, 2)], {
      type: "application/json"
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${type}-export-${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  async exportToCustomCloud(type) {
    if (!this.settings.enableCustomCloudSync || !this.settings.customCloudEndpoint) {
      new import_obsidian7.Notice("Custom cloud sync not configured");
      return false;
    }
    try {
      const data = type === "graph" ? await this.memoryGraph.load() : await this.ragIntegrator.exportVectors();
      const response = await fetch(this.settings.customCloudEndpoint, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.settings.customCloudApiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          type,
          data,
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          vaultName: this.app.vault.getName()
        })
      });
      if (!response.ok)
        throw new Error(await response.text());
      new import_obsidian7.Notice(`Successfully exported ${type} to your cloud`);
      return true;
    } catch (e) {
      new import_obsidian7.Notice(`Cloud export failed: ${e.message}`);
      console.error("Cloud export error:", e);
      return false;
    }
  }
  async importData(type) {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".json";
    input.onchange = async (e) => {
      const file = e.target.files?.[0];
      if (file) {
        try {
          const content = await file.text();
          const data = JSON.parse(content);
          if (type === "graph") {
            await this.memoryGraph.save(data);
          } else {
            await this.ragIntegrator.importVectors(data);
          }
          new import_obsidian7.Notice(`Imported ${type} successfully.`);
        } catch (e2) {
          new import_obsidian7.Notice(`Import failed: ${e2.message}`);
        }
      }
    };
    input.click();
  }
  async visualizeInGraphView() {
    const graph = await this.memoryGraph.load();
    const graphData = {
      nodes: graph.nodes.map((n) => ({
        id: n.id,
        label: n.summary || n.content.slice(0, 20),
        type: n.type,
        x: Math.random() * 1e3,
        y: Math.random() * 1e3
      })),
      edges: graph.edges.map((e) => ({
        from: e.from,
        to: e.to,
        label: e.type,
        weight: e.weight
      }))
    };
    const tempFile = `temp-graph-${(0, import_uuid.v4)()}.json`;
    await this.app.vault.create(tempFile, JSON.stringify(graphData, null, 2));
    const leaf = this.app.workspace.getLeaf("tab");
    const file = this.app.vault.getAbstractFileByPath(tempFile);
    if (file instanceof import_obsidian7.TFile) {
      await leaf.openFile(file, { active: true });
    }
    new import_obsidian7.Notice("Graph visualized in new tab.");
  }
  async importRoleFromMarkdown(file) {
    const content = await this.app.vault.read(file);
    let roleName = file.basename;
    let prompt2 = content;
    if (content.startsWith("---")) {
      const frontmatterEnd = content.indexOf("---", 3);
      if (frontmatterEnd !== -1) {
        const frontmatter = content.substring(3, frontmatterEnd);
        try {
          const yaml = frontmatter.split("\n").reduce((acc, line) => {
            const [key, ...valueParts] = line.split(":");
            if (key && valueParts.length) {
              acc[key.trim()] = valueParts.join(":").trim();
            }
            return acc;
          }, {});
          if (yaml.roleName)
            roleName = yaml.roleName;
        } catch (e) {
          console.error("Failed to parse frontmatter:", e);
        }
        prompt2 = content.substring(frontmatterEnd + 3).trim();
      }
    }
    await this.app.vault.create(`AI Roles/${roleName}.md`, prompt2);
    new import_obsidian7.Notice(`Imported role: ${roleName}`);
  }
  async performSmartSearch(query) {
    try {
      const results = await this.advancedFeatures.smartSearch(query, {
        includeContext: true,
        searchType: "hybrid",
        maxResults: 10
      });
      if (results.length > 0) {
        const resultsContent = `# Smart Search Results: "${query}"

` + results.map(
          (result, index2) => `## Result ${index2 + 1} (${result.type}, Score: ${(result.score || 0).toFixed(2)})
${result.text || result.content || result.summary}

` + (result.context?.related?.length ? `**Related:** ${result.context.related.map((r) => r.summary).join(", ")}

` : "")
        ).join("---\n\n");
        const fileName = `Smart Search - ${query.replace(/[^\w\s]/g, "")} - ${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.md`;
        await this.app.vault.create(fileName, resultsContent);
        const file = this.app.vault.getAbstractFileByPath(fileName);
        if (file instanceof import_obsidian7.TFile) {
          const leaf = this.app.workspace.getLeaf("tab");
          await leaf.openFile(file, { active: true });
        }
        new import_obsidian7.Notice(`Found ${results.length} results for "${query}"`);
      } else {
        new import_obsidian7.Notice(`No results found for "${query}"`);
      }
    } catch (e) {
      new import_obsidian7.Notice(`Search failed: ${e.message}`);
    }
  }
  async openRoleChat() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(ChatView.VIEW_TYPE)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: ChatView.VIEW_TYPE,
          active: true
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  // New methods for enhanced features
  async initializeIntegrations() {
    if (this.settings.voyageApiKey) {
      await this.voyageAI.initialize({
        apiKey: this.settings.voyageApiKey,
        model: this.settings.voyageModel
      });
    }
    if (this.settings.vercelProviders.length > 0) {
      await this.vercelAI.initialize(this.settings.vercelProviders);
    }
    if (this.settings.emailConfig.smtpHost) {
      await this.emailService.configure(this.settings.emailConfig);
    }
  }
  async openDashboard() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(DashboardView.VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf?.setViewState({ type: DashboardView.VIEW_TYPE, active: true });
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async openEnhancedSearch() {
    const query = prompt("Enter search query:");
    if (!query)
      return;
    try {
      const results = await this.enhancedSearch.search({
        query,
        searchType: this.settings.defaultSearchType,
        maxResults: 20,
        useRerank: this.settings.enableSearchRerank,
        rerankThreshold: this.settings.rerankThreshold,
        includeContent: true,
        fileTypes: ["md"],
        sortBy: "relevance",
        sortOrder: "desc"
      });
      new SearchResultsModal(this.app, results).open();
    } catch (error) {
      new import_obsidian7.Notice(`Search failed: ${error.message}`);
    }
  }
  async shareCurrentFileViaEmail() {
    const file = this.app.workspace.getActiveFile();
    if (!file || file.extension !== "md") {
      new import_obsidian7.Notice("Please open a markdown file first");
      return;
    }
    const recipients = prompt("Enter email addresses (comma-separated):");
    if (!recipients)
      return;
    const recipientList = recipients.split(",").map((email) => email.trim());
    const message = prompt("Enter a message (optional):") || "";
    try {
      await this.fileShareService.shareFileViaEmail(file, recipientList, message);
    } catch (error) {
      new import_obsidian7.Notice(`Failed to share file: ${error.message}`);
    }
  }
  async sendVaultSummaryEmail() {
    const recipients = prompt("Enter email addresses (comma-separated):");
    if (!recipients)
      return;
    const recipientList = recipients.split(",").map((email) => email.trim());
    try {
      await this.fileShareService.shareVaultSummary(recipientList, true, true);
    } catch (error) {
      new import_obsidian7.Notice(`Failed to send vault summary: ${error.message}`);
    }
  }
  async testAIProviders() {
    if (this.vercelAI.isReady()) {
      const results = await this.vercelAI.testAllProviders();
      const summary = Object.entries(results).map(([provider, success]) => `${provider}: ${success ? "\u2705" : "\u274C"}`).join("\n");
      new import_obsidian7.Notice(`AI Provider Test Results:
${summary}`, 5e3);
    } else {
      new import_obsidian7.Notice("No AI providers configured");
    }
  }
  async onunload() {
    if (this.performanceOptimizer) {
      this.performanceOptimizer.destroy();
    }
    if (this.notificationManager) {
      this.notificationManager.destroy();
    }
    if (this.enhancedSearch) {
      this.enhancedSearch.destroy();
    }
    if (this.voyageAI) {
      this.voyageAI.destroy();
    }
    if (this.vercelAI) {
      this.vercelAI.destroy();
    }
  }
};
var AIMCPSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI MCP Plugin Settings" });
    new import_obsidian7.Setting(containerEl).setName("Project Instructions Path").setDesc("Path to the project instructions JSON file").addText((text) => text.setValue(this.plugin.settings.projectInstructionsPath).onChange(async (value) => {
      this.plugin.settings.projectInstructionsPath = value;
      await this.plugin.saveSettings();
      await this.plugin.loadProjectInstructions();
    }));
    new import_obsidian7.Setting(containerEl).setName("Mistral API Key").setDesc("API key for Mistral embeddings (free tier available)").addText((text) => text.setPlaceholder("Enter your Mistral API key").setValue(this.plugin.settings.mistralApiKey).onChange(async (value) => {
      this.plugin.settings.mistralApiKey = value;
      await this.plugin.saveSettings();
      if (value) {
        this.plugin.embeddings = new import_mistralai.MistralAIEmbeddings({ apiKey: value });
      }
    }));
    containerEl.createEl("h3", { text: "Qdrant Vector Database" });
    new import_obsidian7.Setting(containerEl).setName("Qdrant URL").setDesc("URL for Qdrant instance (local: http://localhost:6333)").addText((text) => text.setValue(this.plugin.settings.qdrantUrl).onChange(async (value) => {
      this.plugin.settings.qdrantUrl = value;
      await this.plugin.saveSettings();
      this.plugin.initQdrant();
    }));
    new import_obsidian7.Setting(containerEl).setName("Qdrant API Key (Cloud)").setDesc("API key for Qdrant cloud (leave empty for local)").addText((text) => text.setPlaceholder("Enter API key for cloud Qdrant").setValue(this.plugin.settings.qdrantApiKey).onChange(async (value) => {
      this.plugin.settings.qdrantApiKey = value;
      await this.plugin.saveSettings();
      this.plugin.initQdrant();
    }));
    containerEl.createEl("h3", { text: "Cloudflare Integration" });
    new import_obsidian7.Setting(containerEl).setName("Cloudflare Account ID").addText((text) => text.setValue(this.plugin.settings.cloudflareAccountId).onChange(async (value) => {
      this.plugin.settings.cloudflareAccountId = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Cloudflare API Token").addText((text) => text.setValue(this.plugin.settings.cloudflareApiToken).onChange(async (value) => {
      this.plugin.settings.cloudflareApiToken = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Enable Cloudflare RAG (Fallback)").setDesc("Use Cloudflare as fallback for RAG operations").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableCloudflareRag).onChange(async (value) => {
      this.plugin.settings.enableCloudflareRag = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Custom Cloud Sync" });
    new import_obsidian7.Setting(containerEl).setName("Enable Custom Cloud Sync").setDesc("Send exports to your own cloud service").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableCustomCloudSync).onChange(async (value) => {
      this.plugin.settings.enableCustomCloudSync = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Custom Cloud Endpoint").setDesc("Your API endpoint for data sync").addText((text) => text.setPlaceholder("https://your-api.com/sync").setValue(this.plugin.settings.customCloudEndpoint).onChange(async (value) => {
      this.plugin.settings.customCloudEndpoint = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Custom Cloud API Key").addText((text) => text.setPlaceholder("API Key").setValue(this.plugin.settings.customCloudApiKey).onChange(async (value) => {
      this.plugin.settings.customCloudApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Default Role").setDesc("Default AI role for chat interface").addDropdown((dropdown) => dropdown.addOption("assistant", "Assistant").addOption("planner", "Planner").addOption("researcher", "Researcher").setValue(this.plugin.settings.defaultRole).onChange(async (value) => {
      this.plugin.settings.defaultRole = value;
      await this.plugin.saveSettings();
    }));
  }
};
/*! Bundled license information:

@kurkle/color/dist/color.esm.js:
  (*!
   * @kurkle/color v0.3.4
   * https://github.com/kurkle/color#readme
   * (c) 2024 Jukka Kurkela
   * Released under the MIT License
   *)

chart.js/dist/chunks/helpers.dataset.js:
  (*!
   * Chart.js v4.5.0
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)

chart.js/dist/chart.js:
  (*!
   * Chart.js v4.5.0
   * https://www.chartjs.org
   * (c) 2025 Chart.js Contributors
   * Released under the MIT License
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvcGVyZm9ybWFuY2UudHMiLCAic3JjL2FkdmFuY2VkLWZlYXR1cmVzLnRzIiwgInNyYy92b3lhZ2UtYWkudHMiLCAic3JjL3ZlcmNlbC1haS50cyIsICJub2RlX21vZHVsZXMvem9kL3YzL2V4dGVybmFsLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QvdjMvaGVscGVycy91dGlsLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QvdjMvWm9kRXJyb3IuanMiLCAibm9kZV9tb2R1bGVzL3pvZC92My9sb2NhbGVzL2VuLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QvdjMvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy96b2QvdjMvaGVscGVycy9wYXJzZVV0aWwuanMiLCAibm9kZV9tb2R1bGVzL3pvZC92My9oZWxwZXJzL2Vycm9yVXRpbC5qcyIsICJub2RlX21vZHVsZXMvem9kL3YzL3R5cGVzLmpzIiwgInNyYy9kYXNoYm9hcmQudHMiLCAibm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvZGVmYXVsdHMudHMiLCAibm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvaGVscGVycy50cyIsICJub2RlX21vZHVsZXMvbWFya2VkL3NyYy9Ub2tlbml6ZXIudHMiLCAibm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvcnVsZXMudHMiLCAibm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvTGV4ZXIudHMiLCAibm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvUmVuZGVyZXIudHMiLCAibm9kZV9tb2R1bGVzL21hcmtlZC9zcmMvVGV4dFJlbmRlcmVyLnRzIiwgIm5vZGVfbW9kdWxlcy9tYXJrZWQvc3JjL1BhcnNlci50cyIsICJub2RlX21vZHVsZXMvbWFya2VkL3NyYy9Ib29rcy50cyIsICJub2RlX21vZHVsZXMvbWFya2VkL3NyYy9JbnN0YW5jZS50cyIsICJub2RlX21vZHVsZXMvbWFya2VkL3NyYy9tYXJrZWQudHMiLCAibm9kZV9tb2R1bGVzL0BrdXJrbGUvY29sb3IvZGlzdC9jb2xvci5lc20uanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY29yZS50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5tYXRoLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24udHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmVhc2luZy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb2xvci50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb25zLmRlZmF1bHRzLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmxheW91dHMuZGVmYXVsdHMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuaW50bC50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS50aWNrcy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5zY2FsZS5kZWZhdWx0cy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kZWZhdWx0cy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jYW52YXMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2hlbHBlcnMvaGVscGVycy5jb25maWcudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuY3VydmUudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZG9tLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24udHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMucnRsLnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9oZWxwZXJzL2hlbHBlcnMuZGF0YXNldC50cyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRvci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5hbmltYXRpb24uanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIuYmFyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5idWJibGUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLmRvdWdobnV0LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5saW5lLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29udHJvbGxlcnMvY29udHJvbGxlci5wb2xhckFyZWEuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnBpZS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXIucmFkYXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLnNjYXR0ZXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuYWRhcHRlcnMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuaW50ZXJhY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUubGF5b3V0cy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmJhc2UuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNpYy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL3BsYXRmb3JtLmRvbS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsYXRmb3JtL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmVsZW1lbnQudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuYXV0b3NraXAuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUuc2NhbGUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9jb3JlL2NvcmUudHlwZWRSZWdpc3RyeS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5yZWdpc3RyeS5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5wbHVnaW5zLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvY29yZS9jb3JlLmNvbmZpZy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL2NvcmUvY29yZS5jb250cm9sbGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5hcmMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9lbGVtZW50cy9lbGVtZW50LnBvaW50LnRzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvZWxlbWVudHMvZWxlbWVudC5iYXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5jb2xvcnMudHMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5kZWNpbWF0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5zZWdtZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uZmlsbGVyL2ZpbGxlci5oZWxwZXIuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLm9wdGlvbnMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5zdGFjay5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9zaW1wbGVBcmMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi5maWxsZXIvZmlsbGVyLnRhcmdldC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9maWxsZXIuZHJhd2luZy5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmZpbGxlci9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLmxlZ2VuZC5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3BsdWdpbnMvcGx1Z2luLnRpdGxlLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvcGx1Z2lucy9wbHVnaW4uc3VidGl0bGUuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9wbHVnaW5zL3BsdWdpbi50b29sdGlwLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmNhdGVnb3J5LmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxpbmVhcmJhc2UuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9zY2FsZXMvc2NhbGUubGluZWFyLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLmxvZ2FyaXRobWljLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnJhZGlhbExpbmVhci5qcyIsICJub2RlX21vZHVsZXMvY2hhcnQuanMvc3JjL3NjYWxlcy9zY2FsZS50aW1lLmpzIiwgIm5vZGVfbW9kdWxlcy9jaGFydC5qcy9zcmMvc2NhbGVzL3NjYWxlLnRpbWVzZXJpZXMuanMiLCAibm9kZV9tb2R1bGVzL2NoYXJ0LmpzL3NyYy9pbmRleC50cyIsICJzcmMvZW1haWwtbm90aWZpY2F0aW9ucy50cyIsICJzcmMvZW5oYW5jZWQtc2VhcmNoLnRzIiwgInNyYy9zZWFyY2gtcmVzdWx0cy1tb2RhbC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgXG4gIEFwcCwgXG4gIFBsdWdpbiwgXG4gIFBsdWdpblNldHRpbmdUYWIsIFxuICBTZXR0aW5nLCBcbiAgVEZpbGUsIFxuICBOb3RpY2UsIFxuICBXb3Jrc3BhY2VMZWFmLCBcbiAgSXRlbVZpZXcsXG4gIE1vZGFsLFxuICBUZXh0Q29tcG9uZW50LFxuICBEcm9wZG93bkNvbXBvbmVudCxcbiAgVG9nZ2xlQ29tcG9uZW50LFxuICBQbGF0Zm9ybVxufSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IE1pc3RyYWxBSUVtYmVkZGluZ3MgfSBmcm9tIFwiQGxhbmdjaGFpbi9taXN0cmFsYWlcIjtcbmltcG9ydCB7IFFkcmFudENsaWVudCB9IGZyb20gJ0BxZHJhbnQvanMtY2xpZW50LXJlc3QnO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgeyBQZXJmb3JtYW5jZU9wdGltaXplciB9IGZyb20gJy4vc3JjL3BlcmZvcm1hbmNlJztcbmltcG9ydCB7IEFkdmFuY2VkRmVhdHVyZXMsIFNtYXJ0U3VnZ2VzdGlvbnNNb2RhbCB9IGZyb20gJy4vc3JjL2FkdmFuY2VkLWZlYXR1cmVzJztcbmltcG9ydCB7IFZveWFnZUFJSW50ZWdyYXRpb24gfSBmcm9tICcuL3NyYy92b3lhZ2UtYWknO1xuaW1wb3J0IHsgVmVyY2VsQUlJbnRlZ3JhdGlvbiB9IGZyb20gJy4vc3JjL3ZlcmNlbC1haSc7XG5pbXBvcnQgeyBEYXNoYm9hcmRWaWV3IH0gZnJvbSAnLi9zcmMvZGFzaGJvYXJkJztcbmltcG9ydCB7IEVtYWlsU2VydmljZSwgRmlsZVNoYXJlU2VydmljZSwgTm90aWZpY2F0aW9uTWFuYWdlciwgREVGQVVMVF9FTUFJTF9URU1QTEFURVMgfSBmcm9tICcuL3NyYy9lbWFpbC1ub3RpZmljYXRpb25zJztcbmltcG9ydCB7IEVuaGFuY2VkU2VhcmNoRW5naW5lIH0gZnJvbSAnLi9zcmMvZW5oYW5jZWQtc2VhcmNoJztcbmltcG9ydCB7IFNlYXJjaFJlc3VsdHNNb2RhbCB9IGZyb20gJy4vc3JjL3NlYXJjaC1yZXN1bHRzLW1vZGFsJztcblxuLy8gVHlwZXMgJiBJbnRlcmZhY2VzXG5pbnRlcmZhY2UgUGx1Z2luU2V0dGluZ3Mge1xuICBwcm9qZWN0SW5zdHJ1Y3Rpb25zUGF0aDogc3RyaW5nO1xuICBtaXN0cmFsQXBpS2V5OiBzdHJpbmc7XG4gIHFkcmFudFVybDogc3RyaW5nO1xuICBxZHJhbnRBcGlLZXk6IHN0cmluZztcbiAgY2xvdWRmbGFyZUFjY291bnRJZDogc3RyaW5nO1xuICBjbG91ZGZsYXJlQXBpVG9rZW46IHN0cmluZztcbiAgZW5hYmxlQ2xvdWRmbGFyZVJhZzogYm9vbGVhbjtcbiAgZGVmYXVsdFJvbGU6ICdhc3Npc3RhbnQnIHwgJ3BsYW5uZXInIHwgJ3Jlc2VhcmNoZXInO1xuICBjdXN0b21DbG91ZEVuZHBvaW50OiBzdHJpbmc7XG4gIGN1c3RvbUNsb3VkQXBpS2V5OiBzdHJpbmc7XG4gIGVuYWJsZUN1c3RvbUNsb3VkU3luYzogYm9vbGVhbjtcbiAgXG4gIC8vIFZveWFnZSBBSSBzZXR0aW5nc1xuICB2b3lhZ2VBcGlLZXk6IHN0cmluZztcbiAgdm95YWdlTW9kZWw6IHN0cmluZztcbiAgZW5hYmxlVm95YWdlUmVyYW5rOiBib29sZWFuO1xuICBcbiAgLy8gVmVyY2VsIEFJIHNldHRpbmdzXG4gIHZlcmNlbFByb3ZpZGVyczogQXJyYXk8e1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBhcGlLZXk6IHN0cmluZztcbiAgICBtb2RlbDogc3RyaW5nO1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gIH0+O1xuICBkZWZhdWx0QUlQcm92aWRlcjogc3RyaW5nO1xuICBcbiAgLy8gRW1haWwgc2V0dGluZ3NcbiAgZW1haWxDb25maWc6IHtcbiAgICBzbXRwSG9zdDogc3RyaW5nO1xuICAgIHNtdHBQb3J0OiBudW1iZXI7XG4gICAgc2VjdXJlOiBib29sZWFuO1xuICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgcGFzc3dvcmQ6IHN0cmluZztcbiAgICBmcm9tRW1haWw6IHN0cmluZztcbiAgICBmcm9tTmFtZTogc3RyaW5nO1xuICB9O1xuICBlbWFpbFRlbXBsYXRlczogYW55W107XG4gIG5vdGlmaWNhdGlvblJ1bGVzOiBhbnlbXTtcbiAgXG4gIC8vIERhc2hib2FyZCBzZXR0aW5nc1xuICBkYXNoYm9hcmRXaWRnZXRzOiBhbnlbXTtcbiAgXG4gIC8vIEVuaGFuY2VkIHNlYXJjaCBzZXR0aW5nc1xuICBzZWFyY2hIaXN0b3J5OiBhbnlbXTtcbiAgc2F2ZWRTZWFyY2hlczogYW55W107XG4gIGRlZmF1bHRTZWFyY2hUeXBlOiAnc2VtYW50aWMnIHwgJ2tleXdvcmQnIHwgJ2h5YnJpZCcgfCAnYWlfZW5oYW5jZWQnO1xuICBlbmFibGVTZWFyY2hSZXJhbms6IGJvb2xlYW47XG4gIHJlcmFua1RocmVzaG9sZDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgTWVtb3J5Tm9kZSB7XG4gIGlkOiBzdHJpbmc7XG4gIHR5cGU6ICdmYWN0JyB8ICdldmVudCcgfCAndGFzaycgfCAnY29udGV4dCcgfCAnbWFya2Rvd24nO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHN1bW1hcnk6IHN0cmluZztcbiAgdGltZXN0YW1wOiB7IFxuICAgIGNyZWF0ZWRfYXQ6IHN0cmluZzsgXG4gICAgdXBkYXRlZF9hdDogc3RyaW5nOyBcbiAgICB2YWxpZF9mcm9tOiBzdHJpbmc7IFxuICAgIHZhbGlkX3VudGlsOiBzdHJpbmcgfCBudWxsIFxuICB9O1xuICBjb25maWRlbmNlOiBudW1iZXI7XG4gIHNvdXJjZXM6IEFycmF5PHsgXG4gICAgdHlwZTogc3RyaW5nOyBcbiAgICBpZDogc3RyaW5nOyBcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nOyBcbiAgICB1cmw/OiBzdHJpbmcgXG4gIH0+O1xuICBlbWJlZGRpbmdzOiBudW1iZXJbXTtcbiAgYXR0cmlidXRlczogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgZ3JvdXBfaWQ6IHN0cmluZztcbiAgdmVyc2lvbjogbnVtYmVyO1xuICBwcm9wZXJ0aWVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xufVxuXG5pbnRlcmZhY2UgTWVtb3J5RWRnZSB7XG4gIGlkOiBzdHJpbmc7XG4gIGZyb206IHN0cmluZztcbiAgdG86IHN0cmluZztcbiAgdHlwZTogJ2NhdXNhbCcgfCAndGVtcG9yYWwnIHwgJ3NpbWlsYXInIHwgJ3JlZmVyZW5jZXMnO1xuICBmYWN0OiBzdHJpbmc7XG4gIHdlaWdodDogbnVtYmVyO1xuICB0aW1lc3RhbXA6IHsgY3JlYXRlZF9hdDogc3RyaW5nOyB1cGRhdGVkX2F0OiBzdHJpbmcgfTtcbn1cblxuaW50ZXJmYWNlIEdyYXBoRGF0YSB7XG4gIHNjaGVtYV92ZXJzaW9uOiBzdHJpbmc7XG4gIGdyYXBoX21ldGFkYXRhOiB7XG4gICAgdG90YWxfbm9kZXM6IG51bWJlcjtcbiAgICB0b3RhbF9lZGdlczogbnVtYmVyO1xuICAgIGxhc3Rfc3luYzogc3RyaW5nO1xuICAgIGRldmljZV9pZDogc3RyaW5nO1xuICAgIHZlcnNpb246IG51bWJlcjtcbiAgfTtcbiAgbm9kZXM6IE1lbW9yeU5vZGVbXTtcbiAgZWRnZXM6IE1lbW9yeUVkZ2VbXTtcbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogUGx1Z2luU2V0dGluZ3MgPSB7XG4gIHByb2plY3RJbnN0cnVjdGlvbnNQYXRoOiAnYWktbWNwLWluc3RydWN0aW9ucy5qc29uJyxcbiAgbWlzdHJhbEFwaUtleTogJycsXG4gIHFkcmFudFVybDogJ2h0dHA6Ly9sb2NhbGhvc3Q6NjMzMycsXG4gIHFkcmFudEFwaUtleTogJycsXG4gIGNsb3VkZmxhcmVBY2NvdW50SWQ6ICcnLFxuICBjbG91ZGZsYXJlQXBpVG9rZW46ICcnLFxuICBlbmFibGVDbG91ZGZsYXJlUmFnOiBmYWxzZSxcbiAgZGVmYXVsdFJvbGU6ICdhc3Npc3RhbnQnLFxuICBjdXN0b21DbG91ZEVuZHBvaW50OiAnJyxcbiAgY3VzdG9tQ2xvdWRBcGlLZXk6ICcnLFxuICBlbmFibGVDdXN0b21DbG91ZFN5bmM6IGZhbHNlLFxuICBcbiAgLy8gVm95YWdlIEFJIHNldHRpbmdzXG4gIHZveWFnZUFwaUtleTogJycsXG4gIHZveWFnZU1vZGVsOiAndm95YWdlLWxhcmdlLTInLFxuICBlbmFibGVWb3lhZ2VSZXJhbms6IGZhbHNlLFxuICBcbiAgLy8gVmVyY2VsIEFJIHNldHRpbmdzXG4gIHZlcmNlbFByb3ZpZGVyczogW10sXG4gIGRlZmF1bHRBSVByb3ZpZGVyOiAnbWlzdHJhbCcsXG4gIFxuICAvLyBFbWFpbCBzZXR0aW5nc1xuICBlbWFpbENvbmZpZzoge1xuICAgIHNtdHBIb3N0OiAnJyxcbiAgICBzbXRwUG9ydDogNTg3LFxuICAgIHNlY3VyZTogZmFsc2UsXG4gICAgdXNlcm5hbWU6ICcnLFxuICAgIHBhc3N3b3JkOiAnJyxcbiAgICBmcm9tRW1haWw6ICcnLFxuICAgIGZyb21OYW1lOiAnT2JzaWRpYW4gQUkgTUNQJ1xuICB9LFxuICBlbWFpbFRlbXBsYXRlczogREVGQVVMVF9FTUFJTF9URU1QTEFURVMsXG4gIG5vdGlmaWNhdGlvblJ1bGVzOiBbXSxcbiAgXG4gIC8vIERhc2hib2FyZCBzZXR0aW5nc1xuICBkYXNoYm9hcmRXaWRnZXRzOiBbXSxcbiAgXG4gIC8vIEVuaGFuY2VkIHNlYXJjaCBzZXR0aW5nc1xuICBzZWFyY2hIaXN0b3J5OiBbXSxcbiAgc2F2ZWRTZWFyY2hlczogW10sXG4gIGRlZmF1bHRTZWFyY2hUeXBlOiAnaHlicmlkJyxcbiAgZW5hYmxlU2VhcmNoUmVyYW5rOiBmYWxzZSxcbiAgcmVyYW5rVGhyZXNob2xkOiAwLjFcbn07XG5cbmNvbnN0IERFRkFVTFRfSU5TVFJVQ1RJT05TID0ge1xuICBwcm9qZWN0X25hbWU6IFwiT2JzaWRpYW4gQUkgTUNQIFBsdWdpblwiLFxuICBhaV9iZWhhdmlvcjoge1xuICAgIGRlZmF1bHRfcHJvdmlkZXI6IFwibWlzdHJhbFwiLFxuICAgIHByZWZlcnJlZF9tb2RlbHM6IHsgbWlzdHJhbDogW1wibWlzdHJhbC1lbWJlZFwiXSB9LFxuICAgIHRvbmU6IFwicHJvZmVzc2lvbmFsXCIsXG4gICAgbGFuZ3VhZ2U6IFwidGgsIGVuXCIsXG4gICAgbWF4X3Jlc3BvbnNlX2xlbmd0aDogMjAwMCxcbiAgICBjb250ZXh0X3NvdXJjZXM6IFtcIm1lbW9yeV9ncmFwaFwiLCBcInJhZ192YXVsdFwiXSxcbiAgICBmYWxsYmFja19wcm92aWRlcnM6IFtcImxvY2FsXCJdLFxuICAgIHJvbGVzOiB7XG4gICAgICBhc3Npc3RhbnQ6IFwiSGVscGZ1bCBhc3Npc3RhbnQgcmVjYWxsaW5nIHZhdWx0IGNvbnRleHQgdmlhIGdyYXBoLlwiLFxuICAgICAgcGxhbm5lcjogXCJQbGFuIHRhc2tzIHVzaW5nIHRlbXBvcmFsIGVkZ2VzIGluIG1lbW9yeSBncmFwaC5cIixcbiAgICAgIHJlc2VhcmNoZXI6IFwiU2VhcmNoIG1lYW5pbmdzL3NpbWlsYXJpdGllcyB3aXRoIFFkcmFudCB2ZWN0b3JzLlwiXG4gICAgfVxuICB9LFxuICBtY3BfY29uZmlnOiB7XG4gICAgbWVtb3J5X2dyYXBoOiB7XG4gICAgICBzdG9yYWdlOiBcImpzb25cIixcbiAgICAgIGZpbGVfcGF0aDogXCJtZW1vcnktZ3JhcGguanNvblwiLFxuICAgICAgc2NoZW1hX3ZlcnNpb246IFwiMS4wLjBcIixcbiAgICAgIG1heF9ub2RlczogMTAwMDAsXG4gICAgICB2YXVsdF9pbnRlZ3JhdGlvbjogeyBcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSwgXG4gICAgICAgIHNjYW5faW50ZXJ2YWw6IDYwMDAwMCwgXG4gICAgICAgIGZpbGVfdHlwZXM6IFtcIi5tZFwiXSwgXG4gICAgICAgIG1heF9maWxlX3NpemU6IDEwNDg1NzYgXG4gICAgICB9XG4gICAgfSxcbiAgICBlbmNyeXB0ZWRfZ3JhcGhfc3luYzogeyBcbiAgICAgIGVuYWJsZWQ6IHRydWUsIFxuICAgICAgZW5jcnlwdGlvbl9rZXk6IFwidmF1bHQtZGVyaXZlZFwiLCBcbiAgICAgIHN5bmNfcHJvdG9jb2w6IFwid3MtZW5jcnlwdGVkXCIsIFxuICAgICAgbWF4X3N5bmNfYmF0Y2g6IDEwMCwgXG4gICAgICBjb25mbGljdF9yZXNvbHV0aW9uOiBcImxhc3QtbW9kaWZpZWRcIiBcbiAgICB9LFxuICAgIHBsYW5uaW5nX2FnZW50OiB7IFxuICAgICAgdGFza19mb3JtYXQ6IFwiY3JhZnRfY2xpY2t1cFwiLCBcbiAgICAgIG1heF90YXNrczogNTAwIFxuICAgIH1cbiAgfSxcbiAgcmFnX2NvbmZpZzoge1xuICAgIHZlY3Rvcl9zdG9yZTogXCJxZHJhbnRcIixcbiAgICBlbWJlZGRpbmdfbW9kZWw6IFwibWlzdHJhbC1lbWJlZFwiLFxuICAgIGNodW5rX3NpemU6IDUwMCxcbiAgICB0b3BfazogNSxcbiAgICBxZHJhbnRfY29uZmlnOiB7IFxuICAgICAgbG9jYWxfZW5hYmxlZDogdHJ1ZSwgXG4gICAgICBjb2xsZWN0aW9uX25hbWU6IFwib2JzaWRpYW5fcmFnXCIgXG4gICAgfSxcbiAgICBjbG91ZGZsYXJlX2NvbmZpZzogeyBcbiAgICAgIGVuYWJsZWQ6IHRydWUsIFxuICAgICAgaW5kZXhfbmFtZTogXCJvYnNpZGlhbi12ZWN0b3JzXCIsIFxuICAgICAgc3luY19vbmx5OiB0cnVlIFxuICAgIH1cbiAgfSxcbiAgc3luY19jb25maWc6IHsgXG4gICAgc2VydmVyX3BvcnQ6IDgwODAsIFxuICAgIHN5bmNfaW50ZXJ2YWw6IDMwMDAwMCwgXG4gICAgZGF0YV90eXBlczogW1widmVjdG9yc1wiLCBcIm1lbW9yeVwiLCBcInRhc2tzXCJdIFxuICB9XG59O1xuXG4vLyBDaGF0IFZpZXcgQ2xhc3NcbmNsYXNzIENoYXRWaWV3IGV4dGVuZHMgSXRlbVZpZXcge1xuICBzdGF0aWMgVklFV19UWVBFID0gXCJhaS1tY3AtY2hhdFwiO1xuICBwcml2YXRlIG1vZGU6ICdhc2snIHwgJ3BsYW5uaW5nJyB8ICdhZ2VudCcgPSAnYXNrJztcbiAgcHJpdmF0ZSBjb250ZXh0Tm90ZTogVEZpbGUgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSByb2xlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICBcbiAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcHJpdmF0ZSBwbHVnaW46IEFJTUNQUGx1Z2luKSB7XG4gICAgc3VwZXIobGVhZik7XG4gIH1cblxuICBnZXRWaWV3VHlwZSgpIHsgXG4gICAgcmV0dXJuIENoYXRWaWV3LlZJRVdfVFlQRTsgXG4gIH1cbiAgXG4gIGdldERpc3BsYXlUZXh0KCkgeyBcbiAgICByZXR1cm4gXCJBSSBNQ1AgQ2hhdFwiOyBcbiAgfVxuICBcbiAgYXN5bmMgb25PcGVuKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyRWwuY2hpbGRyZW5bMV07XG4gICAgY29udGFpbmVyLmVtcHR5KCk7XG4gICAgY29udGFpbmVyLmFkZENsYXNzKFwiYWktbWNwLWNoYXQtY29udGFpbmVyXCIpO1xuICAgIFxuICAgIC8vIExvYWQgcm9sZXNcbiAgICB0aGlzLnJvbGVzID0gYXdhaXQgdGhpcy5wbHVnaW4ubG9hZFJvbGVzRnJvbVZhdWx0KCk7XG4gICAgXG4gICAgLy8gSGVhZGVyIHdpdGggbW9kZSBzZWxlY3Rpb25cbiAgICBjb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwiYWktbWNwLWhlYWRlclwiIH0sIChoZWFkZXIpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdCA9IGhlYWRlci5jcmVhdGVFbChcInNlbGVjdFwiLCB7IFxuICAgICAgICBjbHM6IFwiYWktbWNwLW1vZGUtc2VsZWN0XCIsIFxuICAgICAgICBhdHRyOiB7IFwiYXJpYS1sYWJlbFwiOiBcIkNoYXQgTW9kZVwiIH0gXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgT2JqZWN0LmtleXModGhpcy5yb2xlcykuZm9yRWFjaChyb2xlID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0LmNyZWF0ZUVsKFwib3B0aW9uXCIsIHsgXG4gICAgICAgICAgdGV4dDogcm9sZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHJvbGUuc2xpY2UoMSksIFxuICAgICAgICAgIHZhbHVlOiByb2xlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocm9sZSA9PT0gdGhpcy5tb2RlKSB7XG4gICAgICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZSgnc2VsZWN0ZWQnLCAnc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHNlbGVjdC5vbmNoYW5nZSA9IChlKSA9PiB0aGlzLnNldE1vZGUoKGUudGFyZ2V0IGFzIEhUTUxTZWxlY3RFbGVtZW50KS52YWx1ZSBhcyBhbnkpO1xuICAgICAgXG4gICAgICAvLyBSb2xlIG1hbmFnZW1lbnQgYnV0dG9uXG4gICAgICBoZWFkZXIuY3JlYXRlRWwoXCJidXR0b25cIiwge1xuICAgICAgICBjbHM6IFwicm9sZS1tYW5hZ2UtYnRuXCIsXG4gICAgICAgIHRleHQ6IFwiXHUyNjk5XHVGRTBGXCIsXG4gICAgICAgIGF0dHI6IHsgXCJhcmlhLWxhYmVsXCI6IFwiTWFuYWdlIFJvbGVzXCIgfVxuICAgICAgfSkub25jbGljayA9ICgpID0+IHRoaXMub3BlblJvbGVNYW5hZ2VtZW50TW9kYWwoKTtcbiAgICAgIFxuICAgICAgLy8gTW9iaWxlOiBjb250ZXh0IHRvZ2dsZVxuICAgICAgaWYgKFBsYXRmb3JtLmlzTW9iaWxlKSB7XG4gICAgICAgIGhlYWRlci5jcmVhdGVFbChcImJ1dHRvblwiLCB7IFxuICAgICAgICAgIGNsczogXCJhaS1tY3AtY29udGV4dC10b2dnbGVcIiwgXG4gICAgICAgICAgdGV4dDogXCJDVFhcIiBcbiAgICAgICAgfSkub25jbGljayA9ICgpID0+IHRoaXMudG9nZ2xlQ29udGV4dFBhbmVsKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQ29udGV4dCBwYW5lbFxuICAgIGNvbnN0IGNvbnRleHRQYW5lbCA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IFxuICAgICAgY2xzOiBgYWktbWNwLWNvbnRleHQtcGFuZWwgJHtQbGF0Zm9ybS5pc01vYmlsZSA/ICdtb2JpbGUtaGlkZGVuJyA6ICcnfWAgXG4gICAgfSk7XG4gICAgXG4gICAgLy8gQ2hhdCBtZXNzYWdlcyBjb250YWluZXJcbiAgICBjb25zdCBtZXNzYWdlc0NvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJhaS1tY3AtbWVzc2FnZXNcIiB9KTtcbiAgICBcbiAgICAvLyBJbnB1dCBhcmVhXG4gICAgY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcImFpLW1jcC1pbnB1dC1hcmVhXCIgfSwgKGlucHV0QXJlYSkgPT4ge1xuICAgICAgY29uc3QgdGV4dGFyZWEgPSBpbnB1dEFyZWEuY3JlYXRlRWwoXCJ0ZXh0YXJlYVwiLCB7IFxuICAgICAgICBjbHM6IFwiYWktbWNwLWlucHV0XCIsIFxuICAgICAgICBhdHRyOiB7IHBsYWNlaG9sZGVyOiBcIkFzayBzb21ldGhpbmcuLi5cIiB9IFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHNlbmRCdG4gPSBpbnB1dEFyZWEuY3JlYXRlRWwoXCJidXR0b25cIiwgeyBcbiAgICAgICAgY2xzOiBcImFpLW1jcC1zZW5kXCIsIFxuICAgICAgICB0ZXh0OiBcIlNlbmRcIiBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBzZW5kQnRuLm9uY2xpY2sgPSAoKSA9PiB0aGlzLnNlbmRNZXNzYWdlKCk7XG4gICAgICB0ZXh0YXJlYS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgaWYgKGUua2V5ID09PSAnRW50ZXInICYmICFlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gU3VnZ2VzdGVkIHJlc3BvbnNlc1xuICAgIGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJhaS1tY3Atc3VnZ2VzdGlvbnNcIiB9LCAoc3VnZ2VzdGlvbnMpID0+IHtcbiAgICAgIHN1Z2dlc3Rpb25zLmNyZWF0ZUVsKFwiZGl2XCIsIHsgXG4gICAgICAgIGNsczogXCJzdWdnZXN0aW9uLWl0ZW1cIiwgXG4gICAgICAgIHRleHQ6IFwiV2hhdCdzIG15IG5leHQgdGFzaz9cIiBcbiAgICAgIH0pLm9uY2xpY2sgPSAoKSA9PiB0aGlzLmZpbGxJbnB1dChcIldoYXQncyBteSBuZXh0IHRhc2s/XCIpO1xuICAgICAgXG4gICAgICBzdWdnZXN0aW9ucy5jcmVhdGVFbChcImRpdlwiLCB7IFxuICAgICAgICBjbHM6IFwic3VnZ2VzdGlvbi1pdGVtXCIsIFxuICAgICAgICB0ZXh0OiBcIlN1bW1hcml6ZSB0aGlzIG5vdGVcIiBcbiAgICAgIH0pLm9uY2xpY2sgPSAoKSA9PiB0aGlzLmZpbGxJbnB1dChcIlN1bW1hcml6ZSB0aGlzIG5vdGVcIik7XG4gICAgICBcbiAgICAgIHN1Z2dlc3Rpb25zLmNyZWF0ZUVsKFwiZGl2XCIsIHsgXG4gICAgICAgIGNsczogXCJzdWdnZXN0aW9uLWl0ZW1cIiwgXG4gICAgICAgIHRleHQ6IFwiU2VhcmNoIHNpbWlsYXIgY29udGVudFwiIFxuICAgICAgfSkub25jbGljayA9ICgpID0+IHRoaXMuZmlsbElucHV0KFwiU2VhcmNoIHNpbWlsYXIgY29udGVudFwiKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBFeHBvcnQgY29udHJvbHNcbiAgICBjb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwiYWktbWNwLWV4cG9ydC1jb250cm9sc1wiIH0sIChleHBvcnRDb250cm9scykgPT4ge1xuICAgICAgZXhwb3J0Q29udHJvbHMuY3JlYXRlRWwoXCJidXR0b25cIiwgeyBcbiAgICAgICAgdGV4dDogXCJFeHBvcnQgR3JhcGhcIiwgXG4gICAgICAgIGNsczogXCJleHBvcnQtYnRuIGdyYXBoXCIgXG4gICAgICB9KS5vbmNsaWNrID0gKCkgPT4gdGhpcy5wbHVnaW4uZXhwb3J0RGF0YSgnZ3JhcGgnKTtcbiAgICAgIFxuICAgICAgZXhwb3J0Q29udHJvbHMuY3JlYXRlRWwoXCJidXR0b25cIiwgeyBcbiAgICAgICAgdGV4dDogXCJFeHBvcnQgVmVjdG9yc1wiLCBcbiAgICAgICAgY2xzOiBcImV4cG9ydC1idG4gdmVjdG9yc1wiIFxuICAgICAgfSkub25jbGljayA9ICgpID0+IHRoaXMucGx1Z2luLmV4cG9ydERhdGEoJ3ZlY3RvcnMnKTtcbiAgICAgIFxuICAgICAgaWYgKHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZUN1c3RvbUNsb3VkU3luYykge1xuICAgICAgICBleHBvcnRDb250cm9scy5jcmVhdGVFbChcImJ1dHRvblwiLCB7IFxuICAgICAgICAgIHRleHQ6IFwiU3luYyB0byBDbG91ZFwiLCBcbiAgICAgICAgICBjbHM6IFwiZXhwb3J0LWJ0biBjbG91ZCBtb2QtY3RhXCIgXG4gICAgICAgIH0pLm9uY2xpY2sgPSAoKSA9PiB0aGlzLnN5bmNUb1VzZXJDbG91ZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgY29udGV4dFxuICAgIGF3YWl0IHRoaXMudXBkYXRlQ29udGV4dEZyb21BY3RpdmVOb3RlKCk7XG4gIH1cbiAgXG4gIHByaXZhdGUgZmlsbElucHV0KHRleHQ6IHN0cmluZykge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKFwiLmFpLW1jcC1pbnB1dFwiKSBhcyBIVE1MVGV4dEFyZWFFbGVtZW50O1xuICAgIGlmIChpbnB1dCkge1xuICAgICAgaW5wdXQudmFsdWUgPSB0ZXh0O1xuICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgc2V0TW9kZShtb2RlOiAnYXNrJyB8ICdwbGFubmluZycgfCAnYWdlbnQnKSB7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICBjb25zdCBzeXN0ZW1Qcm9tcHQgPSB0aGlzLnJvbGVzW21vZGVdIHx8IHRoaXMucGx1Z2luLnByb2plY3RJbnN0cnVjdGlvbnMuYWlfYmVoYXZpb3Iucm9sZXNbbW9kZV07XG4gICAgbmV3IE5vdGljZShgU3dpdGNoZWQgdG8gJHttb2RlfSBtb2RlOiAke3N5c3RlbVByb21wdC5zdWJzdHJpbmcoMCwgNTApfS4uLmApO1xuICB9XG4gIFxuICBwcml2YXRlIHRvZ2dsZUNvbnRleHRQYW5lbCgpIHtcbiAgICBjb25zdCBwYW5lbCA9IHRoaXMuY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihcIi5haS1tY3AtY29udGV4dC1wYW5lbFwiKTtcbiAgICBpZiAocGFuZWwpIHtcbiAgICAgIGlmIChwYW5lbC5oYXNDbGFzcyhcIm1vYmlsZS1oaWRkZW5cIikpIHtcbiAgICAgICAgcGFuZWwucmVtb3ZlQ2xhc3MoXCJtb2JpbGUtaGlkZGVuXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFuZWwuYWRkQ2xhc3MoXCJtb2JpbGUtaGlkZGVuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBvcGVuUm9sZU1hbmFnZW1lbnRNb2RhbCgpIHtcbiAgICBuZXcgUm9sZU1hbmFnZW1lbnRNb2RhbCh0aGlzLmFwcCwgdGhpcy5wbHVnaW4sICgpID0+IHtcbiAgICAgIHRoaXMucmVmcmVzaFJvbGVzKCk7XG4gICAgfSkub3BlbigpO1xuICB9XG4gIFxuICBwcml2YXRlIGFzeW5jIHJlZnJlc2hSb2xlcygpIHtcbiAgICB0aGlzLnJvbGVzID0gYXdhaXQgdGhpcy5wbHVnaW4ubG9hZFJvbGVzRnJvbVZhdWx0KCk7XG4gICAgdGhpcy51cGRhdGVSb2xlRHJvcGRvd24oKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSB1cGRhdGVSb2xlRHJvcGRvd24oKSB7XG4gICAgY29uc3Qgc2VsZWN0ID0gdGhpcy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKFwiLmFpLW1jcC1tb2RlLXNlbGVjdFwiKSBhcyBIVE1MU2VsZWN0RWxlbWVudDtcbiAgICBpZiAoc2VsZWN0KSB7XG4gICAgICBzZWxlY3QuaW5uZXJIVE1MID0gJyc7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnJvbGVzKS5mb3JFYWNoKHJvbGUgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzZWxlY3QuY3JlYXRlRWwoXCJvcHRpb25cIiwgeyBcbiAgICAgICAgICB0ZXh0OiByb2xlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcm9sZS5zbGljZSgxKSwgXG4gICAgICAgICAgdmFsdWU6IHJvbGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyb2xlID09PSB0aGlzLm1vZGUpIHtcbiAgICAgICAgICBvcHRpb24uc2V0QXR0cmlidXRlKCdzZWxlY3RlZCcsICdzZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlQ29udGV4dEZyb21BY3RpdmVOb3RlKCkge1xuICAgIGNvbnN0IGFjdGl2ZUZpbGUgPSB0aGlzLnBsdWdpbi5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICBpZiAoYWN0aXZlRmlsZSkge1xuICAgICAgdGhpcy5jb250ZXh0Tm90ZSA9IGFjdGl2ZUZpbGU7XG4gICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LnJlYWQoYWN0aXZlRmlsZSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5leHRyYWN0UmVsZXZhbnRDb250ZXh0KGNvbnRlbnQsIGFjdGl2ZUZpbGUpO1xuICAgICAgXG4gICAgICBjb25zdCBjb250ZXh0UGFuZWwgPSB0aGlzLmNvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3IoXCIuYWktbWNwLWNvbnRleHQtcGFuZWxcIik7XG4gICAgICBpZiAoY29udGV4dFBhbmVsKSB7XG4gICAgICAgIGNvbnRleHRQYW5lbC5lbXB0eSgpO1xuICAgICAgICBjb250ZXh0UGFuZWwuY3JlYXRlRWwoXCJoNFwiLCB7IHRleHQ6IFwiQ3VycmVudCBDb250ZXh0OlwiIH0pO1xuICAgICAgICBjb250ZXh0UGFuZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyBcbiAgICAgICAgICBjbHM6IFwiY29udGV4dC1jb250ZW50XCIsIFxuICAgICAgICAgIHRleHQ6IGNvbnRleHQuc3Vic3RyaW5nKDAsIDIwMCkgKyBcIi4uLlwiIFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHByaXZhdGUgZXh0cmFjdFJlbGV2YW50Q29udGV4dChjb250ZW50OiBzdHJpbmcsIGZpbGU6IFRGaWxlKTogc3RyaW5nIHtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAvLyBVc2UgcmVzb2x2ZWRMaW5rcyBpbnN0ZWFkIG9mIGdldEJhY2tsaW5rc0ZvckZpbGVcbiAgICBjb25zdCByZXNvbHZlZExpbmtzID0gdGhpcy5wbHVnaW4uYXBwLm1ldGFkYXRhQ2FjaGUucmVzb2x2ZWRMaW5rcztcbiAgICBcbiAgICBsZXQgY29udGV4dCA9IGNvbnRlbnQ7XG4gICAgaWYgKHJlc29sdmVkTGlua3MgJiYgcmVzb2x2ZWRMaW5rc1tmaWxlLnBhdGhdKSB7XG4gICAgICBjb25zdCBsaW5rZWRGaWxlcyA9IE9iamVjdC5rZXlzKHJlc29sdmVkTGlua3NbZmlsZS5wYXRoXSkuc2xpY2UoMCwgMyk7XG4gICAgICBmb3IgKGNvbnN0IGxpbmtlZFBhdGggb2YgbGlua2VkRmlsZXMpIHtcbiAgICAgICAgY29uc3QgbGlua2VkRmlsZSA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobGlua2VkUGF0aCk7XG4gICAgICAgIGlmIChsaW5rZWRGaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgICAgICBjb250ZXh0ICs9IFwiXFxuXFxuW1JFTEFURUQ6IFwiICsgbGlua2VkRmlsZS5uYW1lICsgXCJdXFxuXCIgKyBcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5zdWJzdHJpbmcoMCwgMjAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICBcbiAgcHJpdmF0ZSBhc3luYyBzZW5kTWVzc2FnZSgpIHtcbiAgICBjb25zdCBpbnB1dCA9IHRoaXMuY29udGFpbmVyRWwucXVlcnlTZWxlY3RvcihcIi5haS1tY3AtaW5wdXRcIikgYXMgSFRNTFRleHRBcmVhRWxlbWVudDtcbiAgICBpZiAoIWlucHV0Py52YWx1ZS50cmltKCkpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBtZXNzYWdlc0VsID0gdGhpcy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKFwiLmFpLW1jcC1tZXNzYWdlc1wiKTtcbiAgICBpZiAobWVzc2FnZXNFbCkge1xuICAgICAgLy8gQWRkIHVzZXIgbWVzc2FnZVxuICAgICAgbWVzc2FnZXNFbC5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJtZXNzYWdlIHVzZXJcIiB9LCAobXNnKSA9PiB7XG4gICAgICAgIG1zZy5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJtZXNzYWdlLWNvbnRlbnRcIiwgdGV4dDogaW5wdXQudmFsdWUgfSk7XG4gICAgICAgIG1zZy5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJtZXNzYWdlLXRpbWVcIiwgdGV4dDogbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKSB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCB1c2VyUXVlcnkgPSBpbnB1dC52YWx1ZTtcbiAgICAgIGlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgIFxuICAgICAgLy8gQWRkIGJvdCByZXNwb25zZSBwbGFjZWhvbGRlclxuICAgICAgY29uc3QgYm90TXNnID0gbWVzc2FnZXNFbC5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJtZXNzYWdlIGJvdFwiIH0sIChtc2cpID0+IHtcbiAgICAgICAgbXNnLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcIm1lc3NhZ2UtY29udGVudCBsb2FkaW5nXCIsIHRleHQ6IFwiXHUwRTAxXHUwRTMzXHUwRTI1XHUwRTMxXHUwRTA3XHUwRTA0XHUwRTM0XHUwRTE0Li4uXCIgfSk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2Nyb2xsIHRvIGJvdHRvbVxuICAgICAgbWVzc2FnZXNFbC5zY3JvbGxUb3AgPSBtZXNzYWdlc0VsLnNjcm9sbEhlaWdodDtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldEFJUmVzcG9uc2UodXNlclF1ZXJ5KTtcbiAgICAgICAgY29uc3QgY29udGVudEVsID0gYm90TXNnLnF1ZXJ5U2VsZWN0b3IoXCIubWVzc2FnZS1jb250ZW50XCIpO1xuICAgICAgICBpZiAoY29udGVudEVsKSB7XG4gICAgICAgICAgY29udGVudEVsLnJlbW92ZUNsYXNzKFwibG9hZGluZ1wiKTtcbiAgICAgICAgICBjb250ZW50RWwuc2V0VGV4dChyZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgYm90TXNnLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcIm1lc3NhZ2UtdGltZVwiLCB0ZXh0OiBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBjb250ZW50RWwgPSBib3RNc2cucXVlcnlTZWxlY3RvcihcIi5tZXNzYWdlLWNvbnRlbnRcIik7XG4gICAgICAgIGlmIChjb250ZW50RWwpIHtcbiAgICAgICAgICBjb250ZW50RWwucmVtb3ZlQ2xhc3MoXCJsb2FkaW5nXCIpO1xuICAgICAgICAgIGNvbnRlbnRFbC5hZGRDbGFzcyhcImVycm9yXCIpO1xuICAgICAgICAgIGNvbnRlbnRFbC5zZXRUZXh0KFwiRXJyb3I6IFwiICsgKGUgYXMgRXJyb3IpLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIG1lc3NhZ2VzRWwuc2Nyb2xsVG9wID0gbWVzc2FnZXNFbC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIGFzeW5jIGdldEFJUmVzcG9uc2UocXVlcnk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dE5vdGUgPyBcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5yZWFkKHRoaXMuY29udGV4dE5vdGUpIDogXCJcIjtcbiAgICAgIFxuICAgIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgICBjYXNlICdhc2snOlxuICAgICAgICBpZiAodGhpcy5wbHVnaW4uZW1iZWRkaW5ncykge1xuICAgICAgICAgIGNvbnN0IGVtYmVkZGluZyA9IGF3YWl0IHRoaXMucGx1Z2luLmVtYmVkZGluZ3MuZW1iZWRRdWVyeShxdWVyeSk7XG4gICAgICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMucGx1Z2luLnJhZ0ludGVncmF0b3Iuc2VhcmNoU2ltaWxhcihlbWJlZGRpbmcpO1xuICAgICAgICAgIHJldHVybiByZXN1bHRzLmxlbmd0aCA+IDAgPyBcbiAgICAgICAgICAgIGBCYXNlZCBvbiB5b3VyIHZhdWx0OiAke3Jlc3VsdHNbMF0udGV4dH1gIDogXG4gICAgICAgICAgICBcIk5vIHJlbGV2YW50IGluZm9ybWF0aW9uIGZvdW5kIGluIHlvdXIgdmF1bHQuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiUGxlYXNlIGNvbmZpZ3VyZSBNaXN0cmFsIEFQSSBrZXkgZmlyc3QuXCI7XG4gICAgICAgIFxuICAgICAgY2FzZSAncGxhbm5pbmcnOlxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wbHVnaW4ucGxhbm5pbmdBZ2VudC5wbGFuV2l0aFJvbGUodGhpcy5tb2RlLCBxdWVyeSk7XG4gICAgICAgIFxuICAgICAgY2FzZSAnYWdlbnQnOlxuICAgICAgICByZXR1cm4gYEFzICR7dGhpcy5tb2RlfSBhZ2VudCBhbmFseXppbmc6IFwiJHtxdWVyeX1cIlxcblxcbkNvbnRleHQ6ICR7Y29udGV4dC5zdWJzdHJpbmcoMCwgMjAwKX0uLi5cXG5cXG5JJ20gcHJvY2Vzc2luZyB5b3VyIHJlcXVlc3QgdXNpbmcgdGhlIGZ1bGwgY2FwYWJpbGl0aWVzIG9mIHlvdXIgdmF1bHQncyBrbm93bGVkZ2UgZ3JhcGguYDtcbiAgICAgICAgXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJVbmtub3duIG1vZGUgc2VsZWN0ZWQuXCI7XG4gICAgfVxuICB9XG4gIFxuICBwcml2YXRlIGFzeW5jIHN5bmNUb1VzZXJDbG91ZCgpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uZXhwb3J0RGF0YSgnZ3JhcGgnLCB0cnVlKTtcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmV4cG9ydERhdGEoJ3ZlY3RvcnMnLCB0cnVlKTtcbiAgICAgIG5ldyBOb3RpY2UoXCJGdWxsIGRhdGEgc3luY2VkIHRvIHlvdXIgY2xvdWQgc2VydmljZVwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXcgTm90aWNlKFwiU3luYyBmYWlsZWQ6IFwiICsgKGUgYXMgRXJyb3IpLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBSb2xlIE1hbmFnZW1lbnQgTW9kYWxcbmNsYXNzIFJvbGVNYW5hZ2VtZW50TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwcDogQXBwLCBcbiAgICBwcml2YXRlIHBsdWdpbjogQUlNQ1BQbHVnaW4sXG4gICAgcHJpdmF0ZSBvblJvbGVDaGFuZ2U6ICgpID0+IHZvaWRcbiAgKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IFwiTWFuYWdlIEFJIFJvbGVzXCIgfSk7XG4gICAgXG4gICAgdGhpcy5kaXNwbGF5Um9sZXMoKTtcbiAgICBcbiAgICAvLyBBZGQgbmV3IHJvbGUgYnV0dG9uXG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiYnV0dG9uXCIsIHsgXG4gICAgICB0ZXh0OiBcIkFkZCBOZXcgUm9sZVwiLCBcbiAgICAgIGNsczogXCJtb2QtY3RhXCIgXG4gICAgfSkub25jbGljayA9ICgpID0+IHRoaXMuYWRkTmV3Um9sZSgpO1xuICB9XG4gIFxuICBwcml2YXRlIGFzeW5jIGRpc3BsYXlSb2xlcygpIHtcbiAgICBjb25zdCByb2xlcyA9IGF3YWl0IHRoaXMucGx1Z2luLmxvYWRSb2xlc0Zyb21WYXVsdCgpO1xuICAgIGNvbnN0IHJvbGVzTGlzdCA9IHRoaXMuY29udGVudEVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcInJvbGUtbGlzdFwiIH0pO1xuICAgIFxuICAgIE9iamVjdC5lbnRyaWVzKHJvbGVzKS5mb3JFYWNoKChbbmFtZSwgcHJvbXB0XSkgPT4ge1xuICAgICAgY29uc3Qgcm9sZUl0ZW0gPSByb2xlc0xpc3QuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwicm9sZS1pdGVtXCIgfSk7XG4gICAgICByb2xlSXRlbS5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogbmFtZSB9KTtcbiAgICAgIFxuICAgICAgcm9sZUl0ZW0uY3JlYXRlRWwoXCJkaXZcIiwgeyBcbiAgICAgICAgY2xzOiBcInByb21wdC1wcmV2aWV3XCIsIFxuICAgICAgICB0ZXh0OiBwcm9tcHQuc3Vic3RyaW5nKDAsIDEwMCkgKyAocHJvbXB0Lmxlbmd0aCA+IDEwMCA/IFwiLi4uXCIgOiBcIlwiKSBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjb25zdCBhY3Rpb25zID0gcm9sZUl0ZW0uY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwicm9sZS1hY3Rpb25zXCIgfSk7XG4gICAgICBhY3Rpb25zLmNyZWF0ZUVsKFwiYnV0dG9uXCIsIHsgdGV4dDogXCJFZGl0XCIgfSkub25jbGljayA9ICgpID0+IFxuICAgICAgICB0aGlzLmVkaXRSb2xlKG5hbWUsIHByb21wdCk7XG4gICAgICBhY3Rpb25zLmNyZWF0ZUVsKFwiYnV0dG9uXCIsIHsgdGV4dDogXCJFeHBvcnRcIiB9KS5vbmNsaWNrID0gKCkgPT4gXG4gICAgICAgIHRoaXMuZXhwb3J0Um9sZShuYW1lKTtcbiAgICAgIGFjdGlvbnMuY3JlYXRlRWwoXCJidXR0b25cIiwgeyB0ZXh0OiBcIkRlbGV0ZVwiIH0pLm9uY2xpY2sgPSAoKSA9PiBcbiAgICAgICAgdGhpcy5kZWxldGVSb2xlKG5hbWUpO1xuICAgIH0pO1xuICB9XG4gIFxuICBwcml2YXRlIGFzeW5jIGFkZE5ld1JvbGUoKSB7XG4gICAgY29uc3QgbmFtZSA9IHByb21wdChcIkVudGVyIHJvbGUgbmFtZTpcIik7XG4gICAgaWYgKCFuYW1lKSByZXR1cm47XG4gICAgXG4gICAgY29uc3Qgcm9sZVByb21wdCA9IHByb21wdChcIkVudGVyIHN5c3RlbSBwcm9tcHQgZm9yIHRoaXMgcm9sZTpcIiwgXG4gICAgICBcIllvdSBhcmUgYSBoZWxwZnVsIEFJIGFzc2lzdGFudC5cIik7XG4gICAgaWYgKCFyb2xlUHJvbXB0KSByZXR1cm47XG4gICAgXG4gICAgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNyZWF0ZShcbiAgICAgIGBBSSBSb2xlcy8ke25hbWV9Lm1kYCwgXG4gICAgICByb2xlUHJvbXB0XG4gICAgKTtcbiAgICBcbiAgICB0aGlzLm9uUm9sZUNoYW5nZSgpO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSBhc3luYyBlZGl0Um9sZShuYW1lOiBzdHJpbmcsIGN1cnJlbnRQcm9tcHQ6IHN0cmluZykge1xuICAgIGNvbnN0IG5ld1Byb21wdCA9IHByb21wdChcIkVkaXQgc3lzdGVtIHByb21wdDpcIiwgY3VycmVudFByb21wdCk7XG4gICAgaWYgKCFuZXdQcm9tcHQgfHwgbmV3UHJvbXB0ID09PSBjdXJyZW50UHJvbXB0KSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZmlsZSA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYEFJIFJvbGVzLyR7bmFtZX0ubWRgKTtcbiAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQubW9kaWZ5KGZpbGUsIG5ld1Byb21wdCk7XG4gICAgICB0aGlzLm9uUm9sZUNoYW5nZSgpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBhc3luYyBleHBvcnRSb2xlKG5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGBBSSBSb2xlcy8ke25hbWV9Lm1kYCk7XG4gICAgaWYgKCFmaWxlIHx8ICEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdLCB7IHR5cGU6ICd0ZXh0L21hcmtkb3duJyB9KTtcbiAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIFxuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgYS5ocmVmID0gdXJsO1xuICAgIGEuZG93bmxvYWQgPSBgJHtuYW1lfS1yb2xlLXRlbXBsYXRlLm1kYDtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICAgIGEuY2xpY2soKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSBhc3luYyBkZWxldGVSb2xlKG5hbWU6IHN0cmluZykge1xuICAgIGlmICghY29uZmlybShgRGVsZXRlIHJvbGUgXCIke25hbWV9XCI/YCkpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBmaWxlID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChgQUkgUm9sZXMvJHtuYW1lfS5tZGApO1xuICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5kZWxldGUoZmlsZSk7XG4gICAgICB0aGlzLm9uUm9sZUNoYW5nZSgpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBNZW1vcnkgR3JhcGggQ2xhc3NcbmNsYXNzIE1lbW9yeUdyYXBoIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwbHVnaW46IEFJTUNQUGx1Z2luKSB7fVxuICBcbiAgYXN5bmMgYWRkTm9kZShub2RlRGF0YTogUGFydGlhbDxNZW1vcnlOb2RlPiwgZW1iZWRkaW5nPzogbnVtYmVyW10pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG5vZGU6IE1lbW9yeU5vZGUgPSB7XG4gICAgICBpZDogdXVpZHY0KCksXG4gICAgICB0eXBlOiBub2RlRGF0YS50eXBlIHx8ICdjb250ZXh0JyxcbiAgICAgIGNvbnRlbnQ6IG5vZGVEYXRhLmNvbnRlbnQgfHwgJycsXG4gICAgICBzdW1tYXJ5OiBub2RlRGF0YS5zdW1tYXJ5IHx8IG5vZGVEYXRhLmNvbnRlbnQ/LnN1YnN0cmluZygwLCAxMDApIHx8ICcnLFxuICAgICAgdGltZXN0YW1wOiB7XG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB2YWxpZF9mcm9tOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIHZhbGlkX3VudGlsOiBudWxsXG4gICAgICB9LFxuICAgICAgY29uZmlkZW5jZTogbm9kZURhdGEuY29uZmlkZW5jZSB8fCAwLjgsXG4gICAgICBzb3VyY2VzOiBub2RlRGF0YS5zb3VyY2VzIHx8IFtdLFxuICAgICAgZW1iZWRkaW5nczogZW1iZWRkaW5nIHx8IFtdLFxuICAgICAgYXR0cmlidXRlczogbm9kZURhdGEuYXR0cmlidXRlcyB8fCB7fSxcbiAgICAgIGdyb3VwX2lkOiBub2RlRGF0YS5ncm91cF9pZCB8fCAnZGVmYXVsdCcsXG4gICAgICB2ZXJzaW9uOiAxLFxuICAgICAgcHJvcGVydGllczogbm9kZURhdGEucHJvcGVydGllcyB8fCB7fVxuICAgIH07XG4gICAgXG4gICAgY29uc3QgZ3JhcGggPSBhd2FpdCB0aGlzLmxvYWQoKTtcbiAgICBncmFwaC5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgIGF3YWl0IHRoaXMuc2F2ZShncmFwaCk7XG4gICAgXG4gICAgcmV0dXJuIG5vZGUuaWQ7XG4gIH1cbiAgXG4gIGFzeW5jIGxvYWQoKTogUHJvbWlzZTxHcmFwaERhdGE+IHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5wbHVnaW4ucHJvamVjdEluc3RydWN0aW9ucy5tY3BfY29uZmlnLm1lbW9yeV9ncmFwaC5maWxlX3BhdGg7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuYWRhcHRlci5leGlzdHMocGF0aCkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5hZGFwdGVyLnJlYWQocGF0aCk7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGdyYXBoOicsIGUpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFbXB0eUdyYXBoKCk7XG4gIH1cbiAgXG4gIGFzeW5jIHNhdmUoZ3JhcGg6IEdyYXBoRGF0YSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLnBsdWdpbi5wcm9qZWN0SW5zdHJ1Y3Rpb25zLm1jcF9jb25maWcubWVtb3J5X2dyYXBoLmZpbGVfcGF0aDtcbiAgICBncmFwaC5ncmFwaF9tZXRhZGF0YS5sYXN0X3N5bmMgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgZ3JhcGguZ3JhcGhfbWV0YWRhdGEudG90YWxfbm9kZXMgPSBncmFwaC5ub2Rlcy5sZW5ndGg7XG4gICAgZ3JhcGguZ3JhcGhfbWV0YWRhdGEudG90YWxfZWRnZXMgPSBncmFwaC5lZGdlcy5sZW5ndGg7XG4gICAgXG4gICAgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmFkYXB0ZXIud3JpdGUocGF0aCwgSlNPTi5zdHJpbmdpZnkoZ3JhcGgsIG51bGwsIDIpKTtcbiAgfVxuICBcbiAgcHJpdmF0ZSBjcmVhdGVFbXB0eUdyYXBoKCk6IEdyYXBoRGF0YSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtYV92ZXJzaW9uOiBcIjEuMC4wXCIsXG4gICAgICBncmFwaF9tZXRhZGF0YToge1xuICAgICAgICB0b3RhbF9ub2RlczogMCxcbiAgICAgICAgdG90YWxfZWRnZXM6IDAsXG4gICAgICAgIGxhc3Rfc3luYzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICBkZXZpY2VfaWQ6IHV1aWR2NCgpLFxuICAgICAgICB2ZXJzaW9uOiAxXG4gICAgICB9LFxuICAgICAgbm9kZXM6IFtdLFxuICAgICAgZWRnZXM6IFtdXG4gICAgfTtcbiAgfVxufVxuXG4vLyBSQUcgSW50ZWdyYXRvciBDbGFzc1xuY2xhc3MgUkFHSW50ZWdyYXRvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGx1Z2luOiBBSU1DUFBsdWdpbikge31cbiAgXG4gIGFzeW5jIHNlYXJjaFNpbWlsYXIocXVlcnlFbWJlZGRpbmc6IG51bWJlcltdLCBsaW1pdDogbnVtYmVyID0gNSk6IFByb21pc2U8QXJyYXk8e3RleHQ6IHN0cmluZywgc2NvcmU6IG51bWJlcn0+PiB7XG4gICAgaWYgKCF0aGlzLnBsdWdpbi5xZHJhbnRDbGllbnQpIHJldHVybiBbXTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wbHVnaW4ucWRyYW50Q2xpZW50LnNlYXJjaChcbiAgICAgICAgdGhpcy5wbHVnaW4ucHJvamVjdEluc3RydWN0aW9ucy5yYWdfY29uZmlnLnFkcmFudF9jb25maWcuY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICB7XG4gICAgICAgICAgdmVjdG9yOiBxdWVyeUVtYmVkZGluZyxcbiAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICB3aXRoX3BheWxvYWQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdC5tYXAocG9pbnQgPT4gKHtcbiAgICAgICAgdGV4dDogcG9pbnQucGF5bG9hZD8udGV4dCBhcyBzdHJpbmcgfHwgJycsXG4gICAgICAgIHNjb3JlOiBwb2ludC5zY29yZSB8fCAwXG4gICAgICB9KSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignU2VhcmNoIGZhaWxlZDonLCBlKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cbiAgXG4gIGFzeW5jIHVwc2VydFRvUWRyYW50KGlkOiBzdHJpbmcsIHZlY3RvcjogbnVtYmVyW10sIHRleHQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5wbHVnaW4ucWRyYW50Q2xpZW50KSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnFkcmFudENsaWVudC51cHNlcnQoXG4gICAgICAgIHRoaXMucGx1Z2luLnByb2plY3RJbnN0cnVjdGlvbnMucmFnX2NvbmZpZy5xZHJhbnRfY29uZmlnLmNvbGxlY3Rpb25fbmFtZSxcbiAgICAgICAge1xuICAgICAgICAgIHBvaW50czogW3tcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdmVjdG9yLFxuICAgICAgICAgICAgcGF5bG9hZDogeyB0ZXh0IH1cbiAgICAgICAgICB9XVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vwc2VydCBmYWlsZWQ6JywgZSk7XG4gICAgfVxuICB9XG4gIFxuICBhc3luYyBleHBvcnRWZWN0b3JzKCk6IFByb21pc2U8YW55W10+IHtcbiAgICBpZiAoIXRoaXMucGx1Z2luLnFkcmFudENsaWVudCkgcmV0dXJuIFtdO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnBsdWdpbi5xZHJhbnRDbGllbnQuc2Nyb2xsKFxuICAgICAgICB0aGlzLnBsdWdpbi5wcm9qZWN0SW5zdHJ1Y3Rpb25zLnJhZ19jb25maWcucWRyYW50X2NvbmZpZy5jb2xsZWN0aW9uX25hbWUsXG4gICAgICAgIHsgbGltaXQ6IDEwMDAwLCB3aXRoX3BheWxvYWQ6IHRydWUsIHdpdGhfdmVjdG9yOiB0cnVlIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gcmVzdWx0LnBvaW50cztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFeHBvcnQgZmFpbGVkOicsIGUpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuICBcbiAgYXN5bmMgaW1wb3J0VmVjdG9ycyhwb2ludHM6IGFueVtdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLnBsdWdpbi5xZHJhbnRDbGllbnQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4ucWRyYW50Q2xpZW50LnVwc2VydChcbiAgICAgICAgdGhpcy5wbHVnaW4ucHJvamVjdEluc3RydWN0aW9ucy5yYWdfY29uZmlnLnFkcmFudF9jb25maWcuY29sbGVjdGlvbl9uYW1lLFxuICAgICAgICB7IHBvaW50cyB9XG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ltcG9ydCBmYWlsZWQ6JywgZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFBsYW5uaW5nIEFnZW50IENsYXNzXG5jbGFzcyBQbGFubmluZ0FnZW50IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwbHVnaW46IEFJTUNQUGx1Z2luKSB7fVxuICBcbiAgYXN5bmMgcGxhbldpdGhSb2xlKHJvbGU6IHN0cmluZywgcXVlcnk/OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGdyYXBoID0gYXdhaXQgdGhpcy5wbHVnaW4ubWVtb3J5R3JhcGgubG9hZCgpO1xuICAgIGNvbnN0IHN5c3RlbVByb21wdCA9IHRoaXMucGx1Z2luLnByb2plY3RJbnN0cnVjdGlvbnMuYWlfYmVoYXZpb3Iucm9sZXNbcm9sZV07XG4gICAgXG4gICAgY29uc3QgdGFza3MgPSBncmFwaC5ub2Rlc1xuICAgICAgLmZpbHRlcihuID0+IG4udHlwZSA9PT0gJ3Rhc2snKVxuICAgICAgLnNsaWNlKDAsIHRoaXMucGx1Z2luLnByb2plY3RJbnN0cnVjdGlvbnMubWNwX2NvbmZpZy5wbGFubmluZ19hZ2VudC5tYXhfdGFza3MpO1xuICAgIFxuICAgIGNvbnN0IHBsYW4gPSBgUGxhbm5pbmcgYXMgJHtyb2xlfTpcXG5cXG5RdWVyeTogJHtxdWVyeSB8fCAnR2VuZXJhbCBwbGFubmluZyd9XFxuXFxuU3lzdGVtOiAke3N5c3RlbVByb21wdH1cXG5cXG5BdmFpbGFibGUgdGFza3M6ICR7dGFza3MubWFwKHQgPT4gdC5jb250ZW50KS5qb2luKCc7ICcpfVxcblxcblJlY29tbWVuZGVkIG5leHQgc3RlcHMgYmFzZWQgb24geW91ciB2YXVsdCdzIGtub3dsZWRnZSBncmFwaC5gO1xuICAgIFxuICAgIC8vIENyZWF0ZSBwbGFuIG5vdGVcbiAgICBjb25zdCBwbGFuRmlsZSA9IGBwbGFuLSR7cm9sZX0tJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwxMCl9Lm1kYDtcbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuY3JlYXRlKHBsYW5GaWxlLCBwbGFuKTtcbiAgICBcbiAgICByZXR1cm4gcGxhbjtcbiAgfVxufVxuXG4vLyBNYWluIFBsdWdpbiBDbGFzc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQUlNQ1BQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5nczogUGx1Z2luU2V0dGluZ3M7XG4gIHByb2plY3RJbnN0cnVjdGlvbnM6IGFueTtcbiAgbWVtb3J5R3JhcGg6IE1lbW9yeUdyYXBoO1xuICByYWdJbnRlZ3JhdG9yOiBSQUdJbnRlZ3JhdG9yO1xuICBwbGFubmluZ0FnZW50OiBQbGFubmluZ0FnZW50O1xuICBlbWJlZGRpbmdzOiBNaXN0cmFsQUlFbWJlZGRpbmdzO1xuICBxZHJhbnRDbGllbnQ6IFFkcmFudENsaWVudCB8IG51bGwgPSBudWxsO1xuICBsYXN0SGFzaGVzOiBNYXA8c3RyaW5nLCBzdHJpbmc+ID0gbmV3IE1hcCgpO1xuICBwZXJmb3JtYW5jZU9wdGltaXplcjogUGVyZm9ybWFuY2VPcHRpbWl6ZXI7XG4gIGFkdmFuY2VkRmVhdHVyZXM6IEFkdmFuY2VkRmVhdHVyZXM7XG4gIFxuICAvLyBOZXcgaW50ZWdyYXRpb25zXG4gIHZveWFnZUFJOiBWb3lhZ2VBSUludGVncmF0aW9uO1xuICB2ZXJjZWxBSTogVmVyY2VsQUlJbnRlZ3JhdGlvbjtcbiAgZW1haWxTZXJ2aWNlOiBFbWFpbFNlcnZpY2U7XG4gIGZpbGVTaGFyZVNlcnZpY2U6IEZpbGVTaGFyZVNlcnZpY2U7XG4gIG5vdGlmaWNhdGlvbk1hbmFnZXI6IE5vdGlmaWNhdGlvbk1hbmFnZXI7XG4gIGVuaGFuY2VkU2VhcmNoOiBFbmhhbmNlZFNlYXJjaEVuZ2luZTtcblxuICBhc3luYyBvbmxvYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGNvbXBvbmVudHNcbiAgICB0aGlzLm1lbW9yeUdyYXBoID0gbmV3IE1lbW9yeUdyYXBoKHRoaXMpO1xuICAgIHRoaXMucmFnSW50ZWdyYXRvciA9IG5ldyBSQUdJbnRlZ3JhdG9yKHRoaXMpO1xuICAgIHRoaXMucGxhbm5pbmdBZ2VudCA9IG5ldyBQbGFubmluZ0FnZW50KHRoaXMpO1xuICAgIHRoaXMucGVyZm9ybWFuY2VPcHRpbWl6ZXIgPSBuZXcgUGVyZm9ybWFuY2VPcHRpbWl6ZXIodGhpcyk7XG4gICAgdGhpcy5hZHZhbmNlZEZlYXR1cmVzID0gbmV3IEFkdmFuY2VkRmVhdHVyZXModGhpcyk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBuZXcgaW50ZWdyYXRpb25zXG4gICAgdGhpcy52b3lhZ2VBSSA9IG5ldyBWb3lhZ2VBSUludGVncmF0aW9uKHRoaXMpO1xuICAgIHRoaXMudmVyY2VsQUkgPSBuZXcgVmVyY2VsQUlJbnRlZ3JhdGlvbih0aGlzKTtcbiAgICB0aGlzLmVtYWlsU2VydmljZSA9IG5ldyBFbWFpbFNlcnZpY2UodGhpcyk7XG4gICAgdGhpcy5maWxlU2hhcmVTZXJ2aWNlID0gbmV3IEZpbGVTaGFyZVNlcnZpY2UodGhpcywgdGhpcy5lbWFpbFNlcnZpY2UpO1xuICAgIHRoaXMubm90aWZpY2F0aW9uTWFuYWdlciA9IG5ldyBOb3RpZmljYXRpb25NYW5hZ2VyKHRoaXMsIHRoaXMuZW1haWxTZXJ2aWNlLCB0aGlzLmZpbGVTaGFyZVNlcnZpY2UpO1xuICAgIHRoaXMuZW5oYW5jZWRTZWFyY2ggPSBuZXcgRW5oYW5jZWRTZWFyY2hFbmdpbmUodGhpcywgdGhpcy52b3lhZ2VBSSwgdGhpcy52ZXJjZWxBSSk7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSBpbnRlZ3JhdGlvbnMgd2l0aCBzZXR0aW5nc1xuICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUludGVncmF0aW9ucygpO1xuICAgIFxuICAgIGF3YWl0IHRoaXMubG9hZFByb2plY3RJbnN0cnVjdGlvbnMoKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIGVtYmVkZGluZ3MgaWYgQVBJIGtleSBpcyBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5taXN0cmFsQXBpS2V5KSB7XG4gICAgICB0aGlzLmVtYmVkZGluZ3MgPSBuZXcgTWlzdHJhbEFJRW1iZWRkaW5ncyh7IFxuICAgICAgICBhcGlLZXk6IHRoaXMuc2V0dGluZ3MubWlzdHJhbEFwaUtleSBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaWxlIHdhdGNoZXJzXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oJ21vZGlmeScsIChmaWxlOiBURmlsZSkgPT4gdGhpcy5oYW5kbGVGaWxlQ2hhbmdlKGZpbGUpKVxuICAgICk7XG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oJ2NyZWF0ZScsIChmaWxlOiBURmlsZSkgPT4gdGhpcy5oYW5kbGVGaWxlQ2hhbmdlKGZpbGUpKVxuICAgICk7XG4gICAgXG4gICAgLy8gUmVnaXN0ZXIgdmlld3NcbiAgICB0aGlzLnJlZ2lzdGVyVmlldyhcbiAgICAgIENoYXRWaWV3LlZJRVdfVFlQRSxcbiAgICAgIChsZWFmKSA9PiBuZXcgQ2hhdFZpZXcobGVhZiwgdGhpcylcbiAgICApO1xuICAgIFxuICAgIHRoaXMucmVnaXN0ZXJWaWV3KFxuICAgICAgRGFzaGJvYXJkVmlldy5WSUVXX1RZUEUsXG4gICAgICAobGVhZikgPT4gbmV3IERhc2hib2FyZFZpZXcobGVhZiwgdGhpcylcbiAgICApO1xuICAgIFxuICAgIC8vIENvbW1hbmRzXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnb3Blbi1haS1jaGF0JyxcbiAgICAgIG5hbWU6ICdPcGVuIEFJIENoYXQgSW50ZXJmYWNlJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLm9wZW5Sb2xlQ2hhdCgpXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnaW5pdGlhbGl6ZS12YXVsdC1tZW1vcnknLFxuICAgICAgbmFtZTogJ0luaXRpYWxpemUgVmF1bHQgTWVtb3J5IChGdWxsIFNjYW4pJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLmluaXRpYWxpemVWYXVsdCgpXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnYWRkLW1hcmtkb3duLWNvbnRleHQnLFxuICAgICAgbmFtZTogJ0FkZCBNYXJrZG93biBhcyBDb250ZXh0IHRvIEdyYXBoJyxcbiAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yKSA9PiB0aGlzLmFkZE1hcmtkb3duQ29udGV4dChlZGl0b3IuZ2V0VmFsdWUoKSlcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICd0ZXN0LXZhdWx0LXJlY2FsbCcsXG4gICAgICBuYW1lOiAnVGVzdCBWYXVsdCBSZWNhbGwnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMudGVzdFJlY2FsbCgpXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnZXhwb3J0LWdyYXBoJyxcbiAgICAgIG5hbWU6ICdFeHBvcnQgTWVtb3J5IEdyYXBoJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB0aGlzLmV4cG9ydERhdGEoJ2dyYXBoJylcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdpbXBvcnQtZ3JhcGgnLFxuICAgICAgbmFtZTogJ0ltcG9ydCBNZW1vcnkgR3JhcGgnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuaW1wb3J0RGF0YSgnZ3JhcGgnKVxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogJ3Zpc3VhbGl6ZS1ncmFwaCcsXG4gICAgICBuYW1lOiAnVmlzdWFsaXplIE1lbW9yeSBHcmFwaCcsXG4gICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy52aXN1YWxpemVJbkdyYXBoVmlldygpXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAncGxhbi10YXNrcycsXG4gICAgICBuYW1lOiAnUGxhbiBUYXNrcyB3aXRoIFJvbGUnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMucGxhbm5pbmdBZ2VudC5wbGFuV2l0aFJvbGUodGhpcy5zZXR0aW5ncy5kZWZhdWx0Um9sZSlcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdpbXBvcnQtcm9sZS10ZW1wbGF0ZScsXG4gICAgICBuYW1lOiAnSW1wb3J0IFJvbGUgVGVtcGxhdGUgZnJvbSBNYXJrZG93bicsXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZUZpbGUoKTtcbiAgICAgICAgaWYgKGZpbGUgJiYgZmlsZS5leHRlbnNpb24gPT09ICdtZCcpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmltcG9ydFJvbGVGcm9tTWFya2Rvd24oZmlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIG9wZW4gYSBtYXJrZG93biBmaWxlIGZpcnN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdzaG93LXNtYXJ0LXN1Z2dlc3Rpb25zJyxcbiAgICAgIG5hbWU6ICdTaG93IFNtYXJ0IFN1Z2dlc3Rpb25zJyxcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gYXdhaXQgdGhpcy5hZHZhbmNlZEZlYXR1cmVzLmdlbmVyYXRlU21hcnRTdWdnZXN0aW9ucygpO1xuICAgICAgICBuZXcgU21hcnRTdWdnZXN0aW9uc01vZGFsKHRoaXMsIHN1Z2dlc3Rpb25zKS5vcGVuKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnYXV0by10YWctY3VycmVudC1ub3RlJyxcbiAgICAgIG5hbWU6ICdBdXRvLXRhZyBDdXJyZW50IE5vdGUnLFxuICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgICAgIGlmIChmaWxlICYmIGZpbGUuZXh0ZW5zaW9uID09PSAnbWQnKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgICAgY29uc3QgdGFncyA9IGF3YWl0IHRoaXMuYWR2YW5jZWRGZWF0dXJlcy5hdXRvVGFnQ29udGVudChmaWxlLCBjb250ZW50KTtcbiAgICAgICAgICBpZiAodGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdTdHJpbmcgPSB0YWdzLm1hcCh0YWcgPT4gYCMke3RhZ31gKS5qb2luKCcgJyk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZmlsZSwgY29udGVudCArICdcXG5cXG4nICsgdGFnU3RyaW5nKTtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEFkZGVkICR7dGFncy5sZW5ndGh9IHRhZ3MgdG8gY3VycmVudCBub3RlYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoJ05vIHN1aXRhYmxlIHRhZ3MgZm91bmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIG9wZW4gYSBtYXJrZG93biBmaWxlIGZpcnN0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdvcHRpbWl6ZS1tZW1vcnktdXNhZ2UnLFxuICAgICAgbmFtZTogJ09wdGltaXplIE1lbW9yeSBVc2FnZScsXG4gICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLnBlcmZvcm1hbmNlT3B0aW1pemVyLm9wdGltaXplTWVtb3J5VXNhZ2UoKTtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSB0aGlzLnBlcmZvcm1hbmNlT3B0aW1pemVyLmdldENhY2hlU3RhdHMoKTtcbiAgICAgICAgbmV3IE5vdGljZShgTWVtb3J5IG9wdGltaXplZC4gQ2FjaGU6ICR7c3RhdHMuc2l6ZX0gaXRlbXMsIEhpdCByYXRlOiAkeyhzdGF0cy5oaXRSYXRlICogMTAwKS50b0ZpeGVkKDEpfSVgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdzbWFydC1zZWFyY2gnLFxuICAgICAgbmFtZTogJ1NtYXJ0IFNlYXJjaCcsXG4gICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICBjb25zdCBxdWVyeSA9IHByb21wdCgnRW50ZXIgc2VhcmNoIHF1ZXJ5OicpO1xuICAgICAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgICB0aGlzLnBlcmZvcm1TbWFydFNlYXJjaChxdWVyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBOZXcgY29tbWFuZHMgZm9yIGVuaGFuY2VkIGZlYXR1cmVzXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnb3Blbi1kYXNoYm9hcmQnLFxuICAgICAgbmFtZTogJ09wZW4gQUkgTUNQIERhc2hib2FyZCcsXG4gICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5vcGVuRGFzaGJvYXJkKClcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdlbmhhbmNlZC1zZWFyY2gnLFxuICAgICAgbmFtZTogJ0VuaGFuY2VkIFNlYXJjaCB3aXRoIFJlcmFuaycsXG4gICAgICBjYWxsYmFjazogKCkgPT4gdGhpcy5vcGVuRW5oYW5jZWRTZWFyY2goKVxuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogJ3NoYXJlLWZpbGUtZW1haWwnLFxuICAgICAgbmFtZTogJ1NoYXJlIEN1cnJlbnQgRmlsZSB2aWEgRW1haWwnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuc2hhcmVDdXJyZW50RmlsZVZpYUVtYWlsKClcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICdzZW5kLXZhdWx0LXN1bW1hcnknLFxuICAgICAgbmFtZTogJ1NlbmQgVmF1bHQgU3VtbWFyeSB2aWEgRW1haWwnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMuc2VuZFZhdWx0U3VtbWFyeUVtYWlsKClcbiAgICB9KTtcbiAgICBcbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6ICd0ZXN0LWFpLXByb3ZpZGVycycsXG4gICAgICBuYW1lOiAnVGVzdCBBSSBQcm92aWRlcnMnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHRoaXMudGVzdEFJUHJvdmlkZXJzKClcbiAgICB9KTtcbiAgICBcbiAgICAvLyBSaWJib24gaWNvbnNcbiAgICB0aGlzLmFkZFJpYmJvbkljb24oJ2JyYWluJywgJ0FJIENoYXQgd2l0aCBSb2xlJywgKCkgPT4gdGhpcy5vcGVuUm9sZUNoYXQoKSk7XG4gICAgdGhpcy5hZGRSaWJib25JY29uKCdsYXlvdXQtZGFzaGJvYXJkJywgJ0FJIE1DUCBEYXNoYm9hcmQnLCAoKSA9PiB0aGlzLm9wZW5EYXNoYm9hcmQoKSk7XG4gICAgXG4gICAgLy8gU2V0dGluZ3MgdGFiXG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBBSU1DUFNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcbiAgICBcbiAgICBuZXcgTm90aWNlKCdBSSBNQ1AgUGx1Z2luIGxvYWRlZCEgXHVEODNFXHVEREUwJyk7XG4gIH1cblxuICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIGF3YWl0IHRoaXMubG9hZERhdGEoKSk7XG4gIH1cblxuICBhc3luYyBzYXZlU2V0dGluZ3MoKSB7XG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgfVxuXG4gIGFzeW5jIGxvYWRQcm9qZWN0SW5zdHJ1Y3Rpb25zKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5zZXR0aW5ncy5wcm9qZWN0SW5zdHJ1Y3Rpb25zUGF0aDtcbiAgICAgIGlmIChhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhwYXRoKSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5yZWFkKHBhdGgpO1xuICAgICAgICB0aGlzLnByb2plY3RJbnN0cnVjdGlvbnMgPSBKU09OLnBhcnNlKGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci53cml0ZShcbiAgICAgICAgICBwYXRoLCBcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShERUZBVUxUX0lOU1RSVUNUSU9OUywgbnVsbCwgMilcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0SW5zdHJ1Y3Rpb25zID0gREVGQVVMVF9JTlNUUlVDVElPTlM7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuaW5pdFFkcmFudCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIGluc3RydWN0aW9uczonLCBlKTtcbiAgICAgIHRoaXMucHJvamVjdEluc3RydWN0aW9ucyA9IERFRkFVTFRfSU5TVFJVQ1RJT05TO1xuICAgIH1cbiAgfVxuXG4gIGluaXRRZHJhbnQoKSB7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLnFkcmFudFVybCkgcmV0dXJuO1xuICAgIFxuICAgIHRoaXMucWRyYW50Q2xpZW50ID0gbmV3IFFkcmFudENsaWVudCh7IFxuICAgICAgdXJsOiB0aGlzLnNldHRpbmdzLnFkcmFudFVybCwgXG4gICAgICBhcGlLZXk6IHRoaXMuc2V0dGluZ3MucWRyYW50QXBpS2V5IHx8IHVuZGVmaW5lZFxuICAgIH0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBjb2xsZWN0aW9uIGlmIG5vdCBleGlzdHNcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLnByb2plY3RJbnN0cnVjdGlvbnMucmFnX2NvbmZpZy5xZHJhbnRfY29uZmlnO1xuICAgIHRoaXMucWRyYW50Q2xpZW50LmNyZWF0ZUNvbGxlY3Rpb24oY29uZmlnLmNvbGxlY3Rpb25fbmFtZSwgeyBcbiAgICAgIHZlY3RvcnM6IHsgc2l6ZTogMTAyNCwgZGlzdGFuY2U6ICdDb3NpbmUnIH0gXG4gICAgfSkuY2F0Y2goKCkgPT4ge1xuICAgICAgLy8gQ29sbGVjdGlvbiBtaWdodCBhbHJlYWR5IGV4aXN0XG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBsb2FkUm9sZXNGcm9tVmF1bHQoKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+PiB7XG4gICAgY29uc3Qgcm9sZUZvbGRlciA9ICdBSSBSb2xlcyc7XG4gICAgY29uc3Qgcm9sZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBcbiAgICAvLyBDcmVhdGUgZm9sZGVyIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoIShhd2FpdCB0aGlzLmFwcC52YXVsdC5hZGFwdGVyLmV4aXN0cyhyb2xlRm9sZGVyKSkpIHtcbiAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZUZvbGRlcihyb2xlRm9sZGVyKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTG9hZCBhbGwgZmlsZXMgaW4gZm9sZGVyXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgdGhpcy5hcHAudmF1bHQuYWRhcHRlci5saXN0KHJvbGVGb2xkZXIpO1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzLmZpbGVzKSB7XG4gICAgICAgIGlmIChmaWxlLmVuZHNXaXRoKCcubWQnKSkge1xuICAgICAgICAgIGNvbnN0IHJvbGVOYW1lID0gZmlsZS5zcGxpdCgnLycpLnBvcCgpPy5yZXBsYWNlKCcubWQnLCAnJykgfHwgJyc7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LmFkYXB0ZXIucmVhZChmaWxlKTtcbiAgICAgICAgICByb2xlc1tyb2xlTmFtZV0gPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgcm9sZXM6JywgZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBkZWZhdWx0IHJvbGVzIGlmIGVtcHR5XG4gICAgaWYgKE9iamVjdC5rZXlzKHJvbGVzKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRSb2xlcyA9IHtcbiAgICAgICAgJ2Fzc2lzdGFudCc6ICdIZWxwZnVsIGFzc2lzdGFudCByZWNhbGxpbmcgdmF1bHQgY29udGV4dCB2aWEgZ3JhcGguJyxcbiAgICAgICAgJ3BsYW5uZXInOiAnUGxhbiB0YXNrcyB1c2luZyB0ZW1wb3JhbCBlZGdlcyBpbiBtZW1vcnkgZ3JhcGguJyxcbiAgICAgICAgJ3Jlc2VhcmNoZXInOiAnU2VhcmNoIG1lYW5pbmdzL3NpbWlsYXJpdGllcyB3aXRoIFFkcmFudCB2ZWN0b3JzLidcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgW25hbWUsIHByb21wdF0gb2YgT2JqZWN0LmVudHJpZXMoZGVmYXVsdFJvbGVzKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUoYCR7cm9sZUZvbGRlcn0vJHtuYW1lfS5tZGAsIHByb21wdCk7XG4gICAgICAgIHJvbGVzW25hbWVdID0gcHJvbXB0O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcm9sZXM7XG4gIH1cblxuICBhc3luYyBoYW5kbGVGaWxlQ2hhbmdlKGZpbGU6IFRGaWxlKSB7XG4gICAgaWYgKGZpbGUuZXh0ZW5zaW9uICE9PSAnbWQnKSByZXR1cm47XG4gICAgaWYgKCF0aGlzLmVtYmVkZGluZ3MpIHJldHVybjtcbiAgICBcbiAgICAvLyBVc2UgcGVyZm9ybWFuY2Ugb3B0aW1pemVyIGZvciBkZWJvdW5jZWQgcHJvY2Vzc2luZ1xuICAgIHRoaXMucGVyZm9ybWFuY2VPcHRpbWl6ZXIuZGVib3VuY2VGaWxlUHJvY2Vzc2luZyhmaWxlKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFzaENvbnRlbnQoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBTaW1wbGUgaGFzaCBmdW5jdGlvblxuICAgIGxldCBoYXNoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXIgPSBjb250ZW50LmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjaGFyO1xuICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG4gICAgcmV0dXJuIGhhc2gudG9TdHJpbmcoKTtcbiAgfVxuXG4gIGFzeW5jIGluaXRpYWxpemVWYXVsdCgpIHtcbiAgICBpZiAoIXRoaXMuZW1iZWRkaW5ncykge1xuICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIHNldCBNaXN0cmFsIEFQSSBrZXkgZmlyc3QnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmlsZXMgPSB0aGlzLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICAgIC5maWx0ZXIoZiA9PiBmLnN0YXQuc2l6ZSA8PSB0aGlzLnByb2plY3RJbnN0cnVjdGlvbnMubWNwX2NvbmZpZy5tZW1vcnlfZ3JhcGgudmF1bHRfaW50ZWdyYXRpb24ubWF4X2ZpbGVfc2l6ZSk7XG4gICAgXG4gICAgbGV0IHByb2Nlc3NlZCA9IDA7XG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbmdlc3RGaWxlVG9SQUcoZmlsZSwgY29udGVudCk7XG4gICAgICAgIHByb2Nlc3NlZCsrO1xuICAgICAgICBcbiAgICAgICAgaWYgKHByb2Nlc3NlZCAlIDEwID09PSAwKSB7XG4gICAgICAgICAgbmV3IE5vdGljZShgUHJvY2Vzc2VkICR7cHJvY2Vzc2VkfS8ke2ZpbGVzLmxlbmd0aH0gZmlsZXMuLi5gKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyAke2ZpbGUucGF0aH06YCwgZSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIG5ldyBOb3RpY2UoYEluaXRpYWxpemVkICR7cHJvY2Vzc2VkfSBmaWxlcyB0byBSQUcvR3JhcGguYCk7XG4gIH1cblxuICBhc3luYyBpbmdlc3RGaWxlVG9SQUcoZmlsZTogVEZpbGUsIGNvbnRlbnQ6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5lbWJlZGRpbmdzKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgY2h1bmtzID0gdGhpcy5jaHVua1RleHQoY29udGVudCwgdGhpcy5wcm9qZWN0SW5zdHJ1Y3Rpb25zLnJhZ19jb25maWcuY2h1bmtfc2l6ZSk7XG4gICAgXG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVtYmVkZGluZyA9IGF3YWl0IHRoaXMuZW1iZWRkaW5ncy5lbWJlZFF1ZXJ5KGNodW5rKTtcbiAgICAgICAgY29uc3Qgbm9kZUlkID0gYXdhaXQgdGhpcy5tZW1vcnlHcmFwaC5hZGROb2RlKHtcbiAgICAgICAgICB0eXBlOiAnbWFya2Rvd24nLFxuICAgICAgICAgIGNvbnRlbnQ6IGNodW5rLFxuICAgICAgICAgIHNvdXJjZXM6IFt7XG4gICAgICAgICAgICB0eXBlOiAncmFnX3ZhdWx0JyxcbiAgICAgICAgICAgIGlkOiBmaWxlLnBhdGgsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZmlsZS5uYW1lXG4gICAgICAgICAgfV1cbiAgICAgICAgfSwgZW1iZWRkaW5nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIGluIFFkcmFudFxuICAgICAgICBhd2FpdCB0aGlzLnJhZ0ludGVncmF0b3IudXBzZXJ0VG9RZHJhbnQobm9kZUlkLCBlbWJlZGRpbmcsIGNodW5rKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwcm9jZXNzIGNodW5rIGZyb20gJHtmaWxlLnBhdGh9OmAsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2h1bmtUZXh0KHRleHQ6IHN0cmluZywgc2l6ZTogbnVtYmVyKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGNodW5rczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpICs9IHNpemUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHRleHQuc3Vic3RyaW5nKGksIGkgKyBzaXplKSk7XG4gICAgfVxuICAgIHJldHVybiBjaHVua3M7XG4gIH1cblxuICBhc3luYyBhZGRNYXJrZG93bkNvbnRleHQobWFya2Rvd246IHN0cmluZykge1xuICAgIGlmICghdGhpcy5lbWJlZGRpbmdzKSB7XG4gICAgICBuZXcgTm90aWNlKCdQbGVhc2Ugc2V0IE1pc3RyYWwgQVBJIGtleSBmaXJzdCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5lbWJlZGRpbmdzLmVtYmVkUXVlcnkobWFya2Rvd24pO1xuICAgICAgY29uc3Qgbm9kZUlkID0gYXdhaXQgdGhpcy5tZW1vcnlHcmFwaC5hZGROb2RlKHtcbiAgICAgICAgdHlwZTogJ2NvbnRleHQnLFxuICAgICAgICBjb250ZW50OiBtYXJrZG93bixcbiAgICAgICAgc291cmNlczogW3tcbiAgICAgICAgICB0eXBlOiAndXNlcl9pbnB1dCcsXG4gICAgICAgICAgaWQ6ICdtYW51YWwnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnTWFudWFsIE1hcmtkb3duJ1xuICAgICAgICB9XVxuICAgICAgfSwgZW1iZWRkaW5nKTtcbiAgICAgIFxuICAgICAgbmV3IE5vdGljZShgQWRkZWQgTWFya2Rvd24gY29udGV4dCBhcyBub2RlICR7bm9kZUlkfS5gKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBuZXcgTm90aWNlKCdGYWlsZWQgdG8gYWRkIGNvbnRleHQ6ICcgKyAoZSBhcyBFcnJvcikubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgdGVzdFJlY2FsbCgpIHtcbiAgICBpZiAoIXRoaXMuZW1iZWRkaW5ncykge1xuICAgICAgbmV3IE5vdGljZSgnUGxlYXNlIHNldCBNaXN0cmFsIEFQSSBrZXkgZmlyc3QnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZ3JhcGggPSBhd2FpdCB0aGlzLm1lbW9yeUdyYXBoLmxvYWQoKTtcbiAgICBpZiAoZ3JhcGgubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBuZXcgTm90aWNlKCdObyBub2Rlcy4gSW5pdGlhbGl6ZSBmaXJzdC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmFuZG9tTm9kZSA9IGdyYXBoLm5vZGVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGdyYXBoLm5vZGVzLmxlbmd0aCldO1xuICAgIGNvbnN0IHF1ZXJ5RW1iZWRkaW5nID0gYXdhaXQgdGhpcy5lbWJlZGRpbmdzLmVtYmVkUXVlcnkoXG4gICAgICByYW5kb21Ob2RlLmNvbnRlbnQuc3Vic3RyaW5nKDAsIDUwKVxuICAgICk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMucmFnSW50ZWdyYXRvci5zZWFyY2hTaW1pbGFyKHF1ZXJ5RW1iZWRkaW5nLCAxKTtcbiAgICBjb25zdCBzY29yZSA9IHJlc3VsdHNbMF0/LnNjb3JlIHx8IDA7XG4gICAgY29uc3QgcGFzcyA9IHNjb3JlID4gMC43O1xuICAgIFxuICAgIGNvbnNvbGUubG9nKHsgXG4gICAgICBncm91bmRUcnV0aDogcmFuZG9tTm9kZS5jb250ZW50LCBcbiAgICAgIHNjb3JlLCBcbiAgICAgIHBhc3MgXG4gICAgfSk7XG4gICAgXG4gICAgbmV3IE5vdGljZShgUmVjYWxsIFRlc3Q6ICR7cGFzcyA/ICdQQVNTJyA6ICdGQUlMJ30gKFNjb3JlOiAke3Njb3JlLnRvRml4ZWQoMil9KWApO1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0RGF0YSh0eXBlOiAnZ3JhcGgnIHwgJ3ZlY3RvcnMnLCB0b0Nsb3VkID0gZmFsc2UpIHtcbiAgICBpZiAodG9DbG91ZCAmJiB0aGlzLnNldHRpbmdzLmVuYWJsZUN1c3RvbUNsb3VkU3luYykge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZXhwb3J0VG9DdXN0b21DbG91ZCh0eXBlKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZGF0YSA9IHR5cGUgPT09ICdncmFwaCcgPyBcbiAgICAgIGF3YWl0IHRoaXMubWVtb3J5R3JhcGgubG9hZCgpIDogXG4gICAgICBhd2FpdCB0aGlzLnJhZ0ludGVncmF0b3IuZXhwb3J0VmVjdG9ycygpO1xuICAgIFxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMildLCB7IFxuICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIFxuICAgIH0pO1xuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgXG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBhLmhyZWYgPSB1cmw7XG4gICAgYS5kb3dubG9hZCA9IGAke3R5cGV9LWV4cG9ydC0ke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCl9Lmpzb25gO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYSk7XG4gICAgYS5jbGljaygpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoYSk7XG4gICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICB9XG5cbiAgYXN5bmMgZXhwb3J0VG9DdXN0b21DbG91ZCh0eXBlOiAnZ3JhcGgnIHwgJ3ZlY3RvcnMnKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLnNldHRpbmdzLmVuYWJsZUN1c3RvbUNsb3VkU3luYyB8fCAhdGhpcy5zZXR0aW5ncy5jdXN0b21DbG91ZEVuZHBvaW50KSB7XG4gICAgICBuZXcgTm90aWNlKCdDdXN0b20gY2xvdWQgc3luYyBub3QgY29uZmlndXJlZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IHR5cGUgPT09ICdncmFwaCcgPyBcbiAgICAgICAgYXdhaXQgdGhpcy5tZW1vcnlHcmFwaC5sb2FkKCkgOiBcbiAgICAgICAgYXdhaXQgdGhpcy5yYWdJbnRlZ3JhdG9yLmV4cG9ydFZlY3RvcnMoKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLnNldHRpbmdzLmN1c3RvbUNsb3VkRW5kcG9pbnQsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLnNldHRpbmdzLmN1c3RvbUNsb3VkQXBpS2V5fWAsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBkYXRhLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHZhdWx0TmFtZTogdGhpcy5hcHAudmF1bHQuZ2V0TmFtZSgpXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgICBcbiAgICAgIG5ldyBOb3RpY2UoYFN1Y2Nlc3NmdWxseSBleHBvcnRlZCAke3R5cGV9IHRvIHlvdXIgY2xvdWRgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ldyBOb3RpY2UoYENsb3VkIGV4cG9ydCBmYWlsZWQ6ICR7KGUgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gICAgICBjb25zb2xlLmVycm9yKCdDbG91ZCBleHBvcnQgZXJyb3I6JywgZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaW1wb3J0RGF0YSh0eXBlOiAnZ3JhcGgnIHwgJ3ZlY3RvcnMnKSB7XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGlucHV0LnR5cGUgPSAnZmlsZSc7XG4gICAgaW5wdXQuYWNjZXB0ID0gJy5qc29uJztcbiAgICBcbiAgICBpbnB1dC5vbmNoYW5nZSA9IGFzeW5jIChlKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gKGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQpLmZpbGVzPy5bMF07XG4gICAgICBpZiAoZmlsZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBmaWxlLnRleHQoKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShjb250ZW50KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2dyYXBoJykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5tZW1vcnlHcmFwaC5zYXZlKGRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJhZ0ludGVncmF0b3IuaW1wb3J0VmVjdG9ycyhkYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgbmV3IE5vdGljZShgSW1wb3J0ZWQgJHt0eXBlfSBzdWNjZXNzZnVsbHkuYCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBuZXcgTm90aWNlKGBJbXBvcnQgZmFpbGVkOiAkeyhlIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBpbnB1dC5jbGljaygpO1xuICB9XG5cbiAgYXN5bmMgdmlzdWFsaXplSW5HcmFwaFZpZXcoKSB7XG4gICAgY29uc3QgZ3JhcGggPSBhd2FpdCB0aGlzLm1lbW9yeUdyYXBoLmxvYWQoKTtcbiAgICBcbiAgICBjb25zdCBncmFwaERhdGEgPSB7XG4gICAgICBub2RlczogZ3JhcGgubm9kZXMubWFwKG4gPT4gKHtcbiAgICAgICAgaWQ6IG4uaWQsXG4gICAgICAgIGxhYmVsOiBuLnN1bW1hcnkgfHwgbi5jb250ZW50LnNsaWNlKDAsIDIwKSxcbiAgICAgICAgdHlwZTogbi50eXBlLFxuICAgICAgICB4OiBNYXRoLnJhbmRvbSgpICogMTAwMCxcbiAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIDEwMDBcbiAgICAgIH0pKSxcbiAgICAgIGVkZ2VzOiBncmFwaC5lZGdlcy5tYXAoZSA9PiAoe1xuICAgICAgICBmcm9tOiBlLmZyb20sXG4gICAgICAgIHRvOiBlLnRvLFxuICAgICAgICBsYWJlbDogZS50eXBlLFxuICAgICAgICB3ZWlnaHQ6IGUud2VpZ2h0XG4gICAgICB9KSlcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHRlbXBGaWxlID0gYHRlbXAtZ3JhcGgtJHt1dWlkdjQoKX0uanNvbmA7XG4gICAgYXdhaXQgdGhpcy5hcHAudmF1bHQuY3JlYXRlKHRlbXBGaWxlLCBKU09OLnN0cmluZ2lmeShncmFwaERhdGEsIG51bGwsIDIpKTtcbiAgICBcbiAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoJ3RhYicpO1xuICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGVtcEZpbGUpO1xuICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZpbGUpIHtcbiAgICAgIGF3YWl0IGxlYWYub3BlbkZpbGUoZmlsZSwgeyBhY3RpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIFxuICAgIG5ldyBOb3RpY2UoJ0dyYXBoIHZpc3VhbGl6ZWQgaW4gbmV3IHRhYi4nKTtcbiAgfVxuXG4gIGFzeW5jIGltcG9ydFJvbGVGcm9tTWFya2Rvd24oZmlsZTogVEZpbGUpIHtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICBsZXQgcm9sZU5hbWUgPSBmaWxlLmJhc2VuYW1lO1xuICAgIGxldCBwcm9tcHQgPSBjb250ZW50O1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBmcm9udG1hdHRlclxuICAgIGlmIChjb250ZW50LnN0YXJ0c1dpdGgoJy0tLScpKSB7XG4gICAgICBjb25zdCBmcm9udG1hdHRlckVuZCA9IGNvbnRlbnQuaW5kZXhPZignLS0tJywgMyk7XG4gICAgICBpZiAoZnJvbnRtYXR0ZXJFbmQgIT09IC0xKSB7XG4gICAgICAgIGNvbnN0IGZyb250bWF0dGVyID0gY29udGVudC5zdWJzdHJpbmcoMywgZnJvbnRtYXR0ZXJFbmQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHlhbWwgPSBmcm9udG1hdHRlci5zcGxpdCgnXFxuJykucmVkdWNlKChhY2MsIGxpbmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIC4uLnZhbHVlUGFydHNdID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgaWYgKGtleSAmJiB2YWx1ZVBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBhY2Nba2V5LnRyaW0oKV0gPSB2YWx1ZVBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH0sIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz4pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICh5YW1sLnJvbGVOYW1lKSByb2xlTmFtZSA9IHlhbWwucm9sZU5hbWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcGFyc2UgZnJvbnRtYXR0ZXI6JywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbXB0ID0gY29udGVudC5zdWJzdHJpbmcoZnJvbnRtYXR0ZXJFbmQgKyAzKS50cmltKCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShgQUkgUm9sZXMvJHtyb2xlTmFtZX0ubWRgLCBwcm9tcHQpO1xuICAgIG5ldyBOb3RpY2UoYEltcG9ydGVkIHJvbGU6ICR7cm9sZU5hbWV9YCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1TbWFydFNlYXJjaChxdWVyeTogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmFkdmFuY2VkRmVhdHVyZXMuc21hcnRTZWFyY2gocXVlcnksIHtcbiAgICAgICAgaW5jbHVkZUNvbnRleHQ6IHRydWUsXG4gICAgICAgIHNlYXJjaFR5cGU6ICdoeWJyaWQnLFxuICAgICAgICBtYXhSZXN1bHRzOiAxMFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG5vdGUgd2l0aCBzZWFyY2ggcmVzdWx0c1xuICAgICAgICBjb25zdCByZXN1bHRzQ29udGVudCA9IGAjIFNtYXJ0IFNlYXJjaCBSZXN1bHRzOiBcIiR7cXVlcnl9XCJcXG5cXG5gICtcbiAgICAgICAgICByZXN1bHRzLm1hcCgocmVzdWx0LCBpbmRleCkgPT4gXG4gICAgICAgICAgICBgIyMgUmVzdWx0ICR7aW5kZXggKyAxfSAoJHtyZXN1bHQudHlwZX0sIFNjb3JlOiAkeyhyZXN1bHQuc2NvcmUgfHwgMCkudG9GaXhlZCgyKX0pXFxuYCArXG4gICAgICAgICAgICBgJHtyZXN1bHQudGV4dCB8fCByZXN1bHQuY29udGVudCB8fCByZXN1bHQuc3VtbWFyeX1cXG5cXG5gICtcbiAgICAgICAgICAgIChyZXN1bHQuY29udGV4dD8ucmVsYXRlZD8ubGVuZ3RoID8gXG4gICAgICAgICAgICAgIGAqKlJlbGF0ZWQ6KiogJHtyZXN1bHQuY29udGV4dC5yZWxhdGVkLm1hcCgocjogYW55KSA9PiByLnN1bW1hcnkpLmpvaW4oJywgJyl9XFxuXFxuYCA6ICcnKVxuICAgICAgICAgICkuam9pbignLS0tXFxuXFxuJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGBTbWFydCBTZWFyY2ggLSAke3F1ZXJ5LnJlcGxhY2UoL1teXFx3XFxzXS9nLCAnJyl9IC0gJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgMTApfS5tZGA7XG4gICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShmaWxlTmFtZSwgcmVzdWx0c0NvbnRlbnQpO1xuICAgICAgICBcbiAgICAgICAgLy8gT3BlbiB0aGUgcmVzdWx0cyBmaWxlXG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZU5hbWUpO1xuICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgY29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKCd0YWInKTtcbiAgICAgICAgICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUsIHsgYWN0aXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBuZXcgTm90aWNlKGBGb3VuZCAke3Jlc3VsdHMubGVuZ3RofSByZXN1bHRzIGZvciBcIiR7cXVlcnl9XCJgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYE5vIHJlc3VsdHMgZm91bmQgZm9yIFwiJHtxdWVyeX1cImApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG5ldyBOb3RpY2UoYFNlYXJjaCBmYWlsZWQ6ICR7KGUgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBvcGVuUm9sZUNoYXQoKSB7XG4gICAgY29uc3QgeyB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuICAgIFxuICAgIGxldCBsZWFmID0gd29ya3NwYWNlLmdldExlYXZlc09mVHlwZShDaGF0Vmlldy5WSUVXX1RZUEUpWzBdO1xuICAgIGlmICghbGVhZikge1xuICAgICAgY29uc3QgcmlnaHRMZWFmID0gd29ya3NwYWNlLmdldFJpZ2h0TGVhZihmYWxzZSk7XG4gICAgICBpZiAocmlnaHRMZWFmKSB7XG4gICAgICAgIGxlYWYgPSByaWdodExlYWY7XG4gICAgICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHsgXG4gICAgICAgICAgdHlwZTogQ2hhdFZpZXcuVklFV19UWVBFLCBcbiAgICAgICAgICBhY3RpdmU6IHRydWUgXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAobGVhZikge1xuICAgICAgd29ya3NwYWNlLnJldmVhbExlYWYobGVhZik7XG4gICAgfVxuICB9XG4gIFxuICAvLyBOZXcgbWV0aG9kcyBmb3IgZW5oYW5jZWQgZmVhdHVyZXNcbiAgYXN5bmMgaW5pdGlhbGl6ZUludGVncmF0aW9ucygpIHtcbiAgICAvLyBJbml0aWFsaXplIFZveWFnZSBBSVxuICAgIGlmICh0aGlzLnNldHRpbmdzLnZveWFnZUFwaUtleSkge1xuICAgICAgYXdhaXQgdGhpcy52b3lhZ2VBSS5pbml0aWFsaXplKHtcbiAgICAgICAgYXBpS2V5OiB0aGlzLnNldHRpbmdzLnZveWFnZUFwaUtleSxcbiAgICAgICAgbW9kZWw6IHRoaXMuc2V0dGluZ3Mudm95YWdlTW9kZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBJbml0aWFsaXplIFZlcmNlbCBBSVxuICAgIGlmICh0aGlzLnNldHRpbmdzLnZlcmNlbFByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLnZlcmNlbEFJLmluaXRpYWxpemUodGhpcy5zZXR0aW5ncy52ZXJjZWxQcm92aWRlcnMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJbml0aWFsaXplIEVtYWlsIFNlcnZpY2VcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5lbWFpbENvbmZpZy5zbXRwSG9zdCkge1xuICAgICAgYXdhaXQgdGhpcy5lbWFpbFNlcnZpY2UuY29uZmlndXJlKHRoaXMuc2V0dGluZ3MuZW1haWxDb25maWcpO1xuICAgIH1cbiAgfVxuICBcbiAgYXN5bmMgb3BlbkRhc2hib2FyZCgpIHtcbiAgICBjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgXG4gICAgbGV0IGxlYWY6IFdvcmtzcGFjZUxlYWYgfCBudWxsID0gbnVsbDtcbiAgICBjb25zdCBsZWF2ZXMgPSB3b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKERhc2hib2FyZFZpZXcuVklFV19UWVBFKTtcbiAgICBcbiAgICBpZiAobGVhdmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxlYWYgPSBsZWF2ZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlYWYgPSB3b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKTtcbiAgICAgIGF3YWl0IGxlYWY/LnNldFZpZXdTdGF0ZSh7IHR5cGU6IERhc2hib2FyZFZpZXcuVklFV19UWVBFLCBhY3RpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIFxuICAgIGlmIChsZWFmKSB7XG4gICAgICB3b3Jrc3BhY2UucmV2ZWFsTGVhZihsZWFmKTtcbiAgICB9XG4gIH1cbiAgXG4gIGFzeW5jIG9wZW5FbmhhbmNlZFNlYXJjaCgpIHtcbiAgICBjb25zdCBxdWVyeSA9IHByb21wdCgnRW50ZXIgc2VhcmNoIHF1ZXJ5OicpO1xuICAgIGlmICghcXVlcnkpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMuZW5oYW5jZWRTZWFyY2guc2VhcmNoKHtcbiAgICAgICAgcXVlcnksXG4gICAgICAgIHNlYXJjaFR5cGU6IHRoaXMuc2V0dGluZ3MuZGVmYXVsdFNlYXJjaFR5cGUsXG4gICAgICAgIG1heFJlc3VsdHM6IDIwLFxuICAgICAgICB1c2VSZXJhbms6IHRoaXMuc2V0dGluZ3MuZW5hYmxlU2VhcmNoUmVyYW5rLFxuICAgICAgICByZXJhbmtUaHJlc2hvbGQ6IHRoaXMuc2V0dGluZ3MucmVyYW5rVGhyZXNob2xkLFxuICAgICAgICBpbmNsdWRlQ29udGVudDogdHJ1ZSxcbiAgICAgICAgZmlsZVR5cGVzOiBbJ21kJ10sXG4gICAgICAgIHNvcnRCeTogJ3JlbGV2YW5jZScsXG4gICAgICAgIHNvcnRPcmRlcjogJ2Rlc2MnXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gRGlzcGxheSByZXN1bHRzIGluIGEgbW9kYWwgb3IgbmV3IHZpZXdcbiAgICAgIG5ldyBTZWFyY2hSZXN1bHRzTW9kYWwodGhpcy5hcHAsIHJlc3VsdHMpLm9wZW4oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbmV3IE5vdGljZShgU2VhcmNoIGZhaWxlZDogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG4gIFxuICBhc3luYyBzaGFyZUN1cnJlbnRGaWxlVmlhRW1haWwoKSB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVGaWxlKCk7XG4gICAgaWYgKCFmaWxlIHx8IGZpbGUuZXh0ZW5zaW9uICE9PSAnbWQnKSB7XG4gICAgICBuZXcgTm90aWNlKCdQbGVhc2Ugb3BlbiBhIG1hcmtkb3duIGZpbGUgZmlyc3QnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVjaXBpZW50cyA9IHByb21wdCgnRW50ZXIgZW1haWwgYWRkcmVzc2VzIChjb21tYS1zZXBhcmF0ZWQpOicpO1xuICAgIGlmICghcmVjaXBpZW50cykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHJlY2lwaWVudExpc3QgPSByZWNpcGllbnRzLnNwbGl0KCcsJykubWFwKGVtYWlsID0+IGVtYWlsLnRyaW0oKSk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHByb21wdCgnRW50ZXIgYSBtZXNzYWdlIChvcHRpb25hbCk6JykgfHwgJyc7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuZmlsZVNoYXJlU2VydmljZS5zaGFyZUZpbGVWaWFFbWFpbChmaWxlLCByZWNpcGllbnRMaXN0LCBtZXNzYWdlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbmV3IE5vdGljZShgRmFpbGVkIHRvIHNoYXJlIGZpbGU6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICBcbiAgYXN5bmMgc2VuZFZhdWx0U3VtbWFyeUVtYWlsKCkge1xuICAgIGNvbnN0IHJlY2lwaWVudHMgPSBwcm9tcHQoJ0VudGVyIGVtYWlsIGFkZHJlc3NlcyAoY29tbWEtc2VwYXJhdGVkKTonKTtcbiAgICBpZiAoIXJlY2lwaWVudHMpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCByZWNpcGllbnRMaXN0ID0gcmVjaXBpZW50cy5zcGxpdCgnLCcpLm1hcChlbWFpbCA9PiBlbWFpbC50cmltKCkpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmZpbGVTaGFyZVNlcnZpY2Uuc2hhcmVWYXVsdFN1bW1hcnkocmVjaXBpZW50TGlzdCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBzZW5kIHZhdWx0IHN1bW1hcnk6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuICBcbiAgYXN5bmMgdGVzdEFJUHJvdmlkZXJzKCkge1xuICAgIGlmICh0aGlzLnZlcmNlbEFJLmlzUmVhZHkoKSkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IHRoaXMudmVyY2VsQUkudGVzdEFsbFByb3ZpZGVycygpO1xuICAgICAgY29uc3Qgc3VtbWFyeSA9IE9iamVjdC5lbnRyaWVzKHJlc3VsdHMpXG4gICAgICAgIC5tYXAoKFtwcm92aWRlciwgc3VjY2Vzc10pID0+IGAke3Byb3ZpZGVyfTogJHtzdWNjZXNzID8gJ1x1MjcwNScgOiAnXHUyNzRDJ31gKVxuICAgICAgICAuam9pbignXFxuJyk7XG4gICAgICBcbiAgICAgIG5ldyBOb3RpY2UoYEFJIFByb3ZpZGVyIFRlc3QgUmVzdWx0czpcXG4ke3N1bW1hcnl9YCwgNTAwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBOb3RpY2UoJ05vIEFJIHByb3ZpZGVycyBjb25maWd1cmVkJyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgb251bmxvYWQoKSB7XG4gICAgLy8gQ2xlYW51cCBhbGwgaW50ZWdyYXRpb25zXG4gICAgaWYgKHRoaXMucGVyZm9ybWFuY2VPcHRpbWl6ZXIpIHtcbiAgICAgIHRoaXMucGVyZm9ybWFuY2VPcHRpbWl6ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyKSB7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbk1hbmFnZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbmhhbmNlZFNlYXJjaCkge1xuICAgICAgdGhpcy5lbmhhbmNlZFNlYXJjaC5kZXN0cm95KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZveWFnZUFJKSB7XG4gICAgICB0aGlzLnZveWFnZUFJLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudmVyY2VsQUkpIHtcbiAgICAgIHRoaXMudmVyY2VsQUkuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBTZXR0aW5ncyBUYWJcbmNsYXNzIEFJTUNQU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICBwbHVnaW46IEFJTUNQUGx1Z2luO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IEFJTUNQUGx1Z2luKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJBSSBNQ1AgUGx1Z2luIFNldHRpbmdzXCIgfSk7XG5cbiAgICAvLyBQcm9qZWN0IEluc3RydWN0aW9ucyBQYXRoXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZSgnUHJvamVjdCBJbnN0cnVjdGlvbnMgUGF0aCcpXG4gICAgICAuc2V0RGVzYygnUGF0aCB0byB0aGUgcHJvamVjdCBpbnN0cnVjdGlvbnMgSlNPTiBmaWxlJylcbiAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MucHJvamVjdEluc3RydWN0aW9uc1BhdGgpXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5wcm9qZWN0SW5zdHJ1Y3Rpb25zUGF0aCA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmxvYWRQcm9qZWN0SW5zdHJ1Y3Rpb25zKCk7XG4gICAgICAgIH0pKTtcblxuICAgIC8vIE1pc3RyYWwgQVBJIEtleVxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoJ01pc3RyYWwgQVBJIEtleScpXG4gICAgICAuc2V0RGVzYygnQVBJIGtleSBmb3IgTWlzdHJhbCBlbWJlZGRpbmdzIChmcmVlIHRpZXIgYXZhaWxhYmxlKScpXG4gICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIE1pc3RyYWwgQVBJIGtleScpXG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5taXN0cmFsQXBpS2V5KVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MubWlzdHJhbEFwaUtleSA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uZW1iZWRkaW5ncyA9IG5ldyBNaXN0cmFsQUlFbWJlZGRpbmdzKHsgYXBpS2V5OiB2YWx1ZSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcblxuICAgIC8vIFFkcmFudCBTZXR0aW5nc1xuICAgIGNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBcIlFkcmFudCBWZWN0b3IgRGF0YWJhc2VcIiB9KTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoJ1FkcmFudCBVUkwnKVxuICAgICAgLnNldERlc2MoJ1VSTCBmb3IgUWRyYW50IGluc3RhbmNlIChsb2NhbDogaHR0cDovL2xvY2FsaG9zdDo2MzMzKScpXG4gICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnFkcmFudFVybClcbiAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnFkcmFudFVybCA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgIHRoaXMucGx1Z2luLmluaXRRZHJhbnQoKTtcbiAgICAgICAgfSkpO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZSgnUWRyYW50IEFQSSBLZXkgKENsb3VkKScpXG4gICAgICAuc2V0RGVzYygnQVBJIGtleSBmb3IgUWRyYW50IGNsb3VkIChsZWF2ZSBlbXB0eSBmb3IgbG9jYWwpJylcbiAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIEFQSSBrZXkgZm9yIGNsb3VkIFFkcmFudCcpXG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5xZHJhbnRBcGlLZXkpXG4gICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5xZHJhbnRBcGlLZXkgPSB2YWx1ZTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5pbml0UWRyYW50KCk7XG4gICAgICAgIH0pKTtcblxuICAgIC8vIENsb3VkZmxhcmUgU2V0dGluZ3NcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJDbG91ZGZsYXJlIEludGVncmF0aW9uXCIgfSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdDbG91ZGZsYXJlIEFjY291bnQgSUQnKVxuICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5jbG91ZGZsYXJlQWNjb3VudElkKVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY2xvdWRmbGFyZUFjY291bnRJZCA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdDbG91ZGZsYXJlIEFQSSBUb2tlbicpXG4gICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmNsb3VkZmxhcmVBcGlUb2tlbilcbiAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNsb3VkZmxhcmVBcGlUb2tlbiA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdFbmFibGUgQ2xvdWRmbGFyZSBSQUcgKEZhbGxiYWNrKScpXG4gICAgICAuc2V0RGVzYygnVXNlIENsb3VkZmxhcmUgYXMgZmFsbGJhY2sgZm9yIFJBRyBvcGVyYXRpb25zJylcbiAgICAgIC5hZGRUb2dnbGUodG9nZ2xlID0+IHRvZ2dsZVxuICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlQ2xvdWRmbGFyZVJhZylcbiAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZUNsb3VkZmxhcmVSYWcgPSB2YWx1ZTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgfSkpO1xuXG4gICAgLy8gQ3VzdG9tIENsb3VkIFN5bmNcbiAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImgzXCIsIHsgdGV4dDogXCJDdXN0b20gQ2xvdWQgU3luY1wiIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZSgnRW5hYmxlIEN1c3RvbSBDbG91ZCBTeW5jJylcbiAgICAgIC5zZXREZXNjKCdTZW5kIGV4cG9ydHMgdG8geW91ciBvd24gY2xvdWQgc2VydmljZScpXG4gICAgICAuYWRkVG9nZ2xlKHRvZ2dsZSA9PiB0b2dnbGVcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZUN1c3RvbUNsb3VkU3luYylcbiAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmVuYWJsZUN1c3RvbUNsb3VkU3luYyA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdDdXN0b20gQ2xvdWQgRW5kcG9pbnQnKVxuICAgICAgLnNldERlc2MoJ1lvdXIgQVBJIGVuZHBvaW50IGZvciBkYXRhIHN5bmMnKVxuICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgIC5zZXRQbGFjZWhvbGRlcignaHR0cHM6Ly95b3VyLWFwaS5jb20vc3luYycpXG4gICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5jdXN0b21DbG91ZEVuZHBvaW50KVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY3VzdG9tQ2xvdWRFbmRwb2ludCA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKCdDdXN0b20gQ2xvdWQgQVBJIEtleScpXG4gICAgICAuYWRkVGV4dCh0ZXh0ID0+IHRleHRcbiAgICAgICAgLnNldFBsYWNlaG9sZGVyKCdBUEkgS2V5JylcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmN1c3RvbUNsb3VkQXBpS2V5KVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuY3VzdG9tQ2xvdWRBcGlLZXkgPSB2YWx1ZTtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgfSkpO1xuXG4gICAgLy8gRGVmYXVsdCBSb2xlXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZSgnRGVmYXVsdCBSb2xlJylcbiAgICAgIC5zZXREZXNjKCdEZWZhdWx0IEFJIHJvbGUgZm9yIGNoYXQgaW50ZXJmYWNlJylcbiAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuICAgICAgICAuYWRkT3B0aW9uKCdhc3Npc3RhbnQnLCAnQXNzaXN0YW50JylcbiAgICAgICAgLmFkZE9wdGlvbigncGxhbm5lcicsICdQbGFubmVyJylcbiAgICAgICAgLmFkZE9wdGlvbigncmVzZWFyY2hlcicsICdSZXNlYXJjaGVyJylcbiAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLmRlZmF1bHRSb2xlKVxuICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5kZWZhdWx0Um9sZSA9IHZhbHVlO1xuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICB9KSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBBSU1DUFBsdWdpbiBmcm9tICcuLi9tYWluJztcblxuZXhwb3J0IGludGVyZmFjZSBDYWNoZUVudHJ5IHtcbiAgZGF0YTogYW55O1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgdHRsOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmF0Y2hKb2Ige1xuICBpZDogc3RyaW5nO1xuICB0eXBlOiAnZW1iZWRkaW5nJyB8ICdpbmRleGluZycgfCAnc3luYyc7XG4gIGRhdGE6IGFueTtcbiAgcHJpb3JpdHk6IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBQZXJmb3JtYW5jZU9wdGltaXplciB7XG4gIHByaXZhdGUgY2FjaGUgPSBuZXcgTWFwPHN0cmluZywgQ2FjaGVFbnRyeT4oKTtcbiAgcHJpdmF0ZSBiYXRjaFF1ZXVlOiBCYXRjaEpvYltdID0gW107XG4gIHByaXZhdGUgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIHByaXZhdGUgcmVhZG9ubHkgQ0FDSEVfVFRMID0gNSAqIDYwICogMTAwMDsgLy8gNSBtaW51dGVzXG4gIHByaXZhdGUgcmVhZG9ubHkgQkFUQ0hfU0laRSA9IDEwO1xuICBwcml2YXRlIHJlYWRvbmx5IEJBVENIX0RFTEFZID0gMTAwMDsgLy8gMSBzZWNvbmRcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBsdWdpbjogQUlNQ1BQbHVnaW4pIHtcbiAgICB0aGlzLnN0YXJ0QmF0Y2hQcm9jZXNzb3IoKTtcbiAgICB0aGlzLnN0YXJ0Q2FjaGVDbGVhbnVwKCk7XG4gIH1cblxuICAvLyBDYWNoZSBNYW5hZ2VtZW50XG4gIHNldENhY2hlKGtleTogc3RyaW5nLCBkYXRhOiBhbnksIHR0bDogbnVtYmVyID0gdGhpcy5DQUNIRV9UVEwpOiB2b2lkIHtcbiAgICB0aGlzLmNhY2hlLnNldChrZXksIHtcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICB0dGxcbiAgICB9KTtcbiAgfVxuXG4gIGdldENhY2hlKGtleTogc3RyaW5nKTogYW55IHwgbnVsbCB7XG4gICAgY29uc3QgZW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgIGlmICghZW50cnkpIHJldHVybiBudWxsO1xuXG4gICAgaWYgKERhdGUubm93KCkgLSBlbnRyeS50aW1lc3RhbXAgPiBlbnRyeS50dGwpIHtcbiAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZW50cnkuZGF0YTtcbiAgfVxuXG4gIGNsZWFyQ2FjaGUoKTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgLy8gTGF6eSBMb2FkaW5nIGZvciBMYXJnZSBGaWxlc1xuICBhc3luYyBsYXp5TG9hZEZpbGUoZmlsZTogVEZpbGUpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGBmaWxlXyR7ZmlsZS5wYXRofV8ke2ZpbGUuc3RhdC5tdGltZX1gO1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuZ2V0Q2FjaGUoY2FjaGVLZXkpO1xuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG5cbiAgICAvLyBDaGVjayBmaWxlIHNpemUgYmVmb3JlIGxvYWRpbmdcbiAgICBpZiAoZmlsZS5zdGF0LnNpemUgPiB0aGlzLnBsdWdpbi5wcm9qZWN0SW5zdHJ1Y3Rpb25zLm1jcF9jb25maWcubWVtb3J5X2dyYXBoLnZhdWx0X2ludGVncmF0aW9uLm1heF9maWxlX3NpemUpIHtcbiAgICAgIGNvbnNvbGUud2FybihgRmlsZSAke2ZpbGUucGF0aH0gdG9vIGxhcmdlLCBza2lwcGluZ2ApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgIHRoaXMuc2V0Q2FjaGUoY2FjaGVLZXksIGNvbnRlbnQpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvYWQgZmlsZSAke2ZpbGUucGF0aH06YCwgZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBCYXRjaCBQcm9jZXNzaW5nXG4gIGFkZFRvQmF0Y2goam9iOiBPbWl0PEJhdGNoSm9iLCAnaWQnIHwgJ3RpbWVzdGFtcCc+KTogc3RyaW5nIHtcbiAgICBjb25zdCBpZCA9IGAke2pvYi50eXBlfV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG4gICAgY29uc3QgYmF0Y2hKb2I6IEJhdGNoSm9iID0ge1xuICAgICAgLi4uam9iLFxuICAgICAgaWQsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICB9O1xuXG4gICAgdGhpcy5iYXRjaFF1ZXVlLnB1c2goYmF0Y2hKb2IpO1xuICAgIHRoaXMuYmF0Y2hRdWV1ZS5zb3J0KChhLCBiKSA9PiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eSk7XG5cbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBwcml2YXRlIHN0YXJ0QmF0Y2hQcm9jZXNzb3IoKTogdm9pZCB7XG4gICAgc2V0SW50ZXJ2YWwoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNQcm9jZXNzaW5nIHx8IHRoaXMuYmF0Y2hRdWV1ZS5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgY29uc3QgYmF0Y2ggPSB0aGlzLmJhdGNoUXVldWUuc3BsaWNlKDAsIHRoaXMuQkFUQ0hfU0laRSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0JhdGNoKGJhdGNoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQmF0Y2ggcHJvY2Vzc2luZyBmYWlsZWQ6JywgZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sIHRoaXMuQkFUQ0hfREVMQVkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzQmF0Y2goam9iczogQmF0Y2hKb2JbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGVtYmVkZGluZ0pvYnMgPSBqb2JzLmZpbHRlcihqb2IgPT4gam9iLnR5cGUgPT09ICdlbWJlZGRpbmcnKTtcbiAgICBjb25zdCBpbmRleGluZ0pvYnMgPSBqb2JzLmZpbHRlcihqb2IgPT4gam9iLnR5cGUgPT09ICdpbmRleGluZycpO1xuICAgIGNvbnN0IHN5bmNKb2JzID0gam9icy5maWx0ZXIoam9iID0+IGpvYi50eXBlID09PSAnc3luYycpO1xuXG4gICAgLy8gUHJvY2VzcyBlbWJlZGRpbmdzIGluIHBhcmFsbGVsIChsaW1pdGVkIGNvbmN1cnJlbmN5KVxuICAgIGlmIChlbWJlZGRpbmdKb2JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0VtYmVkZGluZ0JhdGNoKGVtYmVkZGluZ0pvYnMpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgaW5kZXhpbmcgam9ic1xuICAgIGlmIChpbmRleGluZ0pvYnMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzSW5kZXhpbmdCYXRjaChpbmRleGluZ0pvYnMpO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3Mgc3luYyBqb2JzXG4gICAgaWYgKHN5bmNKb2JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc1N5bmNCYXRjaChzeW5jSm9icyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzRW1iZWRkaW5nQmF0Y2goam9iczogQmF0Y2hKb2JbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IG1heENvbmN1cnJlbnQgPSB0aGlzLnBsdWdpbi5wcm9qZWN0SW5zdHJ1Y3Rpb25zLnBlcmZvcm1hbmNlPy5tYXhfY29uY3VycmVudF9yZXF1ZXN0cyB8fCAzO1xuICAgIGNvbnN0IGNodW5rcyA9IHRoaXMuY2h1bmtBcnJheShqb2JzLCBtYXhDb25jdXJyZW50KTtcblxuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IGNodW5rLm1hcChhc3luYyAoam9iKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5wbHVnaW4uZW1iZWRkaW5ncy5lbWJlZFF1ZXJ5KGpvYi5kYXRhLnRleHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhY2hlIHRoZSBlbWJlZGRpbmdcbiAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGBlbWJlZGRpbmdfJHt0aGlzLmhhc2hTdHJpbmcoam9iLmRhdGEudGV4dCl9YDtcbiAgICAgICAgICB0aGlzLnNldENhY2hlKGNhY2hlS2V5LCBlbWJlZGRpbmcsIDI0ICogNjAgKiA2MCAqIDEwMDApOyAvLyAyNCBob3Vyc1xuXG4gICAgICAgICAgLy8gU3RvcmUgaW4gbWVtb3J5IGdyYXBoXG4gICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4ubWVtb3J5R3JhcGguYWRkTm9kZSh7XG4gICAgICAgICAgICB0eXBlOiBqb2IuZGF0YS50eXBlIHx8ICdjb250ZXh0JyxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGpvYi5kYXRhLnRleHQsXG4gICAgICAgICAgICBzb3VyY2VzOiBqb2IuZGF0YS5zb3VyY2VzIHx8IFtdXG4gICAgICAgICAgfSwgZW1iZWRkaW5nKTtcblxuICAgICAgICAgIC8vIFN0b3JlIGluIFFkcmFudFxuICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnJhZ0ludGVncmF0b3IudXBzZXJ0VG9RZHJhbnQoXG4gICAgICAgICAgICBqb2IuaWQsXG4gICAgICAgICAgICBlbWJlZGRpbmcsXG4gICAgICAgICAgICBqb2IuZGF0YS50ZXh0XG4gICAgICAgICAgKTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHByb2Nlc3MgZW1iZWRkaW5nIGpvYiAke2pvYi5pZH06YCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcHJvY2Vzc0luZGV4aW5nQmF0Y2goam9iczogQmF0Y2hKb2JbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGZvciAoY29uc3Qgam9iIG9mIGpvYnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFByb2Nlc3MgaW5kZXhpbmcgam9iXG4gICAgICAgIGF3YWl0IHRoaXMuaW5kZXhDb250ZW50KGpvYi5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHByb2Nlc3MgaW5kZXhpbmcgam9iICR7am9iLmlkfTpgLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NTeW5jQmF0Y2goam9iczogQmF0Y2hKb2JbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGZvciAoY29uc3Qgam9iIG9mIGpvYnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFByb2Nlc3Mgc3luYyBqb2JcbiAgICAgICAgYXdhaXQgdGhpcy5zeW5jRGF0YShqb2IuZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBwcm9jZXNzIHN5bmMgam9iICR7am9iLmlkfTpgLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGluZGV4Q29udGVudChkYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBmb3IgY29udGVudCBpbmRleGluZ1xuICAgIGNvbnNvbGUubG9nKCdJbmRleGluZyBjb250ZW50OicsIGRhdGEpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzeW5jRGF0YShkYXRhOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBmb3IgZGF0YSBzeW5jaHJvbml6YXRpb25cbiAgICBpZiAodGhpcy5wbHVnaW4uc2V0dGluZ3MuZW5hYmxlQ3VzdG9tQ2xvdWRTeW5jKSB7XG4gICAgICBhd2FpdCB0aGlzLnBsdWdpbi5leHBvcnRUb0N1c3RvbUNsb3VkKGRhdGEudHlwZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRGVib3VuY2VkIEZpbGUgUHJvY2Vzc2luZ1xuICBwcml2YXRlIGZpbGVQcm9jZXNzaW5nVGltZW91dHMgPSBuZXcgTWFwPHN0cmluZywgTm9kZUpTLlRpbWVvdXQ+KCk7XG5cbiAgZGVib3VuY2VGaWxlUHJvY2Vzc2luZyhmaWxlOiBURmlsZSwgZGVsYXk6IG51bWJlciA9IDIwMDApOiB2b2lkIHtcbiAgICBjb25zdCBleGlzdGluZyA9IHRoaXMuZmlsZVByb2Nlc3NpbmdUaW1lb3V0cy5nZXQoZmlsZS5wYXRoKTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIGNsZWFyVGltZW91dChleGlzdGluZyk7XG4gICAgfVxuXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5wcm9jZXNzRmlsZUNoYW5nZShmaWxlKTtcbiAgICAgIHRoaXMuZmlsZVByb2Nlc3NpbmdUaW1lb3V0cy5kZWxldGUoZmlsZS5wYXRoKTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLmZpbGVQcm9jZXNzaW5nVGltZW91dHMuc2V0KGZpbGUucGF0aCwgdGltZW91dCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NGaWxlQ2hhbmdlKGZpbGU6IFRGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMubGF6eUxvYWRGaWxlKGZpbGUpO1xuICAgIGlmICghY29udGVudCkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgaWYgY29udGVudCBhY3R1YWxseSBjaGFuZ2VkXG4gICAgY29uc3QgY29udGVudEhhc2ggPSB0aGlzLmhhc2hTdHJpbmcoY29udGVudCk7XG4gICAgY29uc3QgbGFzdEhhc2ggPSB0aGlzLnBsdWdpbi5sYXN0SGFzaGVzLmdldChmaWxlLnBhdGgpO1xuICAgIFxuICAgIGlmIChsYXN0SGFzaCA9PT0gY29udGVudEhhc2gpIHJldHVybjtcblxuICAgIC8vIEFkZCB0byBiYXRjaCBmb3IgcHJvY2Vzc2luZ1xuICAgIHRoaXMuYWRkVG9CYXRjaCh7XG4gICAgICB0eXBlOiAnZW1iZWRkaW5nJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGV4dDogY29udGVudCxcbiAgICAgICAgdHlwZTogJ21hcmtkb3duJyxcbiAgICAgICAgc291cmNlczogW3tcbiAgICAgICAgICB0eXBlOiAndmF1bHRfZmlsZScsXG4gICAgICAgICAgaWQ6IGZpbGUucGF0aCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogZmlsZS5uYW1lXG4gICAgICAgIH1dXG4gICAgICB9LFxuICAgICAgcHJpb3JpdHk6IDFcbiAgICB9KTtcblxuICAgIHRoaXMucGx1Z2luLmxhc3RIYXNoZXMuc2V0KGZpbGUucGF0aCwgY29udGVudEhhc2gpO1xuICB9XG5cbiAgLy8gTWVtb3J5IE1hbmFnZW1lbnRcbiAgYXN5bmMgb3B0aW1pemVNZW1vcnlVc2FnZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBDbGVhciBvbGQgY2FjaGUgZW50cmllc1xuICAgIHRoaXMuY2xlYW51cENhY2hlKCk7XG5cbiAgICAvLyBQcnVuZSBtZW1vcnkgZ3JhcGhcbiAgICBhd2FpdCB0aGlzLnBydW5lTWVtb3J5R3JhcGgoKTtcblxuICAgIC8vIENsZWFuIHVwIG9sZCBiYXRjaCBqb2JzXG4gICAgdGhpcy5jbGVhbnVwQmF0Y2hRdWV1ZSgpO1xuXG4gICAgLy8gRm9yY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIGlmIGF2YWlsYWJsZVxuICAgIGlmIChnbG9iYWwuZ2MpIHtcbiAgICAgIGdsb2JhbC5nYygpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xlYW51cENhY2hlKCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgZm9yIChjb25zdCBba2V5LCBlbnRyeV0gb2YgdGhpcy5jYWNoZS5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChub3cgLSBlbnRyeS50aW1lc3RhbXAgPiBlbnRyeS50dGwpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBydW5lTWVtb3J5R3JhcGgoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZ3JhcGggPSBhd2FpdCB0aGlzLnBsdWdpbi5tZW1vcnlHcmFwaC5sb2FkKCk7XG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5wbHVnaW4ucHJvamVjdEluc3RydWN0aW9ucy5tY3BfY29uZmlnLm1lbW9yeV9ncmFwaC5wcnVuZV90aHJlc2hvbGQ7XG4gICAgXG4gICAgLy8gUmVtb3ZlIG5vZGVzIHdpdGggbG93IGNvbmZpZGVuY2VcbiAgICBncmFwaC5ub2RlcyA9IGdyYXBoLm5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUuY29uZmlkZW5jZSA+PSB0aHJlc2hvbGQpO1xuICAgIFxuICAgIC8vIFJlbW92ZSBvcnBoYW5lZCBlZGdlc1xuICAgIGNvbnN0IG5vZGVJZHMgPSBuZXcgU2V0KGdyYXBoLm5vZGVzLm1hcChuID0+IG4uaWQpKTtcbiAgICBncmFwaC5lZGdlcyA9IGdyYXBoLmVkZ2VzLmZpbHRlcihlZGdlID0+IFxuICAgICAgbm9kZUlkcy5oYXMoZWRnZS5mcm9tKSAmJiBub2RlSWRzLmhhcyhlZGdlLnRvKVxuICAgICk7XG5cbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5tZW1vcnlHcmFwaC5zYXZlKGdyYXBoKTtcbiAgfVxuXG4gIHByaXZhdGUgY2xlYW51cEJhdGNoUXVldWUoKTogdm9pZCB7XG4gICAgY29uc3QgY3V0b2ZmID0gRGF0ZS5ub3coKSAtICg2MCAqIDYwICogMTAwMCk7IC8vIDEgaG91clxuICAgIHRoaXMuYmF0Y2hRdWV1ZSA9IHRoaXMuYmF0Y2hRdWV1ZS5maWx0ZXIoam9iID0+IGpvYi50aW1lc3RhbXAgPiBjdXRvZmYpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGFydENhY2hlQ2xlYW51cCgpOiB2b2lkIHtcbiAgICAvLyBDbGVhbiBjYWNoZSBldmVyeSAxMCBtaW51dGVzXG4gICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhbnVwQ2FjaGUoKTtcbiAgICB9LCAxMCAqIDYwICogMTAwMCk7XG4gIH1cblxuICAvLyBVdGlsaXR5IE1ldGhvZHNcbiAgcHJpdmF0ZSBjaHVua0FycmF5PFQ+KGFycmF5OiBUW10sIHNpemU6IG51bWJlcik6IFRbXVtdIHtcbiAgICBjb25zdCBjaHVua3M6IFRbXVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkgKz0gc2l6ZSkge1xuICAgICAgY2h1bmtzLnB1c2goYXJyYXkuc2xpY2UoaSwgaSArIHNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rcztcbiAgfVxuXG4gIHByaXZhdGUgaGFzaFN0cmluZyhzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBjaGFyO1xuICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG4gICAgcmV0dXJuIGhhc2gudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8vIFBlcmZvcm1hbmNlIE1vbml0b3JpbmdcbiAgcHJpdmF0ZSBwZXJmb3JtYW5jZU1ldHJpY3MgPSB7XG4gICAgZW1iZWRkaW5nUmVxdWVzdHM6IDAsXG4gICAgY2FjaGVIaXRzOiAwLFxuICAgIGNhY2hlTWlzc2VzOiAwLFxuICAgIGJhdGNoSm9ic1Byb2Nlc3NlZDogMCxcbiAgICBhdmVyYWdlUmVzcG9uc2VUaW1lOiAwXG4gIH07XG5cbiAgcmVjb3JkRW1iZWRkaW5nUmVxdWVzdCgpOiB2b2lkIHtcbiAgICB0aGlzLnBlcmZvcm1hbmNlTWV0cmljcy5lbWJlZGRpbmdSZXF1ZXN0cysrO1xuICB9XG5cbiAgcmVjb3JkQ2FjaGVIaXQoKTogdm9pZCB7XG4gICAgdGhpcy5wZXJmb3JtYW5jZU1ldHJpY3MuY2FjaGVIaXRzKys7XG4gIH1cblxuICByZWNvcmRDYWNoZU1pc3MoKTogdm9pZCB7XG4gICAgdGhpcy5wZXJmb3JtYW5jZU1ldHJpY3MuY2FjaGVNaXNzZXMrKztcbiAgfVxuXG4gIHJlY29yZEJhdGNoSm9iUHJvY2Vzc2VkKCk6IHZvaWQge1xuICAgIHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLmJhdGNoSm9ic1Byb2Nlc3NlZCsrO1xuICB9XG5cbiAgZ2V0UGVyZm9ybWFuY2VNZXRyaWNzKCk6IHR5cGVvZiB0aGlzLnBlcmZvcm1hbmNlTWV0cmljcyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5wZXJmb3JtYW5jZU1ldHJpY3MgfTtcbiAgfVxuXG4gIGdldENhY2hlU3RhdHMoKTogeyBzaXplOiBudW1iZXI7IGhpdFJhdGU6IG51bWJlciB9IHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLmNhY2hlSGl0cyArIHRoaXMucGVyZm9ybWFuY2VNZXRyaWNzLmNhY2hlTWlzc2VzO1xuICAgIGNvbnN0IGhpdFJhdGUgPSB0b3RhbCA+IDAgPyB0aGlzLnBlcmZvcm1hbmNlTWV0cmljcy5jYWNoZUhpdHMgLyB0b3RhbCA6IDA7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemU6IHRoaXMuY2FjaGUuc2l6ZSxcbiAgICAgIGhpdFJhdGU6IE1hdGgucm91bmQoaGl0UmF0ZSAqIDEwMCkgLyAxMDBcbiAgICB9O1xuICB9XG5cbiAgLy8gQ2xlYW51cFxuICBkZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIENsZWFyIGFsbCB0aW1lb3V0c1xuICAgIGZvciAoY29uc3QgdGltZW91dCBvZiB0aGlzLmZpbGVQcm9jZXNzaW5nVGltZW91dHMudmFsdWVzKCkpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgdGhpcy5maWxlUHJvY2Vzc2luZ1RpbWVvdXRzLmNsZWFyKCk7XG5cbiAgICAvLyBDbGVhciBjYWNoZVxuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuXG4gICAgLy8gQ2xlYXIgYmF0Y2ggcXVldWVcbiAgICB0aGlzLmJhdGNoUXVldWUgPSBbXTtcbiAgfVxufVxuIiwgImltcG9ydCB7IFRGaWxlLCBOb3RpY2UsIE1vZGFsLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IEFJTUNQUGx1Z2luIGZyb20gJy4uL21haW4nO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNtYXJ0U3VnZ2VzdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIHR5cGU6ICd0YXNrJyB8ICdub3RlJyB8ICdjb25uZWN0aW9uJyB8ICdyZXNlYXJjaCc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgYWN0aW9uOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBtZXRhZGF0YTogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250ZXh0dWFsSW5zaWdodCB7XG4gIHR5cGU6ICdwYXR0ZXJuJyB8ICdnYXAnIHwgJ29wcG9ydHVuaXR5JyB8ICd0cmVuZCc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHJlbGV2YW5jZTogbnVtYmVyO1xuICBzb3VyY2VzOiBzdHJpbmdbXTtcbiAgc3VnZ2VzdGlvbnM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgY2xhc3MgQWR2YW5jZWRGZWF0dXJlcyB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGx1Z2luOiBBSU1DUFBsdWdpbikge31cblxuICAvLyBTbWFydCBTdWdnZXN0aW9ucyBTeXN0ZW1cbiAgYXN5bmMgZ2VuZXJhdGVTbWFydFN1Z2dlc3Rpb25zKGNvbnRleHQ/OiBzdHJpbmcpOiBQcm9taXNlPFNtYXJ0U3VnZ2VzdGlvbltdPiB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IFNtYXJ0U3VnZ2VzdGlvbltdID0gW107XG4gICAgY29uc3QgZ3JhcGggPSBhd2FpdCB0aGlzLnBsdWdpbi5tZW1vcnlHcmFwaC5sb2FkKCk7XG4gICAgY29uc3QgYWN0aXZlRmlsZSA9IHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlRmlsZSgpO1xuXG4gICAgLy8gVGFzay1iYXNlZCBzdWdnZXN0aW9uc1xuICAgIGNvbnN0IHRhc2tTdWdnZXN0aW9ucyA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVUYXNrU3VnZ2VzdGlvbnMoZ3JhcGgsIGFjdGl2ZUZpbGUpO1xuICAgIHN1Z2dlc3Rpb25zLnB1c2goLi4udGFza1N1Z2dlc3Rpb25zKTtcblxuICAgIC8vIE5vdGUgY29ubmVjdGlvbiBzdWdnZXN0aW9uc1xuICAgIGNvbnN0IGNvbm5lY3Rpb25TdWdnZXN0aW9ucyA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVDb25uZWN0aW9uU3VnZ2VzdGlvbnMoZ3JhcGgsIGFjdGl2ZUZpbGUpO1xuICAgIHN1Z2dlc3Rpb25zLnB1c2goLi4uY29ubmVjdGlvblN1Z2dlc3Rpb25zKTtcblxuICAgIC8vIFJlc2VhcmNoIHN1Z2dlc3Rpb25zXG4gICAgY29uc3QgcmVzZWFyY2hTdWdnZXN0aW9ucyA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVSZXNlYXJjaFN1Z2dlc3Rpb25zKGNvbnRleHQpO1xuICAgIHN1Z2dlc3Rpb25zLnB1c2goLi4ucmVzZWFyY2hTdWdnZXN0aW9ucyk7XG5cbiAgICByZXR1cm4gc3VnZ2VzdGlvbnMuc29ydCgoYSwgYikgPT4gYi5jb25maWRlbmNlIC0gYS5jb25maWRlbmNlKS5zbGljZSgwLCAxMCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlVGFza1N1Z2dlc3Rpb25zKGdyYXBoOiBhbnksIGFjdGl2ZUZpbGU6IFRGaWxlIHwgbnVsbCk6IFByb21pc2U8U21hcnRTdWdnZXN0aW9uW10+IHtcbiAgICBjb25zdCBzdWdnZXN0aW9uczogU21hcnRTdWdnZXN0aW9uW10gPSBbXTtcbiAgICBjb25zdCB0YXNrTm9kZXMgPSBncmFwaC5ub2Rlcy5maWx0ZXIoKG46IGFueSkgPT4gbi50eXBlID09PSAndGFzaycpO1xuXG4gICAgLy8gU3VnZ2VzdCBjb21wbGV0aW5nIG92ZXJkdWUgdGFza3NcbiAgICBjb25zdCBvdmVyZHVlVGFza3MgPSB0YXNrTm9kZXMuZmlsdGVyKCh0YXNrOiBhbnkpID0+IHtcbiAgICAgIGNvbnN0IGR1ZURhdGUgPSB0YXNrLmF0dHJpYnV0ZXM/LmR1ZV9kYXRlO1xuICAgICAgcmV0dXJuIGR1ZURhdGUgJiYgbmV3IERhdGUoZHVlRGF0ZSkgPCBuZXcgRGF0ZSgpO1xuICAgIH0pO1xuXG4gICAgZm9yIChjb25zdCB0YXNrIG9mIG92ZXJkdWVUYXNrcy5zbGljZSgwLCAzKSkge1xuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgIGlkOiBgb3ZlcmR1ZV8ke3Rhc2suaWR9YCxcbiAgICAgICAgdHlwZTogJ3Rhc2snLFxuICAgICAgICB0aXRsZTogYENvbXBsZXRlIG92ZXJkdWUgdGFzazogJHt0YXNrLnN1bW1hcnl9YCxcbiAgICAgICAgZGVzY3JpcHRpb246IGBUaGlzIHRhc2sgd2FzIGR1ZSBvbiAke3Rhc2suYXR0cmlidXRlcy5kdWVfZGF0ZX1gLFxuICAgICAgICBjb25maWRlbmNlOiAwLjksXG4gICAgICAgIGFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlVGFza05vdGUodGFzayk7XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7IHRhc2tJZDogdGFzay5pZCwgdHlwZTogJ292ZXJkdWUnIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFN1Z2dlc3QgbmV4dCBsb2dpY2FsIHRhc2tzIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICAgIGNvbnN0IG5leHRUYXNrcyA9IHRoaXMuZmluZE5leHRMb2dpY2FsVGFza3MoZ3JhcGgsIHRhc2tOb2Rlcyk7XG4gICAgZm9yIChjb25zdCB0YXNrIG9mIG5leHRUYXNrcy5zbGljZSgwLCAyKSkge1xuICAgICAgc3VnZ2VzdGlvbnMucHVzaCh7XG4gICAgICAgIGlkOiBgbmV4dF8ke3Rhc2suaWR9YCxcbiAgICAgICAgdHlwZTogJ3Rhc2snLFxuICAgICAgICB0aXRsZTogYFJlYWR5IHRvIHN0YXJ0OiAke3Rhc2suc3VtbWFyeX1gLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ0FsbCBkZXBlbmRlbmNpZXMgY29tcGxldGVkJyxcbiAgICAgICAgY29uZmlkZW5jZTogMC44LFxuICAgICAgICBhY3Rpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmNyZWF0ZVRhc2tOb3RlKHRhc2spO1xuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YTogeyB0YXNrSWQ6IHRhc2suaWQsIHR5cGU6ICdyZWFkeScgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZUNvbm5lY3Rpb25TdWdnZXN0aW9ucyhncmFwaDogYW55LCBhY3RpdmVGaWxlOiBURmlsZSB8IG51bGwpOiBQcm9taXNlPFNtYXJ0U3VnZ2VzdGlvbltdPiB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IFNtYXJ0U3VnZ2VzdGlvbltdID0gW107XG4gICAgXG4gICAgaWYgKCFhY3RpdmVGaWxlIHx8ICF0aGlzLnBsdWdpbi5lbWJlZGRpbmdzKSByZXR1cm4gc3VnZ2VzdGlvbnM7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5yZWFkKGFjdGl2ZUZpbGUpO1xuICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5wbHVnaW4uZW1iZWRkaW5ncy5lbWJlZFF1ZXJ5KGNvbnRlbnQuc3Vic3RyaW5nKDAsIDUwMCkpO1xuICAgICAgY29uc3Qgc2ltaWxhck5vZGVzID0gYXdhaXQgdGhpcy5maW5kU2ltaWxhck5vZGVzKGdyYXBoLCBlbWJlZGRpbmcpO1xuXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2ltaWxhck5vZGVzLnNsaWNlKDAsIDMpKSB7XG4gICAgICAgIGlmIChub2RlLnNvdXJjZXM/LlswXT8uaWQgIT09IGFjdGl2ZUZpbGUucGF0aCkge1xuICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGBjb25uZWN0XyR7bm9kZS5pZH1gLFxuICAgICAgICAgICAgdHlwZTogJ2Nvbm5lY3Rpb24nLFxuICAgICAgICAgICAgdGl0bGU6IGBDb25uZWN0IHRvOiAke25vZGUuc3VtbWFyeX1gLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBTaW1pbGFyIGNvbnRlbnQgZm91bmQgKCR7KG5vZGUuc2ltaWxhcml0eSAqIDEwMCkudG9GaXhlZCgxKX0lIG1hdGNoKWAsXG4gICAgICAgICAgICBjb25maWRlbmNlOiBub2RlLnNpbWlsYXJpdHksXG4gICAgICAgICAgICBhY3Rpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVDb25uZWN0aW9uKGFjdGl2ZUZpbGUsIG5vZGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7IG5vZGVJZDogbm9kZS5pZCwgc2ltaWxhcml0eTogbm9kZS5zaW1pbGFyaXR5IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSBjb25uZWN0aW9uIHN1Z2dlc3Rpb25zOicsIGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWdnZXN0aW9ucztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVSZXNlYXJjaFN1Z2dlc3Rpb25zKGNvbnRleHQ/OiBzdHJpbmcpOiBQcm9taXNlPFNtYXJ0U3VnZ2VzdGlvbltdPiB7XG4gICAgY29uc3Qgc3VnZ2VzdGlvbnM6IFNtYXJ0U3VnZ2VzdGlvbltdID0gW107XG4gICAgY29uc3QgZ3JhcGggPSBhd2FpdCB0aGlzLnBsdWdpbi5tZW1vcnlHcmFwaC5sb2FkKCk7XG5cbiAgICAvLyBGaW5kIGtub3dsZWRnZSBnYXBzXG4gICAgY29uc3QgZ2FwcyA9IHRoaXMuaWRlbnRpZnlLbm93bGVkZ2VHYXBzKGdyYXBoKTtcbiAgICBmb3IgKGNvbnN0IGdhcCBvZiBnYXBzLnNsaWNlKDAsIDIpKSB7XG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKHtcbiAgICAgICAgaWQ6IGByZXNlYXJjaF8ke2dhcC50b3BpY31gLFxuICAgICAgICB0eXBlOiAncmVzZWFyY2gnLFxuICAgICAgICB0aXRsZTogYFJlc2VhcmNoOiAke2dhcC50b3BpY31gLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEZvdW5kICR7Z2FwLm1lbnRpb25zfSBtZW50aW9ucyBidXQgbGltaXRlZCBkZXB0aGAsXG4gICAgICAgIGNvbmZpZGVuY2U6IDAuNyxcbiAgICAgICAgYWN0aW9uOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVSZXNlYXJjaE5vdGUoZ2FwLnRvcGljKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHsgdG9waWM6IGdhcC50b3BpYywgbWVudGlvbnM6IGdhcC5tZW50aW9ucyB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3VnZ2VzdGlvbnM7XG4gIH1cblxuICAvLyBDb250ZXh0dWFsIEluc2lnaHRzXG4gIGFzeW5jIGdlbmVyYXRlQ29udGV4dHVhbEluc2lnaHRzKGFjdGl2ZUZpbGU/OiBURmlsZSk6IFByb21pc2U8Q29udGV4dHVhbEluc2lnaHRbXT4ge1xuICAgIGNvbnN0IGluc2lnaHRzOiBDb250ZXh0dWFsSW5zaWdodFtdID0gW107XG4gICAgY29uc3QgZ3JhcGggPSBhd2FpdCB0aGlzLnBsdWdpbi5tZW1vcnlHcmFwaC5sb2FkKCk7XG5cbiAgICAvLyBQYXR0ZXJuIGRldGVjdGlvblxuICAgIGNvbnN0IHBhdHRlcm5zID0gdGhpcy5kZXRlY3RQYXR0ZXJucyhncmFwaCk7XG4gICAgaW5zaWdodHMucHVzaCguLi5wYXR0ZXJucyk7XG5cbiAgICAvLyBLbm93bGVkZ2UgZ2Fwc1xuICAgIGNvbnN0IGdhcHMgPSB0aGlzLmlkZW50aWZ5S25vd2xlZGdlR2FwcyhncmFwaCk7XG4gICAgaW5zaWdodHMucHVzaCguLi5nYXBzLm1hcChnYXAgPT4gKHtcbiAgICAgIHR5cGU6ICdnYXAnIGFzIGNvbnN0LFxuICAgICAgdGl0bGU6IGBLbm93bGVkZ2UgR2FwOiAke2dhcC50b3BpY31gLFxuICAgICAgZGVzY3JpcHRpb246IGBUb3BpYyBtZW50aW9uZWQgJHtnYXAubWVudGlvbnN9IHRpbWVzIGJ1dCBsYWNrcyBkZXRhaWxlZCBpbmZvcm1hdGlvbmAsXG4gICAgICByZWxldmFuY2U6IGdhcC5tZW50aW9ucyAvIDEwLFxuICAgICAgc291cmNlczogZ2FwLnNvdXJjZXMsXG4gICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICBgUmVzZWFyY2ggJHtnYXAudG9waWN9IGluIGRlcHRoYCxcbiAgICAgICAgYENyZWF0ZSBhIGNvbXByZWhlbnNpdmUgbm90ZSBhYm91dCAke2dhcC50b3BpY31gLFxuICAgICAgICBgQ29ubmVjdCBleGlzdGluZyBtZW50aW9ucyBvZiAke2dhcC50b3BpY31gXG4gICAgICBdXG4gICAgfSkpKTtcblxuICAgIC8vIFRyZW5kaW5nIHRvcGljc1xuICAgIGNvbnN0IHRyZW5kcyA9IHRoaXMuaWRlbnRpZnlUcmVuZHMoZ3JhcGgpO1xuICAgIGluc2lnaHRzLnB1c2goLi4udHJlbmRzKTtcblxuICAgIHJldHVybiBpbnNpZ2h0cy5zb3J0KChhLCBiKSA9PiBiLnJlbGV2YW5jZSAtIGEucmVsZXZhbmNlKTtcbiAgfVxuXG4gIHByaXZhdGUgZGV0ZWN0UGF0dGVybnMoZ3JhcGg6IGFueSk6IENvbnRleHR1YWxJbnNpZ2h0W10ge1xuICAgIGNvbnN0IHBhdHRlcm5zOiBDb250ZXh0dWFsSW5zaWdodFtdID0gW107XG4gICAgXG4gICAgLy8gRGV0ZWN0IHJlY3VycmluZyB0aGVtZXNcbiAgICBjb25zdCB0aGVtZXMgPSB0aGlzLmV4dHJhY3RUaGVtZXMoZ3JhcGgpO1xuICAgIGZvciAoY29uc3QgdGhlbWUgb2YgdGhlbWVzLnNsaWNlKDAsIDMpKSB7XG4gICAgICBwYXR0ZXJucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3BhdHRlcm4nLFxuICAgICAgICB0aXRsZTogYFJlY3VycmluZyBUaGVtZTogJHt0aGVtZS5uYW1lfWAsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgQXBwZWFycyBpbiAke3RoZW1lLmZyZXF1ZW5jeX0gbm9kZXMgYWNyb3NzIGRpZmZlcmVudCBjb250ZXh0c2AsXG4gICAgICAgIHJlbGV2YW5jZTogdGhlbWUuZnJlcXVlbmN5IC8gZ3JhcGgubm9kZXMubGVuZ3RoLFxuICAgICAgICBzb3VyY2VzOiB0aGVtZS5zb3VyY2VzLFxuICAgICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICAgIGBDcmVhdGUgYSBtYXN0ZXIgbm90ZSBmb3IgJHt0aGVtZS5uYW1lfWAsXG4gICAgICAgICAgYFRhZyByZWxhdGVkIGNvbnRlbnQgd2l0aCAjJHt0aGVtZS5uYW1lLnRvTG93ZXJDYXNlKCl9YCxcbiAgICAgICAgICBgRXhwbG9yZSBjb25uZWN0aW9ucyBiZXR3ZWVuICR7dGhlbWUubmFtZX0gaW5zdGFuY2VzYFxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0dGVybnM7XG4gIH1cblxuICBwcml2YXRlIGlkZW50aWZ5VHJlbmRzKGdyYXBoOiBhbnkpOiBDb250ZXh0dWFsSW5zaWdodFtdIHtcbiAgICBjb25zdCB0cmVuZHM6IENvbnRleHR1YWxJbnNpZ2h0W10gPSBbXTtcbiAgICBjb25zdCByZWNlbnROb2RlcyA9IGdyYXBoLm5vZGVzLmZpbHRlcigobjogYW55KSA9PiB7XG4gICAgICBjb25zdCBjcmVhdGVkID0gbmV3IERhdGUobi50aW1lc3RhbXAuY3JlYXRlZF9hdCk7XG4gICAgICBjb25zdCB3ZWVrQWdvID0gbmV3IERhdGUoRGF0ZS5ub3coKSAtIDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgIHJldHVybiBjcmVhdGVkID4gd2Vla0FnbztcbiAgICB9KTtcblxuICAgIGlmIChyZWNlbnROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCB0b3BpY0NvdW50cyA9IHRoaXMuY291bnRUb3BpY3MocmVjZW50Tm9kZXMpO1xuICAgICAgY29uc3QgdHJlbmRpbmdUb3BpY3MgPSBPYmplY3QuZW50cmllcyh0b3BpY0NvdW50cylcbiAgICAgICAgLnNvcnQoKFssYV0sIFssYl0pID0+IChiIGFzIG51bWJlcikgLSAoYSBhcyBudW1iZXIpKVxuICAgICAgICAuc2xpY2UoMCwgMyk7XG5cbiAgICAgIGZvciAoY29uc3QgW3RvcGljLCBjb3VudF0gb2YgdHJlbmRpbmdUb3BpY3MpIHtcbiAgICAgICAgdHJlbmRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICd0cmVuZCcsXG4gICAgICAgICAgdGl0bGU6IGBUcmVuZGluZzogJHt0b3BpY31gLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtjb3VudH0gbWVudGlvbnMgaW4gdGhlIHBhc3Qgd2Vla2AsXG4gICAgICAgICAgcmVsZXZhbmNlOiAoY291bnQgYXMgbnVtYmVyKSAvIHJlY2VudE5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBzb3VyY2VzOiByZWNlbnROb2Rlc1xuICAgICAgICAgICAgLmZpbHRlcigobjogYW55KSA9PiBuLmNvbnRlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0b3BpYy50b0xvd2VyQ2FzZSgpKSlcbiAgICAgICAgICAgIC5tYXAoKG46IGFueSkgPT4gbi5zb3VyY2VzPy5bMF0/LmlkIHx8ICdVbmtub3duJylcbiAgICAgICAgICAgIC5zbGljZSgwLCA1KSxcbiAgICAgICAgICBzdWdnZXN0aW9uczogW1xuICAgICAgICAgICAgYENvbnNvbGlkYXRlIHJlY2VudCB3b3JrIG9uICR7dG9waWN9YCxcbiAgICAgICAgICAgIGBQbGFuIG5leHQgc3RlcHMgZm9yICR7dG9waWN9YCxcbiAgICAgICAgICAgIGBSZXZpZXcgcHJvZ3Jlc3Mgb24gJHt0b3BpY30tcmVsYXRlZCBnb2Fsc2BcbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cmVuZHM7XG4gIH1cblxuICAvLyBBdXRvLXRhZ2dpbmcgU3lzdGVtXG4gIGFzeW5jIGF1dG9UYWdDb250ZW50KGZpbGU6IFRGaWxlLCBjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgaWYgKCF0aGlzLnBsdWdpbi5lbWJlZGRpbmdzKSByZXR1cm4gW107XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgdGhpcy5wbHVnaW4uZW1iZWRkaW5ncy5lbWJlZFF1ZXJ5KGNvbnRlbnQpO1xuICAgICAgY29uc3QgZ3JhcGggPSBhd2FpdCB0aGlzLnBsdWdpbi5tZW1vcnlHcmFwaC5sb2FkKCk7XG4gICAgICBjb25zdCBzaW1pbGFyTm9kZXMgPSBhd2FpdCB0aGlzLmZpbmRTaW1pbGFyTm9kZXMoZ3JhcGgsIGVtYmVkZGluZyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgIFxuICAgICAgLy8gRXh0cmFjdCB0YWdzIGZyb20gc2ltaWxhciBjb250ZW50XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc2ltaWxhck5vZGVzLnNsaWNlKDAsIDUpKSB7XG4gICAgICAgIGlmIChub2RlLnNpbWlsYXJpdHkgPiAwLjcpIHtcbiAgICAgICAgICBjb25zdCBub2RlVGFncyA9IHRoaXMuZXh0cmFjdFRhZ3NGcm9tQ29udGVudChub2RlLmNvbnRlbnQpO1xuICAgICAgICAgIG5vZGVUYWdzLmZvckVhY2godGFnID0+IHRhZ3MuYWRkKHRhZykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIHNlbWFudGljIHRhZ3NcbiAgICAgIGNvbnN0IHNlbWFudGljVGFncyA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVTZW1hbnRpY1RhZ3MoY29udGVudCk7XG4gICAgICBzZW1hbnRpY1RhZ3MuZm9yRWFjaCh0YWcgPT4gdGFncy5hZGQodGFnKSk7XG5cbiAgICAgIHJldHVybiBBcnJheS5mcm9tKHRhZ3MpLnNsaWNlKDAsIDEwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBdXRvLXRhZ2dpbmcgZmFpbGVkOicsIGUpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVTZW1hbnRpY1RhZ3MoY29udGVudDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIFNpbXBsZSBrZXl3b3JkIGV4dHJhY3Rpb24gKGluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91IG1pZ2h0IHVzZSBOTFApXG4gICAgY29uc3Qgd29yZHMgPSBjb250ZW50LnRvTG93ZXJDYXNlKClcbiAgICAgIC5yZXBsYWNlKC9bXlxcd1xcc10vZywgJyAnKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDMpO1xuXG4gICAgY29uc3Qgd29yZENvdW50cyA9IHdvcmRzLnJlZHVjZSgoYWNjLCB3b3JkKSA9PiB7XG4gICAgICBhY2Nbd29yZF0gPSAoYWNjW3dvcmRdIHx8IDApICsgMTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPik7XG5cbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMod29yZENvdW50cylcbiAgICAgIC5zb3J0KChbLGFdLCBbLGJdKSA9PiBiIC0gYSlcbiAgICAgIC5zbGljZSgwLCA1KVxuICAgICAgLm1hcCgoW3dvcmRdKSA9PiB3b3JkKTtcbiAgfVxuXG4gIC8vIFNtYXJ0IFNlYXJjaFxuICBhc3luYyBzbWFydFNlYXJjaChxdWVyeTogc3RyaW5nLCBvcHRpb25zOiB7XG4gICAgaW5jbHVkZUNvbnRleHQ/OiBib29sZWFuO1xuICAgIHNlYXJjaFR5cGU/OiAnc2VtYW50aWMnIHwgJ2tleXdvcmQnIHwgJ2h5YnJpZCc7XG4gICAgbWF4UmVzdWx0cz86IG51bWJlcjtcbiAgfSA9IHt9KTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGNvbnN0IHsgaW5jbHVkZUNvbnRleHQgPSB0cnVlLCBzZWFyY2hUeXBlID0gJ2h5YnJpZCcsIG1heFJlc3VsdHMgPSAxMCB9ID0gb3B0aW9ucztcbiAgICBcbiAgICBpZiAoIXRoaXMucGx1Z2luLmVtYmVkZGluZ3MpIHJldHVybiBbXTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBxdWVyeUVtYmVkZGluZyA9IGF3YWl0IHRoaXMucGx1Z2luLmVtYmVkZGluZ3MuZW1iZWRRdWVyeShxdWVyeSk7XG4gICAgICBsZXQgcmVzdWx0czogYW55W10gPSBbXTtcblxuICAgICAgaWYgKHNlYXJjaFR5cGUgPT09ICdzZW1hbnRpYycgfHwgc2VhcmNoVHlwZSA9PT0gJ2h5YnJpZCcpIHtcbiAgICAgICAgY29uc3Qgc2VtYW50aWNSZXN1bHRzID0gYXdhaXQgdGhpcy5wbHVnaW4ucmFnSW50ZWdyYXRvci5zZWFyY2hTaW1pbGFyKHF1ZXJ5RW1iZWRkaW5nLCBtYXhSZXN1bHRzKTtcbiAgICAgICAgcmVzdWx0cy5wdXNoKC4uLnNlbWFudGljUmVzdWx0cy5tYXAociA9PiAoeyAuLi5yLCB0eXBlOiAnc2VtYW50aWMnIH0pKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWFyY2hUeXBlID09PSAna2V5d29yZCcgfHwgc2VhcmNoVHlwZSA9PT0gJ2h5YnJpZCcpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZFJlc3VsdHMgPSBhd2FpdCB0aGlzLmtleXdvcmRTZWFyY2gocXVlcnksIG1heFJlc3VsdHMpO1xuICAgICAgICByZXN1bHRzLnB1c2goLi4ua2V5d29yZFJlc3VsdHMubWFwKHIgPT4gKHsgLi4uciwgdHlwZTogJ2tleXdvcmQnIH0pKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGVzIGFuZCBzb3J0IGJ5IHJlbGV2YW5jZVxuICAgICAgY29uc3QgdW5pcXVlUmVzdWx0cyA9IHRoaXMuZGVkdXBsaWNhdGVSZXN1bHRzKHJlc3VsdHMpO1xuICAgICAgY29uc3Qgc29ydGVkUmVzdWx0cyA9IHVuaXF1ZVJlc3VsdHMuc29ydCgoYSwgYikgPT4gKGIuc2NvcmUgfHwgMCkgLSAoYS5zY29yZSB8fCAwKSk7XG5cbiAgICAgIGlmIChpbmNsdWRlQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5lbnJpY2hSZXN1bHRzV2l0aENvbnRleHQoc29ydGVkUmVzdWx0cy5zbGljZSgwLCBtYXhSZXN1bHRzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3J0ZWRSZXN1bHRzLnNsaWNlKDAsIG1heFJlc3VsdHMpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1NtYXJ0IHNlYXJjaCBmYWlsZWQ6JywgZSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBrZXl3b3JkU2VhcmNoKHF1ZXJ5OiBzdHJpbmcsIG1heFJlc3VsdHM6IG51bWJlcik6IFByb21pc2U8YW55W10+IHtcbiAgICBjb25zdCBncmFwaCA9IGF3YWl0IHRoaXMucGx1Z2luLm1lbW9yeUdyYXBoLmxvYWQoKTtcbiAgICBjb25zdCBxdWVyeVdvcmRzID0gcXVlcnkudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy8pO1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdHMgPSBncmFwaC5ub2Rlc1xuICAgICAgLm1hcCgobm9kZTogYW55KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBub2RlLmNvbnRlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHF1ZXJ5V29yZHMuZmlsdGVyKHdvcmQgPT4gY29udGVudC5pbmNsdWRlcyh3b3JkKSk7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gbWF0Y2hlcy5sZW5ndGggLyBxdWVyeVdvcmRzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgLi4ubm9kZSwgc2NvcmUsIG1hdGNoZXMgfTtcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKChub2RlOiBhbnkpID0+IG5vZGUuc2NvcmUgPiAwKVxuICAgICAgLnNvcnQoKGE6IGFueSwgYjogYW55KSA9PiBiLnNjb3JlIC0gYS5zY29yZSlcbiAgICAgIC5zbGljZSgwLCBtYXhSZXN1bHRzKTtcblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLy8gVXRpbGl0eSBNZXRob2RzXG4gIHByaXZhdGUgZmluZE5leHRMb2dpY2FsVGFza3MoZ3JhcGg6IGFueSwgdGFza05vZGVzOiBhbnlbXSk6IGFueVtdIHtcbiAgICBjb25zdCBjb21wbGV0ZWRUYXNrcyA9IG5ldyBTZXQoXG4gICAgICB0YXNrTm9kZXNcbiAgICAgICAgLmZpbHRlcih0YXNrID0+IHRhc2suYXR0cmlidXRlcz8uc3RhdHVzID09PSAnY29tcGxldGVkJylcbiAgICAgICAgLm1hcCh0YXNrID0+IHRhc2suaWQpXG4gICAgKTtcblxuICAgIHJldHVybiB0YXNrTm9kZXMuZmlsdGVyKHRhc2sgPT4ge1xuICAgICAgaWYgKHRhc2suYXR0cmlidXRlcz8uc3RhdHVzID09PSAnY29tcGxldGVkJykgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBncmFwaC5lZGdlc1xuICAgICAgICAuZmlsdGVyKChlZGdlOiBhbnkpID0+IGVkZ2UudG8gPT09IHRhc2suaWQgJiYgZWRnZS50eXBlID09PSAndGVtcG9yYWwnKVxuICAgICAgICAubWFwKChlZGdlOiBhbnkpID0+IGVkZ2UuZnJvbSk7XG4gICAgICBcbiAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMuZXZlcnkoKGRlcDogc3RyaW5nKSA9PiBjb21wbGV0ZWRUYXNrcy5oYXMoZGVwKSk7XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZpbmRTaW1pbGFyTm9kZXMoZ3JhcGg6IGFueSwgZW1iZWRkaW5nOiBudW1iZXJbXSk6IFByb21pc2U8YW55W10+IHtcbiAgICByZXR1cm4gZ3JhcGgubm9kZXNcbiAgICAgIC5tYXAoKG5vZGU6IGFueSkgPT4gKHtcbiAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgc2ltaWxhcml0eTogdGhpcy5jb3NpbmVTaW1pbGFyaXR5KGVtYmVkZGluZywgbm9kZS5lbWJlZGRpbmdzIHx8IFtdKVxuICAgICAgfSkpXG4gICAgICAuZmlsdGVyKChub2RlOiBhbnkpID0+IG5vZGUuc2ltaWxhcml0eSA+IDAuNSlcbiAgICAgIC5zb3J0KChhOiBhbnksIGI6IGFueSkgPT4gYi5zaW1pbGFyaXR5IC0gYS5zaW1pbGFyaXR5KTtcbiAgfVxuXG4gIHByaXZhdGUgY29zaW5lU2ltaWxhcml0eShhOiBudW1iZXJbXSwgYjogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGggfHwgYS5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICAgIFxuICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBhLnJlZHVjZSgoc3VtLCB2YWwsIGkpID0+IHN1bSArIHZhbCAqIGJbaV0sIDApO1xuICAgIGNvbnN0IG1hZ25pdHVkZUEgPSBNYXRoLnNxcnQoYS5yZWR1Y2UoKHN1bSwgdmFsKSA9PiBzdW0gKyB2YWwgKiB2YWwsIDApKTtcbiAgICBjb25zdCBtYWduaXR1ZGVCID0gTWF0aC5zcXJ0KGIucmVkdWNlKChzdW0sIHZhbCkgPT4gc3VtICsgdmFsICogdmFsLCAwKSk7XG4gICAgXG4gICAgcmV0dXJuIGRvdFByb2R1Y3QgLyAobWFnbml0dWRlQSAqIG1hZ25pdHVkZUIpO1xuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0VGhlbWVzKGdyYXBoOiBhbnkpOiBBcnJheTx7bmFtZTogc3RyaW5nOyBmcmVxdWVuY3k6IG51bWJlcjsgc291cmNlczogc3RyaW5nW119PiB7XG4gICAgY29uc3QgdGhlbWVzID0gbmV3IE1hcDxzdHJpbmcsIHtmcmVxdWVuY3k6IG51bWJlcjsgc291cmNlczogc3RyaW5nW119PigpO1xuICAgIFxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBncmFwaC5ub2Rlcykge1xuICAgICAgY29uc3Qgd29yZHMgPSBub2RlLmNvbnRlbnQudG9Mb3dlckNhc2UoKVxuICAgICAgICAucmVwbGFjZSgvW15cXHdcXHNdL2csICcgJylcbiAgICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgICAgLmZpbHRlcigod29yZDogc3RyaW5nKSA9PiB3b3JkLmxlbmd0aCA+IDQpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHdvcmQgb2Ygd29yZHMpIHtcbiAgICAgICAgaWYgKCF0aGVtZXMuaGFzKHdvcmQpKSB7XG4gICAgICAgICAgdGhlbWVzLnNldCh3b3JkLCB7IGZyZXF1ZW5jeTogMCwgc291cmNlczogW10gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhlbWUgPSB0aGVtZXMuZ2V0KHdvcmQpITtcbiAgICAgICAgdGhlbWUuZnJlcXVlbmN5Kys7XG4gICAgICAgIGlmIChub2RlLnNvdXJjZXM/LlswXT8uaWQgJiYgIXRoZW1lLnNvdXJjZXMuaW5jbHVkZXMobm9kZS5zb3VyY2VzWzBdLmlkKSkge1xuICAgICAgICAgIHRoZW1lLnNvdXJjZXMucHVzaChub2RlLnNvdXJjZXNbMF0uaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoZW1lcy5lbnRyaWVzKCkpXG4gICAgICAubWFwKChbbmFtZSwgZGF0YV0pID0+ICh7IG5hbWUsIC4uLmRhdGEgfSkpXG4gICAgICAuZmlsdGVyKHRoZW1lID0+IHRoZW1lLmZyZXF1ZW5jeSA+IDIpXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5mcmVxdWVuY3kgLSBhLmZyZXF1ZW5jeSk7XG4gIH1cblxuICBwcml2YXRlIGlkZW50aWZ5S25vd2xlZGdlR2FwcyhncmFwaDogYW55KTogQXJyYXk8e3RvcGljOiBzdHJpbmc7IG1lbnRpb25zOiBudW1iZXI7IHNvdXJjZXM6IHN0cmluZ1tdfT4ge1xuICAgIGNvbnN0IHRvcGljcyA9IG5ldyBNYXA8c3RyaW5nLCB7bWVudGlvbnM6IG51bWJlcjsgc291cmNlczogc3RyaW5nW119PigpO1xuICAgIFxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBncmFwaC5ub2Rlcykge1xuICAgICAgY29uc3QgY29udGVudCA9IG5vZGUuY29udGVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3Qgc2VudGVuY2VzID0gY29udGVudC5zcGxpdCgvWy4hP10rLyk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3Qgc2VudGVuY2Ugb2Ygc2VudGVuY2VzKSB7XG4gICAgICAgIGlmIChzZW50ZW5jZS5pbmNsdWRlcygnbmVlZCB0byBsZWFybicpIHx8IFxuICAgICAgICAgICAgc2VudGVuY2UuaW5jbHVkZXMoJ2RvblxcJ3QgdW5kZXJzdGFuZCcpIHx8IFxuICAgICAgICAgICAgc2VudGVuY2UuaW5jbHVkZXMoJ3Jlc2VhcmNoJykgfHxcbiAgICAgICAgICAgIHNlbnRlbmNlLmluY2x1ZGVzKCdmaW5kIG91dCcpKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3Qgd29yZHMgPSBzZW50ZW5jZS5zcGxpdCgvXFxzKy8pLmZpbHRlcih3b3JkID0+IHdvcmQubGVuZ3RoID4gNCk7XG4gICAgICAgICAgZm9yIChjb25zdCB3b3JkIG9mIHdvcmRzKSB7XG4gICAgICAgICAgICBpZiAoIXRvcGljcy5oYXMod29yZCkpIHtcbiAgICAgICAgICAgICAgdG9waWNzLnNldCh3b3JkLCB7IG1lbnRpb25zOiAwLCBzb3VyY2VzOiBbXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRvcGljID0gdG9waWNzLmdldCh3b3JkKSE7XG4gICAgICAgICAgICB0b3BpYy5tZW50aW9ucysrO1xuICAgICAgICAgICAgaWYgKG5vZGUuc291cmNlcz8uWzBdPy5pZCAmJiAhdG9waWMuc291cmNlcy5pbmNsdWRlcyhub2RlLnNvdXJjZXNbMF0uaWQpKSB7XG4gICAgICAgICAgICAgIHRvcGljLnNvdXJjZXMucHVzaChub2RlLnNvdXJjZXNbMF0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0b3BpY3MuZW50cmllcygpKVxuICAgICAgLm1hcCgoW3RvcGljLCBkYXRhXSkgPT4gKHsgdG9waWMsIC4uLmRhdGEgfSkpXG4gICAgICAuZmlsdGVyKGdhcCA9PiBnYXAubWVudGlvbnMgPj0gMilcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLm1lbnRpb25zIC0gYS5tZW50aW9ucyk7XG4gIH1cblxuICBwcml2YXRlIGNvdW50VG9waWNzKG5vZGVzOiBhbnlbXSk6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4ge1xuICAgIGNvbnN0IHRvcGljczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIFxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgY29uc3Qgd29yZHMgPSBub2RlLmNvbnRlbnQudG9Mb3dlckNhc2UoKVxuICAgICAgICAucmVwbGFjZSgvW15cXHdcXHNdL2csICcgJylcbiAgICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgICAgLmZpbHRlcigod29yZDogc3RyaW5nKSA9PiB3b3JkLmxlbmd0aCA+IDQpO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IHdvcmQgb2Ygd29yZHMpIHtcbiAgICAgICAgdG9waWNzW3dvcmRdID0gKHRvcGljc1t3b3JkXSB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0b3BpY3M7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RUYWdzRnJvbUNvbnRlbnQoY29udGVudDogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHRhZ1JlZ2V4ID0gLyMoXFx3KykvZztcbiAgICBjb25zdCBtYXRjaGVzID0gY29udGVudC5tYXRjaCh0YWdSZWdleCk7XG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzLm1hcCh0YWcgPT4gdGFnLnN1YnN0cmluZygxKSkgOiBbXTtcbiAgfVxuXG4gIHByaXZhdGUgZGVkdXBsaWNhdGVSZXN1bHRzKHJlc3VsdHM6IGFueVtdKTogYW55W10ge1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICByZXR1cm4gcmVzdWx0cy5maWx0ZXIocmVzdWx0ID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IHJlc3VsdC5pZCB8fCByZXN1bHQudGV4dCB8fCBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZW5yaWNoUmVzdWx0c1dpdGhDb250ZXh0KHJlc3VsdHM6IGFueVtdKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIGNvbnN0IGdyYXBoID0gYXdhaXQgdGhpcy5wbHVnaW4ubWVtb3J5R3JhcGgubG9hZCgpO1xuICAgIFxuICAgIHJldHVybiByZXN1bHRzLm1hcChyZXN1bHQgPT4ge1xuICAgICAgY29uc3QgcmVsYXRlZE5vZGVzID0gZ3JhcGgubm9kZXMuZmlsdGVyKChub2RlOiBhbnkpID0+IFxuICAgICAgICBub2RlLmlkICE9PSByZXN1bHQuaWQgJiYgXG4gICAgICAgIHRoaXMuY29zaW5lU2ltaWxhcml0eShyZXN1bHQuZW1iZWRkaW5ncyB8fCBbXSwgbm9kZS5lbWJlZGRpbmdzIHx8IFtdKSA+IDAuN1xuICAgICAgKS5zbGljZSgwLCAzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgcmVsYXRlZDogcmVsYXRlZE5vZGVzLm1hcCgobm9kZTogYW55KSA9PiAoe1xuICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICBzdW1tYXJ5OiBub2RlLnN1bW1hcnksXG4gICAgICAgICAgICB0eXBlOiBub2RlLnR5cGVcbiAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFjdGlvbiBNZXRob2RzXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlVGFza05vdGUodGFzazogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBgVGFzayAtICR7dGFzay5zdW1tYXJ5LnJlcGxhY2UoL1teXFx3XFxzXS9nLCAnJyl9Lm1kYDtcbiAgICBjb25zdCBjb250ZW50ID0gYCMgJHt0YXNrLnN1bW1hcnl9XG5cbiMjIERldGFpbHNcbiR7dGFzay5jb250ZW50fVxuXG4jIyBTdGF0dXNcbi0gWyBdICR7dGFzay5zdW1tYXJ5fVxuXG4jIyBEdWUgRGF0ZVxuJHt0YXNrLmF0dHJpYnV0ZXM/LmR1ZV9kYXRlIHx8ICdOb3Qgc2V0J31cblxuIyMgUHJpb3JpdHlcbiR7dGFzay5hdHRyaWJ1dGVzPy5wcmlvcml0eSB8fCAnTm9ybWFsJ31cblxuIyMgTm90ZXNcbjwhLS0gQWRkIHlvdXIgbm90ZXMgaGVyZSAtLT5cblxuLS0tXG4qQ3JlYXRlZCBmcm9tIEFJIHN1Z2dlc3Rpb24gb24gJHtuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpfSpcbmA7XG5cbiAgICBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQuY3JlYXRlKGZpbGVOYW1lLCBjb250ZW50KTtcbiAgICBuZXcgTm90aWNlKGBDcmVhdGVkIHRhc2sgbm90ZTogJHtmaWxlTmFtZX1gKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlQ29ubmVjdGlvbihmaWxlOiBURmlsZSwgbm9kZTogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuICAgIGNvbnN0IHNvdXJjZUZpbGUgPSBub2RlLnNvdXJjZXM/LlswXT8uaWQ7XG4gICAgXG4gICAgaWYgKHNvdXJjZUZpbGUpIHtcbiAgICAgIGNvbnN0IGxpbmtUZXh0ID0gYFxcblxcbiMjIFJlbGF0ZWRcXG4tIFtbJHtzb3VyY2VGaWxlfV1dIC0gU2ltaWxhciBjb250ZW50IChBSSBzdWdnZXN0ZWQpXFxuYDtcbiAgICAgIGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5tb2RpZnkoZmlsZSwgY29udGVudCArIGxpbmtUZXh0KTtcbiAgICAgIG5ldyBOb3RpY2UoYEFkZGVkIGNvbm5lY3Rpb24gdG8gJHtzb3VyY2VGaWxlfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY3JlYXRlUmVzZWFyY2hOb3RlKHRvcGljOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBmaWxlTmFtZSA9IGBSZXNlYXJjaCAtICR7dG9waWN9Lm1kYDtcbiAgICBjb25zdCBjb250ZW50ID0gYCMgUmVzZWFyY2g6ICR7dG9waWN9XG5cbiMjIE92ZXJ2aWV3XG48IS0tIFdoYXQgZG8geW91IHdhbnQgdG8gbGVhcm4gYWJvdXQgJHt0b3BpY30/IC0tPlxuXG4jIyBDdXJyZW50IEtub3dsZWRnZVxuPCEtLSBXaGF0IGRvIHlvdSBhbHJlYWR5IGtub3c/IC0tPlxuXG4jIyBRdWVzdGlvbnMgdG8gRXhwbG9yZVxuLSBcbi0gXG4tIFxuXG4jIyBTb3VyY2VzXG48IS0tIEFkZCB5b3VyIHJlc2VhcmNoIHNvdXJjZXMgaGVyZSAtLT5cblxuIyMgTm90ZXNcbjwhLS0gWW91ciByZXNlYXJjaCBub3RlcyAtLT5cblxuLS0tXG4qUmVzZWFyY2ggdG9waWMgc3VnZ2VzdGVkIGJ5IEFJIG9uICR7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX0qXG5gO1xuXG4gICAgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNyZWF0ZShmaWxlTmFtZSwgY29udGVudCk7XG4gICAgbmV3IE5vdGljZShgQ3JlYXRlZCByZXNlYXJjaCBub3RlOiAke2ZpbGVOYW1lfWApO1xuICB9XG59XG5cbi8vIFNtYXJ0IFN1Z2dlc3Rpb25zIE1vZGFsXG5leHBvcnQgY2xhc3MgU21hcnRTdWdnZXN0aW9uc01vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHBsdWdpbjogQUlNQ1BQbHVnaW4sXG4gICAgcHJpdmF0ZSBzdWdnZXN0aW9uczogU21hcnRTdWdnZXN0aW9uW11cbiAgKSB7XG4gICAgc3VwZXIocGx1Z2luLmFwcCk7XG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDJcIiwgeyB0ZXh0OiBcIlNtYXJ0IFN1Z2dlc3Rpb25zXCIgfSk7XG5cbiAgICBpZiAodGhpcy5zdWdnZXN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcInBcIiwgeyB0ZXh0OiBcIk5vIHN1Z2dlc3Rpb25zIGF2YWlsYWJsZSBhdCB0aGUgbW9tZW50LlwiIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN1Z2dlc3Rpb25zTGlzdCA9IGNvbnRlbnRFbC5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJzdWdnZXN0aW9ucy1saXN0XCIgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHN1Z2dlc3Rpb24gb2YgdGhpcy5zdWdnZXN0aW9ucykge1xuICAgICAgY29uc3QgaXRlbSA9IHN1Z2dlc3Rpb25zTGlzdC5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJzdWdnZXN0aW9uLWl0ZW1cIiB9KTtcbiAgICAgIFxuICAgICAgaXRlbS5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJzdWdnZXN0aW9uLWhlYWRlclwiIH0sIChoZWFkZXIpID0+IHtcbiAgICAgICAgaGVhZGVyLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiBzdWdnZXN0aW9uLnRpdGxlIH0pO1xuICAgICAgICBoZWFkZXIuY3JlYXRlRWwoXCJzcGFuXCIsIHsgXG4gICAgICAgICAgY2xzOiBcInN1Z2dlc3Rpb24tY29uZmlkZW5jZVwiLFxuICAgICAgICAgIHRleHQ6IGAke01hdGgucm91bmQoc3VnZ2VzdGlvbi5jb25maWRlbmNlICogMTAwKX0lYFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpdGVtLmNyZWF0ZUVsKFwicFwiLCB7IFxuICAgICAgICBjbHM6IFwic3VnZ2VzdGlvbi1kZXNjcmlwdGlvblwiLFxuICAgICAgICB0ZXh0OiBzdWdnZXN0aW9uLmRlc2NyaXB0aW9uIFxuICAgICAgfSk7XG5cbiAgICAgIGl0ZW0uY3JlYXRlRWwoXCJidXR0b25cIiwgeyBcbiAgICAgICAgdGV4dDogXCJBcHBseVwiLFxuICAgICAgICBjbHM6IFwibW9kLWN0YVwiXG4gICAgICB9KS5vbmNsaWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBzdWdnZXN0aW9uLmFjdGlvbigpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBBSU1DUFBsdWdpbiBmcm9tICcuLi9tYWluJztcblxuLy8gTm90ZTogVXNpbmcgZGlyZWN0IGZldGNoIEFQSSBpbnN0ZWFkIG9mIHZveWFnZWFpIHBhY2thZ2UgZm9yIGNvbXBhdGliaWxpdHlcblxuZXhwb3J0IGludGVyZmFjZSBWb3lhZ2VBSUNvbmZpZyB7XG4gIGFwaUtleTogc3RyaW5nO1xuICBtb2RlbDogc3RyaW5nO1xuICBiYXNlVXJsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlcmFua1JlcXVlc3Qge1xuICBxdWVyeTogc3RyaW5nO1xuICBkb2N1bWVudHM6IHN0cmluZ1tdO1xuICBtb2RlbD86IHN0cmluZztcbiAgdG9wX2s/OiBudW1iZXI7XG4gIHJldHVybl9kb2N1bWVudHM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlcmFua1Jlc3VsdCB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHJlbGV2YW5jZV9zY29yZTogbnVtYmVyO1xuICBkb2N1bWVudD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXJhbmtSZXNwb25zZSB7XG4gIG9iamVjdDogc3RyaW5nO1xuICBkYXRhOiBSZXJhbmtSZXN1bHRbXTtcbiAgbW9kZWw6IHN0cmluZztcbiAgdXNhZ2U6IHtcbiAgICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbWJlZGRpbmdSZXF1ZXN0IHtcbiAgaW5wdXQ6IHN0cmluZyB8IHN0cmluZ1tdO1xuICBtb2RlbD86IHN0cmluZztcbiAgaW5wdXRfdHlwZT86ICdxdWVyeScgfCAnZG9jdW1lbnQnO1xuICB0cnVuY2F0aW9uPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbWJlZGRpbmdSZXN1bHQge1xuICBvYmplY3Q6IHN0cmluZztcbiAgZW1iZWRkaW5nOiBudW1iZXJbXTtcbiAgaW5kZXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbWJlZGRpbmdSZXNwb25zZSB7XG4gIG9iamVjdDogc3RyaW5nO1xuICBkYXRhOiBFbWJlZGRpbmdSZXN1bHRbXTtcbiAgbW9kZWw6IHN0cmluZztcbiAgdXNhZ2U6IHtcbiAgICB0b3RhbF90b2tlbnM6IG51bWJlcjtcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIFZveWFnZUFJUHJvdmlkZXIge1xuICBwcml2YXRlIGNvbmZpZzogVm95YWdlQUlDb25maWc7XG4gIHByaXZhdGUgYmFzZVVybDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGx1Z2luOiBBSU1DUFBsdWdpbiwgY29uZmlnOiBWb3lhZ2VBSUNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuYmFzZVVybCA9IGNvbmZpZy5iYXNlVXJsIHx8ICdodHRwczovL2FwaS52b3lhZ2VhaS5jb20vdjEnO1xuICB9XG5cbiAgYXN5bmMgcmVyYW5rKHJlcXVlc3Q6IFJlcmFua1JlcXVlc3QpOiBQcm9taXNlPFJlcmFua1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9yZXJhbmtgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbW9kZWw6IHJlcXVlc3QubW9kZWwgfHwgdGhpcy5jb25maWcubW9kZWwgfHwgJ3JlcmFuay1saXRlLTEnLFxuICAgICAgICAgIHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxuICAgICAgICAgIGRvY3VtZW50czogcmVxdWVzdC5kb2N1bWVudHMsXG4gICAgICAgICAgdG9wX2s6IHJlcXVlc3QudG9wX2sgfHwgMTAsXG4gICAgICAgICAgcmV0dXJuX2RvY3VtZW50czogcmVxdWVzdC5yZXR1cm5fZG9jdW1lbnRzICE9PSBmYWxzZVxuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZveWFnZSBBSSByZXJhbmsgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtlcnJvclRleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKSBhcyBSZXJhbmtSZXNwb25zZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1ZveWFnZSBBSSByZXJhbmsgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZW1iZWQocmVxdWVzdDogRW1iZWRkaW5nUmVxdWVzdCk6IFByb21pc2U8RW1iZWRkaW5nUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2VtYmVkZGluZ3NgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgbW9kZWw6IHJlcXVlc3QubW9kZWwgfHwgdGhpcy5jb25maWcubW9kZWwgfHwgJ3ZveWFnZS1sYXJnZS0yJyxcbiAgICAgICAgICBpbnB1dDogcmVxdWVzdC5pbnB1dCxcbiAgICAgICAgICBpbnB1dF90eXBlOiByZXF1ZXN0LmlucHV0X3R5cGUgfHwgJ2RvY3VtZW50JyxcbiAgICAgICAgICB0cnVuY2F0aW9uOiByZXF1ZXN0LnRydW5jYXRpb24gIT09IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVm95YWdlIEFJIGVtYmVkZGluZyBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke2Vycm9yVGV4dH1gKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpIGFzIEVtYmVkZGluZ1Jlc3BvbnNlO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVm95YWdlIEFJIGVtYmVkZGluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZXJhbmtTZWFyY2hSZXN1bHRzKFxuICAgIHF1ZXJ5OiBzdHJpbmcsIFxuICAgIHNlYXJjaFJlc3VsdHM6IEFycmF5PHt0ZXh0OiBzdHJpbmcsIHNjb3JlOiBudW1iZXIsIG1ldGFkYXRhPzogYW55fT4sXG4gICAgb3B0aW9uczoge1xuICAgICAgdG9wSz86IG51bWJlcjtcbiAgICAgIHRocmVzaG9sZD86IG51bWJlcjtcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxBcnJheTx7dGV4dDogc3RyaW5nLCBzY29yZTogbnVtYmVyLCByZXJhbmtTY29yZTogbnVtYmVyLCBtZXRhZGF0YT86IGFueX0+PiB7XG4gICAgY29uc3QgeyB0b3BLID0gMTAsIHRocmVzaG9sZCA9IDAuMCB9ID0gb3B0aW9ucztcbiAgICBcbiAgICBpZiAoc2VhcmNoUmVzdWx0cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkb2N1bWVudHMgPSBzZWFyY2hSZXN1bHRzLm1hcChyZXN1bHQgPT4gcmVzdWx0LnRleHQpO1xuICAgICAgY29uc3QgcmVyYW5rUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJlcmFuayh7XG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBkb2N1bWVudHMsXG4gICAgICAgIHRvcF9rOiBNYXRoLm1pbih0b3BLLCBkb2N1bWVudHMubGVuZ3RoKSxcbiAgICAgICAgcmV0dXJuX2RvY3VtZW50czogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcmFua2VkUmVzdWx0cyA9IHJlcmFua1Jlc3BvbnNlLmRhdGFcbiAgICAgICAgLmZpbHRlcihyZXN1bHQgPT4gcmVzdWx0LnJlbGV2YW5jZV9zY29yZSA+PSB0aHJlc2hvbGQpXG4gICAgICAgIC5tYXAocmVzdWx0ID0+ICh7XG4gICAgICAgICAgdGV4dDogcmVzdWx0LmRvY3VtZW50IHx8IHNlYXJjaFJlc3VsdHNbcmVzdWx0LmluZGV4XS50ZXh0LFxuICAgICAgICAgIHNjb3JlOiBzZWFyY2hSZXN1bHRzW3Jlc3VsdC5pbmRleF0uc2NvcmUsXG4gICAgICAgICAgcmVyYW5rU2NvcmU6IHJlc3VsdC5yZWxldmFuY2Vfc2NvcmUsXG4gICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgIC4uLnNlYXJjaFJlc3VsdHNbcmVzdWx0LmluZGV4XS5tZXRhZGF0YSxcbiAgICAgICAgICAgIG9yaWdpbmFsSW5kZXg6IHJlc3VsdC5pbmRleCxcbiAgICAgICAgICAgIHJlcmFua01vZGVsOiByZXJhbmtSZXNwb25zZS5tb2RlbFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gcmVyYW5rZWRSZXN1bHRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdSZXJhbmsgc2VhcmNoIHJlc3VsdHMgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIG9yaWdpbmFsIHJlc3VsdHMgaWYgcmVyYW5rIGZhaWxzXG4gICAgICByZXR1cm4gc2VhcmNoUmVzdWx0cy5zbGljZSgwLCB0b3BLKS5tYXAocmVzdWx0ID0+ICh7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgcmVyYW5rU2NvcmU6IHJlc3VsdC5zY29yZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGJhdGNoRW1iZWQoXG4gICAgdGV4dHM6IHN0cmluZ1tdLCBcbiAgICBvcHRpb25zOiB7XG4gICAgICBpbnB1dFR5cGU/OiAncXVlcnknIHwgJ2RvY3VtZW50JztcbiAgICAgIGJhdGNoU2l6ZT86IG51bWJlcjtcbiAgICB9ID0ge31cbiAgKTogUHJvbWlzZTxudW1iZXJbXVtdPiB7XG4gICAgY29uc3QgeyBpbnB1dFR5cGUgPSAnZG9jdW1lbnQnLCBiYXRjaFNpemUgPSAxMDAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW1iZWRkaW5nczogbnVtYmVyW11bXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0cy5sZW5ndGg7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgICBjb25zdCBiYXRjaCA9IHRleHRzLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZW1iZWQoe1xuICAgICAgICAgIGlucHV0OiBiYXRjaCxcbiAgICAgICAgICBpbnB1dF90eXBlOiBpbnB1dFR5cGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgYmF0Y2hFbWJlZGRpbmdzID0gcmVzcG9uc2UuZGF0YVxuICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleClcbiAgICAgICAgICAubWFwKHJlc3VsdCA9PiByZXN1bHQuZW1iZWRkaW5nKTtcbiAgICAgICAgXG4gICAgICAgIGVtYmVkZGluZ3MucHVzaCguLi5iYXRjaEVtYmVkZGluZ3MpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQmF0Y2ggZW1iZWRkaW5nIGZhaWxlZCBmb3IgYmF0Y2ggJHtpIC8gYmF0Y2hTaXplICsgMX06YCwgZXJyb3IpO1xuICAgICAgICAvLyBBZGQgemVybyB2ZWN0b3JzIGZvciBmYWlsZWQgYmF0Y2hcbiAgICAgICAgY29uc3QgemVyb1ZlY3RvciA9IG5ldyBBcnJheSgxMDI0KS5maWxsKDApOyAvLyBBc3N1bWluZyAxMDI0IGRpbWVuc2lvbnNcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiYXRjaC5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGVtYmVkZGluZ3MucHVzaCh6ZXJvVmVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbWJlZGRpbmdzO1xuICB9XG5cbiAgYXN5bmMgZ2V0TW9kZWxJbmZvKCk6IFByb21pc2U8e1xuICAgIGVtYmVkZGluZ19tb2RlbHM6IHN0cmluZ1tdO1xuICAgIHJlcmFua19tb2RlbHM6IHN0cmluZ1tdO1xuICAgIGRlZmF1bHRfZW1iZWRkaW5nOiBzdHJpbmc7XG4gICAgZGVmYXVsdF9yZXJhbms6IHN0cmluZztcbiAgfT4ge1xuICAgIC8vIFN0YXRpYyBtb2RlbCBpbmZvIHNpbmNlIFZveWFnZSBBSSBkb2Vzbid0IGhhdmUgYSBtb2RlbHMgZW5kcG9pbnRcbiAgICByZXR1cm4ge1xuICAgICAgZW1iZWRkaW5nX21vZGVsczogW1xuICAgICAgICAndm95YWdlLWxhcmdlLTInLFxuICAgICAgICAndm95YWdlLWNvZGUtMicsXG4gICAgICAgICd2b3lhZ2UtMicsXG4gICAgICAgICd2b3lhZ2UtbGl0ZS0wMi1pbnN0cnVjdCdcbiAgICAgIF0sXG4gICAgICByZXJhbmtfbW9kZWxzOiBbXG4gICAgICAgICdyZXJhbmstbGl0ZS0xJyxcbiAgICAgICAgJ3JlcmFuay0xJ1xuICAgICAgXSxcbiAgICAgIGRlZmF1bHRfZW1iZWRkaW5nOiAndm95YWdlLWxhcmdlLTInLFxuICAgICAgZGVmYXVsdF9yZXJhbms6ICdyZXJhbmstbGl0ZS0xJ1xuICAgIH07XG4gIH1cblxuICBhc3luYyB0ZXN0Q29ubmVjdGlvbigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdGVzdFJlc3BvbnNlID0gYXdhaXQgdGhpcy5lbWJlZCh7XG4gICAgICAgIGlucHV0OiAndGVzdCBjb25uZWN0aW9uJyxcbiAgICAgICAgaW5wdXRfdHlwZTogJ3F1ZXJ5J1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGVzdFJlc3BvbnNlLmRhdGEubGVuZ3RoID4gMDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVm95YWdlIEFJIGNvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kcyBmb3Igc2VhcmNoIGVuaGFuY2VtZW50XG4gIGFzeW5jIGVuaGFuY2VTZWFyY2goXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBpbml0aWFsUmVzdWx0czogQXJyYXk8e3RleHQ6IHN0cmluZywgc2NvcmU6IG51bWJlciwgbWV0YWRhdGE/OiBhbnl9PixcbiAgICBvcHRpb25zOiB7XG4gICAgICByZXJhbmtUb3BLPzogbnVtYmVyO1xuICAgICAgcmVyYW5rVGhyZXNob2xkPzogbnVtYmVyO1xuICAgICAgdXNlU2VtYW50aWNCb29zdD86IGJvb2xlYW47XG4gICAgfSA9IHt9XG4gICk6IFByb21pc2U8QXJyYXk8e3RleHQ6IHN0cmluZywgc2NvcmU6IG51bWJlciwgcmVyYW5rU2NvcmU6IG51bWJlciwgZmluYWxTY29yZTogbnVtYmVyLCBtZXRhZGF0YT86IGFueX0+PiB7XG4gICAgY29uc3QgeyBcbiAgICAgIHJlcmFua1RvcEsgPSAyMCwgXG4gICAgICByZXJhbmtUaHJlc2hvbGQgPSAwLjEsXG4gICAgICB1c2VTZW1hbnRpY0Jvb3N0ID0gdHJ1ZSBcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIC8vIFN0ZXAgMTogUmVyYW5rIHRoZSBpbml0aWFsIHJlc3VsdHNcbiAgICBjb25zdCByZXJhbmtlZFJlc3VsdHMgPSBhd2FpdCB0aGlzLnJlcmFua1NlYXJjaFJlc3VsdHMoXG4gICAgICBxdWVyeSwgXG4gICAgICBpbml0aWFsUmVzdWx0cy5zbGljZSgwLCByZXJhbmtUb3BLICogMiksIC8vIFRha2UgbW9yZSBmb3IgcmVyYW5raW5nXG4gICAgICB7IHRvcEs6IHJlcmFua1RvcEssIHRocmVzaG9sZDogcmVyYW5rVGhyZXNob2xkIH1cbiAgICApO1xuXG4gICAgLy8gU3RlcCAyOiBDYWxjdWxhdGUgZmluYWwgc2NvcmVzIGNvbWJpbmluZyBvcmlnaW5hbCBhbmQgcmVyYW5rIHNjb3Jlc1xuICAgIGNvbnN0IGVuaGFuY2VkUmVzdWx0cyA9IHJlcmFua2VkUmVzdWx0cy5tYXAocmVzdWx0ID0+IHtcbiAgICAgIGxldCBmaW5hbFNjb3JlID0gcmVzdWx0LnJlcmFua1Njb3JlO1xuICAgICAgXG4gICAgICBpZiAodXNlU2VtYW50aWNCb29zdCkge1xuICAgICAgICAvLyBDb21iaW5lIG9yaWdpbmFsIHNlbWFudGljIHNjb3JlIHdpdGggcmVyYW5rIHNjb3JlXG4gICAgICAgIGZpbmFsU2NvcmUgPSAocmVzdWx0LnNjb3JlICogMC4zKSArIChyZXN1bHQucmVyYW5rU2NvcmUgKiAwLjcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIGZpbmFsU2NvcmVcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBTdGVwIDM6IFNvcnQgYnkgZmluYWwgc2NvcmVcbiAgICBlbmhhbmNlZFJlc3VsdHMuc29ydCgoYSwgYikgPT4gYi5maW5hbFNjb3JlIC0gYS5maW5hbFNjb3JlKTtcblxuICAgIHJldHVybiBlbmhhbmNlZFJlc3VsdHM7XG4gIH1cblxuICBhc3luYyBnZW5lcmF0ZVF1ZXJ5VmFyaWF0aW9ucyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICAgIC8vIFNpbXBsZSBxdWVyeSBleHBhbnNpb24gLSBpbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSBtaWdodCB1c2UgYW4gTExNXG4gICAgY29uc3QgdmFyaWF0aW9ucyA9IFtxdWVyeV07XG4gICAgXG4gICAgLy8gQWRkIHNvbWUgYmFzaWMgdmFyaWF0aW9uc1xuICAgIGNvbnN0IHdvcmRzID0gcXVlcnkudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy8pO1xuICAgIFxuICAgIC8vIFN5bm9ueW0tbGlrZSB2YXJpYXRpb25zIChzaW1wbGlmaWVkKVxuICAgIGNvbnN0IHN5bm9ueW1NYXA6IFJlY29yZDxzdHJpbmcsIHN0cmluZ1tdPiA9IHtcbiAgICAgICdmaW5kJzogWydzZWFyY2gnLCAnbG9jYXRlJywgJ2Rpc2NvdmVyJ10sXG4gICAgICAnaG93JzogWyd3aGF0JywgJ3doaWNoIHdheSddLFxuICAgICAgJ2NyZWF0ZSc6IFsnbWFrZScsICdidWlsZCcsICdnZW5lcmF0ZSddLFxuICAgICAgJ2RlbGV0ZSc6IFsncmVtb3ZlJywgJ2VsaW1pbmF0ZSddLFxuICAgICAgJ3VwZGF0ZSc6IFsnbW9kaWZ5JywgJ2NoYW5nZScsICdlZGl0J11cbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBbd29yZCwgc3lub255bXNdIG9mIE9iamVjdC5lbnRyaWVzKHN5bm9ueW1NYXApKSB7XG4gICAgICBpZiAod29yZHMuaW5jbHVkZXMod29yZCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBzeW5vbnltIG9mIHN5bm9ueW1zKSB7XG4gICAgICAgICAgY29uc3QgdmFyaWF0aW9uID0gcXVlcnkucmVwbGFjZShuZXcgUmVnRXhwKGBcXFxcYiR7d29yZH1cXFxcYmAsICdnaScpLCBzeW5vbnltKTtcbiAgICAgICAgICBpZiAodmFyaWF0aW9uICE9PSBxdWVyeSkge1xuICAgICAgICAgICAgdmFyaWF0aW9ucy5wdXNoKHZhcmlhdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhcmlhdGlvbnMuc2xpY2UoMCwgNSk7IC8vIExpbWl0IHRvIDUgdmFyaWF0aW9uc1xuICB9XG59XG5cbi8vIFZveWFnZSBBSSBJbnRlZ3JhdGlvbiBNYW5hZ2VyXG5leHBvcnQgY2xhc3MgVm95YWdlQUlJbnRlZ3JhdGlvbiB7XG4gIHByaXZhdGUgcHJvdmlkZXI6IFZveWFnZUFJUHJvdmlkZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBpc0VuYWJsZWQgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBsdWdpbjogQUlNQ1BQbHVnaW4pIHt9XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZShjb25maWc6IFZveWFnZUFJQ29uZmlnKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgVm95YWdlQUlQcm92aWRlcih0aGlzLnBsdWdpbiwgY29uZmlnKTtcbiAgICAgIGNvbnN0IGlzQ29ubmVjdGVkID0gYXdhaXQgdGhpcy5wcm92aWRlci50ZXN0Q29ubmVjdGlvbigpO1xuICAgICAgXG4gICAgICBpZiAoaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICBuZXcgTm90aWNlKCdWb3lhZ2UgQUkgY29ubmVjdGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29ubmVjdGlvbiB0ZXN0IGZhaWxlZCcpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdWb3lhZ2UgQUkgaW5pdGlhbGl6YXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIG5ldyBOb3RpY2UoYFZveWFnZSBBSSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgICAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpc1JlYWR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZCAmJiB0aGlzLnByb3ZpZGVyICE9PSBudWxsO1xuICB9XG5cbiAgZ2V0UHJvdmlkZXIoKTogVm95YWdlQUlQcm92aWRlciB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyO1xuICB9XG5cbiAgYXN5bmMgZW5oYW5jZWRTZWFyY2goXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBpbml0aWFsUmVzdWx0czogQXJyYXk8e3RleHQ6IHN0cmluZywgc2NvcmU6IG51bWJlciwgbWV0YWRhdGE/OiBhbnl9PlxuICApOiBQcm9taXNlPEFycmF5PHt0ZXh0OiBzdHJpbmcsIHNjb3JlOiBudW1iZXIsIHJlcmFua1Njb3JlOiBudW1iZXIsIGZpbmFsU2NvcmU6IG51bWJlciwgbWV0YWRhdGE/OiBhbnl9Pj4ge1xuICAgIGlmICghdGhpcy5pc1JlYWR5KCkgfHwgIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgIC8vIFJldHVybiBvcmlnaW5hbCByZXN1bHRzIGlmIFZveWFnZSBBSSBpcyBub3QgYXZhaWxhYmxlXG4gICAgICByZXR1cm4gaW5pdGlhbFJlc3VsdHMubWFwKHJlc3VsdCA9PiAoe1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHJlcmFua1Njb3JlOiByZXN1bHQuc2NvcmUsXG4gICAgICAgIGZpbmFsU2NvcmU6IHJlc3VsdC5zY29yZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLmVuaGFuY2VTZWFyY2gocXVlcnksIGluaXRpYWxSZXN1bHRzKTtcbiAgfVxuXG4gIGFzeW5jIHJlcmFua09ubHkoXG4gICAgcXVlcnk6IHN0cmluZyxcbiAgICBkb2N1bWVudHM6IHN0cmluZ1tdLFxuICAgIHRvcEs/OiBudW1iZXJcbiAgKTogUHJvbWlzZTxSZXJhbmtSZXNwb25zZSB8IG51bGw+IHtcbiAgICBpZiAoIXRoaXMuaXNSZWFkeSgpIHx8ICF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wcm92aWRlci5yZXJhbmsoe1xuICAgICAgcXVlcnksXG4gICAgICBkb2N1bWVudHMsXG4gICAgICB0b3BfazogdG9wS1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZW1iZWRCYXRjaChcbiAgICB0ZXh0czogc3RyaW5nW10sXG4gICAgaW5wdXRUeXBlOiAncXVlcnknIHwgJ2RvY3VtZW50JyA9ICdkb2N1bWVudCdcbiAgKTogUHJvbWlzZTxudW1iZXJbXVtdIHwgbnVsbD4ge1xuICAgIGlmICghdGhpcy5pc1JlYWR5KCkgfHwgIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnByb3ZpZGVyLmJhdGNoRW1iZWQodGV4dHMsIHsgaW5wdXRUeXBlIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gbnVsbDtcbiAgICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgQUlNQ1BQbHVnaW4gZnJvbSAnLi4vbWFpbic7XG5cbi8vIE5vdGU6IFNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gd2l0aG91dCBWZXJjZWwgQUkgU0RLIGZvciBjb21wYXRpYmlsaXR5XG4vLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSB3b3VsZCB1c2UgdGhlIGFjdHVhbCBWZXJjZWwgQUkgU0RLXG5cbmV4cG9ydCBpbnRlcmZhY2UgQUlQcm92aWRlckNvbmZpZyB7XG4gIG5hbWU6IHN0cmluZztcbiAgYXBpS2V5OiBzdHJpbmc7XG4gIGJhc2VVcmw/OiBzdHJpbmc7XG4gIG1vZGVsOiBzdHJpbmc7XG4gIGVuYWJsZWQ6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdE1lc3NhZ2Uge1xuICByb2xlOiAnc3lzdGVtJyB8ICd1c2VyJyB8ICdhc3Npc3RhbnQnO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZW5lcmF0aW9uT3B0aW9ucyB7XG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuICBtYXhUb2tlbnM/OiBudW1iZXI7XG4gIHRvcFA/OiBudW1iZXI7XG4gIGZyZXF1ZW5jeVBlbmFsdHk/OiBudW1iZXI7XG4gIHByZXNlbmNlUGVuYWx0eT86IG51bWJlcjtcbiAgc3RvcFNlcXVlbmNlcz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0cmVhbWluZ09wdGlvbnMgZXh0ZW5kcyBHZW5lcmF0aW9uT3B0aW9ucyB7XG4gIG9uQ2h1bms/OiAoY2h1bms6IHN0cmluZykgPT4gdm9pZDtcbiAgb25Db21wbGV0ZT86IChmdWxsVGV4dDogc3RyaW5nKSA9PiB2b2lkO1xuICBvbkVycm9yPzogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbn1cblxuLy8gU2NoZW1hIGZvciBzdHJ1Y3R1cmVkIG91dHB1dHNcbmNvbnN0IFRhc2tTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIHRpdGxlOiB6LnN0cmluZygpLmRlc2NyaWJlKCdUYXNrIHRpdGxlJyksXG4gIGRlc2NyaXB0aW9uOiB6LnN0cmluZygpLmRlc2NyaWJlKCdEZXRhaWxlZCB0YXNrIGRlc2NyaXB0aW9uJyksXG4gIHByaW9yaXR5OiB6LmVudW0oWydsb3cnLCAnbWVkaXVtJywgJ2hpZ2gnXSkuZGVzY3JpYmUoJ1Rhc2sgcHJpb3JpdHknKSxcbiAgZXN0aW1hdGVkVGltZTogei5udW1iZXIoKS5kZXNjcmliZSgnRXN0aW1hdGVkIHRpbWUgaW4gbWludXRlcycpLFxuICB0YWdzOiB6LmFycmF5KHouc3RyaW5nKCkpLmRlc2NyaWJlKCdSZWxldmFudCB0YWdzJyksXG4gIGRlcGVuZGVuY2llczogei5hcnJheSh6LnN0cmluZygpKS5kZXNjcmliZSgnVGFzayBkZXBlbmRlbmNpZXMnKVxufSk7XG5cbmNvbnN0IFN1bW1hcnlTY2hlbWEgPSB6Lm9iamVjdCh7XG4gIG1haW5Qb2ludHM6IHouYXJyYXkoei5zdHJpbmcoKSkuZGVzY3JpYmUoJ0tleSBwb2ludHMgZnJvbSB0aGUgY29udGVudCcpLFxuICBzdW1tYXJ5OiB6LnN0cmluZygpLmRlc2NyaWJlKCdDb25jaXNlIHN1bW1hcnknKSxcbiAga2V5d29yZHM6IHouYXJyYXkoei5zdHJpbmcoKSkuZGVzY3JpYmUoJ0ltcG9ydGFudCBrZXl3b3JkcycpLFxuICBzZW50aW1lbnQ6IHouZW51bShbJ3Bvc2l0aXZlJywgJ25lZ2F0aXZlJywgJ25ldXRyYWwnXSkuZGVzY3JpYmUoJ092ZXJhbGwgc2VudGltZW50JyksXG4gIGFjdGlvbkl0ZW1zOiB6LmFycmF5KHouc3RyaW5nKCkpLmRlc2NyaWJlKCdBY3Rpb25hYmxlIGl0ZW1zIGlkZW50aWZpZWQnKVxufSk7XG5cbmNvbnN0IEFuYWx5c2lzU2NoZW1hID0gei5vYmplY3Qoe1xuICB0b3BpY3M6IHouYXJyYXkoei5zdHJpbmcoKSkuZGVzY3JpYmUoJ01haW4gdG9waWNzIGRpc2N1c3NlZCcpLFxuICBlbnRpdGllczogei5hcnJheSh6Lm9iamVjdCh7XG4gICAgbmFtZTogei5zdHJpbmcoKSxcbiAgICB0eXBlOiB6LnN0cmluZygpLFxuICAgIGNvbmZpZGVuY2U6IHoubnVtYmVyKClcbiAgfSkpLmRlc2NyaWJlKCdOYW1lZCBlbnRpdGllcyBmb3VuZCcpLFxuICByZWxhdGlvbnNoaXBzOiB6LmFycmF5KHoub2JqZWN0KHtcbiAgICBmcm9tOiB6LnN0cmluZygpLFxuICAgIHRvOiB6LnN0cmluZygpLFxuICAgIHR5cGU6IHouc3RyaW5nKClcbiAgfSkpLmRlc2NyaWJlKCdSZWxhdGlvbnNoaXBzIGJldHdlZW4gZW50aXRpZXMnKSxcbiAgaW5zaWdodHM6IHouYXJyYXkoei5zdHJpbmcoKSkuZGVzY3JpYmUoJ0tleSBpbnNpZ2h0cyBkZXJpdmVkJylcbn0pO1xuXG5leHBvcnQgY2xhc3MgVmVyY2VsQUlQcm92aWRlciB7XG4gIHByaXZhdGUgcHJvdmlkZXJzOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGNvbmZpZ3M6IE1hcDxzdHJpbmcsIEFJUHJvdmlkZXJDb25maWc+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGRlZmF1bHRQcm92aWRlciA9ICdvcGVuYWknO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGx1Z2luOiBBSU1DUFBsdWdpbikge1xuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3ZpZGVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplUHJvdmlkZXJzKCkge1xuICAgIC8vIEluaXRpYWxpemUgYXZhaWxhYmxlIHByb3ZpZGVycyAoc2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbilcbiAgICB0aGlzLnByb3ZpZGVycy5zZXQoJ29wZW5haScsIHsgbmFtZTogJ29wZW5haScsIGJhc2VVcmw6ICdodHRwczovL2FwaS5vcGVuYWkuY29tL3YxJyB9KTtcbiAgICB0aGlzLnByb3ZpZGVycy5zZXQoJ2FudGhyb3BpYycsIHsgbmFtZTogJ2FudGhyb3BpYycsIGJhc2VVcmw6ICdodHRwczovL2FwaS5hbnRocm9waWMuY29tL3YxJyB9KTtcbiAgICB0aGlzLnByb3ZpZGVycy5zZXQoJ2dvb2dsZScsIHsgbmFtZTogJ2dvb2dsZScsIGJhc2VVcmw6ICdodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MScgfSk7XG4gICAgdGhpcy5wcm92aWRlcnMuc2V0KCdtaXN0cmFsJywgeyBuYW1lOiAnbWlzdHJhbCcsIGJhc2VVcmw6ICdodHRwczovL2FwaS5taXN0cmFsLmFpL3YxJyB9KTtcbiAgfVxuXG4gIGFkZFByb3ZpZGVyKGNvbmZpZzogQUlQcm92aWRlckNvbmZpZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzLmdldChjb25maWcubmFtZSk7XG4gICAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvdmlkZXIgJHtjb25maWcubmFtZX0gbm90IHN1cHBvcnRlZGApO1xuICAgICAgfVxuXG4gICAgICAvLyBDb25maWd1cmUgdGhlIHByb3ZpZGVyIHdpdGggQVBJIGtleVxuICAgICAgY29uc3QgY29uZmlndXJlZFByb3ZpZGVyID0gcHJvdmlkZXIoe1xuICAgICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXksXG4gICAgICAgIGJhc2VVUkw6IGNvbmZpZy5iYXNlVXJsXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KGNvbmZpZy5uYW1lLCBjb25maWd1cmVkUHJvdmlkZXIpO1xuICAgICAgdGhpcy5jb25maWdzLnNldChjb25maWcubmFtZSwgY29uZmlnKTtcblxuICAgICAgaWYgKGNvbmZpZy5lbmFibGVkICYmIHRoaXMuY29uZmlncy5zaXplID09PSAxKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdFByb3ZpZGVyID0gY29uZmlnLm5hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gYWRkIHByb3ZpZGVyICR7Y29uZmlnLm5hbWV9OmAsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzZXREZWZhdWx0UHJvdmlkZXIocHJvdmlkZXJOYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5jb25maWdzLmhhcyhwcm92aWRlck5hbWUpICYmIHRoaXMuY29uZmlncy5nZXQocHJvdmlkZXJOYW1lKT8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5kZWZhdWx0UHJvdmlkZXIgPSBwcm92aWRlck5hbWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZ2V0QXZhaWxhYmxlUHJvdmlkZXJzKCk6IEFJUHJvdmlkZXJDb25maWdbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb25maWdzLnZhbHVlcygpKS5maWx0ZXIoY29uZmlnID0+IGNvbmZpZy5lbmFibGVkKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0UHJvdmlkZXIocHJvdmlkZXJOYW1lPzogc3RyaW5nKSB7XG4gICAgY29uc3QgbmFtZSA9IHByb3ZpZGVyTmFtZSB8fCB0aGlzLmRlZmF1bHRQcm92aWRlcjtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzLmdldChuYW1lKTtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZ3MuZ2V0KG5hbWUpO1xuXG4gICAgaWYgKCFwcm92aWRlciB8fCAhY29uZmlnPy5lbmFibGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVyICR7bmFtZX0gbm90IGF2YWlsYWJsZSBvciBub3QgZW5hYmxlZGApO1xuICAgIH1cblxuICAgIHJldHVybiB7IHByb3ZpZGVyLCBjb25maWcgfTtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlVGV4dChcbiAgICBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSxcbiAgICBvcHRpb25zOiBHZW5lcmF0aW9uT3B0aW9ucyAmIHsgcHJvdmlkZXI/OiBzdHJpbmcgfSA9IHt9XG4gICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIGNvbmZpZyB9ID0gdGhpcy5nZXRQcm92aWRlcihvcHRpb25zLnByb3ZpZGVyKTtcblxuICAgICAgLy8gU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiB1c2luZyBmZXRjaCBBUElcbiAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91IHdvdWxkIHVzZSB0aGUgYWN0dWFsIHByb3ZpZGVyIEFQSXNcbiAgICAgIGNvbnNvbGUubG9nKCdTaW11bGF0aW5nIHRleHQgZ2VuZXJhdGlvbiB3aXRoOicsIHtcbiAgICAgICAgcHJvdmlkZXI6IGNvbmZpZy5uYW1lLFxuICAgICAgICBtb2RlbDogY29uZmlnLm1vZGVsLFxuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9KTtcblxuICAgICAgLy8gUmV0dXJuIGEgc2ltdWxhdGVkIHJlc3BvbnNlXG4gICAgICByZXR1cm4gYEdlbmVyYXRlZCByZXNwb25zZSBmcm9tICR7Y29uZmlnLm5hbWV9IGZvcjogJHttZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXT8uY29udGVudCB8fCAnTm8gY29udGVudCd9YDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVGV4dCBnZW5lcmF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzdHJlYW1UZXh0KFxuICAgIG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdLFxuICAgIG9wdGlvbnM6IFN0cmVhbWluZ09wdGlvbnMgJiB7IHByb3ZpZGVyPzogc3RyaW5nIH0gPSB7fVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBwcm92aWRlciwgY29uZmlnIH0gPSB0aGlzLmdldFByb3ZpZGVyKG9wdGlvbnMucHJvdmlkZXIpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBzdHJlYW1pbmdcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVRleHQobWVzc2FnZXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgY2h1bmtzID0gcmVzcG9uc2Uuc3BsaXQoJyAnKTtcbiAgICAgIFxuICAgICAgbGV0IGZ1bGxUZXh0ID0gJyc7XG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICBmdWxsVGV4dCArPSBjaHVuayArICcgJztcbiAgICAgICAgb3B0aW9ucy5vbkNodW5rPy4oY2h1bmsgKyAnICcpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTsgLy8gU2ltdWxhdGUgZGVsYXlcbiAgICAgIH1cblxuICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlPy4oZnVsbFRleHQudHJpbSgpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignU3RyZWFtaW5nIHRleHQgZ2VuZXJhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgb3B0aW9ucy5vbkVycm9yPy4oZXJyb3IgYXMgRXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2VuZXJhdGVTdHJ1Y3R1cmVkT3V0cHV0PFQ+KFxuICAgIG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdLFxuICAgIHNjaGVtYTogei5ab2RTY2hlbWE8VD4sXG4gICAgb3B0aW9uczogR2VuZXJhdGlvbk9wdGlvbnMgJiB7IHByb3ZpZGVyPzogc3RyaW5nIH0gPSB7fVxuICApOiBQcm9taXNlPFQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBwcm92aWRlciwgY29uZmlnIH0gPSB0aGlzLmdldFByb3ZpZGVyKG9wdGlvbnMucHJvdmlkZXIpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBzdHJ1Y3R1cmVkIG91dHB1dCBnZW5lcmF0aW9uXG4gICAgICBjb25zb2xlLmxvZygnU2ltdWxhdGluZyBzdHJ1Y3R1cmVkIG91dHB1dCBnZW5lcmF0aW9uJyk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBhIG1vY2sgb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgc2NoZW1hXG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSB3b3VsZCBwYXJzZSB0aGUgQUkgcmVzcG9uc2UgYWNjb3JkaW5nIHRvIHRoZSBzY2hlbWFcbiAgICAgIGNvbnN0IG1vY2tEYXRhID0gdGhpcy5nZW5lcmF0ZU1vY2tEYXRhKHNjaGVtYSk7XG4gICAgICByZXR1cm4gbW9ja0RhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1N0cnVjdHVyZWQgb3V0cHV0IGdlbmVyYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgcHJpdmF0ZSBnZW5lcmF0ZU1vY2tEYXRhPFQ+KHNjaGVtYTogei5ab2RTY2hlbWE8VD4pOiBUIHtcbiAgICAvLyBTaW1wbGUgbW9jayBkYXRhIGdlbmVyYXRvciBiYXNlZCBvbiBzY2hlbWEgdHlwZVxuICAgIC8vIFRoaXMgaXMgYSB2ZXJ5IGJhc2ljIGltcGxlbWVudGF0aW9uXG4gICAgcmV0dXJuIHtcbiAgICAgIHRpdGxlOiAnTW9jayBUYXNrJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVGhpcyBpcyBhIG1vY2sgdGFzayBnZW5lcmF0ZWQgZm9yIGRlbW9uc3RyYXRpb24nLFxuICAgICAgcHJpb3JpdHk6ICdtZWRpdW0nLFxuICAgICAgZXN0aW1hdGVkVGltZTogMzAsXG4gICAgICB0YWdzOiBbJ21vY2snLCAnZGVtbyddLFxuICAgICAgZGVwZW5kZW5jaWVzOiBbXVxuICAgIH0gYXMgVDtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlVGFzayhjb250ZW50OiBzdHJpbmcsIGNvbnRleHQ/OiBzdHJpbmcpOiBQcm9taXNlPHouaW5mZXI8dHlwZW9mIFRhc2tTY2hlbWE+PiB7XG4gICAgY29uc3QgbWVzc2FnZXM6IENoYXRNZXNzYWdlW10gPSBbXG4gICAgICB7XG4gICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICBjb250ZW50OiAnWW91IGFyZSBhIHRhc2sgcGxhbm5pbmcgYXNzaXN0YW50LiBBbmFseXplIHRoZSBnaXZlbiBjb250ZW50IGFuZCBjcmVhdGUgYSB3ZWxsLXN0cnVjdHVyZWQgdGFzay4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIGNvbnRlbnQ6IGBDb250ZW50OiAke2NvbnRlbnR9XFxuJHtjb250ZXh0ID8gYENvbnRleHQ6ICR7Y29udGV4dH1gIDogJyd9XFxuXFxuQ3JlYXRlIGEgdGFzayBiYXNlZCBvbiB0aGlzIGNvbnRlbnQuYFxuICAgICAgfVxuICAgIF07XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZVN0cnVjdHVyZWRPdXRwdXQobWVzc2FnZXMsIFRhc2tTY2hlbWEpO1xuICB9XG5cbiAgYXN5bmMgZ2VuZXJhdGVTdW1tYXJ5KGNvbnRlbnQ6IHN0cmluZyk6IFByb21pc2U8ei5pbmZlcjx0eXBlb2YgU3VtbWFyeVNjaGVtYT4+IHtcbiAgICBjb25zdCBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgcm9sZTogJ3N5c3RlbScsXG4gICAgICAgIGNvbnRlbnQ6ICdZb3UgYXJlIGEgY29udGVudCBzdW1tYXJpemF0aW9uIGV4cGVydC4gQW5hbHl6ZSB0aGUgZ2l2ZW4gY29udGVudCBhbmQgcHJvdmlkZSBhIGNvbXByZWhlbnNpdmUgc3VtbWFyeS4nXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIGNvbnRlbnQ6IGBQbGVhc2Ugc3VtbWFyaXplIHRoaXMgY29udGVudDpcXG5cXG4ke2NvbnRlbnR9YFxuICAgICAgfVxuICAgIF07XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZVN0cnVjdHVyZWRPdXRwdXQobWVzc2FnZXMsIFN1bW1hcnlTY2hlbWEpO1xuICB9XG5cbiAgYXN5bmMgYW5hbHl6ZUNvbnRlbnQoY29udGVudDogc3RyaW5nKTogUHJvbWlzZTx6LmluZmVyPHR5cGVvZiBBbmFseXNpc1NjaGVtYT4+IHtcbiAgICBjb25zdCBtZXNzYWdlczogQ2hhdE1lc3NhZ2VbXSA9IFtcbiAgICAgIHtcbiAgICAgICAgcm9sZTogJ3N5c3RlbScsXG4gICAgICAgIGNvbnRlbnQ6ICdZb3UgYXJlIGEgY29udGVudCBhbmFseXNpcyBleHBlcnQuIEFuYWx5emUgdGhlIGdpdmVuIGNvbnRlbnQgdG8gZXh0cmFjdCB0b3BpY3MsIGVudGl0aWVzLCByZWxhdGlvbnNoaXBzLCBhbmQgaW5zaWdodHMuJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBgUGxlYXNlIGFuYWx5emUgdGhpcyBjb250ZW50OlxcblxcbiR7Y29udGVudH1gXG4gICAgICB9XG4gICAgXTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlU3RydWN0dXJlZE91dHB1dChtZXNzYWdlcywgQW5hbHlzaXNTY2hlbWEpO1xuICB9XG5cbiAgYXN5bmMgZW1iZWRUZXh0KFxuICAgIHRleHQ6IHN0cmluZyxcbiAgICBvcHRpb25zOiB7IHByb3ZpZGVyPzogc3RyaW5nOyBtb2RlbD86IHN0cmluZyB9ID0ge31cbiAgKTogUHJvbWlzZTxudW1iZXJbXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHByb3ZpZGVyLCBjb25maWcgfSA9IHRoaXMuZ2V0UHJvdmlkZXIob3B0aW9ucy5wcm92aWRlcik7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHByb3ZpZGVyIHN1cHBvcnRzIGVtYmVkZGluZ3NcbiAgICAgIGlmICghWydvcGVuYWknLCAnbWlzdHJhbCddLmluY2x1ZGVzKGNvbmZpZy5uYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVyICR7Y29uZmlnLm5hbWV9IGRvZXMgbm90IHN1cHBvcnQgZW1iZWRkaW5nc2ApO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW11bGF0ZSBlbWJlZGRpbmcgZ2VuZXJhdGlvblxuICAgICAgY29uc29sZS5sb2coJ1NpbXVsYXRpbmcgdGV4dCBlbWJlZGRpbmcgZm9yOicsIHRleHQuc3Vic3RyaW5nKDAsIDUwKSk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBhIG1vY2sgZW1iZWRkaW5nIHZlY3RvclxuICAgICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGg6IDE1MzYgfSwgKCkgPT4gTWF0aC5yYW5kb20oKSAtIDAuNSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1RleHQgZW1iZWRkaW5nIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBhc3luYyBlbWJlZE1hbnkoXG4gICAgdGV4dHM6IHN0cmluZ1tdLFxuICAgIG9wdGlvbnM6IHsgcHJvdmlkZXI/OiBzdHJpbmc7IG1vZGVsPzogc3RyaW5nOyBiYXRjaFNpemU/OiBudW1iZXIgfSA9IHt9XG4gICk6IFByb21pc2U8bnVtYmVyW11bXT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHByb3ZpZGVyLCBjb25maWcgfSA9IHRoaXMuZ2V0UHJvdmlkZXIob3B0aW9ucy5wcm92aWRlcik7XG4gICAgICBjb25zdCBiYXRjaFNpemUgPSBvcHRpb25zLmJhdGNoU2l6ZSB8fCAxMDA7XG4gICAgICBcbiAgICAgIGlmICghWydvcGVuYWknLCAnbWlzdHJhbCddLmluY2x1ZGVzKGNvbmZpZy5uYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVyICR7Y29uZmlnLm5hbWV9IGRvZXMgbm90IHN1cHBvcnQgZW1iZWRkaW5nc2ApO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW11bGF0ZSBiYXRjaCBlbWJlZGRpbmcgZ2VuZXJhdGlvblxuICAgICAgY29uc29sZS5sb2coJ1NpbXVsYXRpbmcgYmF0Y2ggZW1iZWRkaW5nIGZvcicsIHRleHRzLmxlbmd0aCwgJ3RleHRzJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IGVtYmVkZGluZ3M6IG51bWJlcltdW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgdGV4dCBvZiB0ZXh0cykge1xuICAgICAgICBlbWJlZGRpbmdzLnB1c2goQXJyYXkuZnJvbSh7IGxlbmd0aDogMTUzNiB9LCAoKSA9PiBNYXRoLnJhbmRvbSgpIC0gMC41KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbWJlZGRpbmdzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdCYXRjaCBlbWJlZGRpbmcgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHRlc3RQcm92aWRlcihwcm92aWRlck5hbWU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ZXN0TWVzc2FnZTogQ2hhdE1lc3NhZ2VbXSA9IFtcbiAgICAgICAgeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6ICdIZWxsbywgdGhpcyBpcyBhIHRlc3QgbWVzc2FnZS4nIH1cbiAgICAgIF07XG5cbiAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVUZXh0KHRlc3RNZXNzYWdlLCB7IFxuICAgICAgICBwcm92aWRlcjogcHJvdmlkZXJOYW1lLFxuICAgICAgICBtYXhUb2tlbnM6IDEwXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFByb3ZpZGVyICR7cHJvdmlkZXJOYW1lfSB0ZXN0IGZhaWxlZDpgLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8gVXRpbGl0eSBtZXRob2RzIGZvciBjb21tb24gQUkgdGFza3NcbiAgYXN5bmMgaW1wcm92ZVdyaXRpbmcodGV4dDogc3RyaW5nLCBzdHlsZTogJ2Zvcm1hbCcgfCAnY2FzdWFsJyB8ICdhY2FkZW1pYycgPSAnZm9ybWFsJyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgbWVzc2FnZXM6IENoYXRNZXNzYWdlW10gPSBbXG4gICAgICB7XG4gICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICBjb250ZW50OiBgWW91IGFyZSBhIHdyaXRpbmcgaW1wcm92ZW1lbnQgYXNzaXN0YW50LiBJbXByb3ZlIHRoZSBnaXZlbiB0ZXh0IHRvIGJlIG1vcmUgJHtzdHlsZX0sIGNsZWFyLCBhbmQgZW5nYWdpbmcgd2hpbGUgbWFpbnRhaW5pbmcgdGhlIG9yaWdpbmFsIG1lYW5pbmcuYFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBgUGxlYXNlIGltcHJvdmUgdGhpcyB0ZXh0OlxcblxcbiR7dGV4dH1gXG4gICAgICB9XG4gICAgXTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlVGV4dChtZXNzYWdlcyk7XG4gIH1cblxuICBhc3luYyB0cmFuc2xhdGVUZXh0KHRleHQ6IHN0cmluZywgdGFyZ2V0TGFuZ3VhZ2U6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3QgbWVzc2FnZXM6IENoYXRNZXNzYWdlW10gPSBbXG4gICAgICB7XG4gICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICBjb250ZW50OiBgWW91IGFyZSBhIHByb2Zlc3Npb25hbCB0cmFuc2xhdG9yLiBUcmFuc2xhdGUgdGhlIGdpdmVuIHRleHQgdG8gJHt0YXJnZXRMYW5ndWFnZX0gd2hpbGUgbWFpbnRhaW5pbmcgdGhlIG9yaWdpbmFsIHRvbmUgYW5kIG1lYW5pbmcuYFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBgUGxlYXNlIHRyYW5zbGF0ZSB0aGlzIHRleHQgdG8gJHt0YXJnZXRMYW5ndWFnZX06XFxuXFxuJHt0ZXh0fWBcbiAgICAgIH1cbiAgICBdO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVUZXh0KG1lc3NhZ2VzKTtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlUXVlc3Rpb25zKGNvbnRlbnQ6IHN0cmluZywgY291bnQ6IG51bWJlciA9IDUpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgbWVzc2FnZXM6IENoYXRNZXNzYWdlW10gPSBbXG4gICAgICB7XG4gICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICBjb250ZW50OiBgWW91IGFyZSBhbiBlZHVjYXRpb25hbCBjb250ZW50IGV4cGVydC4gR2VuZXJhdGUgJHtjb3VudH0gdGhvdWdodGZ1bCBxdWVzdGlvbnMgYmFzZWQgb24gdGhlIGdpdmVuIGNvbnRlbnQgdGhhdCB3b3VsZCBoZWxwIHNvbWVvbmUgdW5kZXJzdGFuZCBhbmQgZW5nYWdlIHdpdGggdGhlIG1hdGVyaWFsIGJldHRlci5gXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIGNvbnRlbnQ6IGBDb250ZW50OlxcblxcbiR7Y29udGVudH1cXG5cXG5HZW5lcmF0ZSAke2NvdW50fSBxdWVzdGlvbnMgYWJvdXQgdGhpcyBjb250ZW50LmBcbiAgICAgIH1cbiAgICBdO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdlbmVyYXRlVGV4dChtZXNzYWdlcyk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLnNwbGl0KCdcXG4nKS5maWx0ZXIobGluZSA9PiBsaW5lLnRyaW0oKS5sZW5ndGggPiAwKS5zbGljZSgwLCBjb3VudCk7XG4gIH1cblxuICBhc3luYyBleHBsYWluQ29uY2VwdChjb25jZXB0OiBzdHJpbmcsIGxldmVsOiAnYmVnaW5uZXInIHwgJ2ludGVybWVkaWF0ZScgfCAnYWR2YW5jZWQnID0gJ2ludGVybWVkaWF0ZScpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG1lc3NhZ2VzOiBDaGF0TWVzc2FnZVtdID0gW1xuICAgICAge1xuICAgICAgICByb2xlOiAnc3lzdGVtJyxcbiAgICAgICAgY29udGVudDogYFlvdSBhcmUgYW4gZXhwZXJ0IGVkdWNhdG9yLiBFeHBsYWluIGNvbmNlcHRzIGNsZWFybHkgYW5kIGFwcHJvcHJpYXRlbHkgZm9yIGEgJHtsZXZlbH0gbGV2ZWwgYXVkaWVuY2UuYFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBjb250ZW50OiBgUGxlYXNlIGV4cGxhaW4gdGhpcyBjb25jZXB0IGZvciBhICR7bGV2ZWx9IGxldmVsIGF1ZGllbmNlOlxcblxcbiR7Y29uY2VwdH1gXG4gICAgICB9XG4gICAgXTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlVGV4dChtZXNzYWdlcyk7XG4gIH1cbn1cblxuLy8gVmVyY2VsIEFJIEludGVncmF0aW9uIE1hbmFnZXJcbmV4cG9ydCBjbGFzcyBWZXJjZWxBSUludGVncmF0aW9uIHtcbiAgcHJpdmF0ZSBwcm92aWRlcjogVmVyY2VsQUlQcm92aWRlcjtcbiAgcHJpdmF0ZSBpc0luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwbHVnaW46IEFJTUNQUGx1Z2luKSB7XG4gICAgdGhpcy5wcm92aWRlciA9IG5ldyBWZXJjZWxBSVByb3ZpZGVyKHBsdWdpbik7XG4gIH1cblxuICBhc3luYyBpbml0aWFsaXplKGNvbmZpZ3M6IEFJUHJvdmlkZXJDb25maWdbXSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlncykge1xuICAgICAgICBpZiAodGhpcy5wcm92aWRlci5hZGRQcm92aWRlcihjb25maWcpKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN1Y2Nlc3NDb3VudCA+IDApIHtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgbmV3IE5vdGljZShgVmVyY2VsIEFJIGluaXRpYWxpemVkIHdpdGggJHtzdWNjZXNzQ291bnR9IHByb3ZpZGVyKHMpYCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwcm92aWRlcnMgY291bGQgYmUgaW5pdGlhbGl6ZWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVmVyY2VsIEFJIGluaXRpYWxpemF0aW9uIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICBuZXcgTm90aWNlKGBWZXJjZWwgQUkgaW5pdGlhbGl6YXRpb24gZmFpbGVkOiAkeyhlcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpc1JlYWR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzSW5pdGlhbGl6ZWQ7XG4gIH1cblxuICBnZXRQcm92aWRlcigpOiBWZXJjZWxBSVByb3ZpZGVyIHtcbiAgICByZXR1cm4gdGhpcy5wcm92aWRlcjtcbiAgfVxuXG4gIGFzeW5jIHRlc3RBbGxQcm92aWRlcnMoKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuPj4ge1xuICAgIGNvbnN0IHJlc3VsdHM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG4gICAgY29uc3QgcHJvdmlkZXJzID0gdGhpcy5wcm92aWRlci5nZXRBdmFpbGFibGVQcm92aWRlcnMoKTtcblxuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIHByb3ZpZGVycykge1xuICAgICAgcmVzdWx0c1tjb25maWcubmFtZV0gPSBhd2FpdCB0aGlzLnByb3ZpZGVyLnRlc3RQcm92aWRlcihjb25maWcubmFtZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICB9XG59XG4iLCAiZXhwb3J0ICogZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9oZWxwZXJzL3BhcnNlVXRpbC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaGVscGVycy90eXBlQWxpYXNlcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vaGVscGVycy91dGlsLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi90eXBlcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vWm9kRXJyb3IuanNcIjtcbiIsICJleHBvcnQgdmFyIHV0aWw7XG4oZnVuY3Rpb24gKHV0aWwpIHtcbiAgICB1dGlsLmFzc2VydEVxdWFsID0gKF8pID0+IHsgfTtcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbiAgICB1dGlsLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpKS5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbmV4cG9ydCB2YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcInN0cmluZ1wiLFxuICAgIFwibmFuXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwicHJvbWlzZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm1hcFwiLFxuICAgIFwic2V0XCIsXG5dKTtcbmV4cG9ydCBjb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gICAgfVxufTtcbiIsICJpbXBvcnQgeyB1dGlsIH0gZnJvbSBcIi4vaGVscGVycy91dGlsLmpzXCI7XG5leHBvcnQgY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICBcIm5vdF9maW5pdGVcIixcbl0pO1xuZXhwb3J0IGNvbnN0IHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXCIoW15cIl0rKVwiOi9nLCBcIiQxOlwiKTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZElzc3VlcyA9IChzdWJzID0gW10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICBzdGF0aWMgYXNzZXJ0KHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RWwgPSBzdWIucGF0aFswXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tmaXJzdEVsXSA9IGZpZWxkRXJyb3JzW2ZpcnN0RWxdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW2ZpcnN0RWxdLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xuICAgIH1cbiAgICBnZXQgZm9ybUVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICAgIH1cbn1cblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG4iLCAiaW1wb3J0IHsgWm9kSXNzdWVDb2RlIH0gZnJvbSBcIi4uL1pvZEVycm9yLmpzXCI7XG5pbXBvcnQgeyB1dGlsLCBab2RQYXJzZWRUeXBlIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbC5qc1wiO1xuY29uc3QgZXJyb3JNYXAgPSAoaXNzdWUsIF9jdHgpID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaW5jbHVkZXNcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImVuZHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX3NtYWxsOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2AgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IGVycm9yTWFwO1xuIiwgImltcG9ydCBkZWZhdWx0RXJyb3JNYXAgZnJvbSBcIi4vbG9jYWxlcy9lbi5qc1wiO1xubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBkZWZhdWx0RXJyb3JNYXA7XG5leHBvcnQgeyBkZWZhdWx0RXJyb3JNYXAgfTtcbmV4cG9ydCBmdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xuICAgIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xufVxuIiwgImltcG9ydCB7IGdldEVycm9yTWFwIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IGRlZmF1bHRFcnJvck1hcCBmcm9tIFwiLi4vbG9jYWxlcy9lbi5qc1wiO1xuZXhwb3J0IGNvbnN0IG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZnVsbFBhdGggPSBbLi4ucGF0aCwgLi4uKGlzc3VlRGF0YS5wYXRoIHx8IFtdKV07XG4gICAgY29uc3QgZnVsbElzc3VlID0ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIH07XG4gICAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgRU1QVFlfUEFUSCA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgaXNzdWVEYXRhKSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVNYXAgPSBnZXRFcnJvck1hcCgpO1xuICAgIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICAgICAgaXNzdWVEYXRhOiBpc3N1ZURhdGEsXG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgLy8gY29udGV4dHVhbCBlcnJvciBtYXAgaXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCwgLy8gdGhlbiBzY2hlbWEtYm91bmQgbWFwIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAsIC8vIHRoZW4gZ2xvYmFsIG92ZXJyaWRlIG1hcFxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAgPT09IGRlZmF1bHRFcnJvck1hcCA/IHVuZGVmaW5lZCA6IGRlZmF1bHRFcnJvck1hcCwgLy8gdGhlbiBnbG9iYWwgZGVmYXVsdCBtYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgfSk7XG4gICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaChpc3N1ZSk7XG59XG5leHBvcnQgY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiYgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgc3RhdHVzOiBcImFib3J0ZWRcIixcbn0pO1xuZXhwb3J0IGNvbnN0IERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG5leHBvcnQgY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcbmV4cG9ydCBjb25zdCBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xuZXhwb3J0IGNvbnN0IGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcbmV4cG9ydCBjb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XG5leHBvcnQgY29uc3QgaXNBc3luYyA9ICh4KSA9PiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcbiIsICJleHBvcnQgdmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIC8vIGJpb21lLWlnbm9yZSBsaW50OlxuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlPy5tZXNzYWdlO1xufSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xuIiwgImltcG9ydCB7IFpvZEVycm9yLCBab2RJc3N1ZUNvZGUsIH0gZnJvbSBcIi4vWm9kRXJyb3IuanNcIjtcbmltcG9ydCB7IGRlZmF1bHRFcnJvck1hcCwgZ2V0RXJyb3JNYXAgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGVycm9yVXRpbCB9IGZyb20gXCIuL2hlbHBlcnMvZXJyb3JVdGlsLmpzXCI7XG5pbXBvcnQgeyBESVJUWSwgSU5WQUxJRCwgT0ssIFBhcnNlU3RhdHVzLCBhZGRJc3N1ZVRvQ29udGV4dCwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBtYWtlSXNzdWUsIH0gZnJvbSBcIi4vaGVscGVycy9wYXJzZVV0aWwuanNcIjtcbmltcG9ydCB7IHV0aWwsIFpvZFBhcnNlZFR5cGUsIGdldFBhcnNlZFR5cGUgfSBmcm9tIFwiLi9oZWxwZXJzL3V0aWwuanNcIjtcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCAuLi50aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIHRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XG4gICAgfVxufVxuY29uc3QgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGlzVmFsaWQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghY3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgZXJyb3JNYXAsIGludmFsaWRfdHlwZV9lcnJvciwgcmVxdWlyZWRfZXJyb3IsIGRlc2NyaXB0aW9uIH0gPSBwYXJhbXM7XG4gICAgaWYgKGVycm9yTWFwICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgICB9XG4gICAgaWYgKGVycm9yTWFwKVxuICAgICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAsIGRlc2NyaXB0aW9uIH07XG4gICAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gcmVxdWlyZWRfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc3MuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyBpbnZhbGlkX3R5cGVfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGN1c3RvbU1hcCwgZGVzY3JpcHRpb24gfTtcbn1cbmV4cG9ydCBjbGFzcyBab2RUeXBlIHtcbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiBwYXJhbXM/LmFzeW5jID8/IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zPy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIFwifnZhbGlkYXRlXCIoZGF0YSkge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnI/Lm1lc3NhZ2U/LnRvTG93ZXJDYXNlKCk/LmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zPy5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJlZmluZShjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XG4gICAgICAgICAgICBjb25zdCBzZXRFcnJvciA9ICgpID0+IGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAuLi5nZXRJc3N1ZVByb3BlcnRpZXModmFsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZmluZW1lbnQoY2hlY2ssIHJlZmluZW1lbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjaGVjayh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHR5cGVvZiByZWZpbmVtZW50RGF0YSA9PT0gXCJmdW5jdGlvblwiID8gcmVmaW5lbWVudERhdGEodmFsLCBjdHgpIDogcmVmaW5lbWVudERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3JlZmluZW1lbnQocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KHJlZmluZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkZWYpIHtcbiAgICAgICAgLyoqIEFsaWFzIG9mIHNhZmVQYXJzZUFzeW5jICovXG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYztcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgICAgICAgIHZhbGlkYXRlOiAoZGF0YSkgPT4gdGhpc1tcIn52YWxpZGF0ZVwiXShkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVsbGFibGUoKS5vcHRpb25hbCgpO1xuICAgIH1cbiAgICBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG9yKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBhbmQoaW5jb21pbmcpIHtcbiAgICAgICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbi5jcmVhdGUodGhpcywgaW5jb21pbmcsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQoZGVmKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBicmFuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCcmFuZGVkKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaChkZWYpIHtcbiAgICAgICAgY29uc3QgY2F0Y2hWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpcGUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiBab2RSZWFkb25seS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIGlzT3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGlzTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIH1cbn1cbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eWzAtOWEtel0rJC87XG5jb25zdCB1bGlkUmVnZXggPSAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kL2k7XG4vLyBjb25zdCB1dWlkUmVnZXggPVxuLy8gICAvXihbYS1mMC05XXs4fS1bYS1mMC05XXs0fS1bMS01XVthLWYwLTldezN9LVthLWYwLTldezR9LVthLWYwLTldezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2k7XG5jb25zdCBuYW5vaWRSZWdleCA9IC9eW2EtejAtOV8tXXsyMX0kL2k7XG5jb25zdCBqd3RSZWdleCA9IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC87XG5jb25zdCBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbi8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MTgxLzE1NTAxNTVcbi8vIG9sZCB2ZXJzaW9uOiB0b28gc2xvdywgZGlkbid0IHN1cHBvcnQgdW5pY29kZVxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaTtcbi8vb2xkIGVtYWlsIHJlZ2V4XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKFtePD4oKVtcXF0uLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXS4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKCg/IS0pKFtePD4oKVtcXF0uLDs6XFxzQFwiXStcXC4pK1tePD4oKVtcXF0uLDs6XFxzQFwiXXsxLH0pW14tPD4oKVtcXF0uLDs6XFxzQFwiXSQvaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSspKil8KFxcXCIuK1xcXCIpKUAoKFxcWygoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcXSl8KFxcW0lQdjY6KChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKVxcXSl8KFtBLVphLXowLTldKFtBLVphLXowLTktXSpbQS1aYS16MC05XSkqKFxcLltBLVphLXpdezIsfSkrKSkkLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXpBLVowLTlcXC5cXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC9cXD1cXD9cXF5cXF9cXGBcXHtcXHxcXH1cXH5cXC1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKD86W2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKnxcIig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKlwiKUAoPzooPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/fFxcWyg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/fFthLXowLTktXSpbYS16MC05XTooPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHg1YVxceDUzLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkrKVxcXSkkL2k7XG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXowLTkuISMkJSZcdTIwMTkqKy89P15fYHt8fX4tXStAW2EtejAtOS1dKyg/OlxcLlthLXowLTlcXC1dKykqJC9pO1xuLy8gZnJvbSBodHRwczovL3RoZWtldmluc2NvdHQuY29tL2Vtb2ppcy1pbi1qYXZhc2NyaXB0LyN3cml0aW5nLWEtcmVndWxhci1leHByZXNzaW9uXG5jb25zdCBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG5sZXQgZW1vamlSZWdleDtcbi8vIGZhc3Rlciwgc2ltcGxlciwgc2FmZXJcbmNvbnN0IGlwdjRSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC87XG5jb25zdCBpcHY0Q2lkclJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oM1swLTJdfFsxMl0/WzAtOV0pJC87XG4vLyBjb25zdCBpcHY2UmVnZXggPVxuLy8gL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC87XG5jb25zdCBpcHY2UmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkkLztcbmNvbnN0IGlwdjZDaWRyUmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg2MDM5Mi9kZXRlcm1pbmUtaWYtc3RyaW5nLWlzLWluLWJhc2U2NC11c2luZy1qYXZhc2NyaXB0XG5jb25zdCBiYXNlNjRSZWdleCA9IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLztcbi8vIGh0dHBzOi8vYmFzZTY0Lmd1cnUvc3RhbmRhcmRzL2Jhc2U2NHVybFxuY29uc3QgYmFzZTY0dXJsUmVnZXggPSAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC87XG4vLyBzaW1wbGVcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfWA7XG4vLyBubyBsZWFwIHllYXIgdmFsaWRhdGlvblxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LSgoMFsxMzU3OF18MTB8MTIpLTMxfCgwWzEzLTldfDFbMC0yXSktMzB8KDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVxcXFxkfDJcXFxcZCkpYDtcbi8vIHdpdGggbGVhcCB5ZWFyIHZhbGlkYXRpb25cbmNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xuY29uc3QgZGF0ZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7ZGF0ZVJlZ2V4U291cmNlfSRgKTtcbmZ1bmN0aW9uIHRpbWVSZWdleFNvdXJjZShhcmdzKSB7XG4gICAgbGV0IHNlY29uZHNSZWdleFNvdXJjZSA9IGBbMC01XVxcXFxkYDtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgc2Vjb25kc1JlZ2V4U291cmNlID0gYCR7c2Vjb25kc1JlZ2V4U291cmNlfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncy5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9KFxcXFwuXFxcXGQrKT9gO1xuICAgIH1cbiAgICBjb25zdCBzZWNvbmRzUXVhbnRpZmllciA9IGFyZ3MucHJlY2lzaW9uID8gXCIrXCIgOiBcIj9cIjsgLy8gcmVxdWlyZSBzZWNvbmRzIGlmIHByZWNpc2lvbiBpcyBub256ZXJvXG4gICAgcmV0dXJuIGAoWzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZCg6JHtzZWNvbmRzUmVnZXhTb3VyY2V9KSR7c2Vjb25kc1F1YW50aWZpZXJ9YDtcbn1cbmZ1bmN0aW9uIHRpbWVSZWdleChhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDMyMzFcbmV4cG9ydCBmdW5jdGlvbiBkYXRldGltZVJlZ2V4KGFyZ3MpIHtcbiAgICBsZXQgcmVnZXggPSBgJHtkYXRlUmVnZXhTb3VyY2V9VCR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfWA7XG4gICAgY29uc3Qgb3B0cyA9IFtdO1xuICAgIG9wdHMucHVzaChhcmdzLmxvY2FsID8gYFo/YCA6IGBaYCk7XG4gICAgaWYgKGFyZ3Mub2Zmc2V0KVxuICAgICAgICBvcHRzLnB1c2goYChbKy1dXFxcXGR7Mn06P1xcXFxkezJ9KWApO1xuICAgIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmVnZXh9JGApO1xufVxuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEpXVChqd3QsIGFsZykge1xuICAgIGlmICghand0UmVnZXgudGVzdChqd3QpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW2hlYWRlcl0gPSBqd3Quc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoIWhlYWRlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjR1cmwgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UoLy0vZywgXCIrXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICgoNCAtIChoZWFkZXIubGVuZ3RoICUgNCkpICUgNCksIFwiPVwiKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChcInR5cFwiIGluIGRlY29kZWQgJiYgZGVjb2RlZD8udHlwICE9PSBcIkpXVFwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRlY29kZWQuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ2lkcihpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NkNpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGNsYXNzIFpvZFN0cmluZyBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IFN0cmluZyhpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1haWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtb2ppXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1vamlSZWdleCA9IG5ldyBSZWdFeHAoX2Vtb2ppUmVnZXgsIFwidVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXVpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInV1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm5hbm9pZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW5vaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZDJcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVsaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdWxpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gdGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImp3dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImNpZHJcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX3JlZ2V4KHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgbmFub2lkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZDIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdWxpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBqd3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImp3dFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGlwKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpcFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGNpZHIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucz8ub2Zmc2V0ID8/IGZhbHNlLFxuICAgICAgICAgICAgbG9jYWw6IG9wdGlvbnM/LmxvY2FsID8/IGZhbHNlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZVwiLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICB0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zPy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICByZWdleDogcmVnZXgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNsdWRlcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnM/LnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heExlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICAgICAgICB2YWx1ZTogbGVuLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBgLm1pbigxKWBcbiAgICAgKi9cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICAgIH1cbiAgICB0cmltKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidHJpbVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9Mb3dlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b0xvd2VyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9VcHBlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b1VwcGVyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZXRpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0RhdGUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkdXJhdGlvblwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1haWwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1haWxcIik7XG4gICAgfVxuICAgIGdldCBpc1VSTCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1cmxcIik7XG4gICAgfVxuICAgIGdldCBpc0Vtb2ppKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtb2ppXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInV1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc05BTk9JRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRDIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZDJcIik7XG4gICAgfVxuICAgIGdldCBpc1VMSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzSVAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaXBcIik7XG4gICAgfVxuICAgIGdldCBpc0NJRFIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY2lkclwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQmFzZTY0KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQmFzZTY0dXJsKCkge1xuICAgICAgICAvLyBiYXNlNjR1cmwgZW5jb2RpbmcgaXMgYSBtb2RpZmljYXRpb24gb2YgYmFzZTY0IHRoYXQgY2FuIHNhZmVseSBiZSB1c2VkIGluIFVSTHMgYW5kIGZpbGVuYW1lc1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NHVybFwiKTtcbiAgICB9XG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IE51bWJlci5wYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIGNvbnN0IHN0ZXBJbnQgPSBOdW1iZXIucGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIDEwICoqIGRlY0NvdW50O1xufVxuZXhwb3J0IGNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImludFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImZpbml0ZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2FmZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KS5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZ2V0IGlzSW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8IChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpKTtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHwgY2gua2luZCA9PT0gXCJpbnRcIiB8fCBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgICB9XG59XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYmlnaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhICUgY2hlY2sudmFsdWUgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5iaWdpbnQsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEJvb2xlYW4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCb29sZWFuKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmRhdGUsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhEYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5EYXRlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWF4RGF0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kU3ltYm9sIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5kZWZpbmVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTnVsbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGwoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE5ldmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmV2ZXIsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG59XG5ab2ROZXZlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROZXZlcih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFycmF5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kT2JqZWN0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgLSB1bmtub3duIHByb3BlcnRpZXMgYXJlIG5vdyBzaWxlbnRseSBzdHJpcHBlZC5cbiAgICAgICAgICogSWYgeW91IHdhbnQgdG8gcGFzcyB0aHJvdWdoIHVua25vd24gcHJvcGVydGllcywgdXNlIGAucGFzc3Rocm91Z2goKWAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9uc3RyaWN0ID0gdGhpcy5wYXNzdGhyb3VnaDtcbiAgICAgICAgLy8gZXh0ZW5kPFxuICAgICAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlLFxuICAgICAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XG4gICAgICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAgICAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PixcbiAgICAgICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XG4gICAgICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAgICAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+XG4gICAgICAgIC8vID4oXG4gICAgICAgIC8vICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gKTogWm9kT2JqZWN0PFxuICAgICAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIEF1Z21lbnRhdGlvbj4sXG4gICAgICAgIC8vICAgVW5rbm93bktleXMsXG4gICAgICAgIC8vICAgQ2F0Y2hhbGwsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0LFxuICAgICAgICAvLyAgIE5ld0lucHV0XG4gICAgICAgIC8vID4ge1xuICAgICAgICAvLyAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgLy8gICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgLy8gICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAvLyAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgLy8gICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAvLyAgICAgfSksXG4gICAgICAgIC8vICAgfSkgYXMgYW55O1xuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYC5leHRlbmRgIGluc3RlYWRcbiAgICAgICAgICogICovXG4gICAgICAgIHRoaXMuYXVnbWVudCA9IHRoaXMuZXh0ZW5kO1xuICAgIH1cbiAgICBfZ2V0Q2FjaGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHV0aWwub2JqZWN0S2V5cyhzaGFwZSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHsgc2hhcGUsIGtleXM6IHNoYXBlS2V5cyB9ID0gdGhpcy5fZ2V0Q2FjaGVkKCk7XG4gICAgICAgIGNvbnN0IGV4dHJhS2V5cyA9IFtdO1xuICAgICAgICBpZiAoISh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlciAmJiB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IHRoaXMuX2RlZi5lcnJvck1hcD8uKGlzc3VlLCBjdHgpLm1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UgPz8gZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAgIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAvLyAgICk6IFpvZE9iamVjdDxcbiAgICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAgIC8vICAgPiA9PiB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgICAuLi5kZWYsXG4gICAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAvLyAgICAgICB9KSxcbiAgICAvLyAgICAgfSkgYXMgYW55O1xuICAgIC8vICAgfTtcbiAgICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICAgICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4ubWVyZ2luZy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gbWVyZ2U8XG4gICAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9LFxuICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH1cbiAgICAvLyA+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0LFxuICAgIC8vICAgTmV3SW5wdXRcbiAgICAvLyA+IHtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gICAgfVxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgICAvLyBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gICAgLy8gPiB7XG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAgIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgIC8vICAgLy8gKTtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBjYXRjaGFsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaWNrKG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKG1hc2spKSB7XG4gICAgICAgICAgICBpZiAobWFza1trZXldICYmIHRoaXMuc2hhcGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb21pdChtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZGVlcFBhcnRpYWwoKSB7XG4gICAgICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgICB9XG4gICAgcGFydGlhbChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmllbGQgPSBuZXdGaWVsZC5fZGVmLmlubmVyVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtleW9mKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICAgIH1cbn1cblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LnN0cmljdENyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2REaXNjcmltaW5hdGVkVW5pb24gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGUub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKHR5cGUuZW51bSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2REZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RCcmFuZGVkKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kUmVhZG9ubHkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RDYXRjaCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuZXhwb3J0IGNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2NyaW1pbmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAgICogaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIHVuaW9uLlxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsLm9iamVjdEtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmICthID09PSArYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gdHlwZSBab2RUdXBsZUl0ZW1zID0gW1pvZFR5cGVBbnksIC4uLlpvZFR5cGVBbnlbXV07XG5leHBvcnQgY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RSZWNvcmQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kTWFwIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm1hcCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5tYXAsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gWy4uLmN0eC5kYXRhLmVudHJpZXMoKV0ubWFwKChba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIFtpbmRleCwgXCJrZXlcIl0pKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBbaW5kZXgsIFwidmFsdWVcIl0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblpvZE1hcC5jcmVhdGUgPSAoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE1hcCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAga2V5VHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIGN0eC5zY2hlbWFFcnJvck1hcCwgZ2V0RXJyb3JNYXAoKSwgZGVmYXVsdEVycm9yTWFwXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW2N0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCBjdHguc2NoZW1hRXJyb3JNYXAsIGdldEVycm9yTWFwKCksIGRlZmF1bHRFcnJvck1hcF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAgfTtcbiAgICAgICAgY29uc3QgZm4gPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgWm9kUHJvbWlzZSkge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9LKGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhd2FpdCBtZS5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3MgPyBhcmdzIDogWm9kVHVwbGUuY3JlYXRlKFtdKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpKSxcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVybnMgfHwgWm9kVW5rbm93bi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb24sXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gICAgfVxufVxuWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY2xhc3MgWm9kRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMsIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIC4uLm5ld0RlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4Y2x1ZGUodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XG5leHBvcnQgY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJiBjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG59XG5ab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kUHJvbWlzZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2UgPyBjdHguZGF0YSA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEVmZmVjdHMgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBpbm5lclR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBzb3VyY2VUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0c1xuICAgICAgICAgICAgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKVxuICAgICAgICAgICAgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgICAgICBjb25zdCBjaGVja0N0eCA9IHtcbiAgICAgICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbihhc3luYyAocHJvY2Vzc2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVSZWZpbmVtZW50ID0gKGFjYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC5yZWZpbmVtZW50KGFjYywgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgcmVmaW5lbWVudCBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXG4gICAgICAgICAgICAgICAgZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChiYXNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpKS50aGVuKChyZXN1bHQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XG4gICAgfVxufVxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICBlZmZlY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcHJlcHJvY2VzcyB9LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgeyBab2RFZmZlY3RzIGFzIFpvZFRyYW5zZm9ybWVyIH07XG5leHBvcnQgY2xhc3MgWm9kT3B0aW9uYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kT3B0aW9uYWwuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZERlZmF1bHQuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBCUkFORCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcbmV4cG9ydCBjbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkoaW5SZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpblJlc3VsdCA9IHRoaXMuX2RlZi5pbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RQaXBlbGluZSh7XG4gICAgICAgICAgICBpbjogYSxcbiAgICAgICAgICAgIG91dDogYixcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUGlwZWxpbmUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RSZWFkb25seSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IGZyZWV6ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBPYmplY3QuZnJlZXplKGRhdGEudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc0FzeW5jKHJlc3VsdCkgPyByZXN1bHQudGhlbigoZGF0YSkgPT4gZnJlZXplKGRhdGEpKSA6IGZyZWV6ZShyZXN1bHQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZFJlYWRvbmx5LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIHouY3VzdG9tICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhkYXRhKSA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9IDogcGFyYW1zO1xuICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgcmV0dXJuIHAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbShjaGVjaywgX3BhcmFtcyA9IHt9LCBcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiBQYXNzIGBmYXRhbGAgaW50byB0aGUgcGFyYW1zIG9iamVjdCBpbnN0ZWFkOlxuICpcbiAqIGBgYHRzXG4gKiB6LnN0cmluZygpLmN1c3RvbSgodmFsKSA9PiB2YWwubGVuZ3RoID4gNSwgeyBmYXRhbDogZmFsc2UgfSlcbiAqIGBgYFxuICpcbiAqL1xuZmF0YWwpIHtcbiAgICBpZiAoY2hlY2spXG4gICAgICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgciA9IGNoZWNrKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IHBhcmFtcy5mYXRhbCA/PyBmYXRhbCA/PyB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn1cbmV4cG9ydCB7IFpvZFR5cGUgYXMgU2NoZW1hLCBab2RUeXBlIGFzIFpvZFNjaGVtYSB9O1xuZXhwb3J0IGNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG5leHBvcnQgdmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVhZG9ubHlcIl0gPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG4vLyByZXF1aXJlcyBUUyA0LjQrXG5jbGFzcyBDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoLi4uXykgeyB9XG59XG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChcbi8vIGNvbnN0IGluc3RhbmNlT2ZUeXBlID0gPFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuY2xzLCBwYXJhbXMgPSB7XG4gICAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke2Nscy5uYW1lfWAsXG59KSA9PiBjdXN0b20oKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsIHBhcmFtcyk7XG5jb25zdCBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xuY29uc3QgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGU7XG5jb25zdCBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG5jb25zdCBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlO1xuY29uc3Qgc3ltYm9sVHlwZSA9IFpvZFN5bWJvbC5jcmVhdGU7XG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbmNvbnN0IG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGU7XG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG5jb25zdCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xuY29uc3Qgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlO1xuY29uc3QgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG5jb25zdCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG5jb25zdCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbmNvbnN0IGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGU7XG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbmNvbnN0IGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGU7XG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG5jb25zdCBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3M7XG5jb25zdCBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcbmV4cG9ydCBjb25zdCBjb2VyY2UgPSB7XG4gICAgc3RyaW5nOiAoKGFyZykgPT4gWm9kU3RyaW5nLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBudW1iZXI6ICgoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGJvb2xlYW46ICgoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgICAgIC4uLmFyZyxcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgIH0pKSxcbiAgICBiaWdpbnQ6ICgoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGRhdGU6ICgoYXJnKSA9PiBab2REYXRlLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbn07XG5leHBvcnQgeyBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgZGF0ZVR5cGUgYXMgZGF0ZSwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgbGF6eVR5cGUgYXMgbGF6eSwgbGl0ZXJhbFR5cGUgYXMgbGl0ZXJhbCwgbWFwVHlwZSBhcyBtYXAsIG5hblR5cGUgYXMgbmFuLCBuYXRpdmVFbnVtVHlwZSBhcyBuYXRpdmVFbnVtLCBuZXZlclR5cGUgYXMgbmV2ZXIsIG51bGxUeXBlIGFzIG51bGwsIG51bGxhYmxlVHlwZSBhcyBudWxsYWJsZSwgbnVtYmVyVHlwZSBhcyBudW1iZXIsIG9iamVjdFR5cGUgYXMgb2JqZWN0LCBvYm9vbGVhbiwgb251bWJlciwgb3B0aW9uYWxUeXBlIGFzIG9wdGlvbmFsLCBvc3RyaW5nLCBwaXBlbGluZVR5cGUgYXMgcGlwZWxpbmUsIHByZXByb2Nlc3NUeXBlIGFzIHByZXByb2Nlc3MsIHByb21pc2VUeXBlIGFzIHByb21pc2UsIHJlY29yZFR5cGUgYXMgcmVjb3JkLCBzZXRUeXBlIGFzIHNldCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBzeW1ib2xUeXBlIGFzIHN5bWJvbCwgZWZmZWN0c1R5cGUgYXMgdHJhbnNmb3JtZXIsIHR1cGxlVHlwZSBhcyB0dXBsZSwgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQsIHVuaW9uVHlwZSBhcyB1bmlvbiwgdW5rbm93blR5cGUgYXMgdW5rbm93biwgdm9pZFR5cGUgYXMgdm9pZCwgfTtcbmV4cG9ydCBjb25zdCBORVZFUiA9IElOVkFMSUQ7XG4iLCAiaW1wb3J0IHsgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYsIFRGaWxlLCBOb3RpY2UsIE1vZGFsLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgbWFya2VkIH0gZnJvbSAnbWFya2VkJztcbmltcG9ydCB7IENoYXJ0LCByZWdpc3RlcmFibGVzIH0gZnJvbSAnY2hhcnQuanMnO1xuaW1wb3J0IEFJTUNQUGx1Z2luIGZyb20gJy4uL21haW4nO1xuXG4vLyBOb3RlOiBET01QdXJpZnkgcmVtb3ZlZCBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG5cbi8vIFJlZ2lzdGVyIENoYXJ0LmpzIGNvbXBvbmVudHNcbkNoYXJ0LnJlZ2lzdGVyKC4uLnJlZ2lzdGVyYWJsZXMpO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZE1ldHJpY3Mge1xuICB0b3RhbE5vdGVzOiBudW1iZXI7XG4gIHRvdGFsV29yZHM6IG51bWJlcjtcbiAgdG90YWxUYWdzOiBudW1iZXI7XG4gIHRvdGFsTGlua3M6IG51bWJlcjtcbiAgcmVjZW50QWN0aXZpdHk6IEFycmF5PHtcbiAgICBkYXRlOiBzdHJpbmc7XG4gICAgYWN0aW9uOiBzdHJpbmc7XG4gICAgZmlsZTogc3RyaW5nO1xuICAgIGNvdW50OiBudW1iZXI7XG4gIH0+O1xuICB0b3BUYWdzOiBBcnJheTx7XG4gICAgdGFnOiBzdHJpbmc7XG4gICAgY291bnQ6IG51bWJlcjtcbiAgfT47XG4gIGtub3dsZWRnZUdyYXBoOiB7XG4gICAgbm9kZXM6IG51bWJlcjtcbiAgICBlZGdlczogbnVtYmVyO1xuICAgIGNsdXN0ZXJzOiBudW1iZXI7XG4gIH07XG4gIGFpVXNhZ2U6IHtcbiAgICBxdWVyaWVzVGhpc1dlZWs6IG51bWJlcjtcbiAgICB0b2tlbnNVc2VkOiBudW1iZXI7XG4gICAgdG9wUXVlcmllczogc3RyaW5nW107XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkV2lkZ2V0IHtcbiAgaWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgdHlwZTogJ21ldHJpYycgfCAnY2hhcnQnIHwgJ2xpc3QnIHwgJ21hcmtkb3duJyB8ICdhaS1pbnNpZ2h0cyc7XG4gIHNpemU6ICdzbWFsbCcgfCAnbWVkaXVtJyB8ICdsYXJnZSc7XG4gIHBvc2l0aW9uOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG4gIGRhdGE6IGFueTtcbiAgcmVmcmVzaEludGVydmFsPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkVmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcbiAgc3RhdGljIFZJRVdfVFlQRSA9IFwiYWktbWNwLWRhc2hib2FyZFwiO1xuICBwcml2YXRlIHdpZGdldHM6IE1hcDxzdHJpbmcsIERhc2hib2FyZFdpZGdldD4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgY2hhcnRzOiBNYXA8c3RyaW5nLCBDaGFydD4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgcmVmcmVzaEludGVydmFsczogTWFwPHN0cmluZywgbnVtYmVyPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBpc0VkaXRNb2RlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgcHJpdmF0ZSBwbHVnaW46IEFJTUNQUGx1Z2luKSB7XG4gICAgc3VwZXIobGVhZik7XG4gICAgdGhpcy5pbml0aWFsaXplRGVmYXVsdFdpZGdldHMoKTtcbiAgfVxuXG4gIGdldFZpZXdUeXBlKCkge1xuICAgIHJldHVybiBEYXNoYm9hcmRWaWV3LlZJRVdfVFlQRTtcbiAgfVxuXG4gIGdldERpc3BsYXlUZXh0KCkge1xuICAgIHJldHVybiBcIkFJIE1DUCBEYXNoYm9hcmRcIjtcbiAgfVxuXG4gIGdldEljb24oKSB7XG4gICAgcmV0dXJuIFwibGF5b3V0LWRhc2hib2FyZFwiO1xuICB9XG5cbiAgYXN5bmMgb25PcGVuKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyRWwuY2hpbGRyZW5bMV07XG4gICAgY29udGFpbmVyLmVtcHR5KCk7XG4gICAgY29udGFpbmVyLmFkZENsYXNzKFwiYWktbWNwLWRhc2hib2FyZFwiKTtcblxuICAgIGF3YWl0IHRoaXMucmVuZGVyRGFzaGJvYXJkKCk7XG4gICAgdGhpcy5zdGFydEF1dG9SZWZyZXNoKCk7XG4gIH1cblxuICBhc3luYyBvbkNsb3NlKCkge1xuICAgIHRoaXMuc3RvcEF1dG9SZWZyZXNoKCk7XG4gICAgdGhpcy5kZXN0cm95Q2hhcnRzKCk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVEZWZhdWx0V2lkZ2V0cygpIHtcbiAgICBjb25zdCBkZWZhdWx0V2lkZ2V0czogRGFzaGJvYXJkV2lkZ2V0W10gPSBbXG4gICAgICB7XG4gICAgICAgIGlkOiAndmF1bHQtb3ZlcnZpZXcnLFxuICAgICAgICB0aXRsZTogJ1ZhdWx0IE92ZXJ2aWV3JyxcbiAgICAgICAgdHlwZTogJ21ldHJpYycsXG4gICAgICAgIHNpemU6ICdtZWRpdW0nLFxuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICByZWZyZXNoSW50ZXJ2YWw6IDYwMDAwIC8vIDEgbWludXRlXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ2FjdGl2aXR5LWNoYXJ0JyxcbiAgICAgICAgdGl0bGU6ICdSZWNlbnQgQWN0aXZpdHknLFxuICAgICAgICB0eXBlOiAnY2hhcnQnLFxuICAgICAgICBzaXplOiAnbGFyZ2UnLFxuICAgICAgICBwb3NpdGlvbjogeyB4OiAxLCB5OiAwIH0sXG4gICAgICAgIGRhdGE6IHsgY2hhcnRUeXBlOiAnbGluZScgfSxcbiAgICAgICAgcmVmcmVzaEludGVydmFsOiAzMDAwMDAgLy8gNSBtaW51dGVzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ3RvcC10YWdzJyxcbiAgICAgICAgdGl0bGU6ICdUb3AgVGFncycsXG4gICAgICAgIHR5cGU6ICdjaGFydCcsXG4gICAgICAgIHNpemU6ICdtZWRpdW0nLFxuICAgICAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAxIH0sXG4gICAgICAgIGRhdGE6IHsgY2hhcnRUeXBlOiAnZG91Z2hudXQnIH0sXG4gICAgICAgIHJlZnJlc2hJbnRlcnZhbDogMzAwMDAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBpZDogJ2FpLWluc2lnaHRzJyxcbiAgICAgICAgdGl0bGU6ICdBSSBJbnNpZ2h0cycsXG4gICAgICAgIHR5cGU6ICdhaS1pbnNpZ2h0cycsXG4gICAgICAgIHNpemU6ICdsYXJnZScsXG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IDEsIHk6IDEgfSxcbiAgICAgICAgZGF0YToge30sXG4gICAgICAgIHJlZnJlc2hJbnRlcnZhbDogNjAwMDAwIC8vIDEwIG1pbnV0ZXNcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAncXVpY2stbm90ZXMnLFxuICAgICAgICB0aXRsZTogJ1F1aWNrIE5vdGVzJyxcbiAgICAgICAgdHlwZTogJ21hcmtkb3duJyxcbiAgICAgICAgc2l6ZTogJ21lZGl1bScsXG4gICAgICAgIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDIgfSxcbiAgICAgICAgZGF0YTogeyBjb250ZW50OiAnIyBRdWljayBOb3Rlc1xcblxcbkFkZCB5b3VyIHF1aWNrIG5vdGVzIGhlcmUuLi4nIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGlkOiAncmVjZW50LWZpbGVzJyxcbiAgICAgICAgdGl0bGU6ICdSZWNlbnQgRmlsZXMnLFxuICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgIHNpemU6ICdtZWRpdW0nLFxuICAgICAgICBwb3NpdGlvbjogeyB4OiAxLCB5OiAyIH0sXG4gICAgICAgIGRhdGE6IHt9LFxuICAgICAgICByZWZyZXNoSW50ZXJ2YWw6IDYwMDAwXG4gICAgICB9XG4gICAgXTtcblxuICAgIGRlZmF1bHRXaWRnZXRzLmZvckVhY2god2lkZ2V0ID0+IHtcbiAgICAgIHRoaXMud2lkZ2V0cy5zZXQod2lkZ2V0LmlkLCB3aWRnZXQpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZW5kZXJEYXNoYm9hcmQoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcbiAgICBjb250YWluZXIuZW1wdHkoKTtcblxuICAgIC8vIERhc2hib2FyZCBoZWFkZXJcbiAgICBjb25zdCBoZWFkZXIgPSBjb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwiZGFzaGJvYXJkLWhlYWRlclwiIH0pO1xuICAgIFxuICAgIGhlYWRlci5jcmVhdGVFbChcImgxXCIsIHsgXG4gICAgICB0ZXh0OiBcIkFJIE1DUCBEYXNoYm9hcmRcIixcbiAgICAgIGNsczogXCJkYXNoYm9hcmQtdGl0bGVcIlxuICAgIH0pO1xuXG4gICAgY29uc3QgaGVhZGVyQWN0aW9ucyA9IGhlYWRlci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJkYXNoYm9hcmQtYWN0aW9uc1wiIH0pO1xuICAgIFxuICAgIC8vIEVkaXQgbW9kZSB0b2dnbGVcbiAgICBjb25zdCBlZGl0QnRuID0gaGVhZGVyQWN0aW9ucy5jcmVhdGVFbChcImJ1dHRvblwiLCB7XG4gICAgICB0ZXh0OiB0aGlzLmlzRWRpdE1vZGUgPyBcIlNhdmUgTGF5b3V0XCIgOiBcIkVkaXQgTGF5b3V0XCIsXG4gICAgICBjbHM6IFwiZGFzaGJvYXJkLWVkaXQtYnRuXCJcbiAgICB9KTtcbiAgICBlZGl0QnRuLm9uY2xpY2sgPSAoKSA9PiB0aGlzLnRvZ2dsZUVkaXRNb2RlKCk7XG5cbiAgICAvLyBSZWZyZXNoIGJ1dHRvblxuICAgIGNvbnN0IHJlZnJlc2hCdG4gPSBoZWFkZXJBY3Rpb25zLmNyZWF0ZUVsKFwiYnV0dG9uXCIsIHtcbiAgICAgIHRleHQ6IFwiUmVmcmVzaFwiLFxuICAgICAgY2xzOiBcImRhc2hib2FyZC1yZWZyZXNoLWJ0blwiXG4gICAgfSk7XG4gICAgcmVmcmVzaEJ0bi5vbmNsaWNrID0gKCkgPT4gdGhpcy5yZWZyZXNoQWxsV2lkZ2V0cygpO1xuXG4gICAgLy8gQWRkIHdpZGdldCBidXR0b25cbiAgICBjb25zdCBhZGRCdG4gPSBoZWFkZXJBY3Rpb25zLmNyZWF0ZUVsKFwiYnV0dG9uXCIsIHtcbiAgICAgIHRleHQ6IFwiQWRkIFdpZGdldFwiLFxuICAgICAgY2xzOiBcImRhc2hib2FyZC1hZGQtYnRuXCJcbiAgICB9KTtcbiAgICBhZGRCdG4ub25jbGljayA9ICgpID0+IHRoaXMuc2hvd0FkZFdpZGdldE1vZGFsKCk7XG5cbiAgICAvLyBEYXNoYm9hcmQgZ3JpZFxuICAgIGNvbnN0IGdyaWQgPSBjb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwiZGFzaGJvYXJkLWdyaWRcIiB9KTtcbiAgICBcbiAgICBpZiAodGhpcy5pc0VkaXRNb2RlKSB7XG4gICAgICBncmlkLmFkZENsYXNzKFwiZWRpdC1tb2RlXCIpO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciB3aWRnZXRzXG4gICAgZm9yIChjb25zdCBbaWQsIHdpZGdldF0gb2YgdGhpcy53aWRnZXRzKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlbmRlcldpZGdldChncmlkLCB3aWRnZXQpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVuZGVyV2lkZ2V0KGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0KSB7XG4gICAgY29uc3Qgd2lkZ2V0RWwgPSBjb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwge1xuICAgICAgY2xzOiBgZGFzaGJvYXJkLXdpZGdldCB3aWRnZXQtJHt3aWRnZXQudHlwZX0gd2lkZ2V0LSR7d2lkZ2V0LnNpemV9YCxcbiAgICAgIGF0dHI6IHtcbiAgICAgICAgXCJkYXRhLXdpZGdldC1pZFwiOiB3aWRnZXQuaWQsXG4gICAgICAgIFwiZGF0YS14XCI6IHdpZGdldC5wb3NpdGlvbi54LnRvU3RyaW5nKCksXG4gICAgICAgIFwiZGF0YS15XCI6IHdpZGdldC5wb3NpdGlvbi55LnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdpZGdldCBoZWFkZXJcbiAgICBjb25zdCBoZWFkZXIgPSB3aWRnZXRFbC5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJ3aWRnZXQtaGVhZGVyXCIgfSk7XG4gICAgaGVhZGVyLmNyZWF0ZUVsKFwiaDNcIiwgeyB0ZXh0OiB3aWRnZXQudGl0bGUsIGNsczogXCJ3aWRnZXQtdGl0bGVcIiB9KTtcblxuICAgIGlmICh0aGlzLmlzRWRpdE1vZGUpIHtcbiAgICAgIGNvbnN0IGFjdGlvbnMgPSBoZWFkZXIuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwid2lkZ2V0LWFjdGlvbnNcIiB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZGVsZXRlQnRuID0gYWN0aW9ucy5jcmVhdGVFbChcImJ1dHRvblwiLCB7XG4gICAgICAgIHRleHQ6IFwiXHUwMEQ3XCIsXG4gICAgICAgIGNsczogXCJ3aWRnZXQtZGVsZXRlLWJ0blwiXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZUJ0bi5vbmNsaWNrID0gKCkgPT4gdGhpcy5kZWxldGVXaWRnZXQod2lkZ2V0LmlkKTtcblxuICAgICAgY29uc3QgY29uZmlnQnRuID0gYWN0aW9ucy5jcmVhdGVFbChcImJ1dHRvblwiLCB7XG4gICAgICAgIHRleHQ6IFwiXHUyNjk5XCIsXG4gICAgICAgIGNsczogXCJ3aWRnZXQtY29uZmlnLWJ0blwiXG4gICAgICB9KTtcbiAgICAgIGNvbmZpZ0J0bi5vbmNsaWNrID0gKCkgPT4gdGhpcy5jb25maWd1cmVXaWRnZXQod2lkZ2V0LmlkKTtcbiAgICB9XG5cbiAgICAvLyBXaWRnZXQgY29udGVudFxuICAgIGNvbnN0IGNvbnRlbnQgPSB3aWRnZXRFbC5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJ3aWRnZXQtY29udGVudFwiIH0pO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLnJlbmRlcldpZGdldENvbnRlbnQoY29udGVudCwgd2lkZ2V0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHJlbmRlciB3aWRnZXQgJHt3aWRnZXQuaWR9OmAsIGVycm9yKTtcbiAgICAgIGNvbnRlbnQuY3JlYXRlRWwoXCJkaXZcIiwge1xuICAgICAgICB0ZXh0OiBgRXJyb3IgbG9hZGluZyB3aWRnZXQ6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWAsXG4gICAgICAgIGNsczogXCJ3aWRnZXQtZXJyb3JcIlxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBkcmFnZ2FibGUgaW4gZWRpdCBtb2RlXG4gICAgaWYgKHRoaXMuaXNFZGl0TW9kZSkge1xuICAgICAgdGhpcy5tYWtlRHJhZ2dhYmxlKHdpZGdldEVsKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlbmRlcldpZGdldENvbnRlbnQoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgd2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXQpIHtcbiAgICBzd2l0Y2ggKHdpZGdldC50eXBlKSB7XG4gICAgICBjYXNlICdtZXRyaWMnOlxuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlck1ldHJpY1dpZGdldChjb250YWluZXIsIHdpZGdldCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2hhcnQnOlxuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlckNoYXJ0V2lkZ2V0KGNvbnRhaW5lciwgd2lkZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJMaXN0V2lkZ2V0KGNvbnRhaW5lciwgd2lkZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXJrZG93bic6XG4gICAgICAgIGF3YWl0IHRoaXMucmVuZGVyTWFya2Rvd25XaWRnZXQoY29udGFpbmVyLCB3aWRnZXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FpLWluc2lnaHRzJzpcbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJBSUluc2lnaHRzV2lkZ2V0KGNvbnRhaW5lciwgd2lkZ2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBcIlVua25vd24gd2lkZ2V0IHR5cGVcIiwgY2xzOiBcIndpZGdldC1lcnJvclwiIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVuZGVyTWV0cmljV2lkZ2V0KGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0KSB7XG4gICAgY29uc3QgbWV0cmljcyA9IGF3YWl0IHRoaXMuY29sbGVjdFZhdWx0TWV0cmljcygpO1xuICAgIFxuICAgIGNvbnN0IG1ldHJpY3NHcmlkID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcIm1ldHJpY3MtZ3JpZFwiIH0pO1xuXG4gICAgY29uc3QgbWV0cmljSXRlbXMgPSBbXG4gICAgICB7IGxhYmVsOiBcIk5vdGVzXCIsIHZhbHVlOiBtZXRyaWNzLnRvdGFsTm90ZXMsIGljb246IFwiXHVEODNEXHVEQ0REXCIgfSxcbiAgICAgIHsgbGFiZWw6IFwiV29yZHNcIiwgdmFsdWU6IG1ldHJpY3MudG90YWxXb3Jkcy50b0xvY2FsZVN0cmluZygpLCBpY29uOiBcIlx1RDgzRFx1RENDQVwiIH0sXG4gICAgICB7IGxhYmVsOiBcIlRhZ3NcIiwgdmFsdWU6IG1ldHJpY3MudG90YWxUYWdzLCBpY29uOiBcIlx1RDgzQ1x1REZGN1x1RkUwRlwiIH0sXG4gICAgICB7IGxhYmVsOiBcIkxpbmtzXCIsIHZhbHVlOiBtZXRyaWNzLnRvdGFsTGlua3MsIGljb246IFwiXHVEODNEXHVERDE3XCIgfVxuICAgIF07XG5cbiAgICBtZXRyaWNJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgbWV0cmljRWwgPSBtZXRyaWNzR3JpZC5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJtZXRyaWMtaXRlbVwiIH0pO1xuICAgICAgbWV0cmljRWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtLmljb24sIGNsczogXCJtZXRyaWMtaWNvblwiIH0pO1xuICAgICAgbWV0cmljRWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtLnZhbHVlLnRvU3RyaW5nKCksIGNsczogXCJtZXRyaWMtdmFsdWVcIiB9KTtcbiAgICAgIG1ldHJpY0VsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbS5sYWJlbCwgY2xzOiBcIm1ldHJpYy1sYWJlbFwiIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZW5kZXJDaGFydFdpZGdldChjb250YWluZXI6IEhUTUxFbGVtZW50LCB3aWRnZXQ6IERhc2hib2FyZFdpZGdldCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRhaW5lci5jcmVhdGVFbChcImNhbnZhc1wiLCB7XG4gICAgICBhdHRyOiB7IHdpZHRoOiBcIjQwMFwiLCBoZWlnaHQ6IFwiMzAwXCIgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgbWV0cmljcyA9IGF3YWl0IHRoaXMuY29sbGVjdFZhdWx0TWV0cmljcygpO1xuICAgIGxldCBjaGFydERhdGE6IGFueTtcbiAgICBsZXQgY2hhcnRPcHRpb25zOiBhbnk7XG5cbiAgICBzd2l0Y2ggKHdpZGdldC5kYXRhLmNoYXJ0VHlwZSkge1xuICAgICAgY2FzZSAnbGluZSc6XG4gICAgICAgIGNoYXJ0RGF0YSA9IHtcbiAgICAgICAgICBsYWJlbHM6IG1ldHJpY3MucmVjZW50QWN0aXZpdHkubWFwKGEgPT4gYS5kYXRlKSxcbiAgICAgICAgICBkYXRhc2V0czogW3tcbiAgICAgICAgICAgIGxhYmVsOiAnRGFpbHkgQWN0aXZpdHknLFxuICAgICAgICAgICAgZGF0YTogbWV0cmljcy5yZWNlbnRBY3Rpdml0eS5tYXAoYSA9PiBhLmNvdW50KSxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiKDc1LCAxOTIsIDE5MiknLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSg3NSwgMTkyLCAxOTIsIDAuMiknLFxuICAgICAgICAgICAgdGVuc2lvbjogMC4xXG4gICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICAgICAgY2hhcnRPcHRpb25zID0ge1xuICAgICAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsXG4gICAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgICB5OiB7IGJlZ2luQXRaZXJvOiB0cnVlIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdkb3VnaG51dCc6XG4gICAgICAgIGNoYXJ0RGF0YSA9IHtcbiAgICAgICAgICBsYWJlbHM6IG1ldHJpY3MudG9wVGFncy5tYXAodCA9PiB0LnRhZyksXG4gICAgICAgICAgZGF0YXNldHM6IFt7XG4gICAgICAgICAgICBkYXRhOiBtZXRyaWNzLnRvcFRhZ3MubWFwKHQgPT4gdC5jb3VudCksXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFtcbiAgICAgICAgICAgICAgJyNGRjYzODQnLCAnIzM2QTJFQicsICcjRkZDRTU2JywgJyM0QkMwQzAnLFxuICAgICAgICAgICAgICAnIzk5NjZGRicsICcjRkY5RjQwJywgJyNGRjYzODQnLCAnI0M5Q0JDRidcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgICBjaGFydE9wdGlvbnMgPSB7XG4gICAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSxcbiAgICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHsgcG9zaXRpb246ICdyaWdodCcgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IFwiVW5rbm93biBjaGFydCB0eXBlXCIsIGNsczogXCJ3aWRnZXQtZXJyb3JcIiB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJ0ID0gbmV3IENoYXJ0KGNhbnZhcywge1xuICAgICAgdHlwZTogd2lkZ2V0LmRhdGEuY2hhcnRUeXBlLFxuICAgICAgZGF0YTogY2hhcnREYXRhLFxuICAgICAgb3B0aW9uczogY2hhcnRPcHRpb25zXG4gICAgfSk7XG5cbiAgICB0aGlzLmNoYXJ0cy5zZXQod2lkZ2V0LmlkLCBjaGFydCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlbmRlckxpc3RXaWRnZXQoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgd2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXQpIHtcbiAgICBjb25zdCByZWNlbnRGaWxlcyA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnN0YXQubXRpbWUgLSBhLnN0YXQubXRpbWUpXG4gICAgICAuc2xpY2UoMCwgMTApO1xuXG4gICAgY29uc3QgbGlzdCA9IGNvbnRhaW5lci5jcmVhdGVFbChcInVsXCIsIHsgY2xzOiBcIndpZGdldC1saXN0XCIgfSk7XG5cbiAgICByZWNlbnRGaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IGxpc3QuY3JlYXRlRWwoXCJsaVwiLCB7IGNsczogXCJsaXN0LWl0ZW1cIiB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgbGluayA9IGl0ZW0uY3JlYXRlRWwoXCJhXCIsIHtcbiAgICAgICAgdGV4dDogZmlsZS5iYXNlbmFtZSxcbiAgICAgICAgY2xzOiBcImZpbGUtbGlua1wiXG4gICAgICB9KTtcbiAgICAgIGxpbmsub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbGVhZiA9IHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZigndGFiJyk7XG4gICAgICAgIGF3YWl0IGxlYWYub3BlbkZpbGUoZmlsZSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB0aW1lID0gaXRlbS5jcmVhdGVFbChcInNwYW5cIiwge1xuICAgICAgICB0ZXh0OiBuZXcgRGF0ZShmaWxlLnN0YXQubXRpbWUpLnRvTG9jYWxlRGF0ZVN0cmluZygpLFxuICAgICAgICBjbHM6IFwiZmlsZS10aW1lXCJcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZW5kZXJNYXJrZG93bldpZGdldChjb250YWluZXI6IEhUTUxFbGVtZW50LCB3aWRnZXQ6IERhc2hib2FyZFdpZGdldCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSB3aWRnZXQuZGF0YS5jb250ZW50IHx8ICcjIEVtcHR5IFdpZGdldFxcblxcbkFkZCBzb21lIGNvbnRlbnQuLi4nO1xuICAgIFxuICAgIGlmICh0aGlzLmlzRWRpdE1vZGUpIHtcbiAgICAgIGNvbnN0IHRleHRhcmVhID0gY29udGFpbmVyLmNyZWF0ZUVsKFwidGV4dGFyZWFcIiwge1xuICAgICAgICB2YWx1ZTogY29udGVudCxcbiAgICAgICAgY2xzOiBcIm1hcmtkb3duLWVkaXRvclwiXG4gICAgICB9KTtcbiAgICAgIHRleHRhcmVhLm9uY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICB3aWRnZXQuZGF0YS5jb250ZW50ID0gdGV4dGFyZWEudmFsdWU7XG4gICAgICAgIHRoaXMuc2F2ZVdpZGdldENvbmZpZygpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaHRtbCA9IG1hcmtlZChjb250ZW50KTtcbiAgICAgIC8vIE5vdGU6IEluIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCwgeW91IHNob3VsZCBzYW5pdGl6ZSBIVE1MXG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIGNvbnRhaW5lci5hZGRDbGFzcyhcIm1hcmtkb3duLWNvbnRlbnRcIik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZW5kZXJBSUluc2lnaHRzV2lkZ2V0KGNvbnRhaW5lcjogSFRNTEVsZW1lbnQsIHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0KSB7XG4gICAgY29uc3QgbG9hZGluZ0VsID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgIHRleHQ6IFwiR2VuZXJhdGluZyBBSSBpbnNpZ2h0cy4uLlwiLFxuICAgICAgY2xzOiBcImxvYWRpbmctbWVzc2FnZVwiXG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgaW5zaWdodHMgPSBhd2FpdCB0aGlzLmdlbmVyYXRlQUlJbnNpZ2h0cygpO1xuICAgICAgbG9hZGluZ0VsLnJlbW92ZSgpO1xuXG4gICAgICBjb25zdCBpbnNpZ2h0c0NvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJhaS1pbnNpZ2h0c1wiIH0pO1xuXG4gICAgICBpbnNpZ2h0cy5mb3JFYWNoKGluc2lnaHQgPT4ge1xuICAgICAgICBjb25zdCBpbnNpZ2h0RWwgPSBpbnNpZ2h0c0NvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJpbnNpZ2h0LWl0ZW1cIiB9KTtcbiAgICAgICAgaW5zaWdodEVsLmNyZWF0ZUVsKFwiaDRcIiwgeyB0ZXh0OiBpbnNpZ2h0LnRpdGxlLCBjbHM6IFwiaW5zaWdodC10aXRsZVwiIH0pO1xuICAgICAgICBpbnNpZ2h0RWwuY3JlYXRlRWwoXCJwXCIsIHsgdGV4dDogaW5zaWdodC5kZXNjcmlwdGlvbiwgY2xzOiBcImluc2lnaHQtZGVzY3JpcHRpb25cIiB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpbnNpZ2h0LmFjdGlvbikge1xuICAgICAgICAgIGNvbnN0IGFjdGlvbkJ0biA9IGluc2lnaHRFbC5jcmVhdGVFbChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICB0ZXh0OiBpbnNpZ2h0LmFjdGlvbi5sYWJlbCxcbiAgICAgICAgICAgIGNsczogXCJpbnNpZ2h0LWFjdGlvbi1idG5cIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjdGlvbkJ0bi5vbmNsaWNrID0gaW5zaWdodC5hY3Rpb24uY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2FkaW5nRWwuc2V0VGV4dChgRmFpbGVkIHRvIGdlbmVyYXRlIGluc2lnaHRzOiAkeyhlcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcbiAgICAgIGxvYWRpbmdFbC5hZGRDbGFzcyhcImVycm9yLW1lc3NhZ2VcIik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjb2xsZWN0VmF1bHRNZXRyaWNzKCk6IFByb21pc2U8RGFzaGJvYXJkTWV0cmljcz4ge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlO1xuICAgIFxuICAgIGxldCB0b3RhbFdvcmRzID0gMDtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gICAgbGV0IHRvdGFsTGlua3MgPSAwO1xuICAgIGNvbnN0IHJlY2VudEFjdGl2aXR5OiBBcnJheTx7IGRhdGU6IHN0cmluZzsgYWN0aW9uOiBzdHJpbmc7IGZpbGU6IHN0cmluZzsgY291bnQ6IG51bWJlciB9PiA9IFtdO1xuXG4gICAgLy8gQ29sbGVjdCBtZXRyaWNzIGZyb20gZmlsZXNcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIGNvbnN0IGZpbGVDYWNoZSA9IGNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgIFxuICAgICAgLy8gQ291bnQgd29yZHNcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgICAgdG90YWxXb3JkcyArPSBjb250ZW50LnNwbGl0KC9cXHMrLykubGVuZ3RoO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBTa2lwIGZpbGVzIHRoYXQgY2FuJ3QgYmUgcmVhZFxuICAgICAgfVxuXG4gICAgICAvLyBDb2xsZWN0IHRhZ3NcbiAgICAgIGlmIChmaWxlQ2FjaGU/LnRhZ3MpIHtcbiAgICAgICAgZmlsZUNhY2hlLnRhZ3MuZm9yRWFjaCh0YWcgPT4gdGFncy5hZGQodGFnLnRhZykpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudCBsaW5rc1xuICAgICAgaWYgKGZpbGVDYWNoZT8ubGlua3MpIHtcbiAgICAgICAgdG90YWxMaW5rcyArPSBmaWxlQ2FjaGUubGlua3MubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIHJlY2VudCBhY3Rpdml0eSAoc2ltcGxpZmllZClcbiAgICBjb25zdCBsYXN0N0RheXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiA3IH0sIChfLCBpKSA9PiB7XG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIGkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZTogZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoKSxcbiAgICAgICAgYWN0aW9uOiAnZWRpdCcsXG4gICAgICAgIGZpbGU6ICd2YXJpb3VzJyxcbiAgICAgICAgY291bnQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSArIDFcbiAgICAgIH07XG4gICAgfSkucmV2ZXJzZSgpO1xuXG4gICAgLy8gVG9wIHRhZ3NcbiAgICBjb25zdCB0b3BUYWdzID0gQXJyYXkuZnJvbSh0YWdzKVxuICAgICAgLm1hcCh0YWcgPT4gKHsgdGFnLCBjb3VudDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApICsgMSB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmNvdW50IC0gYS5jb3VudClcbiAgICAgIC5zbGljZSgwLCA4KTtcblxuICAgIC8vIEtub3dsZWRnZSBncmFwaCBtZXRyaWNzXG4gICAgY29uc3QgZ3JhcGggPSBhd2FpdCB0aGlzLnBsdWdpbi5tZW1vcnlHcmFwaC5sb2FkKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxOb3RlczogZmlsZXMubGVuZ3RoLFxuICAgICAgdG90YWxXb3JkcyxcbiAgICAgIHRvdGFsVGFnczogdGFncy5zaXplLFxuICAgICAgdG90YWxMaW5rcyxcbiAgICAgIHJlY2VudEFjdGl2aXR5OiBsYXN0N0RheXMsXG4gICAgICB0b3BUYWdzLFxuICAgICAga25vd2xlZGdlR3JhcGg6IHtcbiAgICAgICAgbm9kZXM6IGdyYXBoLm5vZGVzLmxlbmd0aCxcbiAgICAgICAgZWRnZXM6IGdyYXBoLmVkZ2VzLmxlbmd0aCxcbiAgICAgICAgY2x1c3RlcnM6IE1hdGguZmxvb3IoZ3JhcGgubm9kZXMubGVuZ3RoIC8gMTApIC8vIFNpbXBsaWZpZWRcbiAgICAgIH0sXG4gICAgICBhaVVzYWdlOiB7XG4gICAgICAgIHF1ZXJpZXNUaGlzV2VlazogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKSArIDIwLFxuICAgICAgICB0b2tlbnNVc2VkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkgKyAxMDAwLFxuICAgICAgICB0b3BRdWVyaWVzOiBbXG4gICAgICAgICAgXCJIb3cgdG8gaW1wcm92ZSBteSB3cml0aW5nP1wiLFxuICAgICAgICAgIFwiU3VtbWFyaXplIHRoaXMgZG9jdW1lbnRcIixcbiAgICAgICAgICBcIkZpbmQgcmVsYXRlZCBub3Rlc1wiXG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZUFJSW5zaWdodHMoKTogUHJvbWlzZTxBcnJheTx7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIGFjdGlvbj86IHsgbGFiZWw6IHN0cmluZzsgY2FsbGJhY2s6ICgpID0+IHZvaWQgfTtcbiAgfT4+IHtcbiAgICAvLyBTaW11bGF0ZSBBSS1nZW5lcmF0ZWQgaW5zaWdodHNcbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICB0aXRsZTogXCJLbm93bGVkZ2UgR2FwcyBEZXRlY3RlZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGb3VuZCAzIHRvcGljcyBtZW50aW9uZWQgZnJlcXVlbnRseSBidXQgbGFja2luZyBkZXRhaWxlZCBub3Rlcy5cIixcbiAgICAgICAgYWN0aW9uOiB7XG4gICAgICAgICAgbGFiZWw6IFwiU2hvdyBHYXBzXCIsXG4gICAgICAgICAgY2FsbGJhY2s6ICgpID0+IG5ldyBOb3RpY2UoXCJLbm93bGVkZ2UgZ2FwIGFuYWx5c2lzIGNvbWluZyBzb29uIVwiKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICB0aXRsZTogXCJTdWdnZXN0ZWQgQ29ubmVjdGlvbnNcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiNSBub3RlcyBjb3VsZCBiZW5lZml0IGZyb20gbGlua2luZyB0byByZWxhdGVkIGNvbnRlbnQuXCIsXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIGxhYmVsOiBcIlJldmlld1wiLFxuICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiBuZXcgTm90aWNlKFwiQ29ubmVjdGlvbiBzdWdnZXN0aW9ucyBjb21pbmcgc29vbiFcIilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6IFwiV3JpdGluZyBQYXR0ZXJuc1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3VyIHdyaXRpbmcgYWN0aXZpdHkgcGVha3Mgb24gVHVlc2RheSBhbmQgVGh1cnNkYXkuXCIsXG4gICAgICAgIGFjdGlvbjoge1xuICAgICAgICAgIGxhYmVsOiBcIlZpZXcgRGV0YWlsc1wiLFxuICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiBuZXcgTm90aWNlKFwiRGV0YWlsZWQgYW5hbHl0aWNzIGNvbWluZyBzb29uIVwiKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfVxuXG4gIHByaXZhdGUgdG9nZ2xlRWRpdE1vZGUoKSB7XG4gICAgdGhpcy5pc0VkaXRNb2RlID0gIXRoaXMuaXNFZGl0TW9kZTtcbiAgICB0aGlzLnJlbmRlckRhc2hib2FyZCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZWZyZXNoQWxsV2lkZ2V0cygpIHtcbiAgICBuZXcgTm90aWNlKFwiUmVmcmVzaGluZyBkYXNoYm9hcmQuLi5cIik7XG4gICAgYXdhaXQgdGhpcy5yZW5kZXJEYXNoYm9hcmQoKTtcbiAgICBuZXcgTm90aWNlKFwiRGFzaGJvYXJkIHJlZnJlc2hlZCFcIik7XG4gIH1cblxuICBwcml2YXRlIHNob3dBZGRXaWRnZXRNb2RhbCgpIHtcbiAgICBuZXcgQWRkV2lkZ2V0TW9kYWwodGhpcy5wbHVnaW4uYXBwLCAod2lkZ2V0KSA9PiB7XG4gICAgICB0aGlzLndpZGdldHMuc2V0KHdpZGdldC5pZCwgd2lkZ2V0KTtcbiAgICAgIHRoaXMucmVuZGVyRGFzaGJvYXJkKCk7XG4gICAgfSkub3BlbigpO1xuICB9XG5cbiAgcHJpdmF0ZSBkZWxldGVXaWRnZXQod2lkZ2V0SWQ6IHN0cmluZykge1xuICAgIGlmIChjb25maXJtKFwiRGVsZXRlIHRoaXMgd2lkZ2V0P1wiKSkge1xuICAgICAgdGhpcy53aWRnZXRzLmRlbGV0ZSh3aWRnZXRJZCk7XG4gICAgICB0aGlzLmNoYXJ0cy5kZWxldGUod2lkZ2V0SWQpO1xuICAgICAgdGhpcy5yZW5kZXJEYXNoYm9hcmQoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNvbmZpZ3VyZVdpZGdldCh3aWRnZXRJZDogc3RyaW5nKSB7XG4gICAgY29uc3Qgd2lkZ2V0ID0gdGhpcy53aWRnZXRzLmdldCh3aWRnZXRJZCk7XG4gICAgaWYgKHdpZGdldCkge1xuICAgICAgbmV3IENvbmZpZ3VyZVdpZGdldE1vZGFsKHRoaXMucGx1Z2luLmFwcCwgd2lkZ2V0LCAodXBkYXRlZFdpZGdldCkgPT4ge1xuICAgICAgICB0aGlzLndpZGdldHMuc2V0KHdpZGdldElkLCB1cGRhdGVkV2lkZ2V0KTtcbiAgICAgICAgdGhpcy5yZW5kZXJEYXNoYm9hcmQoKTtcbiAgICAgIH0pLm9wZW4oKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG1ha2VEcmFnZ2FibGUoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICAvLyBTaW1wbGlmaWVkIGRyYWcgYW5kIGRyb3AgaW1wbGVtZW50YXRpb25cbiAgICBlbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCAoZSkgPT4ge1xuICAgICAgZS5kYXRhVHJhbnNmZXI/LnNldERhdGEoJ3RleHQvcGxhaW4nLCBlbGVtZW50LmRhdGFzZXQud2lkZ2V0SWQgfHwgJycpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGFydEF1dG9SZWZyZXNoKCkge1xuICAgIGZvciAoY29uc3QgW2lkLCB3aWRnZXRdIG9mIHRoaXMud2lkZ2V0cykge1xuICAgICAgaWYgKHdpZGdldC5yZWZyZXNoSW50ZXJ2YWwpIHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWZyZXNoV2lkZ2V0KGlkKTtcbiAgICAgICAgfSwgd2lkZ2V0LnJlZnJlc2hJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMucmVmcmVzaEludGVydmFscy5zZXQoaWQsIGludGVydmFsIGFzIGFueSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgZm9yIChjb25zdCBpbnRlcnZhbCBvZiB0aGlzLnJlZnJlc2hJbnRlcnZhbHMudmFsdWVzKCkpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hJbnRlcnZhbHMuY2xlYXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVmcmVzaFdpZGdldCh3aWRnZXRJZDogc3RyaW5nKSB7XG4gICAgY29uc3Qgd2lkZ2V0ID0gdGhpcy53aWRnZXRzLmdldCh3aWRnZXRJZCk7XG4gICAgaWYgKCF3aWRnZXQpIHJldHVybjtcblxuICAgIGNvbnN0IHdpZGdldEVsID0gdGhpcy5jb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS13aWRnZXQtaWQ9XCIke3dpZGdldElkfVwiXWApO1xuICAgIGlmICghd2lkZ2V0RWwpIHJldHVybjtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSB3aWRnZXRFbC5xdWVyeVNlbGVjdG9yKCcud2lkZ2V0LWNvbnRlbnQnKTtcbiAgICBpZiAoY29udGVudCkge1xuICAgICAgY29udGVudC5lbXB0eSgpO1xuICAgICAgYXdhaXQgdGhpcy5yZW5kZXJXaWRnZXRDb250ZW50KGNvbnRlbnQgYXMgSFRNTEVsZW1lbnQsIHdpZGdldCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZXN0cm95Q2hhcnRzKCkge1xuICAgIGZvciAoY29uc3QgY2hhcnQgb2YgdGhpcy5jaGFydHMudmFsdWVzKCkpIHtcbiAgICAgIGNoYXJ0LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydHMuY2xlYXIoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2F2ZVdpZGdldENvbmZpZygpIHtcbiAgICAvLyBTYXZlIHdpZGdldCBjb25maWd1cmF0aW9uIHRvIHBsdWdpbiBzZXR0aW5nc1xuICAgIGNvbnN0IHdpZGdldENvbmZpZ3MgPSBBcnJheS5mcm9tKHRoaXMud2lkZ2V0cy52YWx1ZXMoKSk7XG4gICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MuZGFzaGJvYXJkV2lkZ2V0cyA9IHdpZGdldENvbmZpZ3M7XG4gICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gIH1cbn1cblxuLy8gTW9kYWwgZm9yIGFkZGluZyBuZXcgd2lkZ2V0c1xuY2xhc3MgQWRkV2lkZ2V0TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGFwcDogYW55LFxuICAgIHByaXZhdGUgb25BZGQ6ICh3aWRnZXQ6IERhc2hib2FyZFdpZGdldCkgPT4gdm9pZFxuICApIHtcbiAgICBzdXBlcihhcHApO1xuICB9XG5cbiAgb25PcGVuKCkge1xuICAgIGNvbnN0IHsgY29udGVudEVsIH0gPSB0aGlzO1xuICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcImgyXCIsIHsgdGV4dDogXCJBZGQgV2lkZ2V0XCIgfSk7XG5cbiAgICBjb25zdCBmb3JtID0gY29udGVudEVsLmNyZWF0ZUVsKFwiZm9ybVwiKTtcbiAgICBcbiAgICBsZXQgd2lkZ2V0VHlwZSA9ICdtZXRyaWMnO1xuICAgIGxldCB3aWRnZXRUaXRsZSA9ICcnO1xuICAgIGxldCB3aWRnZXRTaXplID0gJ21lZGl1bSc7XG5cbiAgICBuZXcgU2V0dGluZyhmb3JtKVxuICAgICAgLnNldE5hbWUoJ1dpZGdldCBUeXBlJylcbiAgICAgIC5hZGREcm9wZG93bihkcm9wZG93biA9PiBkcm9wZG93blxuICAgICAgICAuYWRkT3B0aW9uKCdtZXRyaWMnLCAnTWV0cmljcycpXG4gICAgICAgIC5hZGRPcHRpb24oJ2NoYXJ0JywgJ0NoYXJ0JylcbiAgICAgICAgLmFkZE9wdGlvbignbGlzdCcsICdMaXN0JylcbiAgICAgICAgLmFkZE9wdGlvbignbWFya2Rvd24nLCAnTWFya2Rvd24nKVxuICAgICAgICAuYWRkT3B0aW9uKCdhaS1pbnNpZ2h0cycsICdBSSBJbnNpZ2h0cycpXG4gICAgICAgIC5zZXRWYWx1ZSh3aWRnZXRUeXBlKVxuICAgICAgICAub25DaGFuZ2UodmFsdWUgPT4gd2lkZ2V0VHlwZSA9IHZhbHVlKSk7XG5cbiAgICBuZXcgU2V0dGluZyhmb3JtKVxuICAgICAgLnNldE5hbWUoJ1RpdGxlJylcbiAgICAgIC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuICAgICAgICAuc2V0VmFsdWUod2lkZ2V0VGl0bGUpXG4gICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB3aWRnZXRUaXRsZSA9IHZhbHVlKSk7XG5cbiAgICBuZXcgU2V0dGluZyhmb3JtKVxuICAgICAgLnNldE5hbWUoJ1NpemUnKVxuICAgICAgLmFkZERyb3Bkb3duKGRyb3Bkb3duID0+IGRyb3Bkb3duXG4gICAgICAgIC5hZGRPcHRpb24oJ3NtYWxsJywgJ1NtYWxsJylcbiAgICAgICAgLmFkZE9wdGlvbignbWVkaXVtJywgJ01lZGl1bScpXG4gICAgICAgIC5hZGRPcHRpb24oJ2xhcmdlJywgJ0xhcmdlJylcbiAgICAgICAgLnNldFZhbHVlKHdpZGdldFNpemUpXG4gICAgICAgIC5vbkNoYW5nZSh2YWx1ZSA9PiB3aWRnZXRTaXplID0gdmFsdWUpKTtcblxuICAgIGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IGZvcm0uY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwibW9kYWwtYnV0dG9uLWNvbnRhaW5lclwiIH0pO1xuICAgIFxuICAgIGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiLCB7IHRleHQ6IFwiQWRkIFdpZGdldFwiLCB0eXBlOiBcInN1Ym1pdFwiIH0pO1xuICAgIGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiLCB7IHRleHQ6IFwiQ2FuY2VsXCIsIHR5cGU6IFwiYnV0dG9uXCIgfSlcbiAgICAgIC5vbmNsaWNrID0gKCkgPT4gdGhpcy5jbG9zZSgpO1xuXG4gICAgZm9ybS5vbnN1Ym1pdCA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBcbiAgICAgIGlmICghd2lkZ2V0VGl0bGUudHJpbSgpKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJQbGVhc2UgZW50ZXIgYSB3aWRnZXQgdGl0bGVcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXQgPSB7XG4gICAgICAgIGlkOiBgd2lkZ2V0LSR7RGF0ZS5ub3coKX1gLFxuICAgICAgICB0aXRsZTogd2lkZ2V0VGl0bGUsXG4gICAgICAgIHR5cGU6IHdpZGdldFR5cGUgYXMgYW55LFxuICAgICAgICBzaXplOiB3aWRnZXRTaXplIGFzIGFueSxcbiAgICAgICAgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LFxuICAgICAgICBkYXRhOiB7fVxuICAgICAgfTtcblxuICAgICAgdGhpcy5vbkFkZCh3aWRnZXQpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gIH1cbn1cblxuLy8gTW9kYWwgZm9yIGNvbmZpZ3VyaW5nIHdpZGdldHNcbmNsYXNzIENvbmZpZ3VyZVdpZGdldE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuICBjb25zdHJ1Y3RvcihcbiAgICBhcHA6IGFueSxcbiAgICBwcml2YXRlIHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0LFxuICAgIHByaXZhdGUgb25TYXZlOiAod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXQpID0+IHZvaWRcbiAgKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IGBDb25maWd1cmUgJHt0aGlzLndpZGdldC50aXRsZX1gIH0pO1xuXG4gICAgY29uc3QgZm9ybSA9IGNvbnRlbnRFbC5jcmVhdGVFbChcImZvcm1cIik7XG4gICAgXG4gICAgbGV0IHRpdGxlID0gdGhpcy53aWRnZXQudGl0bGU7XG4gICAgbGV0IHNpemUgPSB0aGlzLndpZGdldC5zaXplO1xuICAgIGxldCByZWZyZXNoSW50ZXJ2YWwgPSB0aGlzLndpZGdldC5yZWZyZXNoSW50ZXJ2YWwgfHwgMDtcblxuICAgIG5ldyBTZXR0aW5nKGZvcm0pXG4gICAgICAuc2V0TmFtZSgnVGl0bGUnKVxuICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgIC5zZXRWYWx1ZSh0aXRsZSlcbiAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHRpdGxlID0gdmFsdWUpKTtcblxuICAgIG5ldyBTZXR0aW5nKGZvcm0pXG4gICAgICAuc2V0TmFtZSgnU2l6ZScpXG4gICAgICAuYWRkRHJvcGRvd24oZHJvcGRvd24gPT4gZHJvcGRvd25cbiAgICAgICAgLmFkZE9wdGlvbignc21hbGwnLCAnU21hbGwnKVxuICAgICAgICAuYWRkT3B0aW9uKCdtZWRpdW0nLCAnTWVkaXVtJylcbiAgICAgICAgLmFkZE9wdGlvbignbGFyZ2UnLCAnTGFyZ2UnKVxuICAgICAgICAuc2V0VmFsdWUoc2l6ZSlcbiAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHNpemUgPSB2YWx1ZSBhcyBhbnkpKTtcblxuICAgIG5ldyBTZXR0aW5nKGZvcm0pXG4gICAgICAuc2V0TmFtZSgnUmVmcmVzaCBJbnRlcnZhbCAoc2Vjb25kcyknKVxuICAgICAgLnNldERlc2MoJzAgPSBubyBhdXRvLXJlZnJlc2gnKVxuICAgICAgLmFkZFRleHQodGV4dCA9PiB0ZXh0XG4gICAgICAgIC5zZXRWYWx1ZSgocmVmcmVzaEludGVydmFsIC8gMTAwMCkudG9TdHJpbmcoKSlcbiAgICAgICAgLm9uQ2hhbmdlKHZhbHVlID0+IHJlZnJlc2hJbnRlcnZhbCA9IHBhcnNlSW50KHZhbHVlKSAqIDEwMDApKTtcblxuICAgIGNvbnN0IGJ1dHRvbkNvbnRhaW5lciA9IGZvcm0uY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwibW9kYWwtYnV0dG9uLWNvbnRhaW5lclwiIH0pO1xuICAgIFxuICAgIGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiLCB7IHRleHQ6IFwiU2F2ZVwiLCB0eXBlOiBcInN1Ym1pdFwiIH0pO1xuICAgIGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiLCB7IHRleHQ6IFwiQ2FuY2VsXCIsIHR5cGU6IFwiYnV0dG9uXCIgfSlcbiAgICAgIC5vbmNsaWNrID0gKCkgPT4gdGhpcy5jbG9zZSgpO1xuXG4gICAgZm9ybS5vbnN1Ym1pdCA9IChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBcbiAgICAgIHRoaXMud2lkZ2V0LnRpdGxlID0gdGl0bGU7XG4gICAgICB0aGlzLndpZGdldC5zaXplID0gc2l6ZTtcbiAgICAgIHRoaXMud2lkZ2V0LnJlZnJlc2hJbnRlcnZhbCA9IHJlZnJlc2hJbnRlcnZhbCA+IDAgPyByZWZyZXNoSW50ZXJ2YWwgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMub25TYXZlKHRoaXMud2lkZ2V0KTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9O1xuICB9XG59XG4iLCAiLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBtYXJrZWQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldERlZmF1bHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jOiBmYWxzZSxcbiAgICAgICAgYnJlYWtzOiBmYWxzZSxcbiAgICAgICAgZXh0ZW5zaW9uczogbnVsbCxcbiAgICAgICAgZ2ZtOiB0cnVlLFxuICAgICAgICBob29rczogbnVsbCxcbiAgICAgICAgcGVkYW50aWM6IGZhbHNlLFxuICAgICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgICAgdG9rZW5pemVyOiBudWxsLFxuICAgICAgICB3YWxrVG9rZW5zOiBudWxsXG4gICAgfTtcbn1cbmV4cG9ydCBsZXQgX2RlZmF1bHRzID0gX2dldERlZmF1bHRzKCk7XG5leHBvcnQgZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgICBfZGVmYXVsdHMgPSBuZXdEZWZhdWx0cztcbn1cbiIsICIvKipcbiAqIEhlbHBlcnNcbiAqL1xuY29uc3QgZXNjYXBlVGVzdCA9IC9bJjw+XCInXS87XG5jb25zdCBlc2NhcGVSZXBsYWNlID0gbmV3IFJlZ0V4cChlc2NhcGVUZXN0LnNvdXJjZSwgJ2cnKTtcbmNvbnN0IGVzY2FwZVRlc3ROb0VuY29kZSA9IC9bPD5cIiddfCYoPyEoI1xcZHsxLDd9fCNbWHhdW2EtZkEtRjAtOV17MSw2fXxcXHcrKTspLztcbmNvbnN0IGVzY2FwZVJlcGxhY2VOb0VuY29kZSA9IG5ldyBSZWdFeHAoZXNjYXBlVGVzdE5vRW5jb2RlLnNvdXJjZSwgJ2cnKTtcbmNvbnN0IGVzY2FwZVJlcGxhY2VtZW50cyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5Oydcbn07XG5jb25zdCBnZXRFc2NhcGVSZXBsYWNlbWVudCA9IChjaCkgPT4gZXNjYXBlUmVwbGFjZW1lbnRzW2NoXTtcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgICBpZiAoZXNjYXBlVGVzdC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2VOb0VuY29kZSwgZ2V0RXNjYXBlUmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBodG1sO1xufVxuY29uc3QgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gICAgLy8gZXhwbGljaXRseSBtYXRjaCBkZWNpbWFsLCBoZXgsIGFuZCBuYW1lZCBIVE1MIGVudGl0aWVzXG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSh1bmVzY2FwZVRlc3QsIChfLCBuKSA9PiB7XG4gICAgICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChuID09PSAnY29sb24nKVxuICAgICAgICAgICAgcmV0dXJuICc6JztcbiAgICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG4uc3Vic3RyaW5nKDIpLCAxNikpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKCtuLnN1YnN0cmluZygxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xufVxuY29uc3QgY2FyZXQgPSAvKF58W15cXFtdKVxcXi9nO1xuZXhwb3J0IGZ1bmN0aW9uIGVkaXQocmVnZXgsIG9wdCkge1xuICAgIHJlZ2V4ID0gdHlwZW9mIHJlZ2V4ID09PSAnc3RyaW5nJyA/IHJlZ2V4IDogcmVnZXguc291cmNlO1xuICAgIG9wdCA9IG9wdCB8fCAnJztcbiAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIHJlcGxhY2U6IChuYW1lLCB2YWwpID0+IHtcbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICdzb3VyY2UnIGluIHZhbCA/IHZhbC5zb3VyY2UgOiB2YWw7XG4gICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZShjYXJldCwgJyQxJyk7XG4gICAgICAgICAgICByZWdleCA9IHJlZ2V4LnJlcGxhY2UobmFtZSwgdmFsKTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFJlZ2V4OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdleCwgb3B0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iajtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhblVybChocmVmKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaHJlZiA9IGVuY29kZVVSSShocmVmKS5yZXBsYWNlKC8lMjUvZywgJyUnKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBocmVmO1xufVxuZXhwb3J0IGNvbnN0IG5vb3BUZXN0ID0geyBleGVjOiAoKSA9PiBudWxsIH07XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRDZWxscyh0YWJsZVJvdywgY291bnQpIHtcbiAgICAvLyBlbnN1cmUgdGhhdCBldmVyeSBjZWxsLWRlbGltaXRpbmcgcGlwZSBoYXMgYSBzcGFjZVxuICAgIC8vIGJlZm9yZSBpdCB0byBkaXN0aW5ndWlzaCBpdCBmcm9tIGFuIGVzY2FwZWQgcGlwZVxuICAgIGNvbnN0IHJvdyA9IHRhYmxlUm93LnJlcGxhY2UoL1xcfC9nLCAobWF0Y2gsIG9mZnNldCwgc3RyKSA9PiB7XG4gICAgICAgIGxldCBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBjdXJyID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAoLS1jdXJyID49IDAgJiYgc3RyW2N1cnJdID09PSAnXFxcXCcpXG4gICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XG4gICAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgICAgICAvLyBvZGQgbnVtYmVyIG9mIHNsYXNoZXMgbWVhbnMgfCBpcyBlc2NhcGVkXG4gICAgICAgICAgICAvLyBzbyB3ZSBsZWF2ZSBpdCBhbG9uZVxuICAgICAgICAgICAgcmV0dXJuICd8JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGFkZCBzcGFjZSBiZWZvcmUgdW5lc2NhcGVkIHxcbiAgICAgICAgICAgIHJldHVybiAnIHwnO1xuICAgICAgICB9XG4gICAgfSksIGNlbGxzID0gcm93LnNwbGl0KC8gXFx8Lyk7XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIEZpcnN0L2xhc3QgY2VsbCBpbiBhIHJvdyBjYW5ub3QgYmUgZW1wdHkgaWYgaXQgaGFzIG5vIGxlYWRpbmcvdHJhaWxpbmcgcGlwZVxuICAgIGlmICghY2VsbHNbMF0udHJpbSgpKSB7XG4gICAgICAgIGNlbGxzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChjZWxscy5sZW5ndGggPiAwICYmICFjZWxsc1tjZWxscy5sZW5ndGggLSAxXS50cmltKCkpIHtcbiAgICAgICAgY2VsbHMucG9wKCk7XG4gICAgfVxuICAgIGlmIChjb3VudCkge1xuICAgICAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgICAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoY2VsbHMubGVuZ3RoIDwgY291bnQpXG4gICAgICAgICAgICAgICAgY2VsbHMucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICAgIGNlbGxzW2ldID0gY2VsbHNbaV0udHJpbSgpLnJlcGxhY2UoL1xcXFxcXHwvZywgJ3wnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzO1xufVxuLyoqXG4gKiBSZW1vdmUgdHJhaWxpbmcgJ2Mncy4gRXF1aXZhbGVudCB0byBzdHIucmVwbGFjZSgvYyokLywgJycpLlxuICogL2MqJC8gaXMgdnVsbmVyYWJsZSB0byBSRURPUy5cbiAqXG4gKiBAcGFyYW0gc3RyXG4gKiBAcGFyYW0gY1xuICogQHBhcmFtIGludmVydCBSZW1vdmUgc3VmZml4IG9mIG5vbi1jIGNoYXJzIGluc3RlYWQuIERlZmF1bHQgZmFsc2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcnRyaW0oc3RyLCBjLCBpbnZlcnQpIHtcbiAgICBjb25zdCBsID0gc3RyLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIExlbmd0aCBvZiBzdWZmaXggbWF0Y2hpbmcgdGhlIGludmVydCBjb25kaXRpb24uXG4gICAgbGV0IHN1ZmZMZW4gPSAwO1xuICAgIC8vIFN0ZXAgbGVmdCB1bnRpbCB3ZSBmYWlsIHRvIG1hdGNoIHRoZSBpbnZlcnQgY29uZGl0aW9uLlxuICAgIHdoaWxlIChzdWZmTGVuIDwgbCkge1xuICAgICAgICBjb25zdCBjdXJyQ2hhciA9IHN0ci5jaGFyQXQobCAtIHN1ZmZMZW4gLSAxKTtcbiAgICAgICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgICAgICAgIHN1ZmZMZW4rKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyQ2hhciAhPT0gYyAmJiBpbnZlcnQpIHtcbiAgICAgICAgICAgIHN1ZmZMZW4rKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHIuc2xpY2UoMCwgbCAtIHN1ZmZMZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDbG9zaW5nQnJhY2tldChzdHIsIGIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoYlsxXSkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgbGV0IGxldmVsID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJbaV0gPT09IGJbMF0pIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RyW2ldID09PSBiWzFdKSB7XG4gICAgICAgICAgICBsZXZlbC0tO1xuICAgICAgICAgICAgaWYgKGxldmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbiIsICJpbXBvcnQgeyBfZGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzLnRzJztcbmltcG9ydCB7IHJ0cmltLCBzcGxpdENlbGxzLCBlc2NhcGUsIGZpbmRDbG9zaW5nQnJhY2tldCB9IGZyb20gJy4vaGVscGVycy50cyc7XG5mdW5jdGlvbiBvdXRwdXRMaW5rKGNhcCwgbGluaywgcmF3LCBsZXhlcikge1xuICAgIGNvbnN0IGhyZWYgPSBsaW5rLmhyZWY7XG4gICAgY29uc3QgdGl0bGUgPSBsaW5rLnRpdGxlID8gZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgICBjb25zdCB0ZXh0ID0gY2FwWzFdLnJlcGxhY2UoL1xcXFwoW1xcW1xcXV0pL2csICckMScpO1xuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgdG9rZW5zOiBsZXhlci5pbmxpbmVUb2tlbnModGV4dClcbiAgICAgICAgfTtcbiAgICAgICAgbGV4ZXIuc3RhdGUuaW5MaW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0b2tlbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3LFxuICAgICAgICBocmVmLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgdGV4dDogZXNjYXBlKHRleHQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGVudENvZGVDb21wZW5zYXRpb24ocmF3LCB0ZXh0KSB7XG4gICAgY29uc3QgbWF0Y2hJbmRlbnRUb0NvZGUgPSByYXcubWF0Y2goL14oXFxzKykoPzpgYGApLyk7XG4gICAgaWYgKG1hdGNoSW5kZW50VG9Db2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRUb0NvZGUgPSBtYXRjaEluZGVudFRvQ29kZVsxXTtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAobm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoSW5kZW50SW5Ob2RlID0gbm9kZS5tYXRjaCgvXlxccysvKTtcbiAgICAgICAgaWYgKG1hdGNoSW5kZW50SW5Ob2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5kZW50SW5Ob2RlXSA9IG1hdGNoSW5kZW50SW5Ob2RlO1xuICAgICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zbGljZShpbmRlbnRUb0NvZGUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG4vKipcbiAqIFRva2VuaXplclxuICovXG5leHBvcnQgY2xhc3MgX1Rva2VuaXplciB7XG4gICAgb3B0aW9ucztcbiAgICAvLyBUT0RPOiBGaXggdGhpcyBydWxlcyB0eXBlXG4gICAgcnVsZXM7XG4gICAgbGV4ZXI7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IF9kZWZhdWx0cztcbiAgICB9XG4gICAgc3BhY2Uoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2submV3bGluZS5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXAgJiYgY2FwWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb2RlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmNvZGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGNvZGVCbG9ja1N0eWxlOiAnaW5kZW50ZWQnLFxuICAgICAgICAgICAgICAgIHRleHQ6ICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgICAgICAgICAgICAgPyBydHJpbSh0ZXh0LCAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgOiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGZlbmNlcyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCByYXcgPSBjYXBbMF07XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICAgICAgICByYXcsXG4gICAgICAgICAgICAgICAgbGFuZzogY2FwWzJdID8gY2FwWzJdLnRyaW0oKS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGNhcFsyXSxcbiAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhlYWRpbmcoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2suaGVhZGluZy5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gY2FwWzJdLnRyaW0oKTtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyAjc1xuICAgICAgICAgICAgaWYgKC8jJC8udGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBydHJpbSh0ZXh0LCAnIycpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdHJpbW1lZCB8fCAvICQvLnRlc3QodHJpbW1lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tbW9uTWFyayByZXF1aXJlcyBzcGFjZSBiZWZvcmUgdHJhaWxpbmcgI3NcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRyaW1tZWQudHJpbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGRlcHRoOiBjYXBbMV0ubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZSh0ZXh0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBocihzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hyJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBibG9ja3F1b3RlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gcnRyaW0oY2FwWzBdLnJlcGxhY2UoL14gKj5bIFxcdF0/L2dtLCAnJyksICdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMubGV4ZXIuc3RhdGUudG9wO1xuICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS50b3AgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5sZXhlci5ibG9ja1Rva2Vucyh0ZXh0KTtcbiAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2txdW90ZScsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGlzdChzcmMpIHtcbiAgICAgICAgbGV0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2subGlzdC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCBidWxsID0gY2FwWzFdLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGlzb3JkZXJlZCA9IGJ1bGwubGVuZ3RoID4gMTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3QgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgICAgIHJhdzogJycsXG4gICAgICAgICAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGBcXFxcZHsxLDl9XFxcXCR7YnVsbC5zbGljZSgtMSl9YCA6IGBcXFxcJHtidWxsfWA7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgYnVsbCA9IGlzb3JkZXJlZCA/IGJ1bGwgOiAnWyorLV0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IG5leHQgbGlzdCBpdGVtXG4gICAgICAgICAgICBjb25zdCBpdGVtUmVnZXggPSBuZXcgUmVnRXhwKGBeKCB7MCwzfSR7YnVsbH0pKCg/OltcXHQgXVteXFxcXG5dKik/KD86XFxcXG58JCkpYCk7XG4gICAgICAgICAgICBsZXQgcmF3ID0gJyc7XG4gICAgICAgICAgICBsZXQgaXRlbUNvbnRlbnRzID0gJyc7XG4gICAgICAgICAgICBsZXQgZW5kc1dpdGhCbGFua0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgYnVsbGV0IHBvaW50IGNhbiBzdGFydCBhIG5ldyBMaXN0IEl0ZW1cbiAgICAgICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kRWFybHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIShjYXAgPSBpdGVtUmVnZXguZXhlYyhzcmMpKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucnVsZXMuYmxvY2suaHIudGVzdChzcmMpKSB7IC8vIEVuZCBsaXN0IGlmIGJ1bGxldCB3YXMgYWN0dWFsbHkgSFIgKHBvc3NpYmx5IG1vdmUgaW50byBpdGVtUmVnZXg/KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmF3ID0gY2FwWzBdO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcocmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBjYXBbMl0uc3BsaXQoJ1xcbicsIDEpWzBdLnJlcGxhY2UoL15cXHQrLywgKHQpID0+ICcgJy5yZXBlYXQoMyAqIHQubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHRMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGxpbmUudHJpbVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRlbnQgPSBjYXBbMl0uc2VhcmNoKC9bXiBdLyk7IC8vIEZpbmQgZmlyc3Qgbm9uLXNwYWNlIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gaW5kZW50ID4gNCA/IDEgOiBpbmRlbnQ7IC8vIFRyZWF0IGluZGVudGVkIGNvZGUgYmxvY2tzICg+IDQgc3BhY2VzKSBhcyBoYXZpbmcgb25seSAxIGluZGVudFxuICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgPSBsaW5lLnNsaWNlKGluZGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSBjYXBbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYmxhbmtMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFsaW5lICYmIC9eICokLy50ZXN0KG5leHRMaW5lKSkgeyAvLyBJdGVtcyBiZWdpbiB3aXRoIGF0IG1vc3Qgb25lIGJsYW5rIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgcmF3ICs9IG5leHRMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcobmV4dExpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVuZEVhcmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbmRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0QnVsbGV0UmVnZXggPSBuZXcgUmVnRXhwKGBeIHswLCR7TWF0aC5taW4oMywgaW5kZW50IC0gMSl9fSg/OlsqKy1dfFxcXFxkezEsOX1bLildKSgoPzpbIFxcdF1bXlxcXFxuXSopPyg/OlxcXFxufCQpKWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoclJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oKD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZW5jZXNCZWdpblJlZ2V4ID0gbmV3IFJlZ0V4cChgXiB7MCwke01hdGgubWluKDMsIGluZGVudCAtIDEpfX0oPzpcXGBcXGBcXGB8fn5+KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nQmVnaW5SZWdleCA9IG5ldyBSZWdFeHAoYF4gezAsJHtNYXRoLm1pbigzLCBpbmRlbnQgLSAxKX19I2ApO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBmb2xsb3dpbmcgbGluZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGluIExpc3QgSXRlbVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdMaW5lID0gc3JjLnNwbGl0KCdcXG4nLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gcmF3TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLWFsaWduIHRvIGZvbGxvdyBjb21tb25tYXJrIG5lc3RpbmcgcnVsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0TGluZSA9IG5leHRMaW5lLnJlcGxhY2UoL14gezEsNH0oPz0oIHs0fSkqW14gXSkvZywgJyAgJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIGNvZGUgZmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVuY2VzQmVnaW5SZWdleC50ZXN0KG5leHRMaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGxpc3QgaXRlbSBpZiBmb3VuZCBzdGFydCBvZiBuZXcgaGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRpbmdCZWdpblJlZ2V4LnRlc3QobmV4dExpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbmQgbGlzdCBpdGVtIGlmIGZvdW5kIHN0YXJ0IG9mIG5ldyBidWxsZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0QnVsbGV0UmVnZXgudGVzdChuZXh0TGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgcnVsZSBmb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhyUmVnZXgudGVzdChzcmMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dExpbmUuc2VhcmNoKC9bXiBdLykgPj0gaW5kZW50IHx8ICFuZXh0TGluZS50cmltKCkpIHsgLy8gRGVkZW50IGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnRzICs9ICdcXG4nICsgbmV4dExpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBlbm91Z2ggaW5kZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxhbmtMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXJhZ3JhcGggY29udGludWF0aW9uIHVubGVzcyBsYXN0IGxpbmUgd2FzIGEgZGlmZmVyZW50IGJsb2NrIGxldmVsIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5zZWFyY2goL1teIF0vKSA+PSA0KSB7IC8vIGluZGVudGVkIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZW5jZXNCZWdpblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZWFkaW5nQmVnaW5SZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHJSZWdleC50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtQ29udGVudHMgKz0gJ1xcbicgKyBuZXh0TGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmxhbmtMaW5lICYmICFuZXh0TGluZS50cmltKCkpIHsgLy8gQ2hlY2sgaWYgY3VycmVudCBsaW5lIGlzIGJsYW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdyArPSByYXdMaW5lICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHJhd0xpbmUubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gbmV4dExpbmUuc2xpY2UoaW5kZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWxpc3QubG9vc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIGl0ZW0gZW5kZWQgd2l0aCBhIGJsYW5rIGxpbmUsIHRoZSBsaXN0IGlzIGxvb3NlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRzV2l0aEJsYW5rTGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL1xcbiAqXFxuICokLy50ZXN0KHJhdykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHNXaXRoQmxhbmtMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaXN0YXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgaXNjaGVja2VkO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0YXNrIGxpc3QgaXRlbXNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgICAgICAgICBpc3Rhc2sgPSAvXlxcW1sgeFhdXFxdIC8uZXhlYyhpdGVtQ29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXN0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc2NoZWNrZWQgPSBpc3Rhc2tbMF0gIT09ICdbIF0gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50cyA9IGl0ZW1Db250ZW50cy5yZXBsYWNlKC9eXFxbWyB4WF1cXF0gKy8sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0Lml0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgICAgICAgICAgcmF3LFxuICAgICAgICAgICAgICAgICAgICB0YXNrOiAhIWlzdGFzayxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IGl0ZW1Db250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxpc3QucmF3ICs9IHJhdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCBjb25zdW1lIG5ld2xpbmVzIGF0IGVuZCBvZiBmaW5hbCBpdGVtLiBBbHRlcm5hdGl2ZWx5LCBtYWtlIGl0ZW1SZWdleCAqc3RhcnQqIHdpdGggYW55IG5ld2xpbmVzIHRvIHNpbXBsaWZ5L3NwZWVkIHVwIGVuZHNXaXRoQmxhbmtMaW5lIGxvZ2ljXG4gICAgICAgICAgICBsaXN0Lml0ZW1zW2xpc3QuaXRlbXMubGVuZ3RoIC0gMV0ucmF3ID0gcmF3LnRyaW1FbmQoKTtcbiAgICAgICAgICAgIGxpc3QuaXRlbXNbbGlzdC5pdGVtcy5sZW5ndGggLSAxXS50ZXh0ID0gaXRlbUNvbnRlbnRzLnRyaW1FbmQoKTtcbiAgICAgICAgICAgIGxpc3QucmF3ID0gbGlzdC5yYXcudHJpbUVuZCgpO1xuICAgICAgICAgICAgLy8gSXRlbSBjaGlsZCB0b2tlbnMgaGFuZGxlZCBoZXJlIGF0IGVuZCBiZWNhdXNlIHdlIG5lZWRlZCB0byBoYXZlIHRoZSBmaW5hbCBpdGVtIHRvIHRyaW0gaXQgZmlyc3RcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5pdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUudG9wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbGlzdC5pdGVtc1tpXS50b2tlbnMgPSB0aGlzLmxleGVyLmJsb2NrVG9rZW5zKGxpc3QuaXRlbXNbaV0udGV4dCwgW10pO1xuICAgICAgICAgICAgICAgIGlmICghbGlzdC5sb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBsaXN0IHNob3VsZCBiZSBsb29zZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGFjZXJzID0gbGlzdC5pdGVtc1tpXS50b2tlbnMuZmlsdGVyKHQgPT4gdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTXVsdGlwbGVMaW5lQnJlYWtzID0gc3BhY2Vycy5sZW5ndGggPiAwICYmIHNwYWNlcnMuc29tZSh0ID0+IC9cXG4uKlxcbi8udGVzdCh0LnJhdykpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0Lmxvb3NlID0gaGFzTXVsdGlwbGVMaW5lQnJlYWtzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCBhbGwgaXRlbXMgdG8gbG9vc2UgaWYgbGlzdCBpcyBsb29zZVxuICAgICAgICAgICAgaWYgKGxpc3QubG9vc2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QuaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5pdGVtc1tpXS5sb29zZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaHRtbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5odG1sLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIGJsb2NrOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHByZTogY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVmKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmRlZi5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IGNhcFsxXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IGhyZWYgPSBjYXBbMl0gPyBjYXBbMl0ucmVwbGFjZSgvXjwoLiopPiQvLCAnJDEnKS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSBjYXBbM10gPyBjYXBbM10uc3Vic3RyaW5nKDEsIGNhcFszXS5sZW5ndGggLSAxKS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IGNhcFszXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RlZicsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGhyZWYsXG4gICAgICAgICAgICAgICAgdGl0bGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFibGUoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGFibGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBpZiAoIS9bOnxdLy50ZXN0KGNhcFsyXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxpbWl0ZXIgcm93IG11c3QgaGF2ZSBhIHBpcGUgKHwpIG9yIGNvbG9uICg6KSBvdGhlcndpc2UgaXQgaXMgYSBzZXRleHQgaGVhZGluZ1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHNwbGl0Q2VsbHMoY2FwWzFdKS5tYXAoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGMsIHRva2VuczogW10gfTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL15cXHx8XFx8ICokL2csICcnKS5zcGxpdCgnfCcpLFxuICAgICAgICAgICAgICAgIHJvd3M6IGNhcFszXSAmJiBjYXBbM10udHJpbSgpID8gY2FwWzNdLnJlcGxhY2UoL1xcblsgXFx0XSokLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA9PT0gaXRlbS5hbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbCA9IGl0ZW0uYWxpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCBpLCBqLCBrLCByb3c7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGlnbiA9IGl0ZW0uYWxpZ25baV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGlnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoYWxpZ24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXiAqOi0rOiAqJC8udGVzdChhbGlnbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGFsaWduKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsID0gaXRlbS5yb3dzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucm93c1tpXSA9IHNwbGl0Q2VsbHMoaXRlbS5yb3dzW2ldLCBpdGVtLmhlYWRlci5sZW5ndGgpLm1hcChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGMsIHRva2VuczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGNoaWxkIHRva2VucyBpbnNpZGUgaGVhZGVycyBhbmQgY2VsbHNcbiAgICAgICAgICAgICAgICAvLyBoZWFkZXIgY2hpbGQgdG9rZW5zXG4gICAgICAgICAgICAgICAgbCA9IGl0ZW0uaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaGVhZGVyW2pdLnRva2VucyA9IHRoaXMubGV4ZXIuaW5saW5lKGl0ZW0uaGVhZGVyW2pdLnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjZWxsIGNoaWxkIHRva2Vuc1xuICAgICAgICAgICAgICAgIGwgPSBpdGVtLnJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gaXRlbS5yb3dzW2pdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcm93Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3dba10udG9rZW5zID0gdGhpcy5sZXhlci5pbmxpbmUocm93W2tdLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxoZWFkaW5nKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGluZycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgZGVwdGg6IGNhcFsyXS5jaGFyQXQoMCkgPT09ICc9JyA/IDEgOiAyLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFsxXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFsxXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYWdyYXBoKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnBhcmFncmFwaC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgICAgICA6IGNhcFsxXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKHRleHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRleHQoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuYmxvY2sudGV4dC5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lKGNhcFswXSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXNjYXBlKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdlc2NhcGUnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHQ6IGVzY2FwZShjYXBbMV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhZyhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudGFnLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxleGVyLnN0YXRlLmluTGluayAmJiAvXjxhIC9pLnRlc3QoY2FwWzBdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGV4ZXIuc3RhdGUuaW5MaW5rICYmIC9ePFxcL2E+L2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIC9ePChwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrICYmIC9ePFxcLyhwcmV8Y29kZXxrYmR8c2NyaXB0KShcXHN8PikvaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2h0bWwnLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIGluTGluazogdGhpcy5sZXhlci5zdGF0ZS5pbkxpbmssXG4gICAgICAgICAgICAgICAgaW5SYXdCbG9jazogdGhpcy5sZXhlci5zdGF0ZS5pblJhd0Jsb2NrLFxuICAgICAgICAgICAgICAgIGJsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGluayhzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUubGluay5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRVcmwgPSBjYXBbMl0udHJpbSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgL148Ly50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29tbW9ubWFyayByZXF1aXJlcyBtYXRjaGluZyBhbmdsZSBicmFja2V0c1xuICAgICAgICAgICAgICAgIGlmICghKC8+JC8udGVzdCh0cmltbWVkVXJsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbmRpbmcgYW5nbGUgYnJhY2tldCBjYW5ub3QgYmUgZXNjYXBlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHJ0cmltU2xhc2ggPSBydHJpbSh0cmltbWVkVXJsLnNsaWNlKDAsIC0xKSwgJ1xcXFwnKTtcbiAgICAgICAgICAgICAgICBpZiAoKHRyaW1tZWRVcmwubGVuZ3RoIC0gcnRyaW1TbGFzaC5sZW5ndGgpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCBjbG9zaW5nIHBhcmVudGhlc2lzXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFBhcmVuSW5kZXggPSBmaW5kQ2xvc2luZ0JyYWNrZXQoY2FwWzJdLCAnKCknKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBhcmVuSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGNhcFswXS5pbmRleE9mKCchJykgPT09IDAgPyA1IDogNDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua0xlbiA9IHN0YXJ0ICsgY2FwWzFdLmxlbmd0aCArIGxhc3RQYXJlbkluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY2FwWzBdID0gY2FwWzBdLnN1YnN0cmluZygwLCBsaW5rTGVuKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGNhcFszXSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBocmVmID0gY2FwWzJdO1xuICAgICAgICAgICAgbGV0IHRpdGxlID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgcGVkYW50aWMgaHJlZiBhbmQgdGl0bGVcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5rID0gL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLmV4ZWMoaHJlZik7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlID0gbGlua1szXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aXRsZSA9IGNhcFszXSA/IGNhcFszXS5zbGljZSgxLCAtMSkgOiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnRyaW0oKTtcbiAgICAgICAgICAgIGlmICgvXjwvLnRlc3QoaHJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljICYmICEoLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwZWRhbnRpYyBhbGxvd3Mgc3RhcnRpbmcgYW5nbGUgYnJhY2tldCB3aXRob3V0IGVuZGluZyBhbmdsZSBicmFja2V0XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IGhyZWYuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICAgICAgICAgIGhyZWY6IGhyZWYgPyBocmVmLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogaHJlZixcbiAgICAgICAgICAgICAgICB0aXRsZTogdGl0bGUgPyB0aXRsZS5yZXBsYWNlKHRoaXMucnVsZXMuaW5saW5lLl9lc2NhcGVzLCAnJDEnKSA6IHRpdGxlXG4gICAgICAgICAgICB9LCBjYXBbMF0sIHRoaXMubGV4ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZmxpbmsoc3JjLCBsaW5rcykge1xuICAgICAgICBsZXQgY2FwO1xuICAgICAgICBpZiAoKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnJlZmxpbmsuZXhlYyhzcmMpKVxuICAgICAgICAgICAgfHwgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLm5vbGluay5leGVjKHNyYykpKSB7XG4gICAgICAgICAgICBsZXQgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgICAgICBsaW5rID0gbGlua3NbbGluay50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgcmF3OiB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwgbGluaywgY2FwWzBdLCB0aGlzLmxleGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIgPSAnJykge1xuICAgICAgICBsZXQgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbVN0cm9uZy5sRGVsaW0uZXhlYyhzcmMpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBfIGNhbid0IGJlIGJldHdlZW4gdHdvIGFscGhhbnVtZXJpY3MuIFxccHtMfVxccHtOfSBpbmNsdWRlcyBub24tZW5nbGlzaCBhbHBoYWJldC9udW1iZXJzIGFzIHdlbGxcbiAgICAgICAgaWYgKG1hdGNoWzNdICYmIHByZXZDaGFyLm1hdGNoKC9bXFxwe0x9XFxwe059XS91KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbmV4dENoYXIgPSBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCAnJztcbiAgICAgICAgaWYgKCFuZXh0Q2hhciB8fCAhcHJldkNoYXIgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpIHtcbiAgICAgICAgICAgIC8vIHVuaWNvZGUgUmVnZXggY291bnRzIGVtb2ppIGFzIDEgY2hhcjsgc3ByZWFkIGludG8gYXJyYXkgZm9yIHByb3BlciBjb3VudCAodXNlZCBtdWx0aXBsZSB0aW1lcyBiZWxvdylcbiAgICAgICAgICAgIGNvbnN0IGxMZW5ndGggPSBbLi4ubWF0Y2hbMF1dLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBsZXQgckRlbGltLCByTGVuZ3RoLCBkZWxpbVRvdGFsID0gbExlbmd0aCwgbWlkRGVsaW1Ub3RhbCA9IDA7XG4gICAgICAgICAgICBjb25zdCBlbmRSZWcgPSBtYXRjaFswXVswXSA9PT0gJyonID8gdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltQXN0IDogdGhpcy5ydWxlcy5pbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kO1xuICAgICAgICAgICAgZW5kUmVnLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAvLyBDbGlwIG1hc2tlZFNyYyB0byBzYW1lIHNlY3Rpb24gb2Ygc3RyaW5nIGFzIHNyYyAobW92ZSB0byBsZXhlcj8pXG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoICsgbExlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gZW5kUmVnLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJEZWxpbSA9IG1hdGNoWzFdIHx8IG1hdGNoWzJdIHx8IG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IG1hdGNoWzZdO1xuICAgICAgICAgICAgICAgIGlmICghckRlbGltKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBzaW5nbGUgKiBpbiBfX2FiYyphYmNfX1xuICAgICAgICAgICAgICAgIHJMZW5ndGggPSBbLi4uckRlbGltXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoWzNdIHx8IG1hdGNoWzRdKSB7IC8vIGZvdW5kIGFub3RoZXIgTGVmdCBEZWxpbVxuICAgICAgICAgICAgICAgICAgICBkZWxpbVRvdGFsICs9IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaFs1XSB8fCBtYXRjaFs2XSkgeyAvLyBlaXRoZXIgTGVmdCBvciBSaWdodCBEZWxpbVxuICAgICAgICAgICAgICAgICAgICBpZiAobExlbmd0aCAlIDMgJiYgISgobExlbmd0aCArIHJMZW5ndGgpICUgMykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZERlbGltVG90YWwgKz0gckxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBDb21tb25NYXJrIEVtcGhhc2lzIFJ1bGVzIDktMTBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxpbVRvdGFsIC09IHJMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGltVG90YWwgPiAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gSGF2ZW4ndCBmb3VuZCBlbm91Z2ggY2xvc2luZyBkZWxpbWl0ZXJzXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV4dHJhIGNoYXJhY3RlcnMuICphKioqIC0+ICphKlxuICAgICAgICAgICAgICAgIHJMZW5ndGggPSBNYXRoLm1pbihyTGVuZ3RoLCByTGVuZ3RoICsgZGVsaW1Ub3RhbCArIG1pZERlbGltVG90YWwpO1xuICAgICAgICAgICAgICAgIC8vIGNoYXIgbGVuZ3RoIGNhbiBiZSA+MSBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyTGVuZ3RoID0gWy4uLm1hdGNoWzBdXVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3ID0gc3JjLnNsaWNlKDAsIGxMZW5ndGggKyBtYXRjaC5pbmRleCArIGxhc3RDaGFyTGVuZ3RoICsgckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGBlbWAgaWYgc21hbGxlc3QgZGVsaW1pdGVyIGhhcyBvZGQgY2hhciBjb3VudC4gKmEqKipcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5taW4obExlbmd0aCwgckxlbmd0aCkgJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSByYXcuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2VtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHRoaXMubGV4ZXIuaW5saW5lVG9rZW5zKHRleHQpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSAnc3Ryb25nJyBpZiBzbWFsbGVzdCBkZWxpbWl0ZXIgaGFzIGV2ZW4gY2hhciBjb3VudC4gKiphKioqXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IHJhdy5zbGljZSgyLCAtMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cm9uZycsXG4gICAgICAgICAgICAgICAgICAgIHJhdyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2Vucyh0ZXh0KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29kZXNwYW4oc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmNvZGUuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IGNhcFsyXS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc05vblNwYWNlQ2hhcnMgPSAvW14gXS8udGVzdCh0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzID0gL14gLy50ZXN0KHRleHQpICYmIC8gJC8udGVzdCh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChoYXNOb25TcGFjZUNoYXJzICYmIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ID0gZXNjYXBlKHRleHQsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgICAgICAgIHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnIoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmJyLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYnInLFxuICAgICAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbChzcmMpIHtcbiAgICAgICAgY29uc3QgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZGVsLmV4ZWMoc3JjKTtcbiAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgICAgICB0ZXh0OiBjYXBbMl0sXG4gICAgICAgICAgICAgICAgdG9rZW5zOiB0aGlzLmxleGVyLmlubGluZVRva2VucyhjYXBbMl0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGF1dG9saW5rKHNyYykge1xuICAgICAgICBjb25zdCBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG4gICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIGxldCB0ZXh0LCBocmVmO1xuICAgICAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMV0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRva2VuczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybChzcmMpIHtcbiAgICAgICAgbGV0IGNhcDtcbiAgICAgICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnVybC5leGVjKHNyYykpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0LCBocmVmO1xuICAgICAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gZXh0ZW5kZWQgYXV0b2xpbmsgcGF0aCB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgbGV0IHByZXZDYXBaZXJvO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldkNhcFplcm8gPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgICAgIGNhcFswXSA9IHRoaXMucnVsZXMuaW5saW5lLl9iYWNrcGVkYWwuZXhlYyhjYXBbMF0pWzBdO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHByZXZDYXBaZXJvICE9PSBjYXBbMF0pO1xuICAgICAgICAgICAgICAgIHRleHQgPSBlc2NhcGUoY2FwWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FwWzFdID09PSAnd3d3LicpIHtcbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9ICdodHRwOi8vJyArIGNhcFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWYgPSBjYXBbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBocmVmLFxuICAgICAgICAgICAgICAgIHRva2VuczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlubGluZVRleHQoc3JjKSB7XG4gICAgICAgIGNvbnN0IGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRleHQuZXhlYyhzcmMpO1xuICAgICAgICBpZiAoY2FwKSB7XG4gICAgICAgICAgICBsZXQgdGV4dDtcbiAgICAgICAgICAgIGlmICh0aGlzLmxleGVyLnN0YXRlLmluUmF3QmxvY2spIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gY2FwWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZShjYXBbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBub29wVGVzdCwgZWRpdCB9IGZyb20gJy4vaGVscGVycy50cyc7XG4vKipcbiAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAqL1xuLy8gTm90IGFsbCBydWxlcyBhcmUgZGVmaW5lZCBpbiB0aGUgb2JqZWN0IGxpdGVyYWxcbi8vIEB0cy1leHBlY3QtZXJyb3JcbmV4cG9ydCBjb25zdCBibG9jayA9IHtcbiAgICBuZXdsaW5lOiAvXig/OiAqKD86XFxufCQpKSsvLFxuICAgIGNvZGU6IC9eKCB7NH1bXlxcbl0rKD86XFxuKD86ICooPzpcXG58JCkpKik/KSsvLFxuICAgIGZlbmNlczogL14gezAsM30oYHszLH0oPz1bXmBcXG5dKig/OlxcbnwkKSl8fnszLH0pKFteXFxuXSopKD86XFxufCQpKD86fChbXFxzXFxTXSo/KSg/OlxcbnwkKSkoPzogezAsM31cXDFbfmBdKiAqKD89XFxufCQpfCQpLyxcbiAgICBocjogL14gezAsM30oKD86LVtcXHQgXSopezMsfXwoPzpfWyBcXHRdKil7Myx9fCg/OlxcKlsgXFx0XSopezMsfSkoPzpcXG4rfCQpLyxcbiAgICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvLFxuICAgIGJsb2NrcXVvdGU6IC9eKCB7MCwzfT4gPyhwYXJhZ3JhcGh8W15cXG5dKikoPzpcXG58JCkpKy8sXG4gICAgbGlzdDogL14oIHswLDN9YnVsbCkoWyBcXHRdW15cXG5dKz8pPyg/OlxcbnwkKS8sXG4gICAgaHRtbDogJ14gezAsM30oPzonIC8vIG9wdGlvbmFsIGluZGVudGF0aW9uXG4gICAgICAgICsgJzwoc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbXFxcXHM+XVtcXFxcc1xcXFxTXSo/KD86PC9cXFxcMT5bXlxcXFxuXSpcXFxcbit8JCknIC8vICgxKVxuICAgICAgICArICd8Y29tbWVudFteXFxcXG5dKihcXFxcbit8JCknIC8vICgyKVxuICAgICAgICArICd8PFxcXFw/W1xcXFxzXFxcXFNdKj8oPzpcXFxcPz5cXFxcbip8JCknIC8vICgzKVxuICAgICAgICArICd8PCFbQS1aXVtcXFxcc1xcXFxTXSo/KD86PlxcXFxuKnwkKScgLy8gKDQpXG4gICAgICAgICsgJ3w8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/KD86XFxcXF1cXFxcXT5cXFxcbip8JCknIC8vICg1KVxuICAgICAgICArICd8PC8/KHRhZykoPzogK3xcXFxcbnwvPz4pW1xcXFxzXFxcXFNdKj8oPzooPzpcXFxcbiAqKStcXFxcbnwkKScgLy8gKDYpXG4gICAgICAgICsgJ3w8KD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSkoW2Etel1bXFxcXHctXSopKD86YXR0cmlidXRlKSo/ICovPz4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNykgb3BlbiB0YWdcbiAgICAgICAgKyAnfDwvKD8hc2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYSlbYS16XVtcXFxcdy1dKlxcXFxzKj4oPz1bIFxcXFx0XSooPzpcXFxcbnwkKSlbXFxcXHNcXFxcU10qPyg/Oig/OlxcXFxuICopK1xcXFxufCQpJyAvLyAoNykgY2xvc2luZyB0YWdcbiAgICAgICAgKyAnKScsXG4gICAgZGVmOiAvXiB7MCwzfVxcWyhsYWJlbClcXF06ICooPzpcXG4gKik/KFtePFxcc11bXlxcc10qfDwuKj8+KSg/Oig/OiArKD86XFxuICopP3wgKlxcbiAqKSh0aXRsZSkpPyAqKD86XFxuK3wkKS8sXG4gICAgdGFibGU6IG5vb3BUZXN0LFxuICAgIGxoZWFkaW5nOiAvXig/IWJ1bGwgKSgoPzoufFxcbig/IVxccyo/XFxufGJ1bGwgKSkrPylcXG4gezAsM30oPSt8LSspICooPzpcXG4rfCQpLyxcbiAgICAvLyByZWdleCB0ZW1wbGF0ZSwgcGxhY2Vob2xkZXJzIHdpbGwgYmUgcmVwbGFjZWQgYWNjb3JkaW5nIHRvIGRpZmZlcmVudCBwYXJhZ3JhcGhcbiAgICAvLyBpbnRlcnJ1cHRpb24gcnVsZXMgb2YgY29tbW9ubWFyayBhbmQgdGhlIG9yaWdpbmFsIG1hcmtkb3duIHNwZWM6XG4gICAgX3BhcmFncmFwaDogL14oW15cXG5dKyg/Olxcbig/IWhyfGhlYWRpbmd8bGhlYWRpbmd8YmxvY2txdW90ZXxmZW5jZXN8bGlzdHxodG1sfHRhYmxlfCArXFxuKVteXFxuXSspKikvLFxuICAgIHRleHQ6IC9eW15cXG5dKy9cbn07XG5ibG9jay5fbGFiZWwgPSAvKD8hXFxzKlxcXSkoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSsvO1xuYmxvY2suX3RpdGxlID0gLyg/OlwiKD86XFxcXFwiP3xbXlwiXFxcXF0pKlwifCdbXidcXG5dKig/OlxcblteJ1xcbl0rKSpcXG4/J3xcXChbXigpXSpcXCkpLztcbmJsb2NrLmRlZiA9IGVkaXQoYmxvY2suZGVmKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIGJsb2NrLl9sYWJlbClcbiAgICAucmVwbGFjZSgndGl0bGUnLCBibG9jay5fdGl0bGUpXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5idWxsZXQgPSAvKD86WyorLV18XFxkezEsOX1bLildKS87XG5ibG9jay5saXN0SXRlbVN0YXJ0ID0gZWRpdCgvXiggKikoYnVsbCkgKi8pXG4gICAgLnJlcGxhY2UoJ2J1bGwnLCBibG9jay5idWxsZXQpXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5saXN0ID0gZWRpdChibG9jay5saXN0KVxuICAgIC5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgICAucmVwbGFjZSgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86KD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFxcXCogKil7Myx9KSg/OlxcXFxuK3wkKSknKVxuICAgIC5yZXBsYWNlKCdkZWYnLCAnXFxcXG4rKD89JyArIGJsb2NrLmRlZi5zb3VyY2UgKyAnKScpXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5fdGFnID0gJ2FkZHJlc3N8YXJ0aWNsZXxhc2lkZXxiYXNlfGJhc2Vmb250fGJsb2NrcXVvdGV8Ym9keXxjYXB0aW9uJ1xuICAgICsgJ3xjZW50ZXJ8Y29sfGNvbGdyb3VwfGRkfGRldGFpbHN8ZGlhbG9nfGRpcnxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbidcbiAgICArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZSdcbiAgICArICd8bGVnZW5kfGxpfGxpbmt8bWFpbnxtZW51fG1lbnVpdGVtfG1ldGF8bmF2fG5vZnJhbWVzfG9sfG9wdGdyb3VwfG9wdGlvbidcbiAgICArICd8cHxwYXJhbXxzZWN0aW9ufHNvdXJjZXxzdW1tYXJ5fHRhYmxlfHRib2R5fHRkfHRmb290fHRofHRoZWFkfHRpdGxlfHRyJ1xuICAgICsgJ3x0cmFja3x1bCc7XG5ibG9jay5fY29tbWVudCA9IC88IS0tKD8hLT8+KVtcXHNcXFNdKj8oPzotLT58JCkvO1xuYmxvY2suaHRtbCA9IGVkaXQoYmxvY2suaHRtbCwgJ2knKVxuICAgIC5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpXG4gICAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpXG4gICAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC8gK1thLXpBLVo6X11bXFx3LjotXSooPzogKj0gKlwiW15cIlxcbl0qXCJ8ICo9IConW14nXFxuXSonfCAqPSAqW15cXHNcIic9PD5gXSspPy8pXG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5saGVhZGluZyA9IGVkaXQoYmxvY2subGhlYWRpbmcpXG4gICAgLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KSAvLyBsaXN0cyBjYW4gaW50ZXJydXB0XG4gICAgLmdldFJlZ2V4KCk7XG5ibG9jay5wYXJhZ3JhcGggPSBlZGl0KGJsb2NrLl9wYXJhZ3JhcGgpXG4gICAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gICAgLnJlcGxhY2UoJ2hlYWRpbmcnLCAnIHswLDN9I3sxLDZ9KD86XFxcXHN8JCknKVxuICAgIC5yZXBsYWNlKCd8bGhlYWRpbmcnLCAnJykgLy8gc2V0ZXggaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAgIC5yZXBsYWNlKCd8dGFibGUnLCAnJylcbiAgICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JylcbiAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gcGFycyBjYW4gYmUgaW50ZXJydXB0ZWQgYnkgdHlwZSAoNikgaHRtbCBibG9ja3NcbiAgICAuZ2V0UmVnZXgoKTtcbmJsb2NrLmJsb2NrcXVvdGUgPSBlZGl0KGJsb2NrLmJsb2NrcXVvdGUpXG4gICAgLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrLnBhcmFncmFwaClcbiAgICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogTm9ybWFsIEJsb2NrIEdyYW1tYXJcbiAqL1xuYmxvY2subm9ybWFsID0geyAuLi5ibG9jayB9O1xuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5ibG9jay5nZm0gPSB7XG4gICAgLi4uYmxvY2subm9ybWFsLFxuICAgIHRhYmxlOiAnXiAqKFteXFxcXG4gXS4qKVxcXFxuJyAvLyBIZWFkZXJcbiAgICAgICAgKyAnIHswLDN9KCg/OlxcXFx8ICopPzo/LSs6PyAqKD86XFxcXHwgKjo/LSs6PyAqKSooPzpcXFxcfCAqKT8pJyAvLyBBbGlnblxuICAgICAgICArICcoPzpcXFxcbigoPzooPyEgKlxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScgLy8gQ2VsbHNcbn07XG5ibG9jay5nZm0udGFibGUgPSBlZGl0KGJsb2NrLmdmbS50YWJsZSlcbiAgICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ2NvZGUnLCAnIHs0fVteXFxcXG5dJylcbiAgICAucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpXG4gICAgLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXx0ZXh0YXJlYXwhLS0pJylcbiAgICAucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAgIC5nZXRSZWdleCgpO1xuYmxvY2suZ2ZtLnBhcmFncmFwaCA9IGVkaXQoYmxvY2suX3BhcmFncmFwaClcbiAgICAucmVwbGFjZSgnaHInLCBibG9jay5ocilcbiAgICAucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0oPzpcXFxcc3wkKScpXG4gICAgLnJlcGxhY2UoJ3xsaGVhZGluZycsICcnKSAvLyBzZXRleCBoZWFkaW5ncyBkb24ndCBpbnRlcnJ1cHQgY29tbW9ubWFyayBwYXJhZ3JhcGhzXG4gICAgLnJlcGxhY2UoJ3RhYmxlJywgYmxvY2suZ2ZtLnRhYmxlKSAvLyBpbnRlcnJ1cHQgcGFyYWdyYXBocyB3aXRoIHRhYmxlXG4gICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgLnJlcGxhY2UoJ2ZlbmNlcycsICcgezAsM30oPzpgezMsfSg/PVteYFxcXFxuXSpcXFxcbil8fnszLH0pW15cXFxcbl0qXFxcXG4nKVxuICAgIC5yZXBsYWNlKCdsaXN0JywgJyB7MCwzfSg/OlsqKy1dfDFbLildKSAnKSAvLyBvbmx5IGxpc3RzIHN0YXJ0aW5nIGZyb20gMSBjYW4gaW50ZXJydXB0XG4gICAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8dGV4dGFyZWF8IS0tKScpXG4gICAgLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gICAgLmdldFJlZ2V4KCk7XG4vKipcbiAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAqL1xuYmxvY2sucGVkYW50aWMgPSB7XG4gICAgLi4uYmxvY2subm9ybWFsLFxuICAgIGh0bWw6IGVkaXQoJ14gKig/OmNvbW1lbnQgKig/OlxcXFxufFxcXFxzKiQpJ1xuICAgICAgICArICd8PCh0YWcpW1xcXFxzXFxcXFNdKz88L1xcXFwxPiAqKD86XFxcXG57Mix9fFxcXFxzKiQpJyAvLyBjbG9zZWQgdGFnXG4gICAgICAgICsgJ3w8dGFnKD86XCJbXlwiXSpcInxcXCdbXlxcJ10qXFwnfFxcXFxzW15cXCdcIi8+XFxcXHNdKikqPy8/PiAqKD86XFxcXG57Mix9fFxcXFxzKiQpKScpXG4gICAgICAgIC5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpXG4gICAgICAgIC5yZXBsYWNlKC90YWcvZywgJyg/ISg/OidcbiAgICAgICAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGV8dmFyfHNhbXB8a2JkfHN1YidcbiAgICAgICAgKyAnfHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkb3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZyknXG4gICAgICAgICsgJ1xcXFxiKVxcXFx3Kyg/ITp8W15cXFxcd1xcXFxzQF0qQClcXFxcYicpXG4gICAgICAgIC5nZXRSZWdleCgpLFxuICAgIGRlZjogL14gKlxcWyhbXlxcXV0rKVxcXTogKjw/KFteXFxzPl0rKT4/KD86ICsoW1wiKF1bXlxcbl0rW1wiKV0pKT8gKig/Olxcbit8JCkvLFxuICAgIGhlYWRpbmc6IC9eKCN7MSw2fSkoLiopKD86XFxuK3wkKS8sXG4gICAgZmVuY2VzOiBub29wVGVzdCxcbiAgICBsaGVhZGluZzogL14oLis/KVxcbiB7MCwzfSg9K3wtKykgKig/Olxcbit8JCkvLFxuICAgIHBhcmFncmFwaDogZWRpdChibG9jay5ub3JtYWwuX3BhcmFncmFwaClcbiAgICAgICAgLnJlcGxhY2UoJ2hyJywgYmxvY2suaHIpXG4gICAgICAgIC5yZXBsYWNlKCdoZWFkaW5nJywgJyAqI3sxLDZ9ICpbXlxcbl0nKVxuICAgICAgICAucmVwbGFjZSgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZylcbiAgICAgICAgLnJlcGxhY2UoJ2Jsb2NrcXVvdGUnLCAnIHswLDN9PicpXG4gICAgICAgIC5yZXBsYWNlKCd8ZmVuY2VzJywgJycpXG4gICAgICAgIC5yZXBsYWNlKCd8bGlzdCcsICcnKVxuICAgICAgICAucmVwbGFjZSgnfGh0bWwnLCAnJylcbiAgICAgICAgLmdldFJlZ2V4KClcbn07XG4vKipcbiAqIElubGluZS1MZXZlbCBHcmFtbWFyXG4gKi9cbi8vIE5vdCBhbGwgcnVsZXMgYXJlIGRlZmluZWQgaW4gdGhlIG9iamVjdCBsaXRlcmFsXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5leHBvcnQgY29uc3QgaW5saW5lID0ge1xuICAgIGVzY2FwZTogL15cXFxcKFshXCIjJCUmJygpKissXFwtLi86Ozw9Pj9AXFxbXFxdXFxcXF5fYHt8fX5dKS8sXG4gICAgYXV0b2xpbms6IC9ePChzY2hlbWU6W15cXHNcXHgwMC1cXHgxZjw+XSp8ZW1haWwpPi8sXG4gICAgdXJsOiBub29wVGVzdCxcbiAgICB0YWc6ICdeY29tbWVudCdcbiAgICAgICAgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICAgICAgKyAnfF48W2EtekEtWl1bXFxcXHctXSooPzphdHRyaWJ1dGUpKj9cXFxccyovPz4nIC8vIG9wZW4gdGFnXG4gICAgICAgICsgJ3xePFxcXFw/W1xcXFxzXFxcXFNdKj9cXFxcPz4nIC8vIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24sIGUuZy4gPD9waHAgPz5cbiAgICAgICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICAgICAgKyAnfF48IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nLFxuICAgIGxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLyxcbiAgICByZWZsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcWyhyZWYpXFxdLyxcbiAgICBub2xpbms6IC9eIT9cXFsocmVmKVxcXSg/OlxcW1xcXSk/LyxcbiAgICByZWZsaW5rU2VhcmNoOiAncmVmbGlua3xub2xpbmsoPyFcXFxcKCknLFxuICAgIGVtU3Ryb25nOiB7XG4gICAgICAgIGxEZWxpbTogL14oPzpcXCorKD86KCg/IVxcKilbcHVuY3RdKXxbXlxccypdKSl8Xl8rKD86KCg/IV8pW3B1bmN0XSl8KFteXFxzX10pKS8sXG4gICAgICAgIC8vICAgICAgICAgKDEpIGFuZCAoMikgY2FuIG9ubHkgYmUgYSBSaWdodCBEZWxpbWl0ZXIuICgzKSBhbmQgKDQpIGNhbiBvbmx5IGJlIExlZnQuICAoNSkgYW5kICg2KSBjYW4gYmUgZWl0aGVyIExlZnQgb3IgUmlnaHQuXG4gICAgICAgIC8vICAgICAgICAgfCBTa2lwIG9ycGhhbiBpbnNpZGUgc3Ryb25nICAgICAgfCBDb25zdW1lIHRvIGRlbGltIHwgKDEpICMqKiogICAgICAgICAgICAgIHwgKDIpIGEqKiojLCBhKioqICAgICAgICAgICAgICAgICAgICB8ICgzKSAjKioqYSwgKioqYSAgICAgICAgICAgICAgICAgIHwgKDQpICoqKiMgICAgICAgICAgICAgICAgIHwgKDUpICMqKiojICAgICAgICAgICAgICAgICAgICAgICAgIHwgKDYpIGEqKiphXG4gICAgICAgIHJEZWxpbUFzdDogL15bXl8qXSo/X19bXl8qXSo/XFwqW15fKl0qPyg/PV9fKXxbXipdKyg/PVteKl0pfCg/IVxcKilbcHVuY3RdKFxcKispKD89W1xcc118JCl8W15wdW5jdFxcc10oXFwqKykoPyFcXCopKD89W3B1bmN0XFxzXXwkKXwoPyFcXCopW3B1bmN0XFxzXShcXCorKSg/PVtecHVuY3RcXHNdKXxbXFxzXShcXCorKSg/IVxcKikoPz1bcHVuY3RdKXwoPyFcXCopW3B1bmN0XShcXCorKSg/IVxcKikoPz1bcHVuY3RdKXxbXnB1bmN0XFxzXShcXCorKSg/PVtecHVuY3RcXHNdKS8sXG4gICAgICAgIHJEZWxpbVVuZDogL15bXl8qXSo/XFwqXFwqW15fKl0qP19bXl8qXSo/KD89XFwqXFwqKXxbXl9dKyg/PVteX10pfCg/IV8pW3B1bmN0XShfKykoPz1bXFxzXXwkKXxbXnB1bmN0XFxzXShfKykoPyFfKSg/PVtwdW5jdFxcc118JCl8KD8hXylbcHVuY3RcXHNdKF8rKSg/PVtecHVuY3RcXHNdKXxbXFxzXShfKykoPyFfKSg/PVtwdW5jdF0pfCg/IV8pW3B1bmN0XShfKykoPyFfKSg/PVtwdW5jdF0pLyAvLyBeLSBOb3QgYWxsb3dlZCBmb3IgX1xuICAgIH0sXG4gICAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICAgIGRlbDogbm9vcFRlc3QsXG4gICAgdGV4dDogL14oYCt8W15gXSkoPzooPz0gezIsfVxcbil8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKl9dfFxcYl98JCl8W14gXSg/PSB7Mix9XFxuKSkpLyxcbiAgICBwdW5jdHVhdGlvbjogL14oKD8hWypfXSlbXFxzcHVuY3R1YXRpb25dKS9cbn07XG4vLyBsaXN0IG9mIHVuaWNvZGUgcHVuY3R1YXRpb24gbWFya3MsIHBsdXMgYW55IG1pc3NpbmcgY2hhcmFjdGVycyBmcm9tIENvbW1vbk1hcmsgc3BlY1xuaW5saW5lLl9wdW5jdHVhdGlvbiA9ICdcXFxccHtQfSQrPD0+YF58fic7XG5pbmxpbmUucHVuY3R1YXRpb24gPSBlZGl0KGlubGluZS5wdW5jdHVhdGlvbiwgJ3UnKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5nZXRSZWdleCgpO1xuLy8gc2VxdWVuY2VzIGVtIHNob3VsZCBza2lwIG92ZXIgW3RpdGxlXShsaW5rKSwgYGNvZGVgLCA8aHRtbD5cbmlubGluZS5ibG9ja1NraXAgPSAvXFxbW15bXFxdXSo/XFxdXFwoW15cXChcXCldKj9cXCl8YFteYF0qP2B8PFtePD5dKj8+L2c7XG5pbmxpbmUuYW55UHVuY3R1YXRpb24gPSAvXFxcXFtwdW5jdF0vZztcbmlubGluZS5fZXNjYXBlcyA9IC9cXFxcKFtwdW5jdF0pL2c7XG5pbmxpbmUuX2NvbW1lbnQgPSBlZGl0KGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCcoPzotLT58JCknLCAnLS0+JykuZ2V0UmVnZXgoKTtcbmlubGluZS5lbVN0cm9uZy5sRGVsaW0gPSBlZGl0KGlubGluZS5lbVN0cm9uZy5sRGVsaW0sICd1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QgPSBlZGl0KGlubGluZS5lbVN0cm9uZy5yRGVsaW1Bc3QsICdndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kID0gZWRpdChpbmxpbmUuZW1TdHJvbmcuckRlbGltVW5kLCAnZ3UnKVxuICAgIC5yZXBsYWNlKC9wdW5jdC9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLmFueVB1bmN0dWF0aW9uID0gZWRpdChpbmxpbmUuYW55UHVuY3R1YXRpb24sICdndScpXG4gICAgLnJlcGxhY2UoL3B1bmN0L2csIGlubGluZS5fcHVuY3R1YXRpb24pXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuX2VzY2FwZXMgPSBlZGl0KGlubGluZS5fZXNjYXBlcywgJ2d1JylcbiAgICAucmVwbGFjZSgvcHVuY3QvZywgaW5saW5lLl9wdW5jdHVhdGlvbilcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5fc2NoZW1lID0gL1thLXpBLVpdW2EtekEtWjAtOSsuLV17MSwzMX0vO1xuaW5saW5lLl9lbWFpbCA9IC9bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dKyhAKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrKD8hWy1fXSkvO1xuaW5saW5lLmF1dG9saW5rID0gZWRpdChpbmxpbmUuYXV0b2xpbmspXG4gICAgLnJlcGxhY2UoJ3NjaGVtZScsIGlubGluZS5fc2NoZW1lKVxuICAgIC5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUuX2F0dHJpYnV0ZSA9IC9cXHMrW2EtekEtWjpfXVtcXHcuOi1dKig/Olxccyo9XFxzKlwiW15cIl0qXCJ8XFxzKj1cXHMqJ1teJ10qJ3xcXHMqPVxccypbXlxcc1wiJz08PmBdKyk/LztcbmlubGluZS50YWcgPSBlZGl0KGlubGluZS50YWcpXG4gICAgLnJlcGxhY2UoJ2NvbW1lbnQnLCBpbmxpbmUuX2NvbW1lbnQpXG4gICAgLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIGlubGluZS5fYXR0cmlidXRlKVxuICAgIC5nZXRSZWdleCgpO1xuaW5saW5lLl9sYWJlbCA9IC8oPzpcXFsoPzpcXFxcLnxbXlxcW1xcXVxcXFxdKSpcXF18XFxcXC58YFteYF0qYHxbXlxcW1xcXVxcXFxgXSkqPy87XG5pbmxpbmUuX2hyZWYgPSAvPCg/OlxcXFwufFteXFxuPD5cXFxcXSkrPnxbXlxcc1xceDAwLVxceDFmXSovO1xuaW5saW5lLl90aXRsZSA9IC9cIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnKD86XFxcXCc/fFteJ1xcXFxdKSonfFxcKCg/OlxcXFxcXCk/fFteKVxcXFxdKSpcXCkvO1xuaW5saW5lLmxpbmsgPSBlZGl0KGlubGluZS5saW5rKVxuICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgLnJlcGxhY2UoJ2hyZWYnLCBpbmxpbmUuX2hyZWYpXG4gICAgLnJlcGxhY2UoJ3RpdGxlJywgaW5saW5lLl90aXRsZSlcbiAgICAuZ2V0UmVnZXgoKTtcbmlubGluZS5yZWZsaW5rID0gZWRpdChpbmxpbmUucmVmbGluaylcbiAgICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAgIC5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUubm9saW5rID0gZWRpdChpbmxpbmUubm9saW5rKVxuICAgIC5yZXBsYWNlKCdyZWYnLCBibG9jay5fbGFiZWwpXG4gICAgLmdldFJlZ2V4KCk7XG5pbmxpbmUucmVmbGlua1NlYXJjaCA9IGVkaXQoaW5saW5lLnJlZmxpbmtTZWFyY2gsICdnJylcbiAgICAucmVwbGFjZSgncmVmbGluaycsIGlubGluZS5yZWZsaW5rKVxuICAgIC5yZXBsYWNlKCdub2xpbmsnLCBpbmxpbmUubm9saW5rKVxuICAgIC5nZXRSZWdleCgpO1xuLyoqXG4gKiBOb3JtYWwgSW5saW5lIEdyYW1tYXJcbiAqL1xuaW5saW5lLm5vcm1hbCA9IHsgLi4uaW5saW5lIH07XG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cbmlubGluZS5wZWRhbnRpYyA9IHtcbiAgICAuLi5pbmxpbmUubm9ybWFsLFxuICAgIHN0cm9uZzoge1xuICAgICAgICBzdGFydDogL15fX3xcXCpcXCovLFxuICAgICAgICBtaWRkbGU6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICAgICAgICBlbmRBc3Q6IC9cXCpcXCooPyFcXCopL2csXG4gICAgICAgIGVuZFVuZDogL19fKD8hXykvZ1xuICAgIH0sXG4gICAgZW06IHtcbiAgICAgICAgc3RhcnQ6IC9eX3xcXCovLFxuICAgICAgICBtaWRkbGU6IC9eKClcXCooPz1cXFMpKFtcXHNcXFNdKj9cXFMpXFwqKD8hXFwqKXxeXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXykvLFxuICAgICAgICBlbmRBc3Q6IC9cXCooPyFcXCopL2csXG4gICAgICAgIGVuZFVuZDogL18oPyFfKS9nXG4gICAgfSxcbiAgICBsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFwoKC4qPylcXCkvKVxuICAgICAgICAucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKVxuICAgICAgICAuZ2V0UmVnZXgoKSxcbiAgICByZWZsaW5rOiBlZGl0KC9eIT9cXFsobGFiZWwpXFxdXFxzKlxcWyhbXlxcXV0qKVxcXS8pXG4gICAgICAgIC5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpXG4gICAgICAgIC5nZXRSZWdleCgpXG59O1xuLyoqXG4gKiBHRk0gSW5saW5lIEdyYW1tYXJcbiAqL1xuaW5saW5lLmdmbSA9IHtcbiAgICAuLi5pbmxpbmUubm9ybWFsLFxuICAgIGVzY2FwZTogZWRpdChpbmxpbmUuZXNjYXBlKS5yZXBsYWNlKCddKScsICd+fF0pJykuZ2V0UmVnZXgoKSxcbiAgICBfZXh0ZW5kZWRfZW1haWw6IC9bQS1aYS16MC05Ll8rLV0rKEApW2EtekEtWjAtOS1fXSsoPzpcXC5bYS16QS1aMC05LV9dKlthLXpBLVowLTldKSsoPyFbLV9dKS8sXG4gICAgdXJsOiAvXigoPzpmdHB8aHR0cHM/KTpcXC9cXC98d3d3XFwuKSg/OlthLXpBLVowLTlcXC1dK1xcLj8pK1teXFxzPF0qfF5lbWFpbC8sXG4gICAgX2JhY2twZWRhbDogLyg/OltePyEuLDo7Kl8nXCJ+KCkmXSt8XFwoW14pXSpcXCl8Jig/IVthLXpBLVowLTldKzskKXxbPyEuLDo7Kl8nXCJ+KV0rKD8hJCkpKy8sXG4gICAgZGVsOiAvXih+fj8pKD89W15cXHN+XSkoW1xcc1xcU10qP1teXFxzfl0pXFwxKD89W15+XXwkKS8sXG4gICAgdGV4dDogL14oW2B+XSt8W15gfl0pKD86KD89IHsyLH1cXG4pfCg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCl8W1xcc1xcU10qPyg/Oig/PVtcXFxcPCFcXFtgKn5fXXxcXGJffGh0dHBzPzpcXC9cXC98ZnRwOlxcL1xcL3x3d3dcXC58JCl8W14gXSg/PSB7Mix9XFxuKXxbXmEtekEtWjAtOS4hIyQlJicqK1xcLz0/X2B7XFx8fX4tXSg/PVthLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0rQCkpKS9cbn07XG5pbmxpbmUuZ2ZtLnVybCA9IGVkaXQoaW5saW5lLmdmbS51cmwsICdpJylcbiAgICAucmVwbGFjZSgnZW1haWwnLCBpbmxpbmUuZ2ZtLl9leHRlbmRlZF9lbWFpbClcbiAgICAuZ2V0UmVnZXgoKTtcbi8qKlxuICogR0ZNICsgTGluZSBCcmVha3MgSW5saW5lIEdyYW1tYXJcbiAqL1xuaW5saW5lLmJyZWFrcyA9IHtcbiAgICAuLi5pbmxpbmUuZ2ZtLFxuICAgIGJyOiBlZGl0KGlubGluZS5icikucmVwbGFjZSgnezIsfScsICcqJykuZ2V0UmVnZXgoKSxcbiAgICB0ZXh0OiBlZGl0KGlubGluZS5nZm0udGV4dClcbiAgICAgICAgLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpXG4gICAgICAgIC5yZXBsYWNlKC9cXHsyLFxcfS9nLCAnKicpXG4gICAgICAgIC5nZXRSZWdleCgpXG59O1xuIiwgImltcG9ydCB7IF9Ub2tlbml6ZXIgfSBmcm9tICcuL1Rva2VuaXplci50cyc7XG5pbXBvcnQgeyBfZGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzLnRzJztcbmltcG9ydCB7IGJsb2NrLCBpbmxpbmUgfSBmcm9tICcuL3J1bGVzLnRzJztcbi8qKlxuICogQmxvY2sgTGV4ZXJcbiAqL1xuZXhwb3J0IGNsYXNzIF9MZXhlciB7XG4gICAgdG9rZW5zO1xuICAgIG9wdGlvbnM7XG4gICAgc3RhdGU7XG4gICAgdG9rZW5pemVyO1xuICAgIGlubGluZVF1ZXVlO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVG9rZW5MaXN0IGNhbm5vdCBiZSBjcmVhdGVkIGluIG9uZSBnb1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBfVG9rZW5pemVyKCk7XG4gICAgICAgIHRoaXMudG9rZW5pemVyID0gdGhpcy5vcHRpb25zLnRva2VuaXplcjtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy50b2tlbml6ZXIubGV4ZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmlubGluZVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBpbkxpbms6IGZhbHNlLFxuICAgICAgICAgICAgaW5SYXdCbG9jazogZmFsc2UsXG4gICAgICAgICAgICB0b3A6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcnVsZXMgPSB7XG4gICAgICAgICAgICBibG9jazogYmxvY2subm9ybWFsLFxuICAgICAgICAgICAgaW5saW5lOiBpbmxpbmUubm9ybWFsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2sucGVkYW50aWM7XG4gICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUucGVkYW50aWM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgICAgICAgICAgcnVsZXMuYmxvY2sgPSBibG9jay5nZm07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgICAgICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZS5icmVha3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUuZ2ZtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzID0gcnVsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9zZSBSdWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgcnVsZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIGlubGluZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBsZXgoc3JjLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxleGVyID0gbmV3IF9MZXhlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGxleGVyLmxleChzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IElubGluZSBNZXRob2RcbiAgICAgKi9cbiAgICBzdGF0aWMgbGV4SW5saW5lKHNyYywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBsZXhlciA9IG5ldyBfTGV4ZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBsZXhlci5pbmxpbmVUb2tlbnMoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcHJvY2Vzc2luZ1xuICAgICAqL1xuICAgIGxleChzcmMpIHtcbiAgICAgICAgc3JjID0gc3JjXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJyk7XG4gICAgICAgIHRoaXMuYmxvY2tUb2tlbnMoc3JjLCB0aGlzLnRva2Vucyk7XG4gICAgICAgIGxldCBuZXh0O1xuICAgICAgICB3aGlsZSAobmV4dCA9IHRoaXMuaW5saW5lUXVldWUuc2hpZnQoKSkge1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVUb2tlbnMobmV4dC5zcmMsIG5leHQudG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnM7XG4gICAgfVxuICAgIGJsb2NrVG9rZW5zKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICAgICAgc3JjID0gc3JjLnJlcGxhY2UoL1xcdC9nLCAnICAgICcpLnJlcGxhY2UoL14gKyQvZ20sICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9eKCAqKShcXHQrKS9nbSwgKF8sIGxlYWRpbmcsIHRhYnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVhZGluZyArICcgICAgJy5yZXBlYXQodGFicy5sZW5ndGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBsZXQgbGFzdFRva2VuO1xuICAgICAgICBsZXQgY3V0U3JjO1xuICAgICAgICBsZXQgbGFzdFBhcmFncmFwaENsaXBwZWQ7XG4gICAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmJsb2NrXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuYmxvY2suc29tZSgoZXh0VG9rZW5pemVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiA9IGV4dFRva2VuaXplci5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBuZXdsaW5lXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5zcGFjZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ucmF3Lmxlbmd0aCA9PT0gMSAmJiB0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgc2luZ2xlIFxcbiBhcyBhIHNwYWNlciwgaXQncyB0ZXJtaW5hdGluZyB0aGUgbGFzdCBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyBtb3ZlIGl0IHRoZXJlIHNvIHRoYXQgd2UgZG9uJ3QgZ2V0IHVubmVjZXNzYXJ5IHBhcmFncmFwaCB0YWdzXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0ucmF3ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvZGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZVt0aGlzLmlubGluZVF1ZXVlLmxlbmd0aCAtIDFdLnNyYyA9IGxhc3RUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZlbmNlc1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhlYWRpbmdcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaHJcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmhyKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJsb2NrcXVvdGVcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmJsb2NrcXVvdGUoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbGlzdFxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGlzdChzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBodG1sXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5odG1sKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlZlxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVmKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiAobGFzdFRva2VuLnR5cGUgPT09ICdwYXJhZ3JhcGgnIHx8IGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi50ZXh0ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5zLmxpbmtzW3Rva2VuLnRhZ10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB0b2tlbi5ocmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRva2VuLnRpdGxlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGFibGUgKGdmbSlcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhYmxlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGxoZWFkaW5nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saGVhZGluZyhzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0b3AtbGV2ZWwgcGFyYWdyYXBoXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHBhcmFncmFwaCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgICAgICAgIGN1dFNyYyA9IHNyYztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wU3JjID0gc3JjLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuc3RhcnRCbG9jay5mb3JFYWNoKChnZXRTdGFydEluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBTdGFydCA9IGdldFN0YXJ0SW5kZXguY2FsbCh7IGxleGVyOiB0aGlzIH0sIHRlbXBTcmMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBTdGFydCA9PT0gJ251bWJlcicgJiYgdGVtcFN0YXJ0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1pbihzdGFydEluZGV4LCB0ZW1wU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPCBJbmZpbml0eSAmJiBzdGFydEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0U3JjID0gc3JjLnN1YnN0cmluZygwLCBzdGFydEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUudG9wICYmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnBhcmFncmFwaChjdXRTcmMpKSkge1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYXJhZ3JhcGhDbGlwcGVkICYmIGxhc3RUb2tlbi50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lUXVldWVbdGhpcy5pbmxpbmVRdWV1ZS5sZW5ndGggLSAxXS5zcmMgPSBsYXN0VG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFBhcmFncmFwaENsaXBwZWQgPSAoY3V0U3JjLmxlbmd0aCAhPT0gc3JjLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRleHQoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIGxhc3RUb2tlbi50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnJhdyArPSAnXFxuJyArIHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZVF1ZXVlW3RoaXMuaW5saW5lUXVldWUubGVuZ3RoIC0gMV0uc3JjID0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNyYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNpbGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUudG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgaW5saW5lKHNyYywgdG9rZW5zID0gW10pIHtcbiAgICAgICAgdGhpcy5pbmxpbmVRdWV1ZS5wdXNoKHsgc3JjLCB0b2tlbnMgfSk7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExleGluZy9Db21waWxpbmdcbiAgICAgKi9cbiAgICBpbmxpbmVUb2tlbnMoc3JjLCB0b2tlbnMgPSBbXSkge1xuICAgICAgICBsZXQgdG9rZW4sIGxhc3RUb2tlbiwgY3V0U3JjO1xuICAgICAgICAvLyBTdHJpbmcgd2l0aCBsaW5rcyBtYXNrZWQgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIHdpdGggZW0gYW5kIHN0cm9uZ1xuICAgICAgICBsZXQgbWFza2VkU3JjID0gc3JjO1xuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIGxldCBrZWVwUHJldkNoYXIsIHByZXZDaGFyO1xuICAgICAgICAvLyBNYXNrIG91dCByZWZsaW5rc1xuICAgICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gdGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2guZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5rcy5pbmNsdWRlcyhtYXRjaFswXS5zbGljZShtYXRjaFswXS5sYXN0SW5kZXhPZignWycpICsgMSwgLTEpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFza2VkU3JjID0gbWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArICdbJyArICdhJy5yZXBlYXQobWF0Y2hbMF0ubGVuZ3RoIC0gMikgKyAnXScgKyBtYXNrZWRTcmMuc2xpY2UodGhpcy50b2tlbml6ZXIucnVsZXMuaW5saW5lLnJlZmxpbmtTZWFyY2gubGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYXNrIG91dCBvdGhlciBibG9ja3NcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5ibG9ja1NraXAuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgJ2EnLnJlcGVhdChtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFzayBvdXQgZXNjYXBlZCBjaGFyYWN0ZXJzXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24uZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJysrJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYW55UHVuY3R1YXRpb24ubGFzdEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBQcmV2Q2hhcikge1xuICAgICAgICAgICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZWVwUHJldkNoYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZVxuICAgICAgICAgICAgICAgICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLmlubGluZS5zb21lKChleHRUb2tlbml6ZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuID0gZXh0VG9rZW5pemVyLmNhbGwoeyBsZXhlcjogdGhpcyB9LCBzcmMsIHRva2VucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzY2FwZVxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZXNjYXBlKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRhZ1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGFnKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiB0b2tlbi50eXBlID09PSAndGV4dCcgJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9IHRva2VuLnJhdztcbiAgICAgICAgICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gdG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsaW5rXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFRva2VuICYmIHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtICYgc3Ryb25nXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5lbVN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb2RlXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5jb2Rlc3BhbihzcmMpKSB7XG4gICAgICAgICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBiclxuICAgICAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZGVsIChnZm0pXG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWwoc3JjKSkge1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0b2xpbmtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmF1dG9saW5rKHNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVybCAoZ2ZtKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjKSkpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRleHRcbiAgICAgICAgICAgIC8vIHByZXZlbnQgaW5saW5lVGV4dCBjb25zdW1pbmcgZXh0ZW5zaW9ucyBieSBjbGlwcGluZyAnc3JjJyB0byBleHRlbnNpb24gc3RhcnRcbiAgICAgICAgICAgIGN1dFNyYyA9IHNyYztcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5zdGFydElubGluZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcFNyYyA9IHNyYy5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBsZXQgdGVtcFN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnN0YXJ0SW5saW5lLmZvckVhY2goKGdldFN0YXJ0SW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcFN0YXJ0ID0gZ2V0U3RhcnRJbmRleC5jYWxsKHsgbGV4ZXI6IHRoaXMgfSwgdGVtcFNyYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcFN0YXJ0ID09PSAnbnVtYmVyJyAmJiB0ZW1wU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IE1hdGgubWluKHN0YXJ0SW5kZXgsIHRlbXBTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRJbmRleCA8IEluZmluaXR5ICYmIHN0YXJ0SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXRTcmMgPSBzcmMuc3Vic3RyaW5nKDAsIHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5pbmxpbmVUZXh0KGN1dFNyYykpIHtcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5yYXcuc2xpY2UoLTEpICE9PSAnXycpIHsgLy8gVHJhY2sgcHJldkNoYXIgYmVmb3JlIHN0cmluZyBvZiBfX19fIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgcHJldkNoYXIgPSB0b2tlbi5yYXcuc2xpY2UoLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZWVwUHJldkNoYXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gdG9rZW4ucmF3O1xuICAgICAgICAgICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSB0b2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSAnSW5maW5pdGUgbG9vcCBvbiBieXRlOiAnICsgc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBfZGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzLnRzJztcbmltcG9ydCB7IGNsZWFuVXJsLCBlc2NhcGUgfSBmcm9tICcuL2hlbHBlcnMudHMnO1xuLyoqXG4gKiBSZW5kZXJlclxuICovXG5leHBvcnQgY2xhc3MgX1JlbmRlcmVyIHtcbiAgICBvcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgfVxuICAgIGNvZGUoY29kZSwgaW5mb3N0cmluZywgZXNjYXBlZCkge1xuICAgICAgICBjb25zdCBsYW5nID0gKGluZm9zdHJpbmcgfHwgJycpLm1hdGNoKC9eXFxTKi8pPy5bMF07XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoL1xcbiQvLCAnJykgKyAnXFxuJztcbiAgICAgICAgaWYgKCFsYW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+J1xuICAgICAgICAgICAgICAgICsgKGVzY2FwZWQgPyBjb2RlIDogZXNjYXBlKGNvZGUsIHRydWUpKVxuICAgICAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnPHByZT48Y29kZSBjbGFzcz1cImxhbmd1YWdlLSdcbiAgICAgICAgICAgICsgZXNjYXBlKGxhbmcpXG4gICAgICAgICAgICArICdcIj4nXG4gICAgICAgICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgIH1cbiAgICBibG9ja3F1b3RlKHF1b3RlKSB7XG4gICAgICAgIHJldHVybiBgPGJsb2NrcXVvdGU+XFxuJHtxdW90ZX08L2Jsb2NrcXVvdGU+XFxuYDtcbiAgICB9XG4gICAgaHRtbChodG1sLCBibG9jaykge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgaGVhZGluZyh0ZXh0LCBsZXZlbCwgcmF3KSB7XG4gICAgICAgIC8vIGlnbm9yZSBJRHNcbiAgICAgICAgcmV0dXJuIGA8aCR7bGV2ZWx9PiR7dGV4dH08L2gke2xldmVsfT5cXG5gO1xuICAgIH1cbiAgICBocigpIHtcbiAgICAgICAgcmV0dXJuICc8aHI+XFxuJztcbiAgICB9XG4gICAgbGlzdChib2R5LCBvcmRlcmVkLCBzdGFydCkge1xuICAgICAgICBjb25zdCB0eXBlID0gb3JkZXJlZCA/ICdvbCcgOiAndWwnO1xuICAgICAgICBjb25zdCBzdGFydGF0dCA9IChvcmRlcmVkICYmIHN0YXJ0ICE9PSAxKSA/ICgnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJykgOiAnJztcbiAgICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9XG4gICAgbGlzdGl0ZW0odGV4dCwgdGFzaywgY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gYDxsaT4ke3RleHR9PC9saT5cXG5gO1xuICAgIH1cbiAgICBjaGVja2JveChjaGVja2VkKSB7XG4gICAgICAgIHJldHVybiAnPGlucHV0ICdcbiAgICAgICAgICAgICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJylcbiAgICAgICAgICAgICsgJ2Rpc2FibGVkPVwiXCIgdHlwZT1cImNoZWNrYm94XCI+JztcbiAgICB9XG4gICAgcGFyYWdyYXBoKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8cD4ke3RleHR9PC9wPlxcbmA7XG4gICAgfVxuICAgIHRhYmxlKGhlYWRlciwgYm9keSkge1xuICAgICAgICBpZiAoYm9keSlcbiAgICAgICAgICAgIGJvZHkgPSBgPHRib2R5PiR7Ym9keX08L3Rib2R5PmA7XG4gICAgICAgIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICAgICAgICAgICsgJzx0aGVhZD5cXG4nXG4gICAgICAgICAgICArIGhlYWRlclxuICAgICAgICAgICAgKyAnPC90aGVhZD5cXG4nXG4gICAgICAgICAgICArIGJvZHlcbiAgICAgICAgICAgICsgJzwvdGFibGU+XFxuJztcbiAgICB9XG4gICAgdGFibGVyb3coY29udGVudCkge1xuICAgICAgICByZXR1cm4gYDx0cj5cXG4ke2NvbnRlbnR9PC90cj5cXG5gO1xuICAgIH1cbiAgICB0YWJsZWNlbGwoY29udGVudCwgZmxhZ3MpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgICBjb25zdCB0YWcgPSBmbGFncy5hbGlnblxuICAgICAgICAgICAgPyBgPCR7dHlwZX0gYWxpZ249XCIke2ZsYWdzLmFsaWdufVwiPmBcbiAgICAgICAgICAgIDogYDwke3R5cGV9PmA7XG4gICAgICAgIHJldHVybiB0YWcgKyBjb250ZW50ICsgYDwvJHt0eXBlfT5cXG5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzcGFuIGxldmVsIHJlbmRlcmVyXG4gICAgICovXG4gICAgc3Ryb25nKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8c3Ryb25nPiR7dGV4dH08L3N0cm9uZz5gO1xuICAgIH1cbiAgICBlbSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBgPGVtPiR7dGV4dH08L2VtPmA7XG4gICAgfVxuICAgIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGA8Y29kZT4ke3RleHR9PC9jb2RlPmA7XG4gICAgfVxuICAgIGJyKCkge1xuICAgICAgICByZXR1cm4gJzxicj4nO1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gYDxkZWw+JHt0ZXh0fTwvZGVsPmA7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgY29uc3QgY2xlYW5IcmVmID0gY2xlYW5VcmwoaHJlZik7XG4gICAgICAgIGlmIChjbGVhbkhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGhyZWYgPSBjbGVhbkhyZWY7XG4gICAgICAgIGxldCBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICAgIH1cbiAgICAgICAgb3V0ICs9ICc+JyArIHRleHQgKyAnPC9hPic7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNsZWFuSHJlZiA9IGNsZWFuVXJsKGhyZWYpO1xuICAgICAgICBpZiAoY2xlYW5IcmVmID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBocmVmID0gY2xlYW5IcmVmO1xuICAgICAgICBsZXQgb3V0ID0gYDxpbWcgc3JjPVwiJHtocmVmfVwiIGFsdD1cIiR7dGV4dH1cImA7XG4gICAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICAgICAgb3V0ICs9IGAgdGl0bGU9XCIke3RpdGxlfVwiYDtcbiAgICAgICAgfVxuICAgICAgICBvdXQgKz0gJz4nO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB0ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuIiwgIi8qKlxuICogVGV4dFJlbmRlcmVyXG4gKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAqL1xuZXhwb3J0IGNsYXNzIF9UZXh0UmVuZGVyZXIge1xuICAgIC8vIG5vIG5lZWQgZm9yIGJsb2NrIGxldmVsIHJlbmRlcmVyc1xuICAgIHN0cm9uZyh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBlbSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb2Rlc3Bhbih0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBkZWwodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgaHRtbCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB0ZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGV4dDtcbiAgICB9XG4gICAgYnIoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgX1JlbmRlcmVyIH0gZnJvbSAnLi9SZW5kZXJlci50cyc7XG5pbXBvcnQgeyBfVGV4dFJlbmRlcmVyIH0gZnJvbSAnLi9UZXh0UmVuZGVyZXIudHMnO1xuaW1wb3J0IHsgX2RlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy50cyc7XG5pbXBvcnQgeyB1bmVzY2FwZSB9IGZyb20gJy4vaGVscGVycy50cyc7XG4vKipcbiAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIF9QYXJzZXIge1xuICAgIG9wdGlvbnM7XG4gICAgcmVuZGVyZXI7XG4gICAgdGV4dFJlbmRlcmVyO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBfZGVmYXVsdHM7XG4gICAgICAgIHRoaXMub3B0aW9ucy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgX1JlbmRlcmVyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgX1RleHRSZW5kZXJlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgTWV0aG9kXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgX1BhcnNlcihvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUlubGluZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IF9QYXJzZXIob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VJbmxpbmUodG9rZW5zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgTG9vcFxuICAgICAqL1xuICAgIHBhcnNlKHRva2VucywgdG9wID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIC8vIFJ1biBhbnkgcmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRlbnNpb25zICYmIHRoaXMub3B0aW9ucy5leHRlbnNpb25zLnJlbmRlcmVycyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbdG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZ2VuZXJpY1Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgZ2VuZXJpY1Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSBmYWxzZSB8fCAhWydzcGFjZScsICdocicsICdoZWFkaW5nJywgJ2NvZGUnLCAndGFibGUnLCAnYmxvY2txdW90ZScsICdsaXN0JywgJ2h0bWwnLCAncGFyYWdyYXBoJywgJ3RleHQnXS5pbmNsdWRlcyhnZW5lcmljVG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdocic6IHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2hlYWRpbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRpbmdUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5oZWFkaW5nKHRoaXMucGFyc2VJbmxpbmUoaGVhZGluZ1Rva2VuLnRva2VucyksIGhlYWRpbmdUb2tlbi5kZXB0aCwgdW5lc2NhcGUodGhpcy5wYXJzZUlubGluZShoZWFkaW5nVG9rZW4udG9rZW5zLCB0aGlzLnRleHRSZW5kZXJlcikpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKGNvZGVUb2tlbi50ZXh0LCBjb2RlVG9rZW4ubGFuZywgISFjb2RlVG9rZW4uZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGVhZGVyID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhYmxlVG9rZW4uaGVhZGVyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKHRoaXMucGFyc2VJbmxpbmUodGFibGVUb2tlbi5oZWFkZXJbal0udG9rZW5zKSwgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0YWJsZVRva2VuLmFsaWduW2pdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYm9keSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRhYmxlVG9rZW4ucm93cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gdGFibGVUb2tlbi5yb3dzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCByb3cubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKHRoaXMucGFyc2VJbmxpbmUocm93W2tdLnRva2VucyksIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRhYmxlVG9rZW4uYWxpZ25ba10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIudGFibGUoaGVhZGVyLCBib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrcXVvdGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5wYXJzZShibG9ja3F1b3RlVG9rZW4udG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYmxvY2txdW90ZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2xpc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkID0gbGlzdFRva2VuLm9yZGVyZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbGlzdFRva2VuLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29zZSA9IGxpc3RUb2tlbi5sb29zZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaXN0VG9rZW4uaXRlbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0VG9rZW4uaXRlbXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja2VkID0gaXRlbS5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IGl0ZW0udGFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtQm9keSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jaGVja2JveCghIWNoZWNrZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb29zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnMubGVuZ3RoID4gMCAmJiBpdGVtLnRva2Vuc1swXS50eXBlID09PSAncGFyYWdyYXBoJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnNbMF0udGV4dCA9IGNoZWNrYm94ICsgJyAnICsgaXRlbS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vuc1swXS50b2tlbnMgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zLmxlbmd0aCA+IDAgJiYgaXRlbS50b2tlbnNbMF0udG9rZW5zWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveCArICcgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IGNoZWNrYm94ICsgJyAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Cb2R5ICs9IHRoaXMucGFyc2UoaXRlbS50b2tlbnMsIGxvb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKz0gdGhpcy5yZW5kZXJlci5saXN0aXRlbShpdGVtQm9keSwgdGFzaywgISFjaGVja2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5saXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGh0bWxUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5odG1sKGh0bWxUb2tlbi50ZXh0LCBodG1sVG9rZW4uYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZUlubGluZShwYXJhZ3JhcGhUb2tlbi50b2tlbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvZHkgPSB0ZXh0VG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0ZXh0VG9rZW4udG9rZW5zKSA6IHRleHRUb2tlbi50ZXh0O1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSArIDEgPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpICsgMV0udHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0VG9rZW4gPSB0b2tlbnNbKytpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKz0gJ1xcbicgKyAodGV4dFRva2VuLnRva2VucyA/IHRoaXMucGFyc2VJbmxpbmUodGV4dFRva2VuLnRva2VucykgOiB0ZXh0VG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRvcCA/IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKGJvZHkpIDogYm9keTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIElubGluZSBUb2tlbnNcbiAgICAgKi9cbiAgICBwYXJzZUlubGluZSh0b2tlbnMsIHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyID0gcmVuZGVyZXIgfHwgdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBSdW4gYW55IHJlbmRlcmVyIGV4dGVuc2lvbnNcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucyAmJiB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5yZW5kZXJlcnMgJiYgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMucmVuZGVyZXJzW3Rva2VuLnR5cGVdLmNhbGwoeyBwYXJzZXI6IHRoaXMgfSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IGZhbHNlIHx8ICFbJ2VzY2FwZScsICdodG1sJywgJ2xpbmsnLCAnaW1hZ2UnLCAnc3Ryb25nJywgJ2VtJywgJ2NvZGVzcGFuJywgJ2JyJywgJ2RlbCcsICd0ZXh0J10uaW5jbHVkZXModG9rZW4udHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHJldCB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXNjYXBlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dChlc2NhcGVUb2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2h0bWwnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5odG1sKHRhZ1Rva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbGluayc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKGxpbmtUb2tlbi5ocmVmLCBsaW5rVG9rZW4udGl0bGUsIHRoaXMucGFyc2VJbmxpbmUobGlua1Rva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZShpbWFnZVRva2VuLmhyZWYsIGltYWdlVG9rZW4udGl0bGUsIGltYWdlVG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdzdHJvbmcnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0cm9uZ1Rva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5zdHJvbmcodGhpcy5wYXJzZUlubGluZShzdHJvbmdUb2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdlbSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW1Ub2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZW0odGhpcy5wYXJzZUlubGluZShlbVRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGVzcGFuJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2Rlc3BhblRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbihjb2Rlc3BhblRva2VuLnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnYnInOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5icigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZGVsJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIuZGVsKHRoaXMucGFyc2VJbmxpbmUoZGVsVG9rZW4udG9rZW5zLCByZW5kZXJlcikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFRva2VuID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRleHRUb2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gJ1Rva2VuIHdpdGggXCInICsgdG9rZW4udHlwZSArICdcIiB0eXBlIHdhcyBub3QgZm91bmQuJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IF9kZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMudHMnO1xuZXhwb3J0IGNsYXNzIF9Ib29rcyB7XG4gICAgb3B0aW9ucztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgX2RlZmF1bHRzO1xuICAgIH1cbiAgICBzdGF0aWMgcGFzc1Rocm91Z2hIb29rcyA9IG5ldyBTZXQoW1xuICAgICAgICAncHJlcHJvY2VzcycsXG4gICAgICAgICdwb3N0cHJvY2VzcydcbiAgICBdKTtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIG1hcmtkb3duIGJlZm9yZSBtYXJrZWRcbiAgICAgKi9cbiAgICBwcmVwcm9jZXNzKG1hcmtkb3duKSB7XG4gICAgICAgIHJldHVybiBtYXJrZG93bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBIVE1MIGFmdGVyIG1hcmtlZCBpcyBmaW5pc2hlZFxuICAgICAqL1xuICAgIHBvc3Rwcm9jZXNzKGh0bWwpIHtcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IF9nZXREZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMudHMnO1xuaW1wb3J0IHsgX0xleGVyIH0gZnJvbSAnLi9MZXhlci50cyc7XG5pbXBvcnQgeyBfUGFyc2VyIH0gZnJvbSAnLi9QYXJzZXIudHMnO1xuaW1wb3J0IHsgX0hvb2tzIH0gZnJvbSAnLi9Ib29rcy50cyc7XG5pbXBvcnQgeyBfUmVuZGVyZXIgfSBmcm9tICcuL1JlbmRlcmVyLnRzJztcbmltcG9ydCB7IF9Ub2tlbml6ZXIgfSBmcm9tICcuL1Rva2VuaXplci50cyc7XG5pbXBvcnQgeyBfVGV4dFJlbmRlcmVyIH0gZnJvbSAnLi9UZXh0UmVuZGVyZXIudHMnO1xuaW1wb3J0IHsgZXNjYXBlIH0gZnJvbSAnLi9oZWxwZXJzLnRzJztcbmV4cG9ydCBjbGFzcyBNYXJrZWQge1xuICAgIGRlZmF1bHRzID0gX2dldERlZmF1bHRzKCk7XG4gICAgb3B0aW9ucyA9IHRoaXMuc2V0T3B0aW9ucztcbiAgICBwYXJzZSA9IHRoaXMuI3BhcnNlTWFya2Rvd24oX0xleGVyLmxleCwgX1BhcnNlci5wYXJzZSk7XG4gICAgcGFyc2VJbmxpbmUgPSB0aGlzLiNwYXJzZU1hcmtkb3duKF9MZXhlci5sZXhJbmxpbmUsIF9QYXJzZXIucGFyc2VJbmxpbmUpO1xuICAgIFBhcnNlciA9IF9QYXJzZXI7XG4gICAgUmVuZGVyZXIgPSBfUmVuZGVyZXI7XG4gICAgVGV4dFJlbmRlcmVyID0gX1RleHRSZW5kZXJlcjtcbiAgICBMZXhlciA9IF9MZXhlcjtcbiAgICBUb2tlbml6ZXIgPSBfVG9rZW5pemVyO1xuICAgIEhvb2tzID0gX0hvb2tzO1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy51c2UoLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAgICAgKi9cbiAgICB3YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdChjYWxsYmFjay5jYWxsKHRoaXMsIHRva2VuKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFibGVUb2tlbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGFibGVUb2tlbi5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRhYmxlVG9rZW4ucm93cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHJvdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodGhpcy53YWxrVG9rZW5zKGNlbGwudG9rZW5zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdsaXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMobGlzdFRva2VuLml0ZW1zLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmljVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucz8uY2hpbGRUb2tlbnM/LltnZW5lcmljVG9rZW4udHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdHMuZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tnZW5lcmljVG9rZW4udHlwZV0uZm9yRWFjaCgoY2hpbGRUb2tlbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHRoaXMud2Fsa1Rva2VucyhnZW5lcmljVG9rZW5bY2hpbGRUb2tlbnNdLCBjYWxsYmFjaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZ2VuZXJpY1Rva2VuLnRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh0aGlzLndhbGtUb2tlbnMoZ2VuZXJpY1Rva2VuLnRva2VucywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICB1c2UoLi4uYXJncykge1xuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gdGhpcy5kZWZhdWx0cy5leHRlbnNpb25zIHx8IHsgcmVuZGVyZXJzOiB7fSwgY2hpbGRUb2tlbnM6IHt9IH07XG4gICAgICAgIGFyZ3MuZm9yRWFjaCgocGFjaykgPT4ge1xuICAgICAgICAgICAgLy8gY29weSBvcHRpb25zIHRvIG5ldyBvYmplY3RcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSB7IC4uLnBhY2sgfTtcbiAgICAgICAgICAgIC8vIHNldCBhc3luYyB0byB0cnVlIGlmIGl0IHdhcyBzZXQgdG8gdHJ1ZSBiZWZvcmVcbiAgICAgICAgICAgIG9wdHMuYXN5bmMgPSB0aGlzLmRlZmF1bHRzLmFzeW5jIHx8IG9wdHMuYXN5bmMgfHwgZmFsc2U7XG4gICAgICAgICAgICAvLyA9PS0tIFBhcnNlIFwiYWRkb25cIiBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLmV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgICAgICBwYWNrLmV4dGVuc2lvbnMuZm9yRWFjaCgoZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXh0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXh0ZW5zaW9uIG5hbWUgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3JlbmRlcmVyJyBpbiBleHQpIHsgLy8gUmVuZGVyZXIgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldlJlbmRlcmVyID0gZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZSZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgZXh0ZW5zaW9uIHdpdGggZnVuYyB0byBydW4gbmV3IGV4dGVuc2lvbiBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5yZW5kZXJlcnNbZXh0Lm5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IGV4dC5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zLnJlbmRlcmVyc1tleHQubmFtZV0gPSBleHQucmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0b2tlbml6ZXInIGluIGV4dCkgeyAvLyBUb2tlbml6ZXIgRXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleHQubGV2ZWwgfHwgKGV4dC5sZXZlbCAhPT0gJ2Jsb2NrJyAmJiBleHQubGV2ZWwgIT09ICdpbmxpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuc2lvbiBsZXZlbCBtdXN0IGJlICdibG9jaycgb3IgJ2lubGluZSdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRMZXZlbCA9IGV4dGVuc2lvbnNbZXh0LmxldmVsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHRMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dExldmVsLnVuc2hpZnQoZXh0LnRva2VuaXplcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25zW2V4dC5sZXZlbF0gPSBbZXh0LnRva2VuaXplcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0LnN0YXJ0KSB7IC8vIEZ1bmN0aW9uIHRvIGNoZWNrIGZvciBzdGFydCBvZiB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHQubGV2ZWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydEJsb2NrLnB1c2goZXh0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRCbG9jayA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV4dC5sZXZlbCA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbnMuc3RhcnRJbmxpbmUucHVzaChleHQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5zdGFydElubGluZSA9IFtleHQuc3RhcnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgnY2hpbGRUb2tlbnMnIGluIGV4dCAmJiBleHQuY2hpbGRUb2tlbnMpIHsgLy8gQ2hpbGQgdG9rZW5zIHRvIGJlIHZpc2l0ZWQgYnkgd2Fsa1Rva2Vuc1xuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucy5jaGlsZFRva2Vuc1tleHQubmFtZV0gPSBleHQuY2hpbGRUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvcHRzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBcIm92ZXJ3cml0ZVwiIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2sucmVuZGVyZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlciA9IHRoaXMuZGVmYXVsdHMucmVuZGVyZXIgfHwgbmV3IF9SZW5kZXJlcih0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5yZW5kZXJlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlckZ1bmMgPSBwYWNrLnJlbmRlcmVyW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlcktleSA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3JlbmRlcmVyS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSByZW5kZXJlciB3aXRoIGZ1bmMgdG8gcnVuIGV4dGVuc2lvbiwgYnV0IGZhbGwgYmFjayBpZiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlcltyZW5kZXJlcktleV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJldCA9IHJlbmRlcmVyRnVuYy5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXIgPSB0aGlzLmRlZmF1bHRzLnRva2VuaXplciB8fCBuZXcgX1Rva2VuaXplcih0aGlzLmRlZmF1bHRzKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay50b2tlbml6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5pemVyRnVuYyA9IHBhY2sudG9rZW5pemVyW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbml6ZXJLZXkgPSBwcm9wO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2VG9rZW5pemVyID0gdG9rZW5pemVyW3Rva2VuaXplcktleV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdG9rZW5pemVyIHdpdGggZnVuYyB0byBydW4gZXh0ZW5zaW9uLCBidXQgZmFsbCBiYWNrIGlmIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRva2VuaXplclt0b2tlbml6ZXJLZXldID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSB0b2tlbml6ZXJGdW5jLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZUb2tlbml6ZXIuYXBwbHkodG9rZW5pemVyLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBIb29rcyBleHRlbnNpb25zIC0tPT0gLy9cbiAgICAgICAgICAgIGlmIChwYWNrLmhvb2tzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9va3MgPSB0aGlzLmRlZmF1bHRzLmhvb2tzIHx8IG5ldyBfSG9va3MoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcGFjay5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob29rc0Z1bmMgPSBwYWNrLmhvb2tzW3Byb3BdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob29rc0tleSA9IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZIb29rID0gaG9va3NbaG9va3NLZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX0hvb2tzLnBhc3NUaHJvdWdoSG9va3MuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rc1tob29rc0tleV0gPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob29rc0Z1bmMuY2FsbChob29rcywgYXJnKSkudGhlbihyZXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZIb29rLmNhbGwoaG9va3MsIHJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSBob29rc0Z1bmMuY2FsbChob29rcywgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldkhvb2suY2FsbChob29rcywgcmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob29rc1tob29rc0tleV0gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXQgPSBob29rc0Z1bmMuYXBwbHkoaG9va3MsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IHByZXZIb29rLmFwcGx5KGhvb2tzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5ob29rcyA9IGhvb2tzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gPT0tLSBQYXJzZSBXYWxrVG9rZW5zIGV4dGVuc2lvbnMgLS09PSAvL1xuICAgICAgICAgICAgaWYgKHBhY2sud2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGtUb2tlbnMgPSB0aGlzLmRlZmF1bHRzLndhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFja1dhbGt0b2tlbnMgPSBwYWNrLndhbGtUb2tlbnM7XG4gICAgICAgICAgICAgICAgb3B0cy53YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFja1dhbGt0b2tlbnMuY2FsbCh0aGlzLCB0b2tlbikpO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2Fsa1Rva2Vucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh3YWxrVG9rZW5zLmNhbGwodGhpcywgdG9rZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRzID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcHRzIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHQpIHtcbiAgICAgICAgdGhpcy5kZWZhdWx0cyA9IHsgLi4udGhpcy5kZWZhdWx0cywgLi4ub3B0IH07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXhlcihzcmMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9MZXhlci5sZXgoc3JjLCBvcHRpb25zID8/IHRoaXMuZGVmYXVsdHMpO1xuICAgIH1cbiAgICBwYXJzZXIodG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfUGFyc2VyLnBhcnNlKHRva2Vucywgb3B0aW9ucyA/PyB0aGlzLmRlZmF1bHRzKTtcbiAgICB9XG4gICAgI3BhcnNlTWFya2Rvd24obGV4ZXIsIHBhcnNlcikge1xuICAgICAgICByZXR1cm4gKHNyYywgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ09wdCA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3Qgb3B0ID0geyAuLi50aGlzLmRlZmF1bHRzLCAuLi5vcmlnT3B0IH07XG4gICAgICAgICAgICAvLyBTaG93IHdhcm5pbmcgaWYgYW4gZXh0ZW5zaW9uIHNldCBhc3luYyB0byB0cnVlIGJ1dCB0aGUgcGFyc2Ugd2FzIGNhbGxlZCB3aXRoIGFzeW5jOiBmYWxzZVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdHMuYXN5bmMgPT09IHRydWUgJiYgb3JpZ09wdC5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdC5zaWxlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogVGhlIGFzeW5jIG9wdGlvbiB3YXMgc2V0IHRvIHRydWUgYnkgYW4gZXh0ZW5zaW9uLiBUaGUgYXN5bmM6IGZhbHNlIG9wdGlvbiBzZW50IHRvIHBhcnNlIHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRocm93RXJyb3IgPSB0aGlzLiNvbkVycm9yKCEhb3B0LnNpbGVudCwgISFvcHQuYXN5bmMpO1xuICAgICAgICAgICAgLy8gdGhyb3cgZXJyb3IgaW4gY2FzZSBvZiBub24gc3RyaW5nIGlucHV0XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIHVuZGVmaW5lZCBvciBudWxsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRocm93RXJyb3IobmV3IEVycm9yKCdtYXJrZWQoKTogaW5wdXQgcGFyYW1ldGVyIGlzIG9mIHR5cGUgJ1xuICAgICAgICAgICAgICAgICAgICArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpICsgJywgc3RyaW5nIGV4cGVjdGVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgIG9wdC5ob29rcy5vcHRpb25zID0gb3B0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3B0Lmhvb2tzID8gb3B0Lmhvb2tzLnByZXByb2Nlc3Moc3JjKSA6IHNyYylcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oc3JjID0+IGxleGVyKHNyYywgb3B0KSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4odG9rZW5zID0+IG9wdC53YWxrVG9rZW5zID8gUHJvbWlzZS5hbGwodGhpcy53YWxrVG9rZW5zKHRva2Vucywgb3B0LndhbGtUb2tlbnMpKS50aGVuKCgpID0+IHRva2VucykgOiB0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHRva2VucyA9PiBwYXJzZXIodG9rZW5zLCBvcHQpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihodG1sID0+IG9wdC5ob29rcyA/IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKSA6IGh0bWwpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aHJvd0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5ob29rcykge1xuICAgICAgICAgICAgICAgICAgICBzcmMgPSBvcHQuaG9va3MucHJlcHJvY2VzcyhzcmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbnMgPSBsZXhlcihzcmMsIG9wdCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGh0bWwgPSBwYXJzZXIodG9rZW5zLCBvcHQpO1xuICAgICAgICAgICAgICAgIGlmIChvcHQuaG9va3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaHRtbCA9IG9wdC5ob29rcy5wb3N0cHJvY2VzcyhodG1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAjb25FcnJvcihzaWxlbnQsIGFzeW5jKSB7XG4gICAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICAgICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuICAgICAgICAgICAgaWYgKHNpbGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICc8cD5BbiBlcnJvciBvY2N1cnJlZDo8L3A+PHByZT4nXG4gICAgICAgICAgICAgICAgICAgICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICArICc8L3ByZT4nO1xuICAgICAgICAgICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtc2c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9O1xuICAgIH1cbn1cbiIsICJpbXBvcnQgeyBfTGV4ZXIgfSBmcm9tICcuL0xleGVyLnRzJztcbmltcG9ydCB7IF9QYXJzZXIgfSBmcm9tICcuL1BhcnNlci50cyc7XG5pbXBvcnQgeyBfVG9rZW5pemVyIH0gZnJvbSAnLi9Ub2tlbml6ZXIudHMnO1xuaW1wb3J0IHsgX1JlbmRlcmVyIH0gZnJvbSAnLi9SZW5kZXJlci50cyc7XG5pbXBvcnQgeyBfVGV4dFJlbmRlcmVyIH0gZnJvbSAnLi9UZXh0UmVuZGVyZXIudHMnO1xuaW1wb3J0IHsgX0hvb2tzIH0gZnJvbSAnLi9Ib29rcy50cyc7XG5pbXBvcnQgeyBNYXJrZWQgfSBmcm9tICcuL0luc3RhbmNlLnRzJztcbmltcG9ydCB7IF9nZXREZWZhdWx0cywgY2hhbmdlRGVmYXVsdHMsIF9kZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMudHMnO1xuY29uc3QgbWFya2VkSW5zdGFuY2UgPSBuZXcgTWFya2VkKCk7XG5leHBvcnQgZnVuY3Rpb24gbWFya2VkKHNyYywgb3B0KSB7XG4gICAgcmV0dXJuIG1hcmtlZEluc3RhbmNlLnBhcnNlKHNyYywgb3B0KTtcbn1cbi8qKlxuICogU2V0cyB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEhhc2ggb2Ygb3B0aW9uc1xuICovXG5tYXJrZWQub3B0aW9ucyA9XG4gICAgbWFya2VkLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBtYXJrZWRJbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBtYXJrZWQuZGVmYXVsdHMgPSBtYXJrZWRJbnN0YW5jZS5kZWZhdWx0cztcbiAgICAgICAgY2hhbmdlRGVmYXVsdHMobWFya2VkLmRlZmF1bHRzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtlZDtcbiAgICB9O1xuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBtYXJrZWQgZGVmYXVsdCBvcHRpb25zLlxuICovXG5tYXJrZWQuZ2V0RGVmYXVsdHMgPSBfZ2V0RGVmYXVsdHM7XG5tYXJrZWQuZGVmYXVsdHMgPSBfZGVmYXVsdHM7XG4vKipcbiAqIFVzZSBFeHRlbnNpb25cbiAqL1xubWFya2VkLnVzZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgbWFya2VkSW5zdGFuY2UudXNlKC4uLmFyZ3MpO1xuICAgIG1hcmtlZC5kZWZhdWx0cyA9IG1hcmtlZEluc3RhbmNlLmRlZmF1bHRzO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbn07XG4vKipcbiAqIFJ1biBjYWxsYmFjayBmb3IgZXZlcnkgdG9rZW5cbiAqL1xubWFya2VkLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBtYXJrZWRJbnN0YW5jZS53YWxrVG9rZW5zKHRva2VucywgY2FsbGJhY2spO1xufTtcbi8qKlxuICogQ29tcGlsZXMgbWFya2Rvd24gdG8gSFRNTCB3aXRob3V0IGVuY2xvc2luZyBgcGAgdGFnLlxuICpcbiAqIEBwYXJhbSBzcmMgU3RyaW5nIG9mIG1hcmtkb3duIHNvdXJjZSB0byBiZSBjb21waWxlZFxuICogQHBhcmFtIG9wdGlvbnMgSGFzaCBvZiBvcHRpb25zXG4gKiBAcmV0dXJuIFN0cmluZyBvZiBjb21waWxlZCBIVE1MXG4gKi9cbm1hcmtlZC5wYXJzZUlubGluZSA9IG1hcmtlZEluc3RhbmNlLnBhcnNlSW5saW5lO1xuLyoqXG4gKiBFeHBvc2VcbiAqL1xubWFya2VkLlBhcnNlciA9IF9QYXJzZXI7XG5tYXJrZWQucGFyc2VyID0gX1BhcnNlci5wYXJzZTtcbm1hcmtlZC5SZW5kZXJlciA9IF9SZW5kZXJlcjtcbm1hcmtlZC5UZXh0UmVuZGVyZXIgPSBfVGV4dFJlbmRlcmVyO1xubWFya2VkLkxleGVyID0gX0xleGVyO1xubWFya2VkLmxleGVyID0gX0xleGVyLmxleDtcbm1hcmtlZC5Ub2tlbml6ZXIgPSBfVG9rZW5pemVyO1xubWFya2VkLkhvb2tzID0gX0hvb2tzO1xubWFya2VkLnBhcnNlID0gbWFya2VkO1xuZXhwb3J0IGNvbnN0IG9wdGlvbnMgPSBtYXJrZWQub3B0aW9ucztcbmV4cG9ydCBjb25zdCBzZXRPcHRpb25zID0gbWFya2VkLnNldE9wdGlvbnM7XG5leHBvcnQgY29uc3QgdXNlID0gbWFya2VkLnVzZTtcbmV4cG9ydCBjb25zdCB3YWxrVG9rZW5zID0gbWFya2VkLndhbGtUb2tlbnM7XG5leHBvcnQgY29uc3QgcGFyc2VJbmxpbmUgPSBtYXJrZWQucGFyc2VJbmxpbmU7XG5leHBvcnQgY29uc3QgcGFyc2UgPSBtYXJrZWQ7XG5leHBvcnQgY29uc3QgcGFyc2VyID0gX1BhcnNlci5wYXJzZTtcbmV4cG9ydCBjb25zdCBsZXhlciA9IF9MZXhlci5sZXg7XG5leHBvcnQgeyBfZGVmYXVsdHMgYXMgZGVmYXVsdHMsIF9nZXREZWZhdWx0cyBhcyBnZXREZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMudHMnO1xuZXhwb3J0IHsgX0xleGVyIGFzIExleGVyIH0gZnJvbSAnLi9MZXhlci50cyc7XG5leHBvcnQgeyBfUGFyc2VyIGFzIFBhcnNlciB9IGZyb20gJy4vUGFyc2VyLnRzJztcbmV4cG9ydCB7IF9Ub2tlbml6ZXIgYXMgVG9rZW5pemVyIH0gZnJvbSAnLi9Ub2tlbml6ZXIudHMnO1xuZXhwb3J0IHsgX1JlbmRlcmVyIGFzIFJlbmRlcmVyIH0gZnJvbSAnLi9SZW5kZXJlci50cyc7XG5leHBvcnQgeyBfVGV4dFJlbmRlcmVyIGFzIFRleHRSZW5kZXJlciB9IGZyb20gJy4vVGV4dFJlbmRlcmVyLnRzJztcbmV4cG9ydCB7IF9Ib29rcyBhcyBIb29rcyB9IGZyb20gJy4vSG9va3MudHMnO1xuZXhwb3J0IHsgTWFya2VkIH0gZnJvbSAnLi9JbnN0YW5jZS50cyc7XG4iLCAiLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjMuNFxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDI0IEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpLCAwLCAxMDApO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5cbmNvbnN0IG1hcCQxID0gezA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsIDU6IDUsIDY6IDYsIDc6IDcsIDg6IDgsIDk6IDksIEE6IDEwLCBCOiAxMSwgQzogMTIsIEQ6IDEzLCBFOiAxNCwgRjogMTUsIGE6IDEwLCBiOiAxMSwgYzogMTIsIGQ6IDEzLCBlOiAxNCwgZjogMTV9O1xuY29uc3QgaGV4ID0gWy4uLicwMTIzNDU2Nzg5QUJDREVGJ107XG5jb25zdCBoMSA9IGIgPT4gaGV4W2IgJiAweEZdO1xuY29uc3QgaDIgPSBiID0+IGhleFsoYiAmIDB4RjApID4+IDRdICsgaGV4W2IgJiAweEZdO1xuY29uc3QgZXEgPSBiID0+ICgoYiAmIDB4RjApID4+IDQpID09PSAoYiAmIDB4Rik7XG5jb25zdCBpc1Nob3J0ID0gdiA9PiBlcSh2LnIpICYmIGVxKHYuZykgJiYgZXEodi5iKSAmJiBlcSh2LmEpO1xuZnVuY3Rpb24gaGV4UGFyc2Uoc3RyKSB7XG4gIHZhciBsZW4gPSBzdHIubGVuZ3RoO1xuICB2YXIgcmV0O1xuICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICBpZiAobGVuID09PSA0IHx8IGxlbiA9PT0gNSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiAyNTUgJiBtYXAkMVtzdHJbMV1dICogMTcsXG4gICAgICAgIGc6IDI1NSAmIG1hcCQxW3N0clsyXV0gKiAxNyxcbiAgICAgICAgYjogMjU1ICYgbWFwJDFbc3RyWzNdXSAqIDE3LFxuICAgICAgICBhOiBsZW4gPT09IDUgPyBtYXAkMVtzdHJbNF1dICogMTcgOiAyNTVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDcgfHwgbGVuID09PSA5KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IG1hcCQxW3N0clsxXV0gPDwgNCB8IG1hcCQxW3N0clsyXV0sXG4gICAgICAgIGc6IG1hcCQxW3N0clszXV0gPDwgNCB8IG1hcCQxW3N0cls0XV0sXG4gICAgICAgIGI6IG1hcCQxW3N0cls1XV0gPDwgNCB8IG1hcCQxW3N0cls2XV0sXG4gICAgICAgIGE6IGxlbiA9PT0gOSA/IChtYXAkMVtzdHJbN11dIDw8IDQgfCBtYXAkMVtzdHJbOF1dKSA6IDI1NVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGFscGhhID0gKGEsIGYpID0+IGEgPCAyNTUgPyBmKGEpIDogJyc7XG5mdW5jdGlvbiBoZXhTdHJpbmcodikge1xuICB2YXIgZiA9IGlzU2hvcnQodikgPyBoMSA6IGgyO1xuICByZXR1cm4gdlxuICAgID8gJyMnICsgZih2LnIpICsgZih2LmcpICsgZih2LmIpICsgYWxwaGEodi5hLCBmKVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuXG5jb25zdCBtYXAgPSB7XG5cdHg6ICdkYXJrJyxcblx0WjogJ2xpZ2h0Jyxcblx0WTogJ3JlJyxcblx0WDogJ2JsdScsXG5cdFc6ICdncicsXG5cdFY6ICdtZWRpdW0nLFxuXHRVOiAnc2xhdGUnLFxuXHRBOiAnZWUnLFxuXHRUOiAnb2wnLFxuXHRTOiAnb3InLFxuXHRCOiAncmEnLFxuXHRDOiAnbGF0ZWcnLFxuXHREOiAnaWdodHMnLFxuXHRSOiAnaW4nLFxuXHRROiAndHVycXVvaXMnLFxuXHRFOiAnaGknLFxuXHRQOiAncm8nLFxuXHRPOiAnYWwnLFxuXHROOiAnbGUnLFxuXHRNOiAnZGUnLFxuXHRMOiAneWVsbG8nLFxuXHRGOiAnZW4nLFxuXHRLOiAnY2gnLFxuXHRHOiAnYXJrcycsXG5cdEg6ICdlYScsXG5cdEk6ICdpZ2h0ZycsXG5cdEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuXHRPaWNlWGU6ICdmMGY4ZmYnLFxuXHRhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG5cdGFxdWE6ICdmZmZmJyxcblx0YXF1YW1hclJlOiAnN2ZmZmQ0Jyxcblx0YXp1WTogJ2YwZmZmZicsXG5cdGJlaWdlOiAnZjVmNWRjJyxcblx0YmlzcXVlOiAnZmZlNGM0Jyxcblx0YmxhY2s6ICcwJyxcblx0YmxhbktlZE9tb25kOiAnZmZlYmNkJyxcblx0WGU6ICdmZicsXG5cdFhldmlUZXQ6ICc4YTJiZTInLFxuXHRiUHduOiAnYTUyYTJhJyxcblx0YnVybHl3b29kOiAnZGViODg3Jyxcblx0Y2FNdFhlOiAnNWY5ZWEwJyxcblx0S2FydFl1c2U6ICc3ZmZmMDAnLFxuXHRLb2NUYXRlOiAnZDI2OTFlJyxcblx0Y1NPOiAnZmY3ZjUwJyxcblx0Y1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuXHRjU25zaWxrOiAnZmZmOGRjJyxcblx0Y3JpbXNvbjogJ2RjMTQzYycsXG5cdGN5YW46ICdmZmZmJyxcblx0eFhlOiAnOGInLFxuXHR4Y3lhbjogJzhiOGInLFxuXHR4Z1RNblBkOiAnYjg4NjBiJyxcblx0eFdheTogJ2E5YTlhOScsXG5cdHhnWUY6ICc2NDAwJyxcblx0eGdZeTogJ2E5YTlhOScsXG5cdHhraGFraTogJ2JkYjc2YicsXG5cdHhtYWdGdGE6ICc4YjAwOGInLFxuXHR4VGl2ZWdZRjogJzU1NmIyZicsXG5cdHhTYW5nZTogJ2ZmOGMwMCcsXG5cdHhTY0VkOiAnOTkzMmNjJyxcblx0eFlkOiAnOGIwMDAwJyxcblx0eHNPbW9uOiAnZTk5NjdhJyxcblx0eHNIZ1lGOiAnOGZiYzhmJyxcblx0eFVYZTogJzQ4M2Q4YicsXG5cdHhVV2F5OiAnMmY0ZjRmJyxcblx0eFVnWXk6ICcyZjRmNGYnLFxuXHR4UWU6ICdjZWQxJyxcblx0eHZpVGV0OiAnOTQwMGQzJyxcblx0ZEFwcFJrOiAnZmYxNDkzJyxcblx0ZEFwc2t5WGU6ICdiZmZmJyxcblx0ZGltV2F5OiAnNjk2OTY5Jyxcblx0ZGltZ1l5OiAnNjk2OTY5Jyxcblx0ZG9kZ2VyWGU6ICcxZTkwZmYnLFxuXHRmaVlicmljazogJ2IyMjIyMicsXG5cdGZsU093RXRlOiAnZmZmYWYwJyxcblx0Zm9Zc3RXQW46ICcyMjhiMjInLFxuXHRmdUtzaWE6ICdmZjAwZmYnLFxuXHRnYVJzYlNvOiAnZGNkY2RjJyxcblx0Z2hvc3R3RXRlOiAnZjhmOGZmJyxcblx0Z1RkOiAnZmZkNzAwJyxcblx0Z1RNblBkOiAnZGFhNTIwJyxcblx0V2F5OiAnODA4MDgwJyxcblx0Z1lGOiAnODAwMCcsXG5cdGdZRkx3OiAnYWRmZjJmJyxcblx0Z1l5OiAnODA4MDgwJyxcblx0aG9uZXlNdzogJ2YwZmZmMCcsXG5cdGhvdHBSazogJ2ZmNjliNCcsXG5cdFJkaWFuWWQ6ICdjZDVjNWMnLFxuXHRSZGlnbzogJzRiMDA4MicsXG5cdGl2U3k6ICdmZmZmZjAnLFxuXHRraGFraTogJ2YwZTY4YycsXG5cdGxhdkZNcjogJ2U2ZTZmYScsXG5cdGxhdkZNclhzaDogJ2ZmZjBmNScsXG5cdGxhd25nWUY6ICc3Y2ZjMDAnLFxuXHRObW9uY0VmZm9uOiAnZmZmYWNkJyxcblx0WlhlOiAnYWRkOGU2Jyxcblx0WmNTTzogJ2YwODA4MCcsXG5cdFpjeWFuOiAnZTBmZmZmJyxcblx0WmdUTW5QZEx3OiAnZmFmYWQyJyxcblx0WldheTogJ2QzZDNkMycsXG5cdFpnWUY6ICc5MGVlOTAnLFxuXHRaZ1l5OiAnZDNkM2QzJyxcblx0WnBSazogJ2ZmYjZjMScsXG5cdFpzT21vbjogJ2ZmYTA3YScsXG5cdFpzSGdZRjogJzIwYjJhYScsXG5cdFpza3lYZTogJzg3Y2VmYScsXG5cdFpVV2F5OiAnNzc4ODk5Jyxcblx0WlVnWXk6ICc3Nzg4OTknLFxuXHRac3RBbFhlOiAnYjBjNGRlJyxcblx0Wkx3OiAnZmZmZmUwJyxcblx0bGltZTogJ2ZmMDAnLFxuXHRsaW1lZ1lGOiAnMzJjZDMyJyxcblx0bFJGOiAnZmFmMGU2Jyxcblx0bWFnRnRhOiAnZmYwMGZmJyxcblx0bWFQb246ICc4MDAwMDAnLFxuXHRWYXF1YW1hclJlOiAnNjZjZGFhJyxcblx0VlhlOiAnY2QnLFxuXHRWU2NFZDogJ2JhNTVkMycsXG5cdFZwdXJwTjogJzkzNzBkYicsXG5cdFZzSGdZRjogJzNjYjM3MScsXG5cdFZVWGU6ICc3YjY4ZWUnLFxuXHRWc3ByUmdnWUY6ICdmYTlhJyxcblx0VlFlOiAnNDhkMWNjJyxcblx0VnZpVGV0WWQ6ICdjNzE1ODUnLFxuXHRtaWRuaWdodFhlOiAnMTkxOTcwJyxcblx0bVJ0Y1lhbTogJ2Y1ZmZmYScsXG5cdG1pc3R5UHNlOiAnZmZlNGUxJyxcblx0bW9jY2FzUjogJ2ZmZTRiNScsXG5cdG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuXHRuYXZ5OiAnODAnLFxuXHRUZGxhY2U6ICdmZGY1ZTYnLFxuXHRUaXZlOiAnODA4MDAwJyxcblx0VGl2ZWRCYjogJzZiOGUyMycsXG5cdFNhbmdlOiAnZmZhNTAwJyxcblx0U2FuZ2VZZDogJ2ZmNDUwMCcsXG5cdFNjRWQ6ICdkYTcwZDYnLFxuXHRwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuXHRwT2VnWUY6ICc5OGZiOTgnLFxuXHRwT2VRZTogJ2FmZWVlZScsXG5cdHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuXHRwYXBheWF3RXA6ICdmZmVmZDUnLFxuXHRwSEtwdWZmOiAnZmZkYWI5Jyxcblx0cGVydTogJ2NkODUzZicsXG5cdHBSazogJ2ZmYzBjYicsXG5cdHBsdW06ICdkZGEwZGQnLFxuXHRwb3dNclhlOiAnYjBlMGU2Jyxcblx0cHVycE46ICc4MDAwODAnLFxuXHRZYmVjY2FwdXJwTjogJzY2MzM5OScsXG5cdFlkOiAnZmYwMDAwJyxcblx0UHN5YnJvd246ICdiYzhmOGYnLFxuXHRQeU9YZTogJzQxNjllMScsXG5cdHNhZGROYlB3bjogJzhiNDUxMycsXG5cdHNPbW9uOiAnZmE4MDcyJyxcblx0c2FuZHliUHduOiAnZjRhNDYwJyxcblx0c0hnWUY6ICcyZThiNTcnLFxuXHRzSHNoZWxsOiAnZmZmNWVlJyxcblx0c2lGbmE6ICdhMDUyMmQnLFxuXHRzaWx2ZXI6ICdjMGMwYzAnLFxuXHRza3lYZTogJzg3Y2VlYicsXG5cdFVYZTogJzZhNWFjZCcsXG5cdFVXYXk6ICc3MDgwOTAnLFxuXHRVZ1l5OiAnNzA4MDkwJyxcblx0c25vdzogJ2ZmZmFmYScsXG5cdHNwclJnZ1lGOiAnZmY3ZicsXG5cdHN0QWxYZTogJzQ2ODJiNCcsXG5cdHRhbjogJ2QyYjQ4YycsXG5cdHRlTzogJzgwODAnLFxuXHR0RXN0TjogJ2Q4YmZkOCcsXG5cdHRvbWF0bzogJ2ZmNjM0NycsXG5cdFFlOiAnNDBlMGQwJyxcblx0dmlUZXQ6ICdlZTgyZWUnLFxuXHRKSHQ6ICdmNWRlYjMnLFxuXHR3RXRlOiAnZmZmZmZmJyxcblx0d0V0ZXNtb2tlOiAnZjVmNWY1Jyxcblx0THc6ICdmZmZmMDAnLFxuXHRMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cblxubGV0IG5hbWVzO1xuZnVuY3Rpb24gbmFtZVBhcnNlKHN0cikge1xuICBpZiAoIW5hbWVzKSB7XG4gICAgbmFtZXMgPSB1bnBhY2soKTtcbiAgICBuYW1lcy50cmFuc3BhcmVudCA9IFswLCAwLCAwLCAwXTtcbiAgfVxuICBjb25zdCBhID0gbmFtZXNbc3RyLnRvTG93ZXJDYXNlKCldO1xuICByZXR1cm4gYSAmJiB7XG4gICAgcjogYVswXSxcbiAgICBnOiBhWzFdLFxuICAgIGI6IGFbMl0sXG4gICAgYTogYS5sZW5ndGggPT09IDQgPyBhWzNdIDogMjU1XG4gIH07XG59XG5cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW9kSFNMKHYsIGksIHJhdGlvKSB7XG4gIGlmICh2KSB7XG4gICAgbGV0IHRtcCA9IHJnYjJoc2wodik7XG4gICAgdG1wW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odG1wW2ldICsgdG1wW2ldICogcmF0aW8sIGkgPT09IDAgPyAzNjAgOiAxKSk7XG4gICAgdG1wID0gaHNsMnJnYih0bXApO1xuICAgIHYuciA9IHRtcFswXTtcbiAgICB2LmcgPSB0bXBbMV07XG4gICAgdi5iID0gdG1wWzJdO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2LCBwcm90bykge1xuICByZXR1cm4gdiA/IE9iamVjdC5hc3NpZ24ocHJvdG8gfHwge30sIHYpIDogdjtcbn1cbmZ1bmN0aW9uIGZyb21PYmplY3QoaW5wdXQpIHtcbiAgdmFyIHYgPSB7cjogMCwgZzogMCwgYjogMCwgYTogMjU1fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA+PSAzKSB7XG4gICAgICB2ID0ge3I6IGlucHV0WzBdLCBnOiBpbnB1dFsxXSwgYjogaW5wdXRbMl0sIGE6IDI1NX07XG4gICAgICBpZiAoaW5wdXQubGVuZ3RoID4gMykge1xuICAgICAgICB2LmEgPSBuMmIoaW5wdXRbM10pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2ID0gY2xvbmUoaW5wdXQsIHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAxfSk7XG4gICAgdi5hID0gbjJiKHYuYSk7XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5mdW5jdGlvbiBmdW5jdGlvblBhcnNlKHN0cikge1xuICBpZiAoc3RyLmNoYXJBdCgwKSA9PT0gJ3InKSB7XG4gICAgcmV0dXJuIHJnYlBhcnNlKHN0cik7XG4gIH1cbiAgcmV0dXJuIGh1ZVBhcnNlKHN0cik7XG59XG5jbGFzcyBDb2xvciB7XG4gIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBpbnB1dDtcbiAgICBsZXQgdjtcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHYgPSBmcm9tT2JqZWN0KGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2ID0gaGV4UGFyc2UoaW5wdXQpIHx8IG5hbWVQYXJzZShpbnB1dCkgfHwgZnVuY3Rpb25QYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHRoaXMuX3JnYiA9IHY7XG4gICAgdGhpcy5fdmFsaWQgPSAhIXY7XG4gIH1cbiAgZ2V0IHZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZDtcbiAgfVxuICBnZXQgcmdiKCkge1xuICAgIHZhciB2ID0gY2xvbmUodGhpcy5fcmdiKTtcbiAgICBpZiAodikge1xuICAgICAgdi5hID0gYjJuKHYuYSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIHNldCByZ2Iob2JqKSB7XG4gICAgdGhpcy5fcmdiID0gZnJvbU9iamVjdChvYmopO1xuICB9XG4gIHJnYlN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyByZ2JTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoZXhTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaGV4U3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaHNsU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhzbFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIG1peChjb2xvciwgd2VpZ2h0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCBjMSA9IHRoaXMucmdiO1xuICAgICAgY29uc3QgYzIgPSBjb2xvci5yZ2I7XG4gICAgICBsZXQgdzI7XG4gICAgICBjb25zdCBwID0gd2VpZ2h0ID09PSB3MiA/IDAuNSA6IHdlaWdodDtcbiAgICAgIGNvbnN0IHcgPSAyICogcCAtIDE7XG4gICAgICBjb25zdCBhID0gYzEuYSAtIGMyLmE7XG4gICAgICBjb25zdCB3MSA9ICgodyAqIGEgPT09IC0xID8gdyA6ICh3ICsgYSkgLyAoMSArIHcgKiBhKSkgKyAxKSAvIDIuMDtcbiAgICAgIHcyID0gMSAtIHcxO1xuICAgICAgYzEuciA9IDB4RkYgJiB3MSAqIGMxLnIgKyB3MiAqIGMyLnIgKyAwLjU7XG4gICAgICBjMS5nID0gMHhGRiAmIHcxICogYzEuZyArIHcyICogYzIuZyArIDAuNTtcbiAgICAgIGMxLmIgPSAweEZGICYgdzEgKiBjMS5iICsgdzIgKiBjMi5iICsgMC41O1xuICAgICAgYzEuYSA9IHAgKiBjMS5hICsgKDEgLSBwKSAqIGMyLmE7XG4gICAgICB0aGlzLnJnYiA9IGMxO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbnRlcnBvbGF0ZShjb2xvciwgdCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgdGhpcy5fcmdiID0gaW50ZXJwb2xhdGUodGhpcy5fcmdiLCBjb2xvci5fcmdiLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnJnYik7XG4gIH1cbiAgYWxwaGEoYSkge1xuICAgIHRoaXMuX3JnYi5hID0gbjJiKGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSAtIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyZXlzY2FsZSgpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgY29uc3QgdmFsID0gcm91bmQocmdiLnIgKiAwLjMgKyByZ2IuZyAqIDAuNTkgKyByZ2IuYiAqIDAuMTEpO1xuICAgIHJnYi5yID0gcmdiLmcgPSByZ2IuYiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBvcGFxdWVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgKyByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBuZWdhdGUoKSB7XG4gICAgY29uc3QgdiA9IHRoaXMuX3JnYjtcbiAgICB2LnIgPSAyNTUgLSB2LnI7XG4gICAgdi5nID0gMjU1IC0gdi5nO1xuICAgIHYuYiA9IDI1NSAtIHYuYjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaWdodGVuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRhcmtlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIC1yYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcm90YXRlKGRlZykge1xuICAgIHJvdGF0ZSh0aGlzLl9yZ2IsIGRlZyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5leHBvcnQgeyBDb2xvciwgYjJuLCBiMnAsIGluZGV4X2VzbSBhcyBkZWZhdWx0LCBoZXhQYXJzZSwgaGV4U3RyaW5nLCBoc2wycmdiLCBoc2xTdHJpbmcsIGhzdjJyZ2IsIGh1ZVBhcnNlLCBod2IycmdiLCBsaW0sIG4yYiwgbjJwLCBuYW1lUGFyc2UsIHAyYiwgcmdiMmhzbCwgcmdiUGFyc2UsIHJnYlN0cmluZywgcm90YXRlLCByb3VuZCB9O1xuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi9cblxuaW1wb3J0IHR5cGUge0FueU9iamVjdH0gZnJvbSAnLi4vdHlwZXMvYmFzaWMuanMnO1xuaW1wb3J0IHR5cGUge0FjdGl2ZURhdGFQb2ludCwgQ2hhcnRFdmVudH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG4vKipcbiAqIEFuIGVtcHR5IGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQsIGZvciBleGFtcGxlLCBmb3Igb3B0aW9uYWwgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkge1xuICAvKiBub29wICovXG59XG5cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuICovXG5leHBvcnQgY29uc3QgdWlkID0gKCgpID0+IHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuICgpID0+IGlkKys7XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIG5laXRoZXIgbnVsbCBub3IgdW5kZWZpbmVkLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIG51bGwgfCB1bmRlZmluZWQge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSAoaW5jbHVkaW5nIHR5cGVkIGFycmF5cyksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5PFQgPSB1bmtub3duPih2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIFRbXSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh0eXBlLnNsaWNlKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zbGljZSgtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCAoZXhjbHVkaW5nIG51bGwpLCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBBbnlPYmplY3Qge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2VcbiAqIEBwYXJhbSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXJGaW5pdGUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBudW1iZXIge1xuICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG59XG5leHBvcnQge1xuICBpc051bWJlckZpbml0ZSBhcyBpc0Zpbml0ZSxcbn07XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGZpbml0ZSwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyBub3QgZmluaXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlOiB1bmtub3duLCBkZWZhdWx0VmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGRlZmluZWQsIGVsc2UgcmV0dXJucyBgZGVmYXVsdFZhbHVlYC5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgZGVmaW5lZC5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgdmFsdWUgdG8gcmV0dXJuIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQ8VD4odmFsdWU6IFQgfCB1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZTogVCkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuXG5leHBvcnQgY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlOiBudW1iZXIgfCBzdHJpbmcsIGRpbWVuc2lvbjogbnVtYmVyKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwXG4gICAgOiArdmFsdWUgLyBkaW1lbnNpb247XG5cbmV4cG9ydCBjb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nLCBkaW1lbnNpb246IG51bWJlcikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuXG4vKipcbiAqIENhbGxzIGBmbmAgd2l0aCB0aGUgZ2l2ZW4gYGFyZ3NgIGluIHRoZSBzY29wZSBkZWZpbmVkIGJ5IGB0aGlzQXJnYCBhbmQgcmV0dXJucyB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGBmbmAuIElmIGBmbmAgaXMgbm90IGEgZnVuY3Rpb24sIHRoaXMgbWV0aG9kIHJldHVybnMgdW5kZWZpbmVkLlxuICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwuXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgd2l0aCB3aGljaCBgZm5gIHNob3VsZCBiZSBjYWxsZWQuXG4gKiBAcGFyYW0gW3RoaXNBcmddIC0gVGhlIHZhbHVlIG9mIGB0aGlzYCBwcm92aWRlZCBmb3IgdGhlIGNhbGwgdG8gYGZuYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbGxiYWNrPFQgZXh0ZW5kcyAodGhpczogVEEsIC4uLnJlc3RBcmdzOiB1bmtub3duW10pID0+IFIsIFRBLCBSPihcbiAgZm46IFQgfCB1bmRlZmluZWQsXG4gIGFyZ3M6IHVua25vd25bXSxcbiAgdGhpc0FyZz86IFRBXG4pOiBSIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5cbi8qKlxuICogTm90ZShTQikgZm9yIHBlcmZvcm1hbmNlIHNha2UsIHRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiBsb29wYWJsZSB0eXBlXG4gKiBpcyB1bmtub3duIG9yIGluIG5vbmUgaW50ZW5zaXZlIGNvZGUgKG5vdCBjYWxsZWQgb2Z0ZW4gYW5kIHNtYWxsIGxvb3BhYmxlKS4gRWxzZVxuICogaXQncyBwcmVmZXJhYmxlIHRvIHVzZSBhIHJlZ3VsYXIgZm9yKCkgbG9vcCBhbmQgc2F2ZSBleHRyYSBmdW5jdGlvbiBjYWxscy5cbiAqIEBwYXJhbSBsb29wYWJsZSAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgaXRlcmF0ZWQuXG4gKiBAcGFyYW0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKiBAcGFyYW0gW3JldmVyc2VdIC0gSWYgdHJ1ZSwgaXRlcmF0ZXMgYmFja3dhcmQgb24gdGhlIGxvb3BhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogc3RyaW5nKSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCwgVEE+KFxuICBsb29wYWJsZTogVFtdLFxuICBmbjogKHRoaXM6IFRBLCB2OiBULCBpOiBudW1iZXIpID0+IHZvaWQsXG4gIHRoaXNBcmc/OiBUQSxcbiAgcmV2ZXJzZT86IGJvb2xlYW5cbik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gZWFjaDxULCBUQT4oXG4gIGxvb3BhYmxlOiBUW10gfCBSZWNvcmQ8c3RyaW5nLCBUPixcbiAgZm46ICh0aGlzOiBUQSwgdjogVCwgaTogYW55KSA9PiB2b2lkLFxuICB0aGlzQXJnPzogVEEsXG4gIHJldmVyc2U/OiBib29sZWFuXG4pIHtcbiAgbGV0IGk6IG51bWJlciwgbGVuOiBudW1iZXIsIGtleXM6IHN0cmluZ1tdO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGBhMGAgYW5kIGBhMWAgYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudCwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIGEwIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBhMSAtIFRoZSBhcnJheSB0byBjb21wYXJlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTA6IEFjdGl2ZURhdGFQb2ludFtdLCBhMTogQWN0aXZlRGF0YVBvaW50W10pIHtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2MDogQWN0aXZlRGF0YVBvaW50LCB2MTogQWN0aXZlRGF0YVBvaW50O1xuXG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHYwID0gYTBbaV07XG4gICAgdjEgPSBhMVtpXTtcblxuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVlcCBjb3B5IG9mIGBzb3VyY2VgIHdpdGhvdXQga2VlcGluZyByZWZlcmVuY2VzIG9uIG9iamVjdHMgYW5kIGFycmF5cy5cbiAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZTxUPihzb3VyY2U6IFQpOiBUIHtcbiAgaWYgKGlzQXJyYXkoc291cmNlKSkge1xuICAgIHJldHVybiBzb3VyY2UubWFwKGNsb25lKSBhcyB1bmtub3duIGFzIFQ7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcblxuICAgIGZvciAoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICB0YXJnZXRba2V5c1trXV0gPSBjbG9uZShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICByZXR1cm4gc291cmNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKSB7XG4gIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmRleE9mKGtleSkgPT09IC0xO1xufVxuXG4vKipcbiAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cbiAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lcmdlcihrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zOiBBbnlPYmplY3QpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcblxuICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZShzdmFsKTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lcmdlT3B0aW9ucyB7XG4gIG1lcmdlcj86IChrZXk6IHN0cmluZywgdGFyZ2V0OiBBbnlPYmplY3QsIHNvdXJjZTogQW55T2JqZWN0LCBvcHRpb25zPzogQW55T2JqZWN0KSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXG4gKiBJTVBPUlRBTlQ6IGB0YXJnZXRgIGlzIG5vdCBjbG9uZWQgYW5kIHdpbGwgYmUgdXBkYXRlZCB3aXRoIGBzb3VyY2VgIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvYmplY3QgaW4gd2hpY2ggYWxsIHNvdXJjZXMgYXJlIG1lcmdlZCBpbnRvLlxuICogQHBhcmFtIHNvdXJjZSAtIE9iamVjdChzKSB0byBtZXJnZSBpbnRvIGB0YXJnZXRgLlxuICogQHBhcmFtIFtvcHRpb25zXSAtIE1lcmdpbmcgb3B0aW9uczpcbiAqIEBwYXJhbSBbb3B0aW9ucy5tZXJnZXJdIC0gVGhlIG1lcmdlIG1ldGhvZCAoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogW10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxPih0YXJnZXQ6IFQsIHNvdXJjZTogUzEsIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBUICYgUzE7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFMxLCBTMj4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzJdLCBvcHRpb25zPzogTWVyZ2VPcHRpb25zKTogVCAmIFMxICYgUzI7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMz4odGFyZ2V0OiBULCBzb3VyY2U6IFtTMSwgUzIsIFMzXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IFQgJiBTMSAmIFMyICYgUzM7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUzEsIFMyLCBTMywgUzQ+KFxuICB0YXJnZXQ6IFQsXG4gIHNvdXJjZTogW1MxLCBTMiwgUzMsIFM0XSxcbiAgb3B0aW9ucz86IE1lcmdlT3B0aW9uc1xuKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQ+KHRhcmdldDogVCwgc291cmNlOiBBbnlPYmplY3RbXSwgb3B0aW9ucz86IE1lcmdlT3B0aW9ucyk6IEFueU9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxUPih0YXJnZXQ6IFQsIHNvdXJjZTogQW55T2JqZWN0W10sIG9wdGlvbnM/OiBNZXJnZU9wdGlvbnMpOiBBbnlPYmplY3Qge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcblxuICBpZiAoIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0IGFzIEFueU9iamVjdDtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBtZXJnZXIgPSBvcHRpb25zLm1lcmdlciB8fCBfbWVyZ2VyO1xuICBsZXQgY3VycmVudDogQW55T2JqZWN0O1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHNvdXJjZXNbaV07XG4gICAgaWYgKCFpc09iamVjdChjdXJyZW50KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGN1cnJlbnQpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIGN1cnJlbnQsIG9wdGlvbnMgYXMgQW55T2JqZWN0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlZXAgY29waWVzIGBzb3VyY2VgIHByb3BlcnRpZXMgaW50byBgdGFyZ2V0YCAqb25seSogaWYgbm90IGRlZmluZWQgaW4gdGFyZ2V0LlxuICogSU1QT1JUQU5UOiBgdGFyZ2V0YCBpcyBub3QgY2xvbmVkIGFuZCB3aWxsIGJlIHVwZGF0ZWQgd2l0aCBgc291cmNlYCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgb2JqZWN0IGluIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSBtZXJnZWQgaW50by5cbiAqIEBwYXJhbSBzb3VyY2UgLSBPYmplY3QocykgdG8gbWVyZ2UgaW50byBgdGFyZ2V0YC5cbiAqIEByZXR1cm5zIFRoZSBgdGFyZ2V0YCBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQ+KHRhcmdldDogVCwgc291cmNlOiBbXSk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VJZjxULCBTMT4odGFyZ2V0OiBULCBzb3VyY2U6IFMxKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzE+KHRhcmdldDogVCwgc291cmNlOiBbUzFdKTogVCAmIFMxO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyPih0YXJnZXQ6IFQsIHNvdXJjZTogW1MxLCBTMl0pOiBUICYgUzEgJiBTMjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUlmPFQsIFMxLCBTMiwgUzM+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTM10pOiBUICYgUzEgJiBTMiAmIFMzO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VCwgUzEsIFMyLCBTMywgUzQ+KHRhcmdldDogVCwgc291cmNlOiBbUzEsIFMyLCBTMywgUzRdKTogVCAmIFMxICYgUzIgJiBTMyAmIFM0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlSWY8VD4odGFyZ2V0OiBULCBzb3VyY2U6IEFueU9iamVjdFtdKTogQW55T2JqZWN0IHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICByZXR1cm4gbWVyZ2U8VD4odGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuXG4vKipcbiAqIE1lcmdlcyBzb3VyY2Vba2V5XSBpbiB0YXJnZXRba2V5XSBvbmx5IGlmIHRhcmdldFtrZXldIGlzIHVuZGVmaW5lZC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbWVyZ2VySWYoa2V5OiBzdHJpbmcsIHRhcmdldDogQW55T2JqZWN0LCBzb3VyY2U6IEFueU9iamVjdCkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHR2YWwgPSB0YXJnZXRba2V5XTtcbiAgY29uc3Qgc3ZhbCA9IHNvdXJjZVtrZXldO1xuXG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duLCBwcmV2aW91czogc3RyaW5nLCBjdXJyZW50OiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG4gICAgICAnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuXG4vLyByZXNvbHZlT2JqZWN0S2V5IHJlc29sdmVyIGNhY2hlXG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCByZXNvbHZlIGVtcHR5IGtleSB0byByb290IG9iamVjdFxuICAnJzogdiA9PiB2LFxuICAvLyBkZWZhdWx0IHJlc29sdmVyc1xuICB4OiBvID0+IG8ueCxcbiAgeTogbyA9PiBvLnlcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zcGxpdEtleShrZXk6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdG1wID0gJyc7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIHRtcCArPSBwYXJ0O1xuICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXk6IHN0cmluZykge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6XG4gICAgICAgIC8vIENoYXJ0LmhlbHBlcnMuY29yZSByZXNvbHZlT2JqZWN0S2V5IHNob3VsZCBicmVhayBhdCBlbXB0eSBrZXlcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU9iamVjdEtleShvYmo6IEFueU9iamVjdCwga2V5OiBzdHJpbmcpOiBhbnkge1xuICBjb25zdCByZXNvbHZlciA9IGtleVJlc29sdmVyc1trZXldIHx8IChrZXlSZXNvbHZlcnNba2V5XSA9IF9nZXRLZXlSZXNvbHZlcihrZXkpKTtcbiAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZWQgPSAodmFsdWU6IHVua25vd24pID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzExMjg4NTUvY29tcGFyaW5nLWVjbWE2LXNldHMtZm9yLWVxdWFsaXR5IzMxMTI5Mzg0XG5leHBvcnQgY29uc3Qgc2V0c0VxdWFsID0gPFQ+KGE6IFNldDxUPiwgYjogU2V0PFQ+KSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZSAtIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZTogQ2hhcnRFdmVudCkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnR9IGZyb20gJy4uL3R5cGVzL2dlb21ldHJpYy5qcyc7XG5pbXBvcnQge2lzRmluaXRlIGFzIGlzRmluaXRlTnVtYmVyfSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxuICogQG5hbWVzcGFjZVxuICovXG5cbmV4cG9ydCBjb25zdCBQSSA9IE1hdGguUEk7XG5leHBvcnQgY29uc3QgVEFVID0gMiAqIFBJO1xuZXhwb3J0IGNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5leHBvcnQgY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5leHBvcnQgY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmV4cG9ydCBjb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuZXhwb3J0IGNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5leHBvcnQgY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5cbmV4cG9ydCBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5leHBvcnQgY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4OiBudW1iZXIsIHk6IG51bWJlciwgZXBzaWxvbjogbnVtYmVyKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuaWNlTnVtKHJhbmdlOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZFJhbmdlID0gTWF0aC5yb3VuZChyYW5nZSk7XG4gIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgY29uc3QgbmljZVJhbmdlID0gTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAocmFuZ2UpKSk7XG4gIGNvbnN0IGZyYWN0aW9uID0gcmFuZ2UgLyBuaWNlUmFuZ2U7XG4gIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICByZXR1cm4gbmljZUZyYWN0aW9uICogbmljZVJhbmdlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFjdG9ycyBzb3J0ZWQgZnJvbSAxIHRvIHNxcnQodmFsdWUpXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZhY3Rvcml6ZSh2YWx1ZTogbnVtYmVyKSB7XG4gIGNvbnN0IHJlc3VsdDogbnVtYmVyW10gPSBbXTtcbiAgY29uc3Qgc3FydCA9IE1hdGguc3FydCh2YWx1ZSk7XG4gIGxldCBpOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHsgLy8gaWYgdmFsdWUgaXMgYSBzcXVhcmUgbnVtYmVyXG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cblxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgYXR0ZW1wdGluZyB0byBjb2VyY2UgbiB0byBzdHJpbmcgb3IgbnVtYmVyIHdvbid0IHRocm93IGEgVHlwZUVycm9yLlxuICovXG5mdW5jdGlvbiBpc05vblByaW1pdGl2ZShuOiB1bmtub3duKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PT0gJ3N5bWJvbCcgfHwgKHR5cGVvZiBuID09PSAnb2JqZWN0JyAmJiBuICE9PSBudWxsICYmICEoU3ltYm9sLnRvUHJpbWl0aXZlIGluIG4gfHwgJ3RvU3RyaW5nJyBpbiBuIHx8ICd2YWx1ZU9mJyBpbiBuKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihuOiB1bmtub3duKTogbiBpcyBudW1iZXIge1xuICByZXR1cm4gIWlzTm9uUHJpbWl0aXZlKG4pICYmICFpc05hTihwYXJzZUZsb2F0KG4gYXMgc3RyaW5nKSkgJiYgaXNGaW5pdGUobiBhcyBudW1iZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxtb3N0V2hvbGUoeDogbnVtYmVyLCBlcHNpbG9uOiBudW1iZXIpIHtcbiAgY29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoeCk7XG4gIHJldHVybiAoKHJvdW5kZWQgLSBlcHNpbG9uKSA8PSB4KSAmJiAoKHJvdW5kZWQgKyBlcHNpbG9uKSA+PSB4KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KFxuICBhcnJheTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICB0YXJnZXQ6IHsgbWluOiBudW1iZXIsIG1heDogbnVtYmVyIH0sXG4gIHByb3BlcnR5OiBzdHJpbmdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHZhbHVlOiBudW1iZXI7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzOiBudW1iZXIpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnM6IG51bWJlcikge1xuICByZXR1cm4gcmFkaWFucyAqICgxODAgLyBQSSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG4gKiBAcGFyYW0geCAtIEEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZGVjaW1hbFBsYWNlcyh4OiBudW1iZXIpIHtcbiAgaWYgKCFpc0Zpbml0ZU51bWJlcih4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG4vLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuZ2xlRnJvbVBvaW50KFxuICBjZW50cmVQb2ludDogUG9pbnQsXG4gIGFuZ2xlUG9pbnQ6IFBvaW50XG4pIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG5cbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcblxuICBpZiAoYW5nbGUgPCAoLTAuNSAqIFBJKSkge1xuICAgIGFuZ2xlICs9IFRBVTsgLy8gbWFrZSBzdXJlIHRoZSByZXR1cm5lZCBhbmdsZSBpcyBpbiB0aGUgcmFuZ2Ugb2YgKC1QSS8yLCAzUEkvMl1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MTogUG9pbnQsIHB0MjogUG9pbnQpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cblxuLyoqXG4gKiBTaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIGFuZ2xlcywgaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVEaWZmKGE6IG51bWJlciwgYjogbnVtYmVyKSB7XG4gIHJldHVybiAoYSAtIGIgKyBQSVRBVSkgJSBUQVUgLSBQSTtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgYW5nbGUgdG8gYmUgYmV0d2VlbiAwIGFuZCAyKlBJXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGE6IG51bWJlcikge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlOiBudW1iZXIsIHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGU/OiBib29sZWFuKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuXG4vKipcbiAqIExpbWl0IGB2YWx1ZWAgYmV0d2VlbiBgbWluYCBhbmQgYG1heGBcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gZW5kXG4gKiBAcGFyYW0gW2Vwc2lsb25dXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZTogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG4iLCAiaW1wb3J0IHtfY2FwaXRhbGl6ZX0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGNtcFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9sb29rdXAoXG4gIHRhYmxlOiBudW1iZXJbXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbik6IHtsbzogbnVtYmVyLCBoaTogbnVtYmVyfTtcbmV4cG9ydCBmdW5jdGlvbiBfbG9va3VwPFQ+KFxuICB0YWJsZTogVFtdLFxuICB2YWx1ZTogbnVtYmVyLFxuICBjbXA6ICh2YWx1ZTogbnVtYmVyKSA9PiBib29sZWFuXG4pOiB7bG86IG51bWJlciwgaGk6IG51bWJlcn07XG5leHBvcnQgZnVuY3Rpb24gX2xvb2t1cChcbiAgdGFibGU6IHVua25vd25bXSxcbiAgdmFsdWU6IG51bWJlcixcbiAgY21wPzogKHZhbHVlOiBudW1iZXIpID0+IGJvb2xlYW5cbikge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkOiBudW1iZXI7XG5cbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuXG4vKipcbiAqIEJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcGFyYW0gbGFzdCAtIGxvb2t1cCBsYXN0IGluZGV4XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX2xvb2t1cEJ5S2V5ID0gKFxuICB0YWJsZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPltdLFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IG51bWJlcixcbiAgbGFzdD86IGJvb2xlYW5cbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHtcbiAgICAgIGNvbnN0IHRpID0gdGFibGVbaW5kZXhdW2tleV07XG4gICAgICByZXR1cm4gdGkgPCB2YWx1ZSB8fCB0aSA9PT0gdmFsdWUgJiYgdGFibGVbaW5kZXggKyAxXVtrZXldID09PSB2YWx1ZTtcbiAgICB9XG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcblxuLyoqXG4gKiBSZXZlcnNlIGJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3Jsb29rdXBCeUtleSA9IChcbiAgdGFibGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj5bXSxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBudW1iZXJcbikgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcblxuLyoqXG4gKiBSZXR1cm4gc3Vic2V0IG9mIGB2YWx1ZXNgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIGluY2x1c2l2ZS5cbiAqIFZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWVzIC0gc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZVxuICogQHBhcmFtIG1heCAtIG1heCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2ZpbHRlckJldHdlZW4odmFsdWVzOiBudW1iZXJbXSwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cblxuICByZXR1cm4gc3RhcnQgPiAwIHx8IGVuZCA8IHZhbHVlcy5sZW5ndGhcbiAgICA/IHZhbHVlcy5zbGljZShzdGFydCwgZW5kKVxuICAgIDogdmFsdWVzO1xufVxuXG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGludGVyZmFjZSBBcnJheUxpc3RlbmVyPFQ+IHtcbiAgX29uRGF0YVB1c2g/KC4uLml0ZW06IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFQb3A/KCk6IHZvaWQ7XG4gIF9vbkRhdGFTaGlmdD8oKTogdm9pZDtcbiAgX29uRGF0YVNwbGljZT8oaW5kZXg6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IHZvaWQ7XG4gIF9vbkRhdGFVbnNoaWZ0PyguLi5pdGVtOiBUW10pOiB2b2lkO1xufVxuXG4vKipcbiAqIEhvb2tzIHRoZSBhcnJheSBtZXRob2RzIHRoYXQgYWRkIG9yIHJlbW92ZSB2YWx1ZXMgKCdwdXNoJywgcG9wJywgJ3NoaWZ0JywgJ3NwbGljZScsXG4gKiAndW5zaGlmdCcpIGFuZCBub3RpZnkgdGhlIGxpc3RlbmVyIEFGVEVSIHRoZSBhcnJheSBoYXMgYmVlbiBhbHRlcmVkLiBMaXN0ZW5lcnMgYXJlXG4gKiBjYWxsZWQgb24gdGhlICdfb25EYXRhKicgY2FsbGJhY2tzIChlLmcuIF9vbkRhdGFQdXNoLCBldGMuKSB3aXRoIHNhbWUgYXJndW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHM8VD4oYXJyYXk6IFRbXSwgbGlzdGVuZXI6IEFycmF5TGlzdGVuZXI8VD4pOiB2b2lkO1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgY29uc3QgYmFzZSA9IGFycmF5W2tleV07XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnaXZlbiBhcnJheSBldmVudCBsaXN0ZW5lciBhbmQgY2xlYW51cCBleHRyYSBhdHRhY2hlZCBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiB0aGUgX2NoYXJ0anMgc3R1YiBhbmQgb3ZlcnJpZGRlbiBtZXRob2RzKSBpZiBhcnJheSBkb2Vzbid0IGhhdmUgYW55IG1vcmUgbGlzdGVuZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50czxUPihhcnJheTogVFtdLCBsaXN0ZW5lcjogQXJyYXlMaXN0ZW5lcjxUPik6IHZvaWQ7XG5leHBvcnQgZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBsaXN0ZW5lcnMgPSBzdHViLmxpc3RlbmVycztcbiAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcblxuICBkZWxldGUgYXJyYXkuX2NoYXJ0anM7XG59XG5cbi8qKlxuICogQHBhcmFtIGl0ZW1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYXJyYXlVbmlxdWU8VD4oaXRlbXM6IFRbXSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0PFQ+KGl0ZW1zKTtcblxuICBpZiAoc2V0LnNpemUgPT09IGl0ZW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG4iLCAiaW1wb3J0IHR5cGUge0NoYXJ0TWV0YSwgUG9pbnRFbGVtZW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmltcG9ydCB7X2xpbWl0VmFsdWV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGZvbnRTdHJpbmcocGl4ZWxTaXplOiBudW1iZXIsIGZvbnRTdHlsZTogc3RyaW5nLCBmb250RmFtaWx5OiBzdHJpbmcpIHtcbiAgcmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcbn1cblxuLyoqXG4qIFJlcXVlc3QgYW5pbWF0aW9uIHBvbHlmaWxsXG4qL1xuZXhwb3J0IGNvbnN0IHJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn0oKSk7XG5cbi8qKlxuICogVGhyb3R0bGVzIGNhbGxpbmcgYGZuYCBvbmNlIHBlciBhbmltYXRpb24gZnJhbWVcbiAqIExhdGVzdCBhcmd1bWVudHMgYXJlIHVzZWQgb24gdGhlIGFjdHVhbCBjYWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZWQ8VEFyZ3MgZXh0ZW5kcyBBcnJheTxhbnk+PihcbiAgZm46ICguLi5hcmdzOiBUQXJncykgPT4gdm9pZCxcbiAgdGhpc0FyZzogYW55LFxuKSB7XG4gIGxldCBhcmdzVG9Vc2UgPSBbXSBhcyBUQXJncztcbiAgbGV0IHRpY2tpbmcgPSBmYWxzZTtcblxuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogVEFyZ3MpIHtcbiAgICAvLyBTYXZlIHRoZSBhcmdzIGZvciB1c2UgbGF0ZXJcbiAgICBhcmdzVG9Vc2UgPSBhcmdzO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJnc1RvVXNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBEZWJvdW5jZXMgY2FsbGluZyBgZm5gIGZvciBgZGVsYXlgIG1zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZTxUQXJncyBleHRlbmRzIEFycmF5PGFueT4+KGZuOiAoLi4uYXJnczogVEFyZ3MpID0+IHZvaWQsIGRlbGF5OiBudW1iZXIpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBUQXJncykge1xuICAgIGlmIChkZWxheSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGRlbGF5LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyAnc3RhcnQnIHRvICdsZWZ0JywgJ2VuZCcgdG8gJ3JpZ2h0JyBhbmQgb3RoZXJzIHRvICdjZW50ZXInXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduOiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJykgPT4gYWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG5cbi8qKlxuICogUmV0dXJucyBgc3RhcnRgLCBgZW5kYCBvciBgKHN0YXJ0ICsgZW5kKSAvIDJgIGRlcGVuZGluZyBvbiBgYWxpZ25gLiBEZWZhdWx0cyB0byBgY2VudGVyYFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduOiAnc3RhcnQnIHwgJ2VuZCcgfCAnY2VudGVyJywgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpID0+IGFsaWduID09PSAnc3RhcnQnID8gc3RhcnQgOiBhbGlnbiA9PT0gJ2VuZCcgPyBlbmQgOiAoc3RhcnQgKyBlbmQpIC8gMjtcblxuLyoqXG4gKiBSZXR1cm5zIGBsZWZ0YCwgYHJpZ2h0YCBvciBgKGxlZnQgKyByaWdodCkgLyAyYCBkZXBlbmRpbmcgb24gYGFsaWduYC4gRGVmYXVsdHMgdG8gYGxlZnRgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgX3RleHRYID0gKGFsaWduOiAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcicsIGxlZnQ6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgcnRsOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgcmV0dXJuIGFsaWduID09PSBjaGVjayA/IHJpZ2h0IDogYWxpZ24gPT09ICdjZW50ZXInID8gKGxlZnQgKyByaWdodCkgLyAyIDogbGVmdDtcbn07XG5cbi8qKlxuICogUmV0dXJuIHN0YXJ0IGFuZCBjb3VudCBvZiB2aXNpYmxlIHBvaW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhOiBDaGFydE1ldGE8J2xpbmUnIHwgJ3NjYXR0ZXInPiwgcG9pbnRzOiBQb2ludEVsZW1lbnRbXSwgYW5pbWF0aW9uc0Rpc2FibGVkOiBib29sZWFuKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBjb3VudCA9IHBvaW50Q291bnQ7XG5cbiAgaWYgKG1ldGEuX3NvcnRlZCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IHNwYW5HYXBzID0gbWV0YS5kYXRhc2V0ID8gbWV0YS5kYXRhc2V0Lm9wdGlvbnMgPyBtZXRhLmRhdGFzZXQub3B0aW9ucy5zcGFuR2FwcyA6IG51bGwgOiBudWxsO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICBzdGFydCA9IE1hdGgubWluKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBheGlzLCBtaW4pLmxvLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pO1xuICAgICAgaWYgKHNwYW5HYXBzKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkTG8gPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZSgwLCBzdGFydCArIDEpXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIHN0YXJ0IC09IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkTG8pO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgbGV0IGVuZCA9IE1hdGgubWF4KFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4LCB0cnVlKS5oaSArIDEsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgTmVlZCB0byBmaXggdHlwZXMgb24gX2xvb2t1cEJ5S2V5XG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpLCB0cnVlKS5oaSArIDEpO1xuICAgICAgaWYgKHNwYW5HYXBzKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9EZWZpbmVkSGkgPSAoX3BhcnNlZFxuICAgICAgICAgIC5zbGljZShlbmQgLSAxKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIGVuZCArPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZEhpKTtcbiAgICAgIH1cbiAgICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoZW5kLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtzdGFydCwgY291bnR9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc2NhbGUgcmFuZ2VzIGhhdmUgY2hhbmdlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhIC0gZGF0YXNldCBtZXRhLlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZSwgX3NjYWxlUmFuZ2VzfSA9IG1ldGE7XG4gIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICB4bWluOiB4U2NhbGUubWluLFxuICAgIHhtYXg6IHhTY2FsZS5tYXgsXG4gICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICB5bWF4OiB5U2NhbGUubWF4XG4gIH07XG4gIGlmICghX3NjYWxlUmFuZ2VzKSB7XG4gICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgY2hhbmdlZCA9IF9zY2FsZVJhbmdlcy54bWluICE9PSB4U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXhcblx0XHR8fCBfc2NhbGVSYW5nZXMueW1pbiAhPT0geVNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWF4ICE9PSB5U2NhbGUubWF4O1xuXG4gIE9iamVjdC5hc3NpZ24oX3NjYWxlUmFuZ2VzLCBuZXdSYW5nZXMpO1xuICByZXR1cm4gY2hhbmdlZDtcbn1cbiIsICJpbXBvcnQge1BJLCBUQVUsIEhBTEZfUEl9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcblxuY29uc3QgYXRFZGdlID0gKHQ6IG51bWJlcikgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQ6IG51bWJlciwgczogbnVtYmVyLCBwOiBudW1iZXIpID0+IC0oTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkpO1xuY29uc3QgZWxhc3RpY091dCA9ICh0OiBudW1iZXIsIHM6IG51bWJlciwgcDogbnVtYmVyKSA9PiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSArIDE7XG5cbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nLmVmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqL1xuY29uc3QgZWZmZWN0cyA9IHtcbiAgbGluZWFyOiAodDogbnVtYmVyKSA9PiB0LFxuXG4gIGVhc2VJblF1YWQ6ICh0OiBudW1iZXIpID0+IHQgKiB0LFxuXG4gIGVhc2VPdXRRdWFkOiAodDogbnVtYmVyKSA9PiAtdCAqICh0IC0gMiksXG5cbiAgZWFzZUluT3V0UXVhZDogKHQ6IG51bWJlcikgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSksXG5cbiAgZWFzZUluQ3ViaWM6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCxcblxuICBlYXNlT3V0Q3ViaWM6ICh0OiBudW1iZXIpID0+ICh0IC09IDEpICogdCAqIHQgKyAxLFxuXG4gIGVhc2VJbk91dEN1YmljOiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICsgMiksXG5cbiAgZWFzZUluUXVhcnQ6ICh0OiBudW1iZXIpID0+IHQgKiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dFF1YXJ0OiAodDogbnVtYmVyKSA9PiAtKCh0IC09IDEpICogdCAqIHQgKiB0IC0gMSksXG5cbiAgZWFzZUluT3V0UXVhcnQ6ICh0OiBudW1iZXIpID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHRcbiAgICA6IC0wLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgLSAyKSxcblxuICBlYXNlSW5RdWludDogKHQ6IG51bWJlcikgPT4gdCAqIHQgKiB0ICogdCAqIHQsXG5cbiAgZWFzZU91dFF1aW50OiAodDogbnVtYmVyKSA9PiAodCAtPSAxKSAqIHQgKiB0ICogdCAqIHQgKyAxLFxuXG4gIGVhc2VJbk91dFF1aW50OiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpLFxuXG4gIGVhc2VJblNpbmU6ICh0OiBudW1iZXIpID0+IC1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuXG4gIGVhc2VPdXRTaW5lOiAodDogbnVtYmVyKSA9PiBNYXRoLnNpbih0ICogSEFMRl9QSSksXG5cbiAgZWFzZUluT3V0U2luZTogKHQ6IG51bWJlcikgPT4gLTAuNSAqIChNYXRoLmNvcyhQSSAqIHQpIC0gMSksXG5cbiAgZWFzZUluRXhwbzogKHQ6IG51bWJlcikgPT4gKHQgPT09IDApID8gMCA6IE1hdGgucG93KDIsIDEwICogKHQgLSAxKSksXG5cbiAgZWFzZU91dEV4cG86ICh0OiBudW1iZXIpID0+ICh0ID09PSAxKSA/IDEgOiAtTWF0aC5wb3coMiwgLTEwICogdCkgKyAxLFxuXG4gIGVhc2VJbk91dEV4cG86ICh0OiBudW1iZXIpID0+IGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41XG4gICAgPyAwLjUgKiBNYXRoLnBvdygyLCAxMCAqICh0ICogMiAtIDEpKVxuICAgIDogMC41ICogKC1NYXRoLnBvdygyLCAtMTAgKiAodCAqIDIgLSAxKSkgKyAyKSxcblxuICBlYXNlSW5DaXJjOiAodDogbnVtYmVyKSA9PiAodCA+PSAxKSA/IHQgOiAtKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSksXG5cbiAgZWFzZU91dENpcmM6ICh0OiBudW1iZXIpID0+IE1hdGguc3FydCgxIC0gKHQgLT0gMSkgKiB0KSxcblxuICBlYXNlSW5PdXRDaXJjOiAodDogbnVtYmVyKSA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAtMC41ICogKE1hdGguc3FydCgxIC0gdCAqIHQpIC0gMSlcbiAgICA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcblxuICBlYXNlSW5FbGFzdGljOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY0luKHQsIDAuMDc1LCAwLjMpLFxuXG4gIGVhc2VPdXRFbGFzdGljOiAodDogbnVtYmVyKSA9PiBhdEVkZ2UodCkgPyB0IDogZWxhc3RpY091dCh0LCAwLjA3NSwgMC4zKSxcblxuICBlYXNlSW5PdXRFbGFzdGljKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IHMgPSAwLjExMjU7XG4gICAgY29uc3QgcCA9IDAuNDU7XG4gICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOlxuICAgICAgdCA8IDAuNVxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcbiAgICAgICAgOiAwLjUgKyAwLjUgKiBlbGFzdGljT3V0KHQgKiAyIC0gMSwgcywgcCk7XG4gIH0sXG5cbiAgZWFzZUluQmFjayh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgfSxcblxuICBlYXNlT3V0QmFjayh0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gKHQgLT0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxO1xuICB9LFxuXG4gIGVhc2VJbk91dEJhY2sodDogbnVtYmVyKSB7XG4gICAgbGV0IHMgPSAxLjcwMTU4O1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG4gIH0sXG5cbiAgZWFzZUluQm91bmNlOiAodDogbnVtYmVyKSA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcblxuICBlYXNlT3V0Qm91bmNlKHQ6IG51bWJlcikge1xuICAgIGNvbnN0IG0gPSA3LjU2MjU7XG4gICAgY29uc3QgZCA9IDIuNzU7XG4gICAgaWYgKHQgPCAoMSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqIHQgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8ICgyIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDEuNSAvIGQpKSAqIHQgKyAwLjc1O1xuICAgIH1cbiAgICBpZiAodCA8ICgyLjUgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMi4yNSAvIGQpKSAqIHQgKyAwLjkzNzU7XG4gICAgfVxuICAgIHJldHVybiBtICogKHQgLT0gKDIuNjI1IC8gZCkpICogdCArIDAuOTg0Mzc1O1xuICB9LFxuXG4gIGVhc2VJbk91dEJvdW5jZTogKHQ6IG51bWJlcikgPT4gKHQgPCAwLjUpXG4gICAgPyBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjVcbiAgICA6IGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41LFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgRWFzaW5nRnVuY3Rpb24gPSBrZXlvZiB0eXBlb2YgZWZmZWN0c1xuXG5leHBvcnQgZGVmYXVsdCBlZmZlY3RzO1xuIiwgImltcG9ydCB7Q29sb3J9IGZyb20gJ0BrdXJrbGUvY29sb3InO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIENhbnZhc1BhdHRlcm4gfCBDYW52YXNHcmFkaWVudCB7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJyB8fCB0eXBlID09PSAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gY29sb3IodmFsdWU6IENhbnZhc1BhdHRlcm4pOiBDYW52YXNQYXR0ZXJuO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKFxuICB2YWx1ZTpcbiAgfCBzdHJpbmdcbiAgfCB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXI7IGE6IG51bWJlciB9XG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXJdXG4gIHwgW251bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl1cbik6IENvbG9yO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogbmV3IENvbG9yKHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWU6IENhbnZhc0dyYWRpZW50KTogQ2FudmFzR3JhZGllbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogQ2FudmFzUGF0dGVybik6IENhbnZhc1BhdHRlcm47XG5leHBvcnQgZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZTogc3RyaW5nKTogc3RyaW5nO1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogbmV3IENvbG9yKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuIiwgImNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uc0RlZmF1bHRzKGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICAgIGRlbGF5OiB1bmRlZmluZWQsXG4gICAgZHVyYXRpb246IDEwMDAsXG4gICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgICBmbjogdW5kZWZpbmVkLFxuICAgIGZyb206IHVuZGVmaW5lZCxcbiAgICBsb29wOiB1bmRlZmluZWQsXG4gICAgdG86IHVuZGVmaW5lZCxcbiAgICB0eXBlOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb24nLCB7XG4gICAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdvblByb2dyZXNzJyAmJiBuYW1lICE9PSAnb25Db21wbGV0ZScgJiYgbmFtZSAhPT0gJ2ZuJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICAgIGNvbG9yczoge1xuICAgICAgdHlwZTogJ2NvbG9yJyxcbiAgICAgIHByb3BlcnRpZXM6IGNvbG9yc1xuICAgIH0sXG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBudW1iZXJzXG4gICAgfSxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcbiAgfSk7XG5cbiAgZGVmYXVsdHMuc2V0KCd0cmFuc2l0aW9ucycsIHtcbiAgICBhY3RpdmU6IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogNDAwXG4gICAgICB9XG4gICAgfSxcbiAgICByZXNpemU6IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdzoge1xuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICAgIH0sXG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZHVyYXRpb246IDAgLy8gc2hvdyBpbW1lZGlhdGVseVxuICAgICAgICB9LFxuICAgICAgfVxuICAgIH0sXG4gICAgaGlkZToge1xuICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9LFxuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgICAgZm46IHYgPT4gdiB8IDAgLy8gZm9yIGtlZXBpbmcgdGhlIGRhdGFzZXQgdmlzaWJsZSBhbGwgdGhlIHdheSB0aHJvdWdoIHRoZSBhbmltYXRpb25cbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuIiwgImV4cG9ydCBmdW5jdGlvbiBhcHBseUxheW91dHNEZWZhdWx0cyhkZWZhdWx0cykge1xuICBkZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcbiAgICBhdXRvUGFkZGluZzogdHJ1ZSxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMCxcbiAgICAgIGxlZnQ6IDBcbiAgICB9XG4gIH0pO1xufVxuIiwgIlxuY29uc3QgaW50bENhY2hlID0gbmV3IE1hcDxzdHJpbmcsIEludGwuTnVtYmVyRm9ybWF0PigpO1xuXG5mdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlOiBzdHJpbmcsIG9wdGlvbnM/OiBJbnRsLk51bWJlckZvcm1hdE9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtOiBudW1iZXIsIGxvY2FsZTogc3RyaW5nLCBvcHRpb25zPzogSW50bC5OdW1iZXJGb3JtYXRPcHRpb25zKSB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cbiIsICJpbXBvcnQge2lzQXJyYXl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge2xvZzEwfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgZm9ybWF0dGVycyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHRpY2tzXG4gKiBAbmFtZXNwYWNlIENoYXJ0LlRpY2tzLmZvcm1hdHRlcnNcbiAqL1xuY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgLyoqXG4gICAqIEZvcm1hdHRlciBmb3IgdmFsdWUgbGFiZWxzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy52YWx1ZXNcbiAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBkaXNwbGF5XG4gICAqIEByZXR1cm4ge3N0cmluZ3xzdHJpbmdbXX0gdGhlIGxhYmVsIHRvIGRpc3BsYXlcbiAgICovXG4gIHZhbHVlcyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IC8qKiBAdHlwZSB7c3RyaW5nW119ICovICh2YWx1ZSkgOiAnJyArIHZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIG51bWVyaWMgdGlja3NcbiAgICogQG1ldGhvZCBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICogQHBhcmFtIHRpY2tWYWx1ZSB7bnVtYmVyfSB0aGUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gICAqIEBwYXJhbSBpbmRleCB7bnVtYmVyfSB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tWYWx1ZSBwYXJhbWV0ZXIgaW4gdGhlIHRpY2tzIGFycmF5XG4gICAqIEBwYXJhbSB0aWNrcyB7b2JqZWN0W119IHRoZSBsaXN0IG9mIHRpY2tzIGJlaW5nIGNvbnZlcnRlZFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlclxuICAgKi9cbiAgbnVtZXJpYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7IC8vIG5ldmVyIHNob3cgZGVjaW1hbCBwbGFjZXMgZm9yIDBcbiAgICB9XG5cbiAgICBjb25zdCBsb2NhbGUgPSB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlO1xuICAgIGxldCBub3RhdGlvbjtcbiAgICBsZXQgZGVsdGEgPSB0aWNrVmFsdWU7IC8vIFRoaXMgaXMgdXNlZCB3aGVuIHRoZXJlIGFyZSBsZXNzIHRoYW4gMiB0aWNrcyBhcyB0aGUgdGljayBpbnRlcnZhbC5cblxuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBhbGwgdGlja3MgYXJlIHNtYWxsIG9yIHRoZXJlIGh1Z2UgbnVtYmVyczsgdXNlIHNjaWVudGlmaWMgbm90YXRpb25cbiAgICAgIGNvbnN0IG1heFRpY2sgPSBNYXRoLm1heChNYXRoLmFicyh0aWNrc1swXS52YWx1ZSksIE1hdGguYWJzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlKSk7XG4gICAgICBpZiAobWF4VGljayA8IDFlLTQgfHwgbWF4VGljayA+IDFlKzE1KSB7XG4gICAgICAgIG5vdGF0aW9uID0gJ3NjaWVudGlmaWMnO1xuICAgICAgfVxuXG4gICAgICBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ0RlbHRhID0gbG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcblxuICAgIC8vIFdoZW4gZGF0YXNldHMgaGF2ZSB2YWx1ZXMgYXBwcm9hY2hpbmcgTnVtYmVyLk1BWF9WQUxVRSwgdGhlIHRpY2sgY2FsY3VsYXRpb25zIG1pZ2h0IHJlc3VsdCBpblxuICAgIC8vIGluZmluaXR5IGFuZCBldmVudHVhbGx5IE5hTi4gUGFzc2luZyBOYU4gZm9yIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyBvciBtYXhpbXVtRnJhY3Rpb25EaWdpdHNcbiAgICAvLyB3aWxsIG1ha2UgdGhlIG51bWJlciBmb3JtYXR0ZXIgdGhyb3cuIFNvIGluc3RlYWQgd2UgY2hlY2sgZm9yIGlzTmFOIGFuZCB1c2UgYSBmYWxsYmFjayB2YWx1ZS5cbiAgICAvL1xuICAgIC8vIHRvRml4ZWQgaGFzIGEgbWF4IG9mIDIwIGRlY2ltYWwgcGxhY2VzXG4gICAgY29uc3QgbnVtRGVjaW1hbCA9IGlzTmFOKGxvZ0RlbHRhKSA/IDEgOiBNYXRoLm1heChNYXRoLm1pbigtMSAqIE1hdGguZmxvb3IobG9nRGVsdGEpLCAyMCksIDApO1xuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHtub3RhdGlvbiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWx9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG5cbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBGb3JtYXR0ZXIgZm9yIGxvZ2FyaXRobWljIHRpY2tzXG4gICAqIEBtZXRob2QgQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pY1xuICAgKiBAcGFyYW0gdGlja1ZhbHVlIHtudW1iZXJ9IHRoZSB2YWx1ZSB0byBiZSBmb3JtYXR0ZWRcbiAgICogQHBhcmFtIGluZGV4IHtudW1iZXJ9IHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja1ZhbHVlIHBhcmFtZXRlciBpbiB0aGUgdGlja3MgYXJyYXlcbiAgICogQHBhcmFtIHRpY2tzIHtvYmplY3RbXX0gdGhlIGxpc3Qgb2YgdGlja3MgYmVpbmcgY29udmVydGVkXG4gICAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0aWNrVmFsdWUgcGFyYW1ldGVyXG4gICAqL1xuICBsb2dhcml0aG1pYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tzW2luZGV4XS5zaWduaWZpY2FuZCB8fCAodGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWx1ZSkpKSkpO1xuICAgIGlmIChbMSwgMiwgMywgNSwgMTAsIDE1XS5pbmNsdWRlcyhyZW1haW4pIHx8IGluZGV4ID4gMC44ICogdGlja3MubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5udW1lcmljLmNhbGwodGhpcywgdGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cblxufTtcblxuXG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gIC8vIEZpZ3VyZSBvdXQgaG93IG1hbnkgZGlnaXRzIHRvIHNob3dcbiAgLy8gVGhlIHNwYWNlIGJldHdlZW4gdGhlIGZpcnN0IHR3byB0aWNrcyBtaWdodCBiZSBzbWFsbGVyIHRoYW4gbm9ybWFsIHNwYWNpbmdcbiAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuXG4gIC8vIElmIHdlIGhhdmUgYSBudW1iZXIgbGlrZSAyLjUgYXMgdGhlIGRlbHRhLCBmaWd1cmUgb3V0IGhvdyBtYW55IGRlY2ltYWwgcGxhY2VzIHdlIG5lZWRcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAxICYmIHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG4gICAgLy8gbm90IGFuIGludGVnZXJcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG5cbi8qKlxuICogTmFtZXNwYWNlIHRvIGhvbGQgc3RhdGljIHRpY2sgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuVGlja3NcbiAqL1xuZXhwb3J0IGRlZmF1bHQge2Zvcm1hdHRlcnN9O1xuIiwgImltcG9ydCBUaWNrcyBmcm9tICcuL2NvcmUudGlja3MuanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTY2FsZURlZmF1bHRzKGRlZmF1bHRzKSB7XG4gIGRlZmF1bHRzLnNldCgnc2NhbGUnLCB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBvZmZzZXQ6IGZhbHNlLFxuICAgIHJldmVyc2U6IGZhbHNlLFxuICAgIGJlZ2luQXRaZXJvOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFNjYWxlIGJvdW5kYXJ5IHN0cmF0ZWd5IChieXBhc3NlZCBieSBtaW4vbWF4IHRpbWUgb3B0aW9ucylcbiAgICAgKiAtIGBkYXRhYDogbWFrZSBzdXJlIGRhdGEgYXJlIGZ1bGx5IHZpc2libGUsIHRpY2tzIG91dHNpZGUgYXJlIHJlbW92ZWRcbiAgICAgKiAtIGB0aWNrc2A6IG1ha2Ugc3VyZSB0aWNrcyBhcmUgZnVsbHkgdmlzaWJsZSwgZGF0YSBvdXRzaWRlIGFyZSB0cnVuY2F0ZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDU1NlxuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqL1xuICAgIGJvdW5kczogJ3RpY2tzJyxcblxuICAgIGNsaXA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbiBncmFjZSBhZGRlZCB0byBtYXggYW5kIHJlZHVjZWQgZnJvbSBtaW4gZGF0YSB2YWx1ZS5cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKi9cbiAgICBncmFjZTogMCxcblxuICAgIC8vIGdyaWQgbGluZSBzZXR0aW5nc1xuICAgIGdyaWQ6IHtcbiAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBkcmF3T25DaGFydEFyZWE6IHRydWUsXG4gICAgICBkcmF3VGlja3M6IHRydWUsXG4gICAgICB0aWNrTGVuZ3RoOiA4LFxuICAgICAgdGlja1dpZHRoOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmNvbG9yLFxuICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICB9LFxuXG4gICAgYm9yZGVyOiB7XG4gICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgZGFzaDogW10sXG4gICAgICBkYXNoT2Zmc2V0OiAwLjAsXG4gICAgICB3aWR0aDogMVxuICAgIH0sXG5cbiAgICAvLyBzY2FsZSB0aXRsZVxuICAgIHRpdGxlOiB7XG4gICAgICAvLyBkaXNwbGF5IHByb3BlcnR5XG4gICAgICBkaXNwbGF5OiBmYWxzZSxcblxuICAgICAgLy8gYWN0dWFsIGxhYmVsXG4gICAgICB0ZXh0OiAnJyxcblxuICAgICAgLy8gdG9wL2JvdHRvbSBwYWRkaW5nXG4gICAgICBwYWRkaW5nOiB7XG4gICAgICAgIHRvcDogNCxcbiAgICAgICAgYm90dG9tOiA0XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGxhYmVsIHNldHRpbmdzXG4gICAgdGlja3M6IHtcbiAgICAgIG1pblJvdGF0aW9uOiAwLFxuICAgICAgbWF4Um90YXRpb246IDUwLFxuICAgICAgbWlycm9yOiBmYWxzZSxcbiAgICAgIHRleHRTdHJva2VXaWR0aDogMCxcbiAgICAgIHRleHRTdHJva2VDb2xvcjogJycsXG4gICAgICBwYWRkaW5nOiAzLFxuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGF1dG9Ta2lwOiB0cnVlLFxuICAgICAgYXV0b1NraXBQYWRkaW5nOiAzLFxuICAgICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgICAvLyBXZSBwYXNzIHRocm91Z2ggYXJyYXlzIHRvIGJlIHJlbmRlcmVkIGFzIG11bHRpbGluZSBsYWJlbHMsIHdlIGNvbnZlcnQgT3RoZXJzIHRvIHN0cmluZ3MgaGVyZS5cbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcbiAgICAgIG1pbm9yOiB7fSxcbiAgICAgIG1ham9yOiB7fSxcbiAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgIGNyb3NzQWxpZ246ICduZWFyJyxcblxuICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IGZhbHNlLFxuICAgICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICAgIH1cbiAgfSk7XG5cbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpY2tzJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmJvcmRlcicsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbiAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpdGxlJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZScsIHtcbiAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnYmVmb3JlJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnYWZ0ZXInKSAmJiBuYW1lICE9PSAnY2FsbGJhY2snICYmIG5hbWUgIT09ICdwYXJzZXInLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ3RpY2tCb3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZGFzaCcsXG4gIH0pO1xuXG4gIGRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZXMnLCB7XG4gICAgX2ZhbGxiYWNrOiAnc2NhbGUnLFxuICB9KTtcblxuICBkZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUudGlja3MnLCB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyxcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHtnZXRIb3ZlckNvbG9yfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sb3IuanMnO1xuaW1wb3J0IHtpc09iamVjdCwgbWVyZ2UsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzfSBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5TGF5b3V0c0RlZmF1bHRzfSBmcm9tICcuL2NvcmUubGF5b3V0cy5kZWZhdWx0cy5qcyc7XG5pbXBvcnQge2FwcGx5U2NhbGVEZWZhdWx0c30gZnJvbSAnLi9jb3JlLnNjYWxlLmRlZmF1bHRzLmpzJztcblxuZXhwb3J0IGNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5leHBvcnQgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNjb3BlKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gIGlmICh0eXBlb2Ygc2NvcGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUocm9vdCwgJycpLCBzY29wZSk7XG59XG5cbi8qKlxuICogUGxlYXNlIHVzZSB0aGUgbW9kdWxlJ3MgZGVmYXVsdCBleHBvcnQgd2hpY2ggcHJvdmlkZXMgYSBzaW5nbGV0b24gaW5zdGFuY2VcbiAqIE5vdGU6IGNsYXNzIGlzIGV4cG9ydGVkIGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0cyB7XG4gIGNvbnN0cnVjdG9yKF9kZXNjcmlwdG9ycywgX2FwcGxpZXJzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuXG4gICAgdGhpcy5kZXNjcmliZShfZGVzY3JpcHRvcnMpO1xuICAgIHRoaXMuYXBwbHkoX2FwcGxpZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZVxuXHQgKi9cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlKHRoaXMsIHNjb3BlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHNjb3BlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbdmFsdWVzXVxuXHQgKi9cbiAgZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQoZGVzY3JpcHRvcnMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG5cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSb3V0ZXMgdGhlIG5hbWVkIGRlZmF1bHRzIHRvIGZhbGxiYWNrIHRvIGFub3RoZXIgc2NvcGUvbmFtZS5cblx0ICogVGhpcyByb3V0aW5nIGlzIHVzZWZ1bCB3aGVuIHRob3NlIHRhcmdldCB2YWx1ZXMsIGxpa2UgZGVmYXVsdHMuY29sb3IsIGFyZSBjaGFuZ2VkIHJ1bnRpbWUuXG5cdCAqIElmIHRoZSB2YWx1ZXMgd291bGQgYmUgY29waWVkLCB0aGUgcnVudGltZSBjaGFuZ2Ugd291bGQgbm90IHRha2UgZWZmZWN0LiBCeSByb3V0aW5nLCB0aGVcblx0ICogZmFsbGJhY2sgaXMgZXZhbHVhdGVkIGF0IGVhY2ggYWNjZXNzLCBzbyBpdHMgYWx3YXlzIHVwIHRvIGRhdGUuXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqXG5cdCAqIFx0ZGVmYXVsdHMucm91dGUoJ2VsZW1lbnRzLmFyYycsICdiYWNrZ3JvdW5kQ29sb3InLCAnJywgJ2NvbG9yJylcblx0ICogICAtIHJlYWRzIHRoZSBiYWNrZ3JvdW5kQ29sb3IgZnJvbSBkZWZhdWx0cy5jb2xvciB3aGVuIHVuZGVmaW5lZCBsb2NhbGx5XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSBTY29wZSB0aGlzIHJvdXRlIGFwcGxpZXMgdG8uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWUgdGhhdCBzaG91bGQgYmUgcm91dGVkIHRvIGRpZmZlcmVudCBuYW1lc3BhY2Ugd2hlbiBub3QgZGVmaW5lZCBoZXJlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0U2NvcGUgVGhlIG5hbWVzcGFjZSB3aGVyZSB0aG9zZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSByb3V0ZWQgdG8uXG5cdCAqIEVtcHR5IHN0cmluZyAoJycpIGlzIHRoZSByb290IG9mIGRlZmF1bHRzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0TmFtZSBUaGUgdGFyZ2V0IG5hbWUgaW4gdGhlIHRhcmdldCBzY29wZSB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJvdXRlZCB0by5cblx0ICovXG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgIGNvbnN0IHByaXZhdGVOYW1lID0gJ18nICsgbmFtZTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICAvLyBBIHByaXZhdGUgcHJvcGVydHkgaXMgZGVmaW5lZCB0byBob2xkIHRoZSBhY3R1YWwgdmFsdWUsIHdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBzZXQgaW4gaXRzIHNjb3BlIChzZXQgaW4gdGhlIHNldHRlcilcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC8vIFRoZSBhY3R1YWwgcHJvcGVydHkgaXMgZGVmaW5lZCBhcyBnZXR0ZXIvc2V0dGVyIHNvIHdlIGNhbiBkbyB0aGUgcm91dGluZyB3aGVuIHZhbHVlIGlzIG5vdCBsb2NhbGx5IHNldC5cbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYXBwbHkoYXBwbGllcnMpIHtcbiAgICBhcHBsaWVycy5mb3JFYWNoKChhcHBseSkgPT4gYXBwbHkodGhpcykpO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGRlZmF1bHQgLyogI19fUFVSRV9fICovIG5ldyBEZWZhdWx0cyh7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdldmVudHMnLFxuICBob3Zlcjoge1xuICAgIF9mYWxsYmFjazogJ2ludGVyYWN0aW9uJ1xuICB9LFxuICBpbnRlcmFjdGlvbjoge1xuICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfVxufSwgW2FwcGx5QW5pbWF0aW9uc0RlZmF1bHRzLCBhcHBseUxheW91dHNEZWZhdWx0cywgYXBwbHlTY2FsZURlZmF1bHRzXSk7XG4iLCAiaW1wb3J0IHR5cGUge1xuICBDaGFydCxcbiAgUG9pbnQsXG4gIEZvbnRTcGVjLFxuICBDYW52YXNGb250U3BlYyxcbiAgUG9pbnRTdHlsZSxcbiAgUmVuZGVyVGV4dE9wdHMsXG4gIEJhY2tkcm9wT3B0aW9uc1xufSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFRSQkwsXG4gIFNwbGluZVBvaW50LFxuICBSb3VuZGVkUmVjdCxcbiAgVFJCTENvcm5lcnNcbn0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtQSSwgVEFVLCBIQUxGX1BJLCBRVUFSVEVSX1BJLCBUV09fVEhJUkRTX1BJLCBSQURfUEVSX0RFR30gZnJvbSAnLi9oZWxwZXJzLm1hdGguanMnO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBmb250IG9iamVjdCBpbnRvIGEgQ1NTIGZvbnQgc3RyaW5nLlxuICogQHBhcmFtIGZvbnQgLSBBIGZvbnQgb2JqZWN0LlxuICogQHJldHVybiBUaGUgQ1NTIGZvbnQgc3RyaW5nLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udDogRm9udFNwZWMpIHtcbiAgaWYgKCFmb250IHx8IGlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBpc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX21lYXN1cmVUZXh0KFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgZ2M6IHN0cmluZ1tdLFxuICBsb25nZXN0OiBudW1iZXIsXG4gIHN0cmluZzogc3RyaW5nXG4pIHtcbiAgbGV0IHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICBnYy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICBsb25nZXN0ID0gdGV4dFdpZHRoO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuXG50eXBlIFRoaW5nID0gc3RyaW5nIHwgdW5kZWZpbmVkIHwgbnVsbFxudHlwZSBUaGluZ3MgPSAoVGhpbmcgfCBUaGluZ1tdKVtdXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmV4cG9ydCBmdW5jdGlvbiBfbG9uZ2VzdFRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBmb250OiBzdHJpbmcsXG4gIGFycmF5T2ZUaGluZ3M6IFRoaW5ncyxcbiAgY2FjaGU/OiB7ZGF0YT86IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sIGdhcmJhZ2VDb2xsZWN0Pzogc3RyaW5nW10sIGZvbnQ/OiBzdHJpbmd9XG4pIHtcbiAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgbGV0IGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcblxuICBpZiAoY2FjaGUuZm9udCAhPT0gZm9udCkge1xuICAgIGRhdGEgPSBjYWNoZS5kYXRhID0ge307XG4gICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgIGNhY2hlLmZvbnQgPSBmb250O1xuICB9XG5cbiAgY3R4LnNhdmUoKTtcblxuICBjdHguZm9udCA9IGZvbnQ7XG4gIGxldCBsb25nZXN0ID0gMDtcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuICBsZXQgaTogbnVtYmVyLCBqOiBudW1iZXIsIGpsZW46IG51bWJlciwgdGhpbmc6IFRoaW5nIHwgVGhpbmdbXSwgbmVzdGVkVGhpbmc6IFRoaW5nIHwgVGhpbmdbXTtcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcblxuICAgIC8vIFVuZGVmaW5lZCBzdHJpbmdzIGFuZCBhcnJheXMgc2hvdWxkIG5vdCBiZSBtZWFzdXJlZFxuICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KHRoaW5nKSkge1xuICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHRoaW5nKSkge1xuICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgbGV0cyBtZWFzdXJlIGVhY2ggZWxlbWVudFxuICAgICAgLy8gdG8gZG8gbWF5YmUgc2ltcGxpZnkgdGhpcyBmdW5jdGlvbiBhIGJpdCBzbyB3ZSBjYW4gZG8gdGhpcyBtb3JlIHJlY3Vyc2l2ZWx5P1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xuICAgICAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgaWYgKG5lc3RlZFRoaW5nICE9PSB1bmRlZmluZWQgJiYgbmVzdGVkVGhpbmcgIT09IG51bGwgJiYgIWlzQXJyYXkobmVzdGVkVGhpbmcpKSB7XG4gICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjdHgucmVzdG9yZSgpO1xuXG4gIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgaWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgIH1cbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUgdG8gYXZvaWQgYW50aS1hbGlhc2luZyBibHVyXG4gKiBAcGFyYW0gY2hhcnQgLSBUaGUgY2hhcnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0gcGl4ZWwgLSBBIHBpeGVsIHZhbHVlLlxuICogQHBhcmFtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50LlxuICogQHJldHVybnMgVGhlIGFsaWduZWQgcGl4ZWwgdmFsdWUuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2FsaWduUGl4ZWwoY2hhcnQ6IENoYXJ0LCBwaXhlbDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbztcbiAgY29uc3QgaGFsZldpZHRoID0gd2lkdGggIT09IDAgPyBNYXRoLm1heCh3aWR0aCAvIDIsIDAuNSkgOiAwO1xuICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuXG4vKipcbiAqIENsZWFycyB0aGUgZW50aXJlIGNhbnZhcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcz86IEhUTUxDYW52YXNFbGVtZW50LCBjdHg/OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgaWYgKCFjdHggJiYgIWNhbnZhcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBjdHguc2F2ZSgpO1xuICAvLyBjYW52YXMud2lkdGggYW5kIGNhbnZhcy5oZWlnaHQgZG8gbm90IGNvbnNpZGVyIHRoZSBjYW52YXMgdHJhbnNmb3JtLFxuICAvLyB3aGlsZSBjbGVhclJlY3QgZG9lc1xuICBjdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERyYXdQb2ludE9wdGlvbnMge1xuICBwb2ludFN0eWxlOiBQb2ludFN0eWxlO1xuICByb3RhdGlvbj86IG51bWJlcjtcbiAgcmFkaXVzOiBudW1iZXI7XG4gIGJvcmRlcldpZHRoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3UG9pbnQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICBvcHRpb25zOiBEcmF3UG9pbnRPcHRpb25zLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlclxuKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgbnVsbCk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZHJhd1BvaW50TGVnZW5kKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgb3B0aW9uczogRHJhd1BvaW50T3B0aW9ucyxcbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIHc6IG51bWJlclxuKSB7XG4gIGxldCB0eXBlOiBzdHJpbmcsIHhPZmZzZXQ6IG51bWJlciwgeU9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIsIGNvcm5lclJhZGl1czogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCB4T2Zmc2V0VzogbnVtYmVyLCB5T2Zmc2V0VzogbnVtYmVyO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuXG4gIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgdHlwZSA9IHN0eWxlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEhUTUxJbWFnZUVsZW1lbnRdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ2FudmFzRWxlbWVudF0nKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGN0eC5yb3RhdGUocmFkKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2Uoc3R5bGUsIC1zdHlsZS53aWR0aCAvIDIsIC1zdHlsZS5oZWlnaHQgLyAyLCBzdHlsZS53aWR0aCwgc3R5bGUuaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgc3dpdGNoIChzdHlsZSkge1xuICAvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodykge1xuICAgICAgICBjdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgcmFkaXVzLCAwLCAwLCBUQVUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0Um91bmRlZCc6XG4gICAgLy8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG4gICAgLy8gYHF1YWRyYXRpY0N1cnZlVG9gIHNpbmNlIGl0IGdlbmVyYXRlcyBiZXR0ZXIgcmVzdWx0cyB3aGVuIHJlY3QgaXNcbiAgICAvLyBhbG1vc3QgYSBjaXJjbGUuIDAuNTE2IChpbnN0ZWFkIG9mIDAuNSkgcHJvZHVjZXMgcmVzdWx0cyB3aXRoIHZpc3VhbGx5XG4gICAgLy8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcbiAgICAvLyBjaXJjbGUgd2l0aCBgcmFkaXVzYC4gRm9yIG1vcmUgZGV0YWlscywgc2VlIHRoZSBmb2xsb3dpbmcgUFJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81NTk3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcbiAgICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogKHcgPyB3IC8gMiAtIGNvcm5lclJhZGl1cyA6IHNpemUpO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICBjdHguYXJjKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgICBjdHguYXJjKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMoeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZWN0JzpcbiAgICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgICAgd2lkdGggPSB3ID8gdyAvIDIgOiBzaXplO1xuICAgICAgICBjdHgucmVjdCh4IC0gd2lkdGgsIHkgLSBzaXplLCAyICogd2lkdGgsIDIgKiBzaXplKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAncmVjdFJvdCc6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjcm9zc1JvdCc6XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSAnY3Jvc3MnOlxuICAgICAgeE9mZnNldFcgPSBNYXRoLmNvcyhyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldFcgPSBNYXRoLnNpbihyYWQpICogKHcgPyB3IC8gMiA6IHJhZGl1cyk7XG4gICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldFcsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0VywgeSArIHhPZmZzZXQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc3Rhcic6XG4gICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xpbmUnOlxuICAgICAgeE9mZnNldCA9IHcgPyB3IC8gMiA6IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Rhc2gnOlxuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKSwgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmYWxzZTpcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgY3R4LmZpbGwoKTtcbiAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgdGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IHRvIHRlc3RcbiAqIEBwYXJhbSBhcmVhIC0gVGhlIHJlY3RhbmdsZVxuICogQHBhcmFtIG1hcmdpbiAtIGFsbG93ZWQgbWFyZ2luXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEoXG4gIHBvaW50OiBQb2ludCxcbiAgYXJlYTogVFJCTCxcbiAgbWFyZ2luPzogbnVtYmVyXG4pIHtcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTsgLy8gbWFyZ2luIC0gZGVmYXVsdCBpcyB0byBtYXRjaCByb3VuZGVkIGRlY2ltYWxzXG5cbiAgcmV0dXJuICFhcmVhIHx8IChwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmXG5cdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCwgYXJlYTogVFJCTCkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5jbGlwQXJlYShjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xuICBjdHgucmVzdG9yZSgpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3RlcHBlZExpbmVUbyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHByZXZpb3VzOiBQb2ludCxcbiAgdGFyZ2V0OiBQb2ludCxcbiAgZmxpcD86IGJvb2xlYW4sXG4gIG1vZGU/OiBzdHJpbmdcbikge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZVRvKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgcHJldmlvdXM6IFNwbGluZVBvaW50LFxuICB0YXJnZXQ6IFNwbGluZVBvaW50LFxuICBmbGlwPzogYm9vbGVhblxuKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ4IDogdGFyZ2V0LmNwMXgsXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXG4gICAgdGFyZ2V0LngsXG4gICAgdGFyZ2V0LnkpO1xufVxuXG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBSZW5kZXJUZXh0T3B0cykge1xuICBpZiAob3B0cy50cmFuc2xhdGlvbikge1xuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gIH1cblxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG5cbiAgaWYgKG9wdHMuY29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRBbGlnbikge1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgfVxuXG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgbGluZTogc3RyaW5nLFxuICBvcHRzOiBSZW5kZXJUZXh0T3B0c1xuKSB7XG4gIGlmIChvcHRzLnN0cmlrZXRocm91Z2ggfHwgb3B0cy51bmRlcmxpbmUpIHtcbiAgICAvKipcbiAgICAgKiBOb3cgdGhhdCBJRTExIHN1cHBvcnQgaGFzIGJlZW4gZHJvcHBlZCwgd2UgY2FuIHVzZSBtb3JlXG4gICAgICogb2YgdGhlIFRleHRNZXRyaWNzIG9iamVjdC4gVGhlIGFjdHVhbCBib3VuZGluZyBib3hlc1xuICAgICAqIGFyZSB1bmZsYWdnZWQgaW4gQ2hyb21lLCBGaXJlZm94LCBFZGdlLCBhbmQgU2FmYXJpIHNvIHRoZXlcbiAgICAgKiBjYW4gYmUgc2FmZWx5IHVzZWQuXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0TWV0cmljcyNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgKi9cbiAgICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGxpbmUpO1xuICAgIGNvbnN0IGxlZnQgPSB4IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQ7XG4gICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgIGNvbnN0IHRvcCA9IHkgLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgIGNvbnN0IGJvdHRvbSA9IHkgKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcblxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0JhY2tkcm9wKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcHRzOiBCYWNrZHJvcE9wdGlvbnMpIHtcbiAgY29uc3Qgb2xkQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuXG4gIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yIGFzIHN0cmluZztcbiAgY3R4LmZpbGxSZWN0KG9wdHMubGVmdCwgb3B0cy50b3AsIG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxTdHlsZSA9IG9sZENvbG9yO1xufVxuXG4vKipcbiAqIFJlbmRlciB0ZXh0IG9udG8gdGhlIGNhbnZhc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyVGV4dChcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIHRleHQ6IHN0cmluZyB8IHN0cmluZ1tdLFxuICB4OiBudW1iZXIsXG4gIHk6IG51bWJlcixcbiAgZm9udDogQ2FudmFzRm9udFNwZWMsXG4gIG9wdHM6IFJlbmRlclRleHRPcHRzID0ge31cbikge1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgbGV0IGk6IG51bWJlciwgbGluZTogc3RyaW5nO1xuXG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG5cbiAgICBpZiAob3B0cy5iYWNrZHJvcCkge1xuICAgICAgZHJhd0JhY2tkcm9wKGN0eCwgb3B0cy5iYWNrZHJvcCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoO1xuICAgICAgfVxuXG4gICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG5cbiAgICB5ICs9IE51bWJlcihmb250LmxpbmVIZWlnaHQpO1xuICB9XG5cbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHJlY3QgLSBCb3VuZGluZyByZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRSb3VuZGVkUmVjdFBhdGgoXG4gIGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELFxuICByZWN0OiBSb3VuZGVkUmVjdCAmIHsgcmFkaXVzOiBUUkJMQ29ybmVycyB9XG4pIHtcbiAgY29uc3Qge3gsIHksIHcsIGgsIHJhZGl1c30gPSByZWN0O1xuXG4gIC8vIHRvcCBsZWZ0IGFyY1xuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgMS41ICogUEksIFBJLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gdG9wIGxlZnQgdG8gYm90dG9tIGxlZnRcbiAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcblxuICAvLyBib3R0b20gbGVmdCBhcmNcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLmJvdHRvbUxlZnQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQsIHJhZGl1cy5ib3R0b21MZWZ0LCBQSSwgSEFMRl9QSSwgdHJ1ZSk7XG5cbiAgLy8gbGluZSBmcm9tIGJvdHRvbSBsZWZ0IHRvIGJvdHRvbSByaWdodFxuICBjdHgubGluZVRvKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCk7XG5cbiAgLy8gYm90dG9tIHJpZ2h0IGFyY1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcblxuICAvLyBsaW5lIGZyb20gYm90dG9tIHJpZ2h0IHRvIHRvcCByaWdodFxuICBjdHgubGluZVRvKHggKyB3LCB5ICsgcmFkaXVzLnRvcFJpZ2h0KTtcblxuICAvLyB0b3AgcmlnaHQgYXJjXG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuXG4gIC8vIGxpbmUgZnJvbSB0b3AgcmlnaHQgdG8gdG9wIGxlZnRcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuIiwgImltcG9ydCBkZWZhdWx0cyBmcm9tICcuLi9jb3JlL2NvcmUuZGVmYXVsdHMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdCwgdG9EaW1lbnNpb24sIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRm9udFN0cmluZ30gZnJvbSAnLi9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRBcmVhLCBGb250U3BlYywgUG9pbnR9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtUUkJMLCBUUkJMQ29ybmVyc30gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgTElORV9IRUlHSFQgPSAvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLztcbmNvbnN0IEZPTlRfU1RZTEUgPSAvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLztcblxuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi9cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGxpbmUgaGVpZ2h0IGB2YWx1ZWAgaW4gcGl4ZWxzIGZvciBhIHNwZWNpZmljIGZvbnQgYHNpemVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGxpbmVIZWlnaHQgdG8gcGFyc2UgKGVnLiAxLjYsICcxNHB4JywgJzc1JScsICcxLjZlbScpLlxuICogQHBhcmFtIHNpemUgLSBUaGUgZm9udCBzaXplIChpbiBwaXhlbHMpIHVzZWQgdG8gcmVzb2x2ZSByZWxhdGl2ZSBgdmFsdWVgLlxuICogQHJldHVybnMgVGhlIGVmZmVjdGl2ZSBsaW5lIGhlaWdodCBpbiBwaXhlbHMgKHNpemUgKiAxLjIgaWYgdmFsdWUgaXMgaW52YWxpZCkuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9saW5lLWhlaWdodFxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWU6IG51bWJlciB8IHN0cmluZywgc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG5cbiAgdmFsdWUgPSArbWF0Y2hlc1syXTtcblxuICBzd2l0Y2ggKG1hdGNoZXNbM10pIHtcbiAgICBjYXNlICdweCc6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgY2FzZSAnJSc6XG4gICAgICB2YWx1ZSAvPSAxMDA7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gc2l6ZSAqIHZhbHVlO1xufVxuXG5jb25zdCBudW1iZXJPclplcm8gPSAodjogdW5rbm93bikgPT4gK3YgfHwgMDtcblxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBwcm9wc1xuICovXG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHM8SyBleHRlbmRzIHN0cmluZz4odmFsdWU6IG51bWJlciB8IFJlY29yZDxLLCBudW1iZXI+LCBwcm9wczogS1tdKTogUmVjb3JkPEssIG51bWJlcj47XG5leHBvcnQgZnVuY3Rpb24gX3JlYWRWYWx1ZVRvUHJvcHM8SyBleHRlbmRzIHN0cmluZywgVCBleHRlbmRzIHN0cmluZz4odmFsdWU6IG51bWJlciB8IFJlY29yZDxLICYgVCwgbnVtYmVyPiwgcHJvcHM6IFJlY29yZDxULCBLPik6IFJlY29yZDxULCBudW1iZXI+O1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlOiBudW1iZXIgfCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LCBwcm9wczogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KSB7XG4gIGNvbnN0IHJldCA9IHt9O1xuICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgY29uc3Qga2V5cyA9IG9ialByb3BzID8gT2JqZWN0LmtleXMocHJvcHMpIDogcHJvcHM7XG4gIGNvbnN0IHJlYWQgPSBpc09iamVjdCh2YWx1ZSlcbiAgICA/IG9ialByb3BzXG4gICAgICA/IHByb3AgPT4gdmFsdWVPckRlZmF1bHQodmFsdWVbcHJvcF0sIHZhbHVlW3Byb3BzW3Byb3BdXSlcbiAgICAgIDogcHJvcCA9PiB2YWx1ZVtwcm9wXVxuICAgIDogKCkgPT4gdmFsdWU7XG5cbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcbiAgICByZXRbcHJvcF0gPSBudW1iZXJPclplcm8ocmVhZChwcm9wKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIFRSQkwgb2JqZWN0LlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29tcG9uZW50LFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogIHggLyB5IGFyZSBzaG9ydGhhbmRzIGZvciBzYW1lIHZhbHVlIGZvciBsZWZ0L3JpZ2h0IGFuZCB0b3AvYm90dG9tLlxuICogQHJldHVybnMgVGhlIHBhZGRpbmcgdmFsdWVzICh0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQpXG4gKiBAc2luY2UgMy4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVFJCTCh2YWx1ZTogbnVtYmVyIHwgVFJCTCB8IFBvaW50KSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwge3RvcDogJ3knLCByaWdodDogJ3gnLCBib3R0b206ICd5JywgbGVmdDogJ3gnfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIGNvcm5lcnMgb2JqZWN0IChzaW1pbGFyIHdpdGggY3NzIGJvcmRlci1yYWRpdXMpLlxuICogQHBhcmFtIHZhbHVlIC0gSWYgYSBudW1iZXIsIHNldCB0aGUgdmFsdWUgdG8gYWxsIFRSQkwgY29ybmVyIGNvbXBvbmVudHMsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiBAcmV0dXJucyBUaGUgVFJCTCBjb3JuZXIgdmFsdWVzICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpXG4gKiBAc2luY2UgMy4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVFJCTENvcm5lcnModmFsdWU6IG51bWJlciB8IFRSQkxDb3JuZXJzKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWyd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBwYWRkaW5nIG9iamVjdCB3aXRoIHByZS1jb21wdXRlZCB3aWR0aC9oZWlnaHQuXG4gKiBAcGFyYW0gdmFsdWUgLSBJZiBhIG51bWJlciwgc2V0IHRoZSB2YWx1ZSB0byBhbGwgVFJCTCBjb21wb25lbnQsXG4gKiAgZWxzZSwgaWYgYW4gb2JqZWN0LCB1c2UgZGVmaW5lZCBwcm9wZXJ0aWVzIGFuZCBzZXRzIHVuZGVmaW5lZCBvbmVzIHRvIDAuXG4gKiAgeCAvIHkgYXJlIHNob3J0aGFuZHMgZm9yIHNhbWUgdmFsdWUgZm9yIGxlZnQvcmlnaHQgYW5kIHRvcC9ib3R0b20uXG4gKiBAcmV0dXJucyBUaGUgcGFkZGluZyB2YWx1ZXMgKHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgd2lkdGgsIGhlaWdodClcbiAqIEBzaW5jZSAyLjcuMFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlPzogbnVtYmVyIHwgVFJCTCk6IENoYXJ0QXJlYSB7XG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSkgYXMgQ2hhcnRBcmVhO1xuXG4gIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBQYXJzZXMgZm9udCBvcHRpb25zIGFuZCByZXR1cm5zIHRoZSBmb250IG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmb250IG9wdGlvbnMgdG8gYmUgcGFyc2VkLlxuICogQHBhcmFtIGZhbGxiYWNrIC0gQSBvYmplY3QgdGhhdCBjb250YWlucyBmYWxsYmFjayBmb250IG9wdGlvbnMuXG4gKiBAcmV0dXJuIFRoZSBmb250IG9iamVjdC5cbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvRm9udChvcHRpb25zOiBQYXJ0aWFsPEZvbnRTcGVjPiwgZmFsbGJhY2s/OiBQYXJ0aWFsPEZvbnRTcGVjPikge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250IGFzIEZvbnRTcGVjO1xuXG4gIGxldCBzaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5zaXplLCBmYWxsYmFjay5zaXplKTtcblxuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gIGlmIChzdHlsZSAmJiAhKCcnICsgc3R5bGUpLm1hdGNoKEZPTlRfU1RZTEUpKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgIHN0eWxlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgY29uc3QgZm9udCA9IHtcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGZhbGxiYWNrLmxpbmVIZWlnaHQpLCBzaXplKSxcbiAgICBzaXplLFxuICAgIHN0eWxlLFxuICAgIHdlaWdodDogdmFsdWVPckRlZmF1bHQob3B0aW9ucy53ZWlnaHQsIGZhbGxiYWNrLndlaWdodCksXG4gICAgc3RyaW5nOiAnJ1xuICB9O1xuXG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuICByZXR1cm4gZm9udDtcbn1cblxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGBpbnB1dHNgIHNlcXVlbnRpYWxseSBhbmQgcmV0dXJucyB0aGUgZmlyc3QgZGVmaW5lZCB2YWx1ZS5cbiAqIEBwYXJhbSBpbnB1dHMgLSBBbiBhcnJheSBvZiB2YWx1ZXMsIGZhbGxpbmcgYmFjayB0byB0aGUgbGFzdCB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0IC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYSBmdW5jdGlvbiwgdGhlIHZhbHVlXG4gKiBpcyBjYWxsZWQgd2l0aCBgY29udGV4dGAgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHRoZSByZXN1bHQgYmVjb21lcyB0aGUgbmV3IGlucHV0LlxuICogQHBhcmFtIGluZGV4IC0gSWYgZGVmaW5lZCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgaXMgYW4gYXJyYXksIHRoZSB2YWx1ZVxuICogYXQgYGluZGV4YCBiZWNvbWUgdGhlIG5ldyBpbnB1dC5cbiAqIEBwYXJhbSBpbmZvIC0gb2JqZWN0IHRvIHJldHVybiBpbmZvcm1hdGlvbiBhYm91dCByZXNvbHV0aW9uIGluXG4gKiBAcGFyYW0gaW5mby5jYWNoZWFibGUgLSBXaWxsIGJlIHNldCB0byBgZmFsc2VgIGlmIG9wdGlvbiBpcyBub3QgY2FjaGVhYmxlLlxuICogQHNpbmNlIDIuNy4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKGlucHV0czogQXJyYXk8dW5rbm93bj4sIGNvbnRleHQ/OiBvYmplY3QsIGluZGV4PzogbnVtYmVyLCBpbmZvPzogeyBjYWNoZWFibGU6IGJvb2xlYW4gfSkge1xuICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCB2YWx1ZTogdW5rbm93bjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIG1pbm1heFxuICogQHBhcmFtIGdyYWNlXG4gKiBAcGFyYW0gYmVnaW5BdFplcm9cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4OiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlcjsgfSwgZ3JhY2U6IG51bWJlciB8IHN0cmluZywgYmVnaW5BdFplcm86IGJvb2xlYW4pIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlOiBudW1iZXIsIGFkZDogbnVtYmVyKSA9PiBiZWdpbkF0WmVybyAmJiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSArIGFkZDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxuICAgIG1heDoga2VlcFplcm8obWF4LCBjaGFuZ2UpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY29udGV4dCBpbmhlcml0aW5nIHBhcmVudENvbnRleHRcbiAqIEBwYXJhbSBwYXJlbnRDb250ZXh0XG4gKiBAcGFyYW0gY29udGV4dFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQ8VCBleHRlbmRzIG9iamVjdD4ocGFyZW50Q29udGV4dDogbnVsbCwgY29udGV4dDogVCk6IFQ7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dDxUIGV4dGVuZHMgb2JqZWN0LCBQIGV4dGVuZHMgVD4ocGFyZW50Q29udGV4dDogUCwgY29udGV4dDogVCk6IFAgJiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dDogb2JqZWN0LCBjb250ZXh0OiBvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRDb250ZXh0KSwgY29udGV4dCk7XG59XG4iLCAiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRNZXRhfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSB7XG4gIFJlc29sdmVyT2JqZWN0S2V5LFxuICBSZXNvbHZlckNhY2hlLFxuICBSZXNvbHZlclByb3h5LFxuICBEZXNjcmlwdG9yRGVmYXVsdHMsXG4gIERlc2NyaXB0b3IsXG4gIENvbnRleHRDYWNoZSxcbiAgQ29udGV4dFByb3h5XG59IGZyb20gJy4vaGVscGVycy5jb25maWcudHlwZXMuanMnO1xuaW1wb3J0IHtpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgcmVzb2x2ZU9iamVjdEtleSwgX2NhcGl0YWxpemV9IGZyb20gJy4vaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzLmNvbmZpZy50eXBlcy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIFByb3h5IGZvciByZXNvbHZpbmcgcmF3IHZhbHVlcyBmb3Igb3B0aW9ucy5cbiAqIEBwYXJhbSBzY29wZXMgLSBUaGUgb3B0aW9uIHNjb3BlcyB0byBsb29rIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXJcbiAqIEBwYXJhbSBwcmVmaXhlcyAtIFRoZSBwcmVmaXhlcyBmb3IgdmFsdWVzLCBpbiByZXNvbHV0aW9uIG9yZGVyLlxuICogQHBhcmFtIHJvb3RTY29wZXMgLSBUaGUgcm9vdCBvcHRpb24gc2NvcGVzXG4gKiBAcGFyYW0gZmFsbGJhY2sgLSBQYXJlbnQgc2NvcGVzIGZhbGxiYWNrXG4gKiBAcGFyYW0gZ2V0VGFyZ2V0IC0gY2FsbGJhY2sgZm9yIGdldHRpbmcgdGhlIHRhcmdldCBmb3IgY2hhbmdlZCB2YWx1ZXNcbiAqIEByZXR1cm5zIFByb3h5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyPFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgc2NvcGVzOiBULFxuICBwcmVmaXhlcyA9IFsnJ10sXG4gIHJvb3RTY29wZXM/OiBSLFxuICBmYWxsYmFjaz86IFJlc29sdmVyT2JqZWN0S2V5LFxuICBnZXRUYXJnZXQgPSAoKSA9PiBzY29wZXNbMF1cbikge1xuICBjb25zdCBmaW5hbFJvb3RTY29wZXMgPSByb290U2NvcGVzIHx8IHNjb3BlcztcbiAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlOiBSZXNvbHZlckNhY2hlPFQsIFI+ID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3BlczogZmluYWxSb290U2NvcGVzLFxuICAgIF9mYWxsYmFjazogZmFsbGJhY2ssXG4gICAgX2dldFRhcmdldDogZ2V0VGFyZ2V0LFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIGZpbmFsUm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcDogc3RyaW5nKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdOyAvLyByZW1vdmUgZnJvbSB0b3AgbGV2ZWwgc2NvcGVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZykge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCB0YXJnZXQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLlxuICAgICAqIEFsc28gdXNlZCBieSBPYmplY3QuaGFzT3duUHJvcGVydHkuXG4gICAgICovXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi9cbiAgICBoYXModGFyZ2V0LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqL1xuICAgIG93bktleXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBzZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQodGFyZ2V0LCBwcm9wOiBzdHJpbmcsIHZhbHVlKSB7XG4gICAgICBjb25zdCBzdG9yYWdlID0gdGFyZ2V0Ll9zdG9yYWdlIHx8ICh0YXJnZXQuX3N0b3JhZ2UgPSBnZXRUYXJnZXQoKSk7XG4gICAgICB0YXJnZXRbcHJvcF0gPSBzdG9yYWdlW3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byB0b3AgbGV2ZWwgc2NvcGUgKyBjYWNoZVxuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5czsgLy8gcmVtb3ZlIGNhY2hlZCBrZXlzXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIFJlc29sdmVyUHJveHk8VCwgUj47XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBQcm94eSBmb3IgcmVzb2x2aW5nIG9wdGlvbiB2YWx1ZXMgd2l0aCBjb250ZXh0LlxuICogQHBhcmFtIHByb3h5IC0gVGhlIFByb3h5IHJldHVybmVkIGJ5IGBfY3JlYXRlUmVzb2x2ZXJgXG4gKiBAcGFyYW0gY29udGV4dCAtIENvbnRleHQgb2JqZWN0IGZvciBzY3JpcHRhYmxlL2luZGV4YWJsZSBvcHRpb25zXG4gKiBAcGFyYW0gc3ViUHJveHkgLSBUaGUgcHJveHkgcHJvdmlkZWQgZm9yIHNjcmlwdGFibGUgb3B0aW9uc1xuICogQHBhcmFtIGRlc2NyaXB0b3JEZWZhdWx0cyAtIERlZmF1bHRzIGZvciBkZXNjcmlwdG9yc1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hdHRhY2hDb250ZXh0PFxuICBUIGV4dGVuZHMgQW55T2JqZWN0W10gPSBBbnlPYmplY3RbXSxcbiAgUiBleHRlbmRzIEFueU9iamVjdFtdID0gVFxuPihcbiAgcHJveHk6IFJlc29sdmVyUHJveHk8VCwgUj4sXG4gIGNvbnRleHQ6IEFueU9iamVjdCxcbiAgc3ViUHJveHk/OiBSZXNvbHZlclByb3h5PFQsIFI+LFxuICBkZXNjcmlwdG9yRGVmYXVsdHM/OiBEZXNjcmlwdG9yRGVmYXVsdHNcbikge1xuICBjb25zdCBjYWNoZTogQ29udGV4dENhY2hlPFQsIFI+ID0ge1xuICAgIF9jYWNoZWFibGU6IGZhbHNlLFxuICAgIF9wcm94eTogcHJveHksXG4gICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgX3N1YlByb3h5OiBzdWJQcm94eSxcbiAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICBfZGVzY3JpcHRvcnM6IF9kZXNjcmlwdG9ycyhwcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICBzZXRDb250ZXh0OiAoY3R4OiBBbnlPYmplY3QpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGU6IEFueU9iamVjdCkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gcHJveHlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIGdldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIGdldCh0YXJnZXQsIHByb3A6IHN0cmluZywgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqL1xuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihwcm94eSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGluIG9wZXJhdG9yLlxuICAgICAqL1xuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgYW5kIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMuXG4gICAgICovXG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqL1xuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlOyAvLyBzZXQgdG8gcHJveHlcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07IC8vIHJlbW92ZSBmcm9tIGNhY2hlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pIGFzIENvbnRleHRQcm94eTxULCBSPjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKFxuICBwcm94eTogUmVzb2x2ZXJDYWNoZSxcbiAgZGVmYXVsdHM6IERlc2NyaXB0b3JEZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9XG4pOiBEZXNjcmlwdG9yIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4OiBzdHJpbmcsIG5hbWU6IHN0cmluZykgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wOiBzdHJpbmcsIHZhbHVlOiB1bmtub3duKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgcHJvcCAhPT0gJ2FkYXB0ZXJzJyAmJlxuICAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gbnVsbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KTtcblxuZnVuY3Rpb24gX2NhY2hlZChcbiAgdGFyZ2V0OiBBbnlPYmplY3QsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVzb2x2ZTogKCkgPT4gdW5rbm93blxuKSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBwcm9wKSB8fCBwcm9wID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dChcbiAgdGFyZ2V0OiBDb250ZXh0Q2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgcmVjZWl2ZXI6IEFueU9iamVjdFxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuXG4gIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgLy8gaWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzIGFuIG9iamVjdCwgY3JlYXRlIGEgc3ViIHJlc29sdmVyIGZvciBpdFxuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUoXG4gIHByb3A6IHN0cmluZyxcbiAgZ2V0VmFsdWU6IChjdHg6IEFueU9iamVjdCwgc3ViOiBBbnlPYmplY3QpID0+IHVua25vd24sXG4gIHRhcmdldDogQ29udGV4dENhY2hlLFxuICByZWNlaXZlcjogQW55T2JqZWN0XG4pIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICAvLyBXaGVuIHNjcmlwdGFibGUgb3B0aW9uIHJldHVybnMgYW4gb2JqZWN0LCBjcmVhdGUgYSByZXNvbHZlciBvbiB0aGF0LlxuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVBcnJheShcbiAgcHJvcDogc3RyaW5nLFxuICB2YWx1ZTogdW5rbm93bltdLFxuICB0YXJnZXQ6IENvbnRleHRDYWNoZSxcbiAgaXNJbmRleGFibGU6IChrZXk6IHN0cmluZykgPT4gYm9vbGVhblxuKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuXG4gIGlmICh0eXBlb2YgX2NvbnRleHQuaW5kZXggIT09ICd1bmRlZmluZWQnICYmIGlzSW5kZXhhYmxlKHByb3ApKSB7XG4gICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgY29uc3QgYXJyID0gdmFsdWU7XG4gICAgY29uc3Qgc2NvcGVzID0gX3Byb3h5Ll9zY29wZXMuZmlsdGVyKHMgPT4gcyAhPT0gYXJyKTtcbiAgICB2YWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKFxuICBmYWxsYmFjazogUmVzb2x2ZXJPYmplY3RLZXkgfCAoKHByb3A6IFJlc29sdmVyT2JqZWN0S2V5LCB2YWx1ZTogdW5rbm93bikgPT4gUmVzb2x2ZXJPYmplY3RLZXkpLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cblxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5OiBSZXNvbHZlck9iamVjdEtleSwgcGFyZW50OiBBbnlPYmplY3QpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGFkZFNjb3BlcyhcbiAgc2V0OiBTZXQ8QW55T2JqZWN0PixcbiAgcGFyZW50U2NvcGVzOiBBbnlPYmplY3RbXSxcbiAga2V5OiBSZXNvbHZlck9iamVjdEtleSxcbiAgcGFyZW50RmFsbGJhY2s6IFJlc29sdmVyT2JqZWN0S2V5LFxuICB2YWx1ZTogdW5rbm93blxuKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBmYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgZmFsbGJhY2sgIT09IGtleSAmJiBmYWxsYmFjayAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgLy8gVGhlIGZhbGxiYWNrIHdpbGwgcmVzdW1lIHRvIHRoYXQgbmV3IHNjb3BlLlxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgdHlwZW9mIHBhcmVudEZhbGxiYWNrICE9PSAndW5kZWZpbmVkJyAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBgZmFsc2VgIHJlc3VsdHMgdG8gYGZhbHNlYCwgd2hlbiBmYWxsaW5nIGJhY2sgdG8gZGlmZmVyZW50IGtleS5cbiAgICAgIC8vIEZvciBleGFtcGxlIGBpbnRlcmFjdGlvbmAgZnJvbSBgaG92ZXJgIG9yIGBwbHVnaW5zLnRvb2x0aXBgIGFuZCBgYW5pbWF0aW9uYCBmcm9tIGBhbmltYXRpb25zYFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIoXG4gIHBhcmVudFNjb3BlczogQW55T2JqZWN0W10sXG4gIHJlc29sdmVyOiBSZXNvbHZlckNhY2hlLFxuICBwcm9wOiBSZXNvbHZlck9iamVjdEtleSxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCByb290U2NvcGVzID0gcmVzb2x2ZXIuX3Jvb3RTY29wZXM7XG4gIGNvbnN0IGZhbGxiYWNrID0gcmVzb2x2ZUZhbGxiYWNrKHJlc29sdmVyLl9mYWxsYmFjaywgcHJvcCwgdmFsdWUpO1xuICBjb25zdCBhbGxTY29wZXMgPSBbLi4ucGFyZW50U2NvcGVzLCAuLi5yb290U2NvcGVzXTtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxBbnlPYmplY3Q+KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCBhcyBzdHJpbmcsIHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoXG4gIHNldDogU2V0PEFueU9iamVjdD4sXG4gIGFsbFNjb3BlczogQW55T2JqZWN0W10sXG4gIGtleTogUmVzb2x2ZXJPYmplY3RLZXksXG4gIGZhbGxiYWNrOiBSZXNvbHZlck9iamVjdEtleSxcbiAgaXRlbTogdW5rbm93blxuKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChcbiAgcmVzb2x2ZXI6IFJlc29sdmVyQ2FjaGUsXG4gIHByb3A6IHN0cmluZyxcbiAgdmFsdWU6IHVua25vd25cbikge1xuICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gIGlmICghKHByb3AgaW4gcGFyZW50KSkge1xuICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHBhcmVudFtwcm9wXTtcbiAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAvLyBGb3IgYXJyYXkgb2Ygb2JqZWN0cywgdGhlIG9iamVjdCBpcyB1c2VkIHRvIHN0b3JlIHVwZGF0ZWQgdmFsdWVzXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQgfHwge307XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aFByZWZpeGVzKFxuICBwcm9wOiBzdHJpbmcsXG4gIHByZWZpeGVzOiBzdHJpbmdbXSxcbiAgc2NvcGVzOiBBbnlPYmplY3RbXSxcbiAgcHJveHk6IFJlc29sdmVyUHJveHlcbikge1xuICBsZXQgdmFsdWU6IHVua25vd247XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKVxuICAgICAgICA/IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgcHJveHksIHByb3AsIHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZShrZXk6IHN0cmluZywgc2NvcGVzOiBBbnlPYmplY3RbXSkge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0OiBSZXNvbHZlckNhY2hlKSB7XG4gIGxldCBrZXlzID0gdGFyZ2V0Ll9rZXlzO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gdGFyZ2V0Ll9rZXlzID0gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHRhcmdldC5fc2NvcGVzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3BlczogQW55T2JqZWN0W10pIHtcbiAgY29uc3Qgc2V0ID0gbmV3IFNldDxzdHJpbmc+KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShcbiAgbWV0YTogQ2hhcnRNZXRhPCdsaW5lJyB8ICdzY2F0dGVyJz4sXG4gIGRhdGE6IEFueU9iamVjdFtdLFxuICBzdGFydDogbnVtYmVyLFxuICBjb3VudDogbnVtYmVyXG4pIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheTx7cjogdW5rbm93bn0+KGNvdW50KTtcbiAgbGV0IGk6IG51bWJlciwgaWxlbjogbnVtYmVyLCBpbmRleDogbnVtYmVyLCBpdGVtOiBBbnlPYmplY3Q7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cbiIsICJpbXBvcnQge2FsbW9zdEVxdWFscywgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBzaWdufSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19pc1BvaW50SW5BcmVhfSBmcm9tICcuL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtDaGFydEFyZWF9IGZyb20gJy4uL3R5cGVzL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtTcGxpbmVQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuXG50eXBlIE9wdGlvbmFsU3BsaW5lUG9pbnQgPSBTcGxpbmVQb2ludCB8IGZhbHNlXG5jb25zdCBnZXRQb2ludCA9IChwb2ludHM6IFNwbGluZVBvaW50W10sIGk6IG51bWJlcik6IE9wdGlvbmFsU3BsaW5lUG9pbnQgPT4gaSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXM6ICd4JyB8ICd5JykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpbmVDdXJ2ZShcbiAgZmlyc3RQb2ludDogU3BsaW5lUG9pbnQsXG4gIG1pZGRsZVBvaW50OiBTcGxpbmVQb2ludCxcbiAgYWZ0ZXJQb2ludDogU3BsaW5lUG9pbnQsXG4gIHQ6IG51bWJlclxuKToge1xuICAgIHByZXZpb3VzOiBTcGxpbmVQb2ludFxuICAgIG5leHQ6IFNwbGluZVBvaW50XG4gIH0ge1xuICAvLyBQcm9wcyB0byBSb2IgU3BlbmNlciBhdCBzY2FsZWQgaW5ub3ZhdGlvbiBmb3IgaGlzIHBvc3Qgb24gc3BsaW5pbmcgYmV0d2VlbiBwb2ludHNcbiAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcblxuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG5cbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG5cbiAgLy8gSWYgYWxsIHBvaW50cyBhcmUgdGhlIHNhbWUsIHMwMSAmIHMwMiB3aWxsIGJlIGluZlxuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG5cbiAgY29uc3QgZmEgPSB0ICogczAxOyAvLyBzY2FsaW5nIGZhY3RvciBmb3IgdHJpYW5nbGUgVGFcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuXG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogQWRqdXN0IHRhbmdlbnRzIHRvIGVuc3VyZSBtb25vdG9uaWMgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHM6IFNwbGluZVBvaW50W10sIGRlbHRhSzogbnVtYmVyW10sIG1LOiBudW1iZXJbXSkge1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gIGxldCBhbHBoYUs6IG51bWJlciwgYmV0YUs6IG51bWJlciwgdGF1SzogbnVtYmVyLCBzcXVhcmVkTWFnbml0dWRlOiBudW1iZXIsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoYWxtb3N0RXF1YWxzKGRlbHRhS1tpXSwgMCwgRVBTSUxPTikpIHtcbiAgICAgIG1LW2ldID0gbUtbaSArIDFdID0gMDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50czogU3BsaW5lUG9pbnRbXSwgbUs6IG51bWJlcltdLCBpbmRleEF4aXM6ICd4JyB8ICd5JyA9ICd4Jykge1xuICBjb25zdCB2YWx1ZUF4aXMgPSBnZXRWYWx1ZUF4aXMoaW5kZXhBeGlzKTtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGRlbHRhOiBudW1iZXIsIHBvaW50QmVmb3JlOiBPcHRpb25hbFNwbGluZVBvaW50LCBwb2ludEN1cnJlbnQ6IE9wdGlvbmFsU3BsaW5lUG9pbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGlQaXhlbCA9IHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgIGlmIChwb2ludEJlZm9yZSkge1xuICAgICAgZGVsdGEgPSAoaVBpeGVsIC0gcG9pbnRCZWZvcmVbaW5kZXhBeGlzXSkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke2luZGV4QXhpc31gXSA9IGlQaXhlbCAtIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDEke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCAtIGRlbHRhICogbUtbaV07XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyBCw6l6aWVyIGNvbnRyb2wgcG9pbnRzIGluIGEgc2ltaWxhciB3YXkgdGhhbiB8c3BsaW5lQ3VydmV8LFxuICogYnV0IHByZXNlcnZlcyBtb25vdG9uaWNpdHkgb2YgdGhlIHByb3ZpZGVkIGRhdGEgYW5kIGVuc3VyZXMgbm8gbG9jYWwgZXh0cmVtdW1zIGFyZSBhZGRlZFxuICogYmV0d2VlbiB0aGUgZGF0YXNldCBkaXNjcmV0ZSBwb2ludHMgZHVlIHRvIHRoZSBpbnRlcnBvbGF0aW9uLlxuICogU2VlIDogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9ub3RvbmVfY3ViaWNfaW50ZXJwb2xhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHM6IFNwbGluZVBvaW50W10sIGluZGV4QXhpczogJ3gnIHwgJ3knID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUs6IG51bWJlcltdID0gQXJyYXkocG9pbnRzTGVuKS5maWxsKDApO1xuICBjb25zdCBtSzogbnVtYmVyW10gPSBBcnJheShwb2ludHNMZW4pO1xuXG4gIC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuICBsZXQgaSwgcG9pbnRCZWZvcmU6IE9wdGlvbmFsU3BsaW5lUG9pbnQsIHBvaW50Q3VycmVudDogT3B0aW9uYWxTcGxpbmVQb2ludDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuXG4gICAgICAvLyBJbiB0aGUgY2FzZSBvZiB0d28gcG9pbnRzIHRoYXQgYXBwZWFyIGF0IHRoZSBzYW1lIHggcGl4ZWwsIHNsb3BlRGVsdGFYIGlzIDBcbiAgICAgIGRlbHRhS1tpXSA9IHNsb3BlRGVsdGEgIT09IDAgPyAocG9pbnRBZnRlclt2YWx1ZUF4aXNdIC0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc10pIC8gc2xvcGVEZWx0YSA6IDA7XG4gICAgfVxuICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldXG4gICAgICA6ICFwb2ludEFmdGVyID8gZGVsdGFLW2kgLSAxXVxuICAgICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgICAgIDogKGRlbHRhS1tpIC0gMV0gKyBkZWx0YUtbaV0pIC8gMjtcbiAgfVxuXG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG5cbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5cbmZ1bmN0aW9uIGNhcENvbnRyb2xQb2ludChwdDogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuXG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzOiBTcGxpbmVQb2ludFtdLCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKFxuICBwb2ludHM6IFNwbGluZVBvaW50W10sXG4gIG9wdGlvbnMsXG4gIGFyZWE6IENoYXJ0QXJlYSxcbiAgbG9vcDogYm9vbGVhbixcbiAgaW5kZXhBeGlzOiAneCcgfCAneSdcbikge1xuICBsZXQgaTogbnVtYmVyLCBpbGVuOiBudW1iZXIsIHBvaW50OiBTcGxpbmVQb2ludCwgY29udHJvbFBvaW50czogUmV0dXJuVHlwZTx0eXBlb2Ygc3BsaW5lQ3VydmU+O1xuXG4gIC8vIE9ubHkgY29uc2lkZXIgcG9pbnRzIHRoYXQgYXJlIGRyYXduIGluIGNhc2UgdGhlIHNwYW5HYXBzIG9wdGlvbiBpcyB1c2VkXG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnRyb2xQb2ludHMgPSBzcGxpbmVDdXJ2ZShcbiAgICAgICAgcHJldixcbiAgICAgICAgcG9pbnQsXG4gICAgICAgIHBvaW50c1tNYXRoLm1pbihpICsgMSwgaWxlbiAtIChsb29wID8gMCA6IDEpKSAlIGlsZW5dLFxuICAgICAgICBvcHRpb25zLnRlbnNpb25cbiAgICAgICk7XG4gICAgICBwb2ludC5jcDF4ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy54O1xuICAgICAgcG9pbnQuY3AxeSA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueTtcbiAgICAgIHBvaW50LmNwMnggPSBjb250cm9sUG9pbnRzLm5leHQueDtcbiAgICAgIHBvaW50LmNwMnkgPSBjb250cm9sUG9pbnRzLm5leHQueTtcbiAgICAgIHByZXYgPSBwb2ludDtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtDaGFydEFyZWEsIFNjYWxlfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5pbXBvcnQgdHlwZSBQcml2YXRlQ2hhcnQgZnJvbSAnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHR5cGUge0NoYXJ0LCBDaGFydEV2ZW50fSBmcm9tICcuLi90eXBlcy5qcyc7XG5pbXBvcnQge0lORklOSVRZfSBmcm9tICcuL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpOiBib29sZWFuIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRQYXJlbnROb2RlKGRvbU5vZGU6IEhUTUxDYW52YXNFbGVtZW50KTogSFRNTENhbnZhc0VsZW1lbnQge1xuICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICBwYXJlbnQgPSAocGFyZW50IGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudCBhcyBIVE1MQ2FudmFzRWxlbWVudDtcbn1cblxuLyoqXG4gKiBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZTogc3RyaW5nIHwgbnVtYmVyLCBub2RlOiBIVE1MRWxlbWVudCwgcGFyZW50UHJvcGVydHk6IHN0cmluZykge1xuICBsZXQgdmFsdWVJblBpeGVsczogbnVtYmVyO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcblxuICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuICAgICAgdmFsdWVJblBpeGVscyA9ICh2YWx1ZUluUGl4ZWxzIC8gMTAwKSAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlSW5QaXhlbHM7XG59XG5cbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSAoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBDU1NTdHlsZURlY2xhcmF0aW9uID0+XG4gIGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3R5bGUoZWw6IEhUTUxFbGVtZW50LCBwcm9wZXJ0eTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuXG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlczogQ1NTU3R5bGVEZWNsYXJhdGlvbiwgc3R5bGU6IHN0cmluZywgc3VmZml4Pzogc3RyaW5nKTogQ2hhcnRBcmVhIHtcbiAgY29uc3QgcmVzdWx0ID0ge30gYXMgQ2hhcnRBcmVhO1xuICBzdWZmaXggPSBzdWZmaXggPyAnLScgKyBzdWZmaXggOiAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBjb25zdCBwb3MgPSBwb3NpdGlvbnNbaV07XG4gICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gIH1cbiAgcmVzdWx0LndpZHRoID0gcmVzdWx0LmxlZnQgKyByZXN1bHQucmlnaHQ7XG4gIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCB0YXJnZXQ6IEhUTUxFbGVtZW50IHwgRXZlbnRUYXJnZXQpID0+XG4gICh4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgISh0YXJnZXQgYXMgSFRNTEVsZW1lbnQpLnNoYWRvd1Jvb3QpO1xuXG4vKipcbiAqIEBwYXJhbSBlXG4gKiBAcGFyYW0gY2FudmFzXG4gKiBAcmV0dXJucyBDYW52YXMgcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oXG4gIGU6IEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnRcbik6IHtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIGJveDogYm9vbGVhbjtcbiAgfSB7XG4gIGNvbnN0IHRvdWNoZXMgPSAoZSBhcyBUb3VjaEV2ZW50KS50b3VjaGVzO1xuICBjb25zdCBzb3VyY2UgPSAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlKSBhcyBNb3VzZUV2ZW50O1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2UgYXMgTW91c2VFdmVudDtcbiAgbGV0IGJveCA9IGZhbHNlO1xuICBsZXQgeCwgeTtcbiAgaWYgKHVzZU9mZnNldFBvcyhvZmZzZXRYLCBvZmZzZXRZLCBlLnRhcmdldCkpIHtcbiAgICB4ID0gb2Zmc2V0WDtcbiAgICB5ID0gb2Zmc2V0WTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBzb3VyY2UuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICB5ID0gc291cmNlLmNsaWVudFkgLSByZWN0LnRvcDtcbiAgICBib3ggPSB0cnVlO1xuICB9XG4gIHJldHVybiB7eCwgeSwgYm94fTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIGV2ZW50J3MgeCwgeSBjb29yZGluYXRlcywgcmVsYXRpdmUgdG8gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwYXJhbSBldmVudFxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcmV0dXJucyB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKFxuICBldmVudDogRXZlbnQgfCBDaGFydEV2ZW50IHwgVG91Y2hFdmVudCB8IE1vdXNlRXZlbnQsXG4gIGNoYXJ0OiBDaGFydCB8IFByaXZhdGVDaGFydFxuKTogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHtcbiAgaWYgKCduYXRpdmUnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG5cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldmVudCwgY2FudmFzKTtcbiAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gIGNvbnN0IHlPZmZzZXQgPSBwYWRkaW5ncy50b3AgKyAoYm94ICYmIGJvcmRlcnMudG9wKTtcblxuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogUGFydGlhbDxTY2FsZT4ge1xuICBsZXQgbWF4V2lkdGg6IG51bWJlciwgbWF4SGVpZ2h0OiBudW1iZXI7XG5cbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyB0aGlzIGlzIHRoZSBib3JkZXIgYm94IG9mIHRoZSBjb250YWluZXJcbiAgICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICAgICAgY29uc3QgY29udGFpbmVyQm9yZGVyID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gZ2V0UG9zaXRpb25lZFN0eWxlKGNvbnRhaW5lclN0eWxlLCAncGFkZGluZycpO1xuICAgICAgd2lkdGggPSByZWN0LndpZHRoIC0gY29udGFpbmVyUGFkZGluZy53aWR0aCAtIGNvbnRhaW5lckJvcmRlci53aWR0aDtcbiAgICAgIGhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gY29udGFpbmVyUGFkZGluZy5oZWlnaHQgLSBjb250YWluZXJCb3JkZXIuaGVpZ2h0O1xuICAgICAgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heFdpZHRoLCBjb250YWluZXIsICdjbGllbnRXaWR0aCcpO1xuICAgICAgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhIZWlnaHQsIGNvbnRhaW5lciwgJ2NsaWVudEhlaWdodCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBtYXhXaWR0aDogbWF4V2lkdGggfHwgSU5GSU5JVFksXG4gICAgbWF4SGVpZ2h0OiBtYXhIZWlnaHQgfHwgSU5GSU5JVFlcbiAgfTtcbn1cblxuY29uc3Qgcm91bmQxID0gKHY6IG51bWJlcikgPT4gTWF0aC5yb3VuZCh2ICogMTApIC8gMTA7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoXG4gIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsXG4gIGJiV2lkdGg/OiBudW1iZXIsXG4gIGJiSGVpZ2h0PzogbnVtYmVyLFxuICBhc3BlY3RSYXRpbz86IG51bWJlclxuKTogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9IHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcblxuICBpZiAoc3R5bGUuYm94U2l6aW5nID09PSAnY29udGVudC1ib3gnKSB7XG4gICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCAtIG1hcmdpbnMud2lkdGgpO1xuICBoZWlnaHQgPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IHdpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWlnaHQgLSBtYXJnaW5zLmhlaWdodCk7XG4gIHdpZHRoID0gcm91bmQxKE1hdGgubWluKHdpZHRoLCBtYXhXaWR0aCwgY29udGFpbmVyU2l6ZS5tYXhXaWR0aCkpO1xuICBoZWlnaHQgPSByb3VuZDEoTWF0aC5taW4oaGVpZ2h0LCBtYXhIZWlnaHQsIGNvbnRhaW5lclNpemUubWF4SGVpZ2h0KSk7XG4gIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQ2NTlcbiAgICAvLyBJZiB0aGUgY2FudmFzIGhhcyB3aWR0aCwgYnV0IG5vIGhlaWdodCwgZGVmYXVsdCB0byBhc3BlY3RSYXRpbyBvZiAyIChjYW52YXMgZGVmYXVsdClcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgfVxuXG4gIGNvbnN0IG1haW50YWluSGVpZ2h0ID0gYmJXaWR0aCAhPT0gdW5kZWZpbmVkIHx8IGJiSGVpZ2h0ICE9PSB1bmRlZmluZWQ7XG5cbiAgaWYgKG1haW50YWluSGVpZ2h0ICYmIGFzcGVjdFJhdGlvICYmIGNvbnRhaW5lclNpemUuaGVpZ2h0ICYmIGhlaWdodCA+IGNvbnRhaW5lclNpemUuaGVpZ2h0KSB7XG4gICAgaGVpZ2h0ID0gY29udGFpbmVyU2l6ZS5oZWlnaHQ7XG4gICAgd2lkdGggPSByb3VuZDEoTWF0aC5mbG9vcihoZWlnaHQgKiBhc3BlY3RSYXRpbykpO1xuICB9XG5cbiAgcmV0dXJuIHt3aWR0aCwgaGVpZ2h0fTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gY2hhcnRcbiAqIEBwYXJhbSBmb3JjZVJhdGlvXG4gKiBAcGFyYW0gZm9yY2VTdHlsZVxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgY2FudmFzIGNvbnRleHQgc2l6ZSBvciB0cmFuc2Zvcm1hdGlvbiBoYXMgY2hhbmdlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldGluYVNjYWxlKFxuICBjaGFydDogQ2hhcnQgfCBQcml2YXRlQ2hhcnQsXG4gIGZvcmNlUmF0aW86IG51bWJlcixcbiAgZm9yY2VTdHlsZT86IGJvb2xlYW5cbik6IGJvb2xlYW4gfCB2b2lkIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG5cbiAgKGNoYXJ0IGFzIFByaXZhdGVDaGFydCkuaGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQpO1xuICAoY2hhcnQgYXMgUHJpdmF0ZUNoYXJ0KS53aWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGgpO1xuXG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcblxuICAvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuICAvLyBtYWtpbmcgdGhlIGNoYXJ0IHZpc3VhbGx5IGJpZ2dlciwgc28gbGV0J3MgZW5mb3JjZSBpdCB0byB0aGUgXCJjb3JyZWN0XCIgdmFsdWVzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzM1NzVcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG5cbiAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBwaXhlbFJhdGlvXG4gICAgICB8fCBjYW52YXMuaGVpZ2h0ICE9PSBkZXZpY2VIZWlnaHRcbiAgICAgIHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICAoY2hhcnQgYXMgUHJpdmF0ZUNoYXJ0KS5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGRldmljZUhlaWdodDtcbiAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICBjaGFydC5jdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlciBhdHRlbXB0cyB0byBhY2Nlc3MgdGhlIHBhc3NpdmUgcHJvcGVydHkuXG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBhcyBFdmVudExpc3RlbmVyT3B0aW9ucztcblxuICAgIGlmIChfaXNEb21TdXBwb3J0ZWQoKSkge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcblxuLyoqXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG4gKiBiZWVuIHBlcmZvcm1lZC4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYGVsZW1lbnRgIGJ1dCByZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcbiAqIGZvciBleGFtcGxlIGJlY2F1c2Ugb2YgYGRpc3BsYXk6IG5vbmVgIG9uIGEgcGFyZW50IG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXG4gKiBAcmV0dXJucyBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmVhZFVzZWRTaXplKFxuICBlbGVtZW50OiBIVE1MRWxlbWVudCxcbiAgcHJvcGVydHk6ICd3aWR0aCcgfCAnaGVpZ2h0J1xuKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cbiIsICJpbXBvcnQgdHlwZSB7UG9pbnQsIFNwbGluZVBvaW50fSBmcm9tICcuLi90eXBlcy9nZW9tZXRyaWMuanMnO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfcG9pbnRJbkxpbmUocDE6IFBvaW50LCBwMjogUG9pbnQsIHQ6IG51bWJlciwgbW9kZT8pIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogcDEueSArIHQgKiAocDIueSAtIHAxLnkpXG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihcbiAgcDE6IFBvaW50LFxuICBwMjogUG9pbnQsXG4gIHQ6IG51bWJlciwgbW9kZTogJ21pZGRsZScgfCAnYWZ0ZXInIHwgdW5rbm93blxuKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IG1vZGUgPT09ICdtaWRkbGUnID8gdCA8IDAuNSA/IHAxLnkgOiBwMi55XG4gICAgICA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55XG4gICAgICAgIDogdCA+IDAgPyBwMi55IDogcDEueVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfYmV6aWVySW50ZXJwb2xhdGlvbihwMTogU3BsaW5lUG9pbnQsIHAyOiBTcGxpbmVQb2ludCwgdDogbnVtYmVyLCBtb2RlPykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG4iLCAiZXhwb3J0IGludGVyZmFjZSBSVExBZGFwdGVyIHtcbiAgeCh4OiBudW1iZXIpOiBudW1iZXI7XG4gIHNldFdpZHRoKHc6IG51bWJlcik6IHZvaWQ7XG4gIHRleHRBbGlnbihhbGlnbjogJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnKTogJ2NlbnRlcicgfCAnbGVmdCcgfCAncmlnaHQnO1xuICB4UGx1cyh4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiBudW1iZXI7XG4gIGxlZnRGb3JMdHIoeDogbnVtYmVyLCBpdGVtV2lkdGg6IG51bWJlcik6IG51bWJlcjtcbn1cblxuY29uc3QgZ2V0UmlnaHRUb0xlZnRBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFg6IG51bWJlciwgd2lkdGg6IG51bWJlcik6IFJUTEFkYXB0ZXIge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHJlY3RYICsgcmVjdFggKyB3aWR0aCAtIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgICB3aWR0aCA9IHc7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCAtIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBpdGVtV2lkdGgpIHtcbiAgICAgIHJldHVybiB4IC0gaXRlbVdpZHRoO1xuICAgIH0sXG4gIH07XG59O1xuXG5jb25zdCBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIgPSBmdW5jdGlvbigpOiBSVExBZGFwdGVyIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsOiBib29sZWFuLCByZWN0WDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKSB7XG4gIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBkaXJlY3Rpb246ICdsdHInIHwgJ3J0bCcpIHtcbiAgbGV0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uLCBvcmlnaW5hbDogW3N0cmluZywgc3RyaW5nXTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcblxuICAgIHN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBkaXJlY3Rpb24sICdpbXBvcnRhbnQnKTtcbiAgICAoY3R4IGFzIHsgcHJldlRleHREaXJlY3Rpb24/OiBbc3RyaW5nLCBzdHJpbmddIH0pLnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBvcmlnaW5hbD86IFtzdHJpbmcsIHN0cmluZ10pIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgKGN0eCBhcyB7IHByZXZUZXh0RGlyZWN0aW9uPzogW3N0cmluZywgc3RyaW5nXSB9KS5wcmV2VGV4dERpcmVjdGlvbjtcbiAgICBjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xuICB9XG59XG4iLCAiaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBfYW5nbGVEaWZmLCBfaXNCZXR3ZWVuLCBfbm9ybWFsaXplQW5nbGV9IGZyb20gJy4vaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7Y3JlYXRlQ29udGV4dH0gZnJvbSAnLi9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtpc1BhdHRlcm5PckdyYWRpZW50fSBmcm9tICcuL2hlbHBlcnMuY29sb3IuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LmxpbmUuanMnKS5kZWZhdWx0IH0gTGluZUVsZW1lbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICogQHR5cGVkZWYge3tzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgbG9vcDogYm9vbGVhbiwgc3R5bGU/OiBhbnl9fSBTZWdtZW50XG4gKi9cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU2VnbWVudCh7c3RhcnQsIGVuZCwgY291bnQsIGxvb3AsIHN0eWxlfSkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgIGVuZDogZW5kICUgY291bnQsXG4gICAgbG9vcDogbG9vcCAmJiAoZW5kIC0gc3RhcnQgKyAxKSAlIGNvdW50ID09PSAwLFxuICAgIHN0eWxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBzdGFydCArPSBjb3VudDtcbiAgICBlbmQgKz0gY291bnQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAoIWJldHdlZW4obm9ybWFsaXplKHBvaW50c1tzdGFydCAlIGNvdW50XVtwcm9wZXJ0eV0pLCBzdGFydEJvdW5kLCBlbmRCb3VuZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGFydC0tO1xuICAgICAgZW5kLS07XG4gICAgfVxuICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgIGVuZCAlPSBjb3VudDtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzdWItc2VnbWVudChzKSBvZiBhIGxpbmUgc2VnbWVudCB0aGF0IGZhbGwgaW4gdGhlIGdpdmVuIGJvdW5kc1xuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50LnN0eWxlXSAtIHNlZ21lbnQgc3R5bGVcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50cyAtIHRoZSBwb2ludHMgdGhhdCB0aGlzIHNlZ21lbnQgcmVmZXJzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgb2YgYSBgUG9pbnRFbGVtZW50YCB3ZSBhcmUgYm91bmRpbmcuIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIHByb3BlcnR5XG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLmVuZCAtIGVuZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKiovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cblxuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7Y29tcGFyZSwgYmV0d2Vlbiwgbm9ybWFsaXplfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICBjb25zdCB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGV9ID0gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcyk7XG5cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuXG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcblxuICBmb3IgKGxldCBpID0gc3RhcnQsIHByZXYgPSBzdGFydDsgaSA8PSBlbmQ7ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW2kgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcblxuICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG5cbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cblxuICAgIGlmIChzdWJTdGFydCAhPT0gbnVsbCAmJiBzaG91bGRTdG9wKCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0OiBzdWJTdGFydCwgZW5kOiBpLCBsb29wLCBjb3VudCwgc3R5bGV9KSk7XG4gICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgfVxuICAgIHByZXYgPSBpO1xuICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWdtZW50cyBvZiB0aGUgbGluZSB0aGF0IGFyZSBpbnNpZGUgZ2l2ZW4gYm91bmRzXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW2JvdW5kc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZHMucHJvcGVydHkgLSB0aGUgcHJvcGVydHkgd2UgYXJlIGJvdW5kaW5nIHdpdGguIGB4YCwgYHlgIG9yIGBhbmdsZWAuXG4gKiBAcGFyYW0ge251bWJlcn0gYm91bmRzLnN0YXJ0IC0gc3RhcnQgdmFsdWUgb2YgdGhlIGBwcm9wZXJ0eWBcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3VuZHMuZW5kIC0gZW5kIHZhbHVlIG9mIHRoZSBgcHJvcGVydHlgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEZpbmQgc3RhcnQgYW5kIGVuZCBpbmRleCBvZiBhIGxpbmUuXG4gKi9cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuXG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIC8vIGxvb3AgYW5kIG5vdCBzcGFubmluZyBnYXBzLCBmaXJzdCBmaW5kIGEgZ2FwIHRvIHN0YXJ0IGZyb21cbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgZmlyc3Qgbm9uIHNraXBwZWQgcG9pbnQgKGFmdGVyIHRoZSBmaXJzdCBnYXAgcG9zc2libHkpXG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cblxuICAvLyBpZiB3ZSBsb29wZWQgdG8gY291bnQsIHN0YXJ0IG5lZWRzIHRvIGJlIDBcbiAgc3RhcnQgJT0gY291bnQ7XG5cbiAgaWYgKGxvb3ApIHtcbiAgICAvLyBsb29wIHdpbGwgZ28gcGFzdCBjb3VudCwgaWYgc3RhcnQgPiAwXG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG5cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCkge1xuICAgIGVuZC0tO1xuICB9XG5cbiAgLy8gZW5kIGNvdWxkIGJlIG1vcmUgdGhhbiBjb3VudCwgbm9ybWFsaXplXG4gIGVuZCAlPSBjb3VudDtcblxuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuXG4vKipcbiAqIENvbXB1dGUgc29saWQgc2VnbWVudHMgZnJvbSBQb2ludHMsIHdoZW4gc3BhbkdhcHMgPT09IGZhbHNlXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudFtdfSBwb2ludHMgLSB0aGUgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IG1heCAtIG1heCBpbmRleCAoY2FuIGdvIHBhc3QgY291bnQgb24gYSBsb29wKVxuICogQHBhcmFtIHtib29sZWFufSBsb29wIC0gYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhpcyB3b3VsZCBiZSBhIGxvb3AgaWYgbm8gZ2FwcyBhcmUgZm91bmRcbiAqL1xuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuXG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IGVuZDtcbiAgICAgIGlmIChwcmV2LnNraXApIHtcbiAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHByZXYgPSBjdXI7XG4gIH1cblxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgY29udGludW91cyBzZWdtZW50cyB0aGF0IGRlZmluZSB0aGUgd2hvbGUgbGluZVxuICogVGhlcmUgY2FuIGJlIHNraXBwZWQgcG9pbnRzIHdpdGhpbiBhIHNlZ21lbnQsIGlmIHNwYW5HYXBzIGlzIHRydWUuXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jb21wdXRlU2VnbWVudHMobGluZSwgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG5cbiAgaWYgKHNwYW5HYXBzID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW3tzdGFydCwgZW5kLCBsb29wfV0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U2VnbWVudFtdfSBzZWdtZW50c1xuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge29iamVjdH0gW3NlZ21lbnRPcHRpb25zXVxuICogQHJldHVybiB7U2VnbWVudFtdfVxuICovXG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge1NlZ21lbnRbXX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7UG9pbnRFbGVtZW50W119IHBvaW50c1xuICogQHBhcmFtIHtvYmplY3R9IFtzZWdtZW50T3B0aW9uc11cbiAqIEByZXR1cm4ge1NlZ21lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0Q29udGV4dCA9IGxpbmUuX2NoYXJ0LmdldENvbnRleHQoKTtcbiAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gIGNvbnN0IHtfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXgsIG9wdGlvbnM6IHtzcGFuR2Fwc319ID0gbGluZTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgbGV0IHN0YXJ0ID0gc2VnbWVudHNbMF0uc3RhcnQ7XG4gIGxldCBpID0gc3RhcnQ7XG5cbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICBjb25zdCBkaXIgPSBzcGFuR2FwcyA/IC0xIDogMTtcbiAgICBpZiAocyA9PT0gZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTdHlsZSBjYW4gbm90IHN0YXJ0L2VuZCBvbiBhIHNraXBwZWQgcG9pbnQsIGFkanVzdCBpbmRpY2VzIGFjY29yZGluZ2x5XG4gICAgcyArPSBjb3VudDtcbiAgICB3aGlsZSAocG9pbnRzW3MgJSBjb3VudF0uc2tpcCkge1xuICAgICAgcyAtPSBkaXI7XG4gICAgfVxuICAgIHdoaWxlIChwb2ludHNbZSAlIGNvdW50XS5za2lwKSB7XG4gICAgICBlICs9IGRpcjtcbiAgICB9XG4gICAgaWYgKHMgJSBjb3VudCAhPT0gZSAlIGNvdW50KSB7XG4gICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHMgJSBjb3VudCwgZW5kOiBlICUgY291bnQsIGxvb3A6IGwsIHN0eWxlOiBzdH0pO1xuICAgICAgcHJldlN0eWxlID0gc3Q7XG4gICAgICBzdGFydCA9IGUgJSBjb3VudDtcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwMDogcHJldixcbiAgICAgICAgcDE6IHB0LFxuICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICBkYXRhc2V0SW5kZXhcbiAgICAgIH0pKSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZWFkU3R5bGUob3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgYm9yZGVyQ2FwU3R5bGU6IG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUsXG4gICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICBib3JkZXJKb2luU3R5bGU6IG9wdGlvbnMuYm9yZGVySm9pblN0eWxlLFxuICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gIGlmICghcHJldlN0eWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhY2hlID0gW107XG4gIGNvbnN0IHJlcGxhY2VyID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmICghaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKCFjYWNoZS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgIGNhY2hlLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGUuaW5kZXhPZih2YWx1ZSk7XG4gIH07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHlsZSwgcmVwbGFjZXIpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUsIHJlcGxhY2VyKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7Q2hhcnQsIENoYXJ0QXJlYSwgQ2hhcnRNZXRhLCBTY2FsZSwgVFJCTH0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBnZXRTaXplRm9yQXJlYShzY2FsZTogU2NhbGUsIGNoYXJ0QXJlYTogQ2hhcnRBcmVhLCBmaWVsZDoga2V5b2YgQ2hhcnRBcmVhKSB7XG4gIHJldHVybiBzY2FsZS5vcHRpb25zLmNsaXAgPyBzY2FsZVtmaWVsZF0gOiBjaGFydEFyZWFbZmllbGRdO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhc2V0QXJlYShtZXRhOiBDaGFydE1ldGEsIGNoYXJ0QXJlYTogQ2hhcnRBcmVhKTogVFJCTCB7XG4gIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICBpZiAoeFNjYWxlICYmIHlTY2FsZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ2xlZnQnKSxcbiAgICAgIHJpZ2h0OiBnZXRTaXplRm9yQXJlYSh4U2NhbGUsIGNoYXJ0QXJlYSwgJ3JpZ2h0JyksXG4gICAgICB0b3A6IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAndG9wJyksXG4gICAgICBib3R0b206IGdldFNpemVGb3JBcmVhKHlTY2FsZSwgY2hhcnRBcmVhLCAnYm90dG9tJylcbiAgICB9O1xuICB9XG4gIHJldHVybiBjaGFydEFyZWE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhc2V0Q2xpcEFyZWEoY2hhcnQ6IENoYXJ0LCBtZXRhOiBDaGFydE1ldGEpOiBUUkJMIHwgZmFsc2Uge1xuICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgaWYgKGNsaXAuZGlzYWJsZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYXJlYSA9IGdldERhdGFzZXRBcmVhKG1ldGEsIGNoYXJ0LmNoYXJ0QXJlYSk7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIChjbGlwLmxlZnQgPT09IHRydWUgPyAwIDogY2xpcC5sZWZ0KSxcbiAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyBjaGFydC53aWR0aCA6IGFyZWEucmlnaHQgKyAoY2xpcC5yaWdodCA9PT0gdHJ1ZSA/IDAgOiBjbGlwLnJpZ2h0KSxcbiAgICB0b3A6IGNsaXAudG9wID09PSBmYWxzZSA/IDAgOiBhcmVhLnRvcCAtIChjbGlwLnRvcCA9PT0gdHJ1ZSA/IDAgOiBjbGlwLnRvcCksXG4gICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyBjaGFydC5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIChjbGlwLmJvdHRvbSA9PT0gdHJ1ZSA/IDAgOiBjbGlwLmJvdHRvbSlcbiAgfTtcbn1cbiIsICJpbXBvcnQge3JlcXVlc3RBbmltRnJhbWV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuYW5pbWF0aW9uLmpzJykuZGVmYXVsdCB9IEFuaW1hdGlvblxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuLyoqXG4gKiBQbGVhc2UgdXNlIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCB3aGljaCBwcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZVxuICogTm90ZTogY2xhc3MgaXMgZXhwb3J0IGZvciB0eXBlZG9jXG4gKi9cbmV4cG9ydCBjbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCB0eXBlKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gYW5pbXMubGlzdGVuZXJzW3R5cGVdO1xuICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG5cbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcnVubmluZyA9IHRydWU7XG5cbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG5cbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuXG4gICAgICBmb3IgKDsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuXG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGFuZCBpdHMgZHVyYXRpb24gcHJvbG9uZ2VkLFxuICAgICAgICAgICAgLy8gdXBkYXRlIHRvIHRvdGFsIGR1cmF0aW9uIG9mIGN1cnJlbnQgYW5pbWF0aW9ucyBydW4gKGZvciBwcm9ncmVzcyBldmVudClcbiAgICAgICAgICAgIGFuaW1zLmR1cmF0aW9uID0gaXRlbS5fdG90YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICBkcmF3ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW0gYnkgcmVwbGFjaW5nIGl0IHdpdGggbGFzdCBpdGVtIGFuZCByZW1vdmluZyB0aGUgbGFzdFxuICAgICAgICAgIC8vIEEgbG90IGZhc3RlciB0aGFuIHNwbGljZS5cbiAgICAgICAgICBpdGVtc1tpXSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGl0ZW1zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVtYWluaW5nICs9IGl0ZW1zLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcblxuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrXG5cdCAqL1xuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEFkZCBhbmltYXRpb25zXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwYXJhbSB7QW5pbWF0aW9uW119IGl0ZW1zIC0gYW5pbWF0aW9uc1xuXHQgKi9cbiAgYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gIH1cblxuICAvKipcblx0ICogQ291bnRzIG51bWJlciBvZiBhY3RpdmUgYW5pbWF0aW9ucyBmb3IgdGhlIGNoYXJ0XG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqL1xuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcblx0ICogU3RhcnQgYW5pbWF0aW5nIChhbGwgY2hhcnRzKVxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKi9cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG5cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBTdG9wIGFsbCBhbmltYXRpb25zIGZvciB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcblx0ICogUmVtb3ZlIGNoYXJ0IGZyb20gQW5pbWF0b3Jcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICovXG4gIHJlbW92ZShjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgQW5pbWF0b3IoKTtcbiIsICJpbXBvcnQgZWZmZWN0cyBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZWFzaW5nLmpzJztcbmltcG9ydCB7cmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtjb2xvciBhcyBoZWxwZXJzQ29sb3J9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xvci5qcyc7XG5cbmNvbnN0IHRyYW5zcGFyZW50ID0gJ3RyYW5zcGFyZW50JztcbmNvbnN0IGludGVycG9sYXRvcnMgPSB7XG4gIGJvb2xlYW4oZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmYWN0b3IgPiAwLjUgPyB0byA6IGZyb207XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZnJvbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvclxuICAgKi9cbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gaGVscGVyc0NvbG9yKGZyb20gfHwgdHJhbnNwYXJlbnQpO1xuICAgIGNvbnN0IGMxID0gYzAudmFsaWQgJiYgaGVscGVyc0NvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0bykge1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXTtcblxuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuXG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xuICB9XG5cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuXG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAvLyB1cGRhdGUgY3VycmVudCBldmFsdWF0ZWQgdmFsdWUsIGZvciBzbW9vdGhlciBhbmltYXRpb25zXG4gICAgICB0aGlzLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcblxuICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcblxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcblxuICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRoaXMuX2ZuKGZyb20sIHRvLCBmYWN0b3IpO1xuICB9XG5cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG5cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgYW5pbWF0b3IgZnJvbSAnLi9jb3JlLmFuaW1hdG9yLmpzJztcbmltcG9ydCBBbmltYXRpb24gZnJvbSAnLi9jb3JlLmFuaW1hdGlvbi5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuXG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuYW5pbWF0aW9uKTtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcblxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuXG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09IGtleSB8fCAhYW5pbWF0ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgdG8gaGFuZGxlIGFuaW1hdGlvbiBvZiBgb3B0aW9uc2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgLy8gR29pbmcgdG8gc2hhcmVkIG9wdGlvbnM6XG4gICAgICAvLyBBZnRlciBhbGwgYW5pbWF0aW9ucyBhcmUgZG9uZSwgYXNzaWduIHRoZSBzaGFyZWQgb3B0aW9ucyBvYmplY3QgdG8gdGhlIGVsZW1lbnRcbiAgICAgIC8vIFNvIGFueSBuZXcgdXBkYXRlcyB0byB0aGUgc2hhcmVkIG9wdGlvbnMgYXJlIG9ic2VydmVkXG4gICAgICBhd2FpdEFsbCh0YXJnZXQub3B0aW9ucy4kYW5pbWF0aW9ucywgbmV3T3B0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICAgIH0sICgpID0+IHtcbiAgICAgICAgLy8gcmVqZWN0ZWQsIG5vb3BcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBydW5uaW5nID0gdGFyZ2V0LiRhbmltYXRpb25zIHx8ICh0YXJnZXQuJGFuaW1hdGlvbnMgPSB7fSk7XG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuICAgIGNvbnN0IGRhdGUgPSBEYXRlLm5vdygpO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi50aGlzLl9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcblxuICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICBpZiAoY2ZnICYmIGFuaW1hdGlvbi5hY3RpdmUoKSkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIGFuIGV4aXN0aW5nIGFjdGl2ZSBhbmltYXRpb24sIGxldCdzIHVwZGF0ZSB0aGF0XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgLy8gbm90IGFuaW1hdGVkLCBzZXQgZGlyZWN0bHkgdG8gbmV3IHZhbHVlXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIFVwZGF0ZSBgdGFyZ2V0YCBwcm9wZXJ0aWVzIHRvIG5ldyB2YWx1ZXMsIHVzaW5nIGNvbmZpZ3VyZWQgYW5pbWF0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IC0gb2JqZWN0IHRvIHVwZGF0ZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIC0gbmV3IHRhcmdldCBwcm9wZXJ0aWVzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gLSBgdHJ1ZWAgaWYgYW5pbWF0aW9ucyB3ZXJlIHN0YXJ0ZWRcblx0ICoqL1xuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICAvLyBOb3RoaW5nIGlzIGFuaW1hdGVkLCBqdXN0IGFwcGx5IHRoZSBuZXcgdmFsdWVzLlxuICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHZhbHVlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuXG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGF3YWl0QWxsKGFuaW1hdGlvbnMsIHByb3BlcnRpZXMpIHtcbiAgY29uc3QgcnVubmluZyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFuaW0gPSBhbmltYXRpb25zW2tleXNbaV1dO1xuICAgIGlmIChhbmltICYmIGFuaW0uYWN0aXZlKCkpIHtcbiAgICAgIHJ1bm5pbmcucHVzaChhbmltLndhaXQoKSk7XG4gICAgfVxuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xuICAgIC8vIEdvaW5nIGZyb20gc2hhcmVkIG9wdGlvbnMgdG8gZGlzdGluY3Qgb25lOlxuICAgIC8vIENyZWF0ZSBuZXcgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgb2xkIHNoYXJlZCB2YWx1ZXMgYW5kIHN0YXJ0IHVwZGF0aW5nIHRoYXQuXG4gICAgdGFyZ2V0Lm9wdGlvbnMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyRzaGFyZWQ6IGZhbHNlLCAkYW5pbWF0aW9uczoge319KTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbiIsICJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7aXNBcnJheSwgaXNGaW5pdGUsIGlzT2JqZWN0LCB2YWx1ZU9yRGVmYXVsdCwgcmVzb2x2ZU9iamVjdEtleSwgZGVmaW5lZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtsaXN0ZW5BcnJheUV2ZW50cywgdW5saXN0ZW5BcnJheUV2ZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBzaWdufSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqL1xuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcblxuICByZXR1cm4ge1xuICAgIHRvcDogeS5lbmQsXG4gICAgcmlnaHQ6IHguZW5kLFxuICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICBsZWZ0OiB4LnN0YXJ0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcblxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogcixcbiAgICBib3R0b206IGIsXG4gICAgbGVmdDogbCxcbiAgICBkaXNhYmxlZDogdmFsdWUgPT09IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cblxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBrZXlzID0gc3RhY2sua2V5cztcbiAgY29uc3Qgc2luZ2xlTW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZSc7XG4gIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbGV0IGZvdW5kID0gZmFsc2U7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghZm91bmQgJiYgIW9wdGlvbnMuYWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKSB7XG4gIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyAneCcgOiAneSc7XG4gIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/ICd4JyA6ICd5JztcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICBjb25zdCBhZGF0YSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG4gIGxldCBpLCBpbGVuLCBrZXk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgYWRhdGFbaV0gPSB7XG4gICAgICBbaUF4aXNLZXldOiBrZXksXG4gICAgICBbdkF4aXNLZXldOiBkYXRhW2tleV1cbiAgICB9O1xuICB9XG4gIHJldHVybiBhZGF0YTtcbn1cblxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XG59XG5cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgcmV0dXJuIHtcbiAgICBtaW46IG1pbkRlZmluZWQgPyBtaW4gOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgcG9zaXRpdmUsIHR5cGUpIHtcbiAgZm9yIChjb25zdCBtZXRhIG9mIHZTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTsgLy8gbWFwIHN0cnVjdHVyZSBpcyB7c3RhY2tLZXk6IHtkYXRhc2V0SW5kZXg6IHZhbHVlfX1cbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcblxuICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgc3RhY2suX2JvdHRvbSA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgZmFsc2UsIG1ldGEudHlwZSk7XG5cbiAgICBjb25zdCB2aXN1YWxWYWx1ZXMgPSBzdGFjay5fdmlzdWFsVmFsdWVzIHx8IChzdGFjay5fdmlzdWFsVmFsdWVzID0ge30pO1xuICAgIHZpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCxcbiAgICB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgZGF0YXNldDogdW5kZWZpbmVkLFxuICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgIGluZGV4LFxuICAgICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfVxuICApO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBwYXJzZWQ6IHVuZGVmaW5lZCxcbiAgICByYXc6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50LFxuICAgIGluZGV4LFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICB0eXBlOiAnZGF0YSdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIC8vIE5vdCB1c2luZyBtZXRhLmluZGV4IGhlcmUsIGJlY2F1c2UgaXQgbWlnaHQgYmUgYWxyZWFkeSB1cGRhdGVkIGlmIHRoZSBkYXRhc2V0IGNoYW5nZWQgbG9jYXRpb25cbiAgY29uc3QgZGF0YXNldEluZGV4ID0gbWV0YS5jb250cm9sbGVyLmluZGV4O1xuICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaXRlbXMgPSBpdGVtcyB8fCBtZXRhLl9wYXJzZWQ7XG4gIGZvciAoY29uc3QgcGFyc2VkIG9mIGl0ZW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gcGFyc2VkLl9zdGFja3M7XG4gICAgaWYgKCFzdGFja3MgfHwgc3RhY2tzW2F4aXNdID09PSB1bmRlZmluZWQgfHwgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgc3RhY2tzW2F4aXNdW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKHN0YWNrc1theGlzXS5fdmlzdWFsVmFsdWVzICE9PSB1bmRlZmluZWQgJiYgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge307XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhc2V0IChlLmcuIENoYXJ0LmVsZW1lbnQuTGluZUVsZW1lbnQpLlxuICAgKi9cbiAgc3RhdGljIGRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEVsZW1lbnQgdHlwZSB1c2VkIHRvIGdlbmVyYXRlIGEgbWV0YSBkYXRhIChlLmcuIENoYXJ0LmVsZW1lbnQuUG9pbnRFbGVtZW50KS5cbiAgICovXG4gIHN0YXRpYyBkYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGF0YXNldEluZGV4XG5cdCAqL1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX2N0eCA9IGNoYXJ0LmN0eDtcbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IG9iamVjdH0gKi9cbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YXNldEVsZW1lbnRUeXBlO1xuICAgIHRoaXMuZGF0YUVsZW1lbnRUeXBlID0gbmV3LnRhcmdldC5kYXRhRWxlbWVudFR5cGU7XG5cbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmxpbmtTY2FsZXMoKTtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmZpbGwgJiYgIXRoaXMuY2hhcnQuaXNQbHVnaW5FbmFibGVkKCdmaWxsZXInKSkge1xuICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gdXNlIHRoZSAnZmlsbCcgb3B0aW9uIHdpdGhvdXQgdGhlICdGaWxsZXInIHBsdWdpbiBlbmFibGVkLiBQbGVhc2UgaW1wb3J0IGFuZCByZWdpc3RlciB0aGUgJ0ZpbGxlcicgcGx1Z2luIGFuZCBtYWtlIHN1cmUgaXQgaXMgbm90IGRpc2FibGVkIGluIHRoZSBvcHRpb25zXCIpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG5cbiAgbGlua1NjYWxlcygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuXG4gICAgY29uc3QgY2hvb3NlSWQgPSAoYXhpcywgeCwgeSwgcikgPT4gYXhpcyA9PT0gJ3gnID8geCA6IGF4aXMgPT09ICdyJyA/IHIgOiB5O1xuXG4gICAgY29uc3QgeGlkID0gbWV0YS54QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC54QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd4JykpO1xuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcbiAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gbWV0YS5pbmRleEF4aXM7XG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcbiAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgIG1ldGEueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgIG1ldGEuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuXG4gIGdldERhdGFzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIGdldE1ldGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEodGhpcy5pbmRleCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNjYWxlSURcblx0ICogQHJldHVybiB7U2NhbGV9XG5cdCAqL1xuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRPdGhlclNjYWxlKHNjYWxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgcmV0dXJuIHNjYWxlID09PSBtZXRhLmlTY2FsZVxuICAgICAgPyBtZXRhLnZTY2FsZVxuICAgICAgOiBtZXRhLmlTY2FsZTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2Rlc3Ryb3koKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHVubGlzdGVuQXJyYXlFdmVudHModGhpcy5fZGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kYXRhQ2hlY2soKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICBjb25zdCBfZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAvLyBJbiBvcmRlciB0byBjb3JyZWN0bHkgaGFuZGxlIGRhdGEgYWRkaXRpb24vZGVsZXRpb24gYW5pbWF0aW9uIChhbmQgdGh1cyBzaW11bGF0ZVxuICAgIC8vIHJlYWwtdGltZSBjaGFydHMpLCB3ZSBuZWVkIHRvIG1vbml0b3IgdGhlc2UgZGF0YSBtb2RpZmljYXRpb25zIGFuZCBzeW5jaHJvbml6ZVxuICAgIC8vIHRoZSBpbnRlcm5hbCBtZXRhZGF0YSBhY2NvcmRpbmdseS5cblxuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEsIG1ldGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICAvLyBUaGlzIGNhc2UgaGFwcGVucyB3aGVuIHRoZSB1c2VyIHJlcGxhY2VkIHRoZSBkYXRhIGFycmF5IGluc3RhbmNlLlxuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgLy8gRGlzY2FyZCBvbGQgcGFyc2VkIGRhdGEgYW5kIHN0YWNrc1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgIG1ldGEuX3BhcnNlZCA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShkYXRhKSkge1xuICAgICAgICBsaXN0ZW5BcnJheUV2ZW50cyhkYXRhLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgICB9XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuXG4gICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICB9XG4gIH1cblxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBjYWNoZWQgX3N0YWNrZWQgc3RhdHVzIGlzIGN1cnJlbnRcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcblxuICAgIC8vIGRldGVjdCBjaGFuZ2UgaW4gc3RhY2sgb3B0aW9uXG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgdmFsdWVzIGZyb20gb2xkIHN0YWNrXG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cblxuICAgIC8vIFJlLXN5bmMgbWV0YSBkYXRhIGluIGNhc2UgdGhlIHVzZXIgcmVwbGFjZWQgdGhlIGRhdGEgYXJyYXkgb3IgaWYgd2UgbWlzc2VkXG4gICAgLy8gYW55IHVwZGF0ZXMgYW5kIHNvIG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBudW1iZXIgb2YgZGF0YXBvaW50cyBjaGFuZ2luZy5cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcblxuICAgIC8vIGlmIHN0YWNrIGNoYW5nZWQsIHVwZGF0ZSBzdGFjayB2YWx1ZXMgZm9yIHRoZSB3aG9sZSBkYXRhc2V0XG4gICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBNZXJnZXMgdXNlci1zdXBwbGllZCBhbmQgZGVmYXVsdCBkYXRhc2V0LWxldmVsIG9wdGlvbnNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldFNjb3BlS2V5cyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLl9wYXJzaW5nID0gdGhpcy5vcHRpb25zLnBhcnNpbmc7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvdW50XG5cdCAqL1xuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IG1ldGEsIF9kYXRhOiBkYXRhfSA9IHRoaXM7XG4gICAgY29uc3Qge2lTY2FsZSwgX3N0YWNrZWR9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuXG4gICAgbGV0IHNvcnRlZCA9IHN0YXJ0ID09PSAwICYmIGNvdW50ID09PSBkYXRhLmxlbmd0aCA/IHRydWUgOiBtZXRhLl9zb3J0ZWQ7XG4gICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgbGV0IGksIGN1ciwgcGFyc2VkO1xuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWV0YS5fc29ydGVkID0gc29ydGVkO1xuICAgIH1cblxuICAgIGlmIChfc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIHBhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXNcblx0ICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGFcblx0ICogQHBhcmFtIHthcnJheX0gZGF0YSAtIGRhdGEgYXJyYXkuIEV4YW1wbGUgWzEsMyw0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBzdGFydCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBudW1iZXIgb2YgaXRlbXMgdG8gcGFyc2Vcblx0ICogQHJldHVybnMge29iamVjdH0gcGFyc2VkIGl0ZW0gLSBpdGVtIGNvbnRhaW5pbmcgaW5kZXggYW5kIGEgcGFyc2VkIHZhbHVlXG5cdCAqIGZvciBlYWNoIHNjYWxlIGlkLlxuXHQgKiBFeGFtcGxlOiB7eFNjYWxlMDogMCwgeVNjYWxlMDogMX1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXG4gICAgICAgIFt2QXhpc106IHZTY2FsZS5wYXJzZShkYXRhW2luZGV4XSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIGFycmF5c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbWzEsMl0sWzMsNF1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuXG5cdCAqIEV4YW1wbGU6IHt4OiAwLCB5OiAxfVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShpdGVtWzBdLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcGFyYW0ge29iamVjdH0gbWV0YSAtIGRhdGFzZXQgbWV0YVxuXHQgKiBAcGFyYW0ge2FycmF5fSBkYXRhIC0gZGF0YSBhcnJheS4gRXhhbXBsZSBbe3g6MSwgeTo1fSwge3g6MiwgeToxMH1dXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIG51bWJlciBvZiBpdGVtcyB0byBwYXJzZVxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBwYXJzZWQgaXRlbSAtIGl0ZW0gY29udGFpbmluZyBpbmRleCBhbmQgYSBwYXJzZWQgdmFsdWVcblx0ICogZm9yIGVhY2ggc2NhbGUgaWQuIF9jdXN0b20gaXMgb3B0aW9uYWxcblx0ICogRXhhbXBsZToge3hTY2FsZTA6IDAsIHlTY2FsZTA6IDEsIF9jdXN0b206IHtyOiAxMCwgZm9vOiAnYmFyJ319XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB4QXhpc0tleSksIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0UGFyc2VkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFtpbmRleF07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YUVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBhcHBseVN0YWNrKHNjYWxlLCBwYXJzZWQsIG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICB2YWx1ZXM6IHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNcbiAgICB9O1xuICAgIHJldHVybiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgbWV0YS5pbmRleCwge21vZGV9KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkVmFsdWUgPT09IG51bGwgPyBOYU4gOiBwYXJzZWRWYWx1ZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICBpZiAoc3RhY2sgJiYgdmFsdWVzKSB7XG4gICAgICBzdGFjay52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICB2YWx1ZSA9IGFwcGx5U3RhY2soc3RhY2ssIHBhcnNlZFZhbHVlLCB0aGlzLl9jYWNoZWRNZXRhLmluZGV4KTtcbiAgICB9XG4gICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWluTWF4KHNjYWxlLCBjYW5TdGFjaykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IF9wYXJzZWQgPSBtZXRhLl9wYXJzZWQ7XG4gICAgY29uc3Qgc29ydGVkID0gbWV0YS5fc29ydGVkICYmIHNjYWxlID09PSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgY29uc3Qgb3RoZXJTY2FsZSA9IHRoaXMuX2dldE90aGVyU2NhbGUoc2NhbGUpO1xuICAgIGNvbnN0IHN0YWNrID0gY3JlYXRlU3RhY2soY2FuU3RhY2ssIG1ldGEsIHRoaXMuY2hhcnQpO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgY29uc3Qge21pbjogb3RoZXJNaW4sIG1heDogb3RoZXJNYXh9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICBsZXQgaSwgcGFyc2VkO1xuXG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc0Zpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAvLyBpZiB0aGUgZGF0YSBpcyBzb3J0ZWQsIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZnVydGhlciBmcm9tIHRoaXMgZW5kIG9mIGFycmF5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc29ydGVkKSB7XG4gICAgICAvLyBpbiB0aGUgc29ydGVkIGNhc2UsIGZpbmQgZmlyc3Qgbm9uLXNraXBwZWQgdmFsdWUgZnJvbSBvdGhlciBlbmQgb2YgYXJyYXlcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBnZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQ7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIHZhbHVlO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VkW2ldW3NjYWxlLmF4aXNdO1xuICAgICAgaWYgKGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfGJvb2xlYW59XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogaVNjYWxlID8gJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSA6ICcnLFxuICAgICAgdmFsdWU6IHZTY2FsZSA/ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSkgOiAnJ1xuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZVxuXHQgKi9cbiAgdXBkYXRlKG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhY3RpdmUgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZHJhd0NvdW50IHx8IChlbGVtZW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgY29uc3QgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgbGV0IGk7XG5cbiAgICBpZiAobWV0YS5kYXRhc2V0KSB7XG4gICAgICBtZXRhLmRhdGFzZXQuZHJhdyhjdHgsIGFyZWEsIHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYSBzZXQgb2YgcHJlZGVmaW5lZCBzdHlsZSBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBkYXRhc2V0XG5cdCAqIG9yIHRoZSBkYXRhIGlmIHRoZSBpbmRleCBpcyBzcGVjaWZpZWRcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gZGF0YSBpbmRleFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthY3RpdmVdIC0gdHJ1ZSBpZiBob3ZlclxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IHN0eWxlIG9iamVjdFxuXHQgKi9cbiAgZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgIGNvbnN0IG1vZGUgPSBhY3RpdmUgPyAnYWN0aXZlJyA6ICdkZWZhdWx0JztcbiAgICByZXR1cm4gaW5kZXggPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXRcbiAgICAgID8gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpXG4gICAgICA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgbGV0IGNvbnRleHQ7XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQgPSBlbGVtZW50LiRjb250ZXh0IHx8XG4gICAgICAgIChlbGVtZW50LiRjb250ZXh0ID0gY3JlYXRlRGF0YUNvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBlbGVtZW50KSk7XG4gICAgICBjb250ZXh0LnBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgIGNvbnRleHQucmF3ID0gZGF0YXNldC5kYXRhW2luZGV4XTtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFJbmRleCA9IGluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gdGhpcy4kY29udGV4dCB8fFxuICAgICAgICAodGhpcy4kY29udGV4dCA9IGNyZWF0ZURhdGFzZXRDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLmluZGV4KSk7XG4gICAgICBjb250ZXh0LmRhdGFzZXQgPSBkYXRhc2V0O1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICB9XG5cbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xuICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFttb2RlXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICAvLyBjb250ZXh0IGlzIHByb3ZpZGVkIGFzIGEgZnVuY3Rpb24sIGFuZCBpcyBjYWxsZWQgb25seSBpZiBuZWVkZWQsXG4gICAgLy8gc28gd2UgZG9uJ3QgY3JlYXRlIGEgY29udGV4dCBmb3IgZWFjaCBlbGVtZW50IGlmIG5vdCBuZWVkZWQuXG4gICAgY29uc3QgY29udGV4dCA9ICgpID0+IHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG5cbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIC8vIGAkc2hhcmVkYCBpbmRpY2F0ZXMgdGhpcyBzZXQgb2Ygb3B0aW9ucyBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgZWxlbWVudHMuXG4gICAgICAvLyBTaGFyaW5nIGlzIHVzZWQgdG8gcmVkdWNlIG51bWJlciBvZiBwcm9wZXJ0aWVzIHRvIGNoYW5nZSBkdXJpbmcgYW5pbWF0aW9uLlxuICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuXG4gICAgICAvLyBXZSBjYWNoZSBvcHRpb25zIGJ5IGBtb2RlYCwgd2hpY2ggY2FuIGJlICdhY3RpdmUnIGZvciBleGFtcGxlLiBUaGlzIGVuYWJsZXMgdXNcbiAgICAgIC8vIHRvIGhhdmUgdGhlICdhY3RpdmUnIGVsZW1lbnQgb3B0aW9ucyBhbmQgJ2RlZmF1bHQnIG9wdGlvbnMgdG8gc3dpdGNoIGJldHdlZW5cbiAgICAgIC8vIHdoZW4gaW50ZXJhY3RpbmcuXG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGNsb25lSWZOb3RTaGFyZWQodmFsdWVzLCBzaGFyaW5nKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBnZXR0aW5nIHRoZSBvcHRpb25zIG9iamVjdCBzaGFyZWQgYmV0d2VlbiBlbGVtZW50c1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVdGlsaXR5IGZvciBkZXRlcm1pbmluZyBpZiBgb3B0aW9uc2Agc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB1cGRhdGVkIHByb3BlcnRpZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykge1xuICAgIHJldHVybiAhc2hhcmVkT3B0aW9ucyB8fCBpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkgfHwgdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0b2RvIHY0LCByZW5hbWUgdG8gZ2V0U2hhcmVkT3B0aW9ucyBhbmQgcmVtb3ZlIGV4Y2VzcyBmdW5jdGlvbnNcbiAgICovXG4gIF9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKSB7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyA9IHRoaXMuX3NoYXJlZE9wdGlvbnM7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB8fCAoc2hhcmVkT3B0aW9ucyAhPT0gcHJldmlvdXNseVNoYXJlZE9wdGlvbnMpO1xuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgIHJldHVybiB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFV0aWxpdHkgZm9yIHVwZGF0aW5nIGFuIGVsZW1lbnQgd2l0aCBuZXcgcHJvcGVydGllcywgdXNpbmcgYW5pbWF0aW9ucyB3aGVuIGFwcHJvcHJpYXRlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCBwcm9wZXJ0aWVzLCBtb2RlKSB7XG4gICAgaWYgKGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUpLnVwZGF0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSB0byBhbmltYXRlIHRoZSBzaGFyZWQgb3B0aW9ucywgdGhhdCBhcmUgcG90ZW50aWFsbHkgYWZmZWN0aW5nIG11bHRpcGxlIGVsZW1lbnRzLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICB1cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIG5ld09wdGlvbnMpIHtcbiAgICBpZiAoc2hhcmVkT3B0aW9ucyAmJiAhaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpLnVwZGF0ZShzaGFyZWRPcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgbW9kZSwgYWN0aXZlKSB7XG4gICAgZWxlbWVudC5hY3RpdmUgPSBhY3RpdmU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSk7XG4gICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUsIGFjdGl2ZSkudXBkYXRlKGVsZW1lbnQsIHtcbiAgICAgIC8vIFdoZW4gZ29pbmcgZnJvbSBhY3RpdmUgdG8gaW5hY3RpdmUsIHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBzaGFyZWQgb3B0aW9ucy5cbiAgICAgIC8vIFRoaXMgd2F5IHRoZSBvbmNlIGhvdmVyZWQgZWxlbWVudCB3aWxsIGVuZCB1cCB3aXRoIHRoZSBzYW1lIG9yaWdpbmFsIHNoYXJlZCBvcHRpb25zIGluc3RhbmNlLCBhZnRlciBhbmltYXRpb24uXG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xuICB9XG5cbiAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsICdhY3RpdmUnLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG5cbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0U3R5bGUoZWxlbWVudCwgdW5kZWZpbmVkLCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgLy8gQXBwbHkgY2hhbmdlcyBkZXRlY3RlZCB0aHJvdWdoIGFycmF5IGxpc3RlbmVyc1xuICAgIGZvciAoY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gb2YgdGhpcy5fc3luY0xpc3QpIHtcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcblxuICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtRGF0YSA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGNvdW50ID0gTWF0aC5taW4obnVtRGF0YSwgbnVtTWV0YSk7XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIC8vIFRPRE86IEl0IGlzIG5vdCBvcHRpbWFsIHRvIGFsd2F5cyBwYXJzZSB0aGUgb2xkIGRhdGFcbiAgICAgIC8vIFRoaXMgaXMgZG9uZSBiZWNhdXNlIHdlIGFyZSBub3QgZGV0ZWN0aW5nIGRpcmVjdCBhc3NpZ25tZW50czpcbiAgICAgIC8vIGNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVs1XSA9IDEwO1xuICAgICAgLy8gY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhWzVdLnkgPSAxMDtcbiAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgIH1cblxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuXG4gICAgY29uc3QgbW92ZSA9IChhcnIpID0+IHtcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdmUoZGF0YSk7XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZShzdGFydCwgY291bnQpO1xuXG4gICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZGF0YSwgc3RhcnQsIGNvdW50LCAncmVzZXQnKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhlbGVtZW50LCBzdGFydCwgY291bnQsIG1vZGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgY29uc3QgcmVtb3ZlZCA9IG1ldGEuX3BhcnNlZC5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEsIHJlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcbiAgICovXG4gIF9zeW5jKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gPSBhcmdzO1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4LCAuLi5hcmdzXSk7XG4gIH1cblxuICBfb25EYXRhUHVzaCgpIHtcbiAgICBjb25zdCBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsIGNvdW50XSk7XG4gIH1cblxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG5cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XG4gIH1cblxuICBfb25EYXRhU3BsaWNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHN0YXJ0LCBjb3VudF0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIHN0YXJ0LCBuZXdDb3VudF0pO1xuICAgIH1cbiAgfVxuXG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7XG4gIF9hcnJheVVuaXF1ZSwgaXNBcnJheSwgaXNOdWxsT3JVbmRlZixcbiAgdmFsdWVPckRlZmF1bHQsIHJlc29sdmVPYmplY3RLZXksIHNpZ24sIGRlZmluZWRcbn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCB0eXBlKSB7XG4gIGlmICghc2NhbGUuX2NhY2hlLiRiYXIpIHtcbiAgICBjb25zdCB2aXNpYmxlTWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKTtcbiAgICBsZXQgdmFsdWVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlcyA9IHZhbHVlcy5jb25jYXQodmlzaWJsZU1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSk7XG4gICAgfVxuICAgIHNjYWxlLl9jYWNoZS4kYmFyID0gX2FycmF5VW5pcXVlKHZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYikpO1xuICB9XG4gIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgXCJvcHRpbWFsXCIgc2FtcGxlIHNpemUgdG8gbWFpbnRhaW4gYmFycyBlcXVhbGx5IHNpemVkIHdoaWxlIHByZXZlbnRpbmcgb3ZlcmxhcC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpIHtcbiAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdmFsdWVzID0gZ2V0QWxsU2NhbGVWYWx1ZXMoc2NhbGUsIG1ldGEudHlwZSk7XG4gIGxldCBtaW4gPSBzY2FsZS5fbGVuZ3RoO1xuICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgY29uc3QgdXBkYXRlTWluQW5kUHJldiA9ICgpID0+IHtcbiAgICBpZiAoY3VyciA9PT0gMzI3NjcgfHwgY3VyciA9PT0gLTMyNzY4KSB7XG4gICAgICAvLyBJZ25vcmUgdHJ1bmNhdGVkIHBpeGVsc1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChwcmV2KSkge1xuICAgICAgLy8gY3VyciAtIHByZXYgPT09IDAgaXMgaWdub3JlZFxuICAgICAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhjdXJyIC0gcHJldikgfHwgbWluKTtcbiAgICB9XG4gICAgcHJldiA9IGN1cnI7XG4gIH07XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZXNbaV0pO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuXG4gIHByZXYgPSB1bmRlZmluZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuXG4gIHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJpZGVhbFwiIGNhdGVnb3J5IGJhc2VkIG9uIHRoZSBhYnNvbHV0ZSBiYXIgdGhpY2tuZXNzIG9yLCBpZiB1bmRlZmluZWQgb3IgbnVsbCxcbiAqIHVzZXMgdGhlIHNtYWxsZXN0IGludGVydmFsIChzZWUgY29tcHV0ZU1pblNhbXBsZVNpemUpIHRoYXQgcHJldmVudHMgYmFyIG92ZXJsYXBwaW5nLiBUaGlzXG4gKiBtb2RlIGN1cnJlbnRseSBhbHdheXMgZ2VuZXJhdGVzIGJhcnMgZXF1YWxseSBzaXplZCAodW50aWwgd2UgaW50cm9kdWNlIHNjcmlwdGFibGUgb3B0aW9ucz8pLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgbGV0IHNpemUsIHJhdGlvO1xuXG4gIGlmIChpc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcbiAgICBzaXplID0gcnVsZXIubWluICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gICAgcmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiBiYXIgdGhpY2tuZXNzIGlzIGVuZm9yY2VkLCBjYXRlZ29yeSBhbmQgYmFyIHBlcmNlbnRhZ2VzIGFyZSBpZ25vcmVkLlxuICAgIC8vIE5vdGUoU0IpOiB3ZSBjb3VsZCBhZGQgc3VwcG9ydCBmb3IgcmVsYXRpdmUgYmFyIHRoaWNrbmVzcyAoZS5nLiBiYXJUaGlja25lc3M6ICc1MCUnKVxuICAgIC8vIGFuZCBkZXByZWNhdGUgYmFyUGVyY2VudGFnZSBzaW5jZSB0aGlzIHZhbHVlIGlzIGlnbm9yZWQgd2hlbiB0aGlja25lc3MgaXMgYWJzb2x1dGUuXG4gICAgc2l6ZSA9IHRoaWNrbmVzcyAqIHN0YWNrQ291bnQ7XG4gICAgcmF0aW8gPSAxO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW8sXG4gICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSAoc2l6ZSAvIDIpXG4gIH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgYW4gXCJvcHRpbWFsXCIgY2F0ZWdvcnkgdGhhdCBnbG9iYWxseSBhcnJhbmdlcyBiYXJzIHNpZGUgYnkgc2lkZSAobm8gZ2FwIHdoZW5cbiAqIHBlcmNlbnRhZ2Ugb3B0aW9ucyBhcmUgMSksIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBhbmQgZm9sbG93aW5nIGNhdGVnb3JpZXMuIFRoaXMgbW9kZVxuICogZ2VuZXJhdGVzIGJhcnMgd2l0aCBkaWZmZXJlbnQgd2lkdGhzIHdoZW4gZGF0YSBhcmUgbm90IGV2ZW5seSBzcGFjZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gIGNvbnN0IGN1cnIgPSBwaXhlbHNbaW5kZXhdO1xuICBsZXQgcHJldiA9IGluZGV4ID4gMCA/IHBpeGVsc1tpbmRleCAtIDFdIDogbnVsbDtcbiAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICBjb25zdCBwZXJjZW50ID0gb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG5cbiAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAvLyBmaXJzdCBkYXRhOiBpdHMgc2l6ZSBpcyBkb3VibGUgYmFzZWQgb24gdGhlIG5leHQgcG9pbnQgb3IsXG4gICAgLy8gaWYgaXQncyBhbHNvIHRoZSBsYXN0IGRhdGEsIHdlIHVzZSB0aGUgc2NhbGUgc2l6ZS5cbiAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gIH1cblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIGxhc3QgZGF0YTogaXRzIHNpemUgaXMgYWxzbyBkb3VibGUgYmFzZWQgb24gdGhlIHByZXZpb3VzIHBvaW50LlxuICAgIG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG4gIH1cblxuICBjb25zdCBzdGFydCA9IGN1cnIgLSAoY3VyciAtIE1hdGgubWluKHByZXYsIG5leHQpKSAvIDIgKiBwZXJjZW50O1xuICBjb25zdCBzaXplID0gTWF0aC5hYnMobmV4dCAtIHByZXYpIC8gMiAqIHBlcmNlbnQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgY29uc3Qgc3RhcnRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVswXSwgaSk7XG4gIGNvbnN0IGVuZFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzFdLCBpKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGxldCBiYXJTdGFydCA9IG1pbjtcbiAgbGV0IGJhckVuZCA9IG1heDtcblxuICBpZiAoTWF0aC5hYnMobWluKSA+IE1hdGguYWJzKG1heCkpIHtcbiAgICBiYXJTdGFydCA9IG1heDtcbiAgICBiYXJFbmQgPSBtaW47XG4gIH1cblxuICAvLyBTdG9yZSBgYmFyRW5kYCAoZnVydGhlc3QgYXdheSBmcm9tIG9yaWdpbikgYXMgcGFyc2VkIHZhbHVlLFxuICAvLyB0byBtYWtlIHN0YWNraW5nIHN0cmFpZ2h0IGZvcndhcmRcbiAgaXRlbVt2U2NhbGUuYXhpc10gPSBiYXJFbmQ7XG5cbiAgaXRlbS5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0LFxuICAgIGJhckVuZCxcbiAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICBlbmQ6IGVuZFZhbHVlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGlmIChpc0FycmF5KGVudHJ5KSkge1xuICAgIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbVt2U2NhbGUuYXhpc10gPSB2U2NhbGUucGFyc2UoZW50cnksIGkpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICBjb25zdCBwYXJzZWQgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuXG4gIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGVudHJ5ID0gZGF0YVtpXTtcbiAgICBpdGVtID0ge307XG4gICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5mdW5jdGlvbiBpc0Zsb2F0QmFyKGN1c3RvbSkge1xuICByZXR1cm4gY3VzdG9tICYmIGN1c3RvbS5iYXJTdGFydCAhPT0gdW5kZWZpbmVkICYmIGN1c3RvbS5iYXJFbmQgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpIHtcbiAgaWYgKHNpemUgIT09IDApIHtcbiAgICByZXR1cm4gc2lnbihzaXplKTtcbiAgfVxuICByZXR1cm4gKHZTY2FsZS5pc0hvcml6b250YWwoKSA/IDEgOiAtMSkgKiAodlNjYWxlLm1pbiA+PSBhY3R1YWxCYXNlID8gMSA6IC0xKTtcbn1cblxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICBsZXQgcmV2ZXJzZSwgc3RhcnQsIGVuZCwgdG9wLCBib3R0b207XG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlID4gcHJvcGVydGllcy54O1xuICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgIGVuZCA9ICdyaWdodCc7XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICBzdGFydCA9ICdib3R0b20nO1xuICAgIGVuZCA9ICd0b3AnO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgdG9wID0gJ2VuZCc7XG4gICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAnc3RhcnQnO1xuICAgIGJvdHRvbSA9ICdlbmQnO1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219O1xufVxuXG5mdW5jdGlvbiBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCkge1xuICBsZXQgZWRnZSA9IG9wdGlvbnMuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgcmVzID0ge307XG5cbiAgaWYgKCFlZGdlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChlZGdlID09PSB0cnVlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0ge3RvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgbGVmdDogdHJ1ZX07XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfSA9IGJvcmRlclByb3BzKHByb3BlcnRpZXMpO1xuXG4gIGlmIChlZGdlID09PSAnbWlkZGxlJyAmJiBzdGFjaykge1xuICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICBpZiAoKHN0YWNrLl90b3AgfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH0gZWxzZSBpZiAoKHN0YWNrLl9ib3R0b20gfHwgMCkgPT09IGluZGV4KSB7XG4gICAgICBlZGdlID0gYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfVxuICB9XG5cbiAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRWRnZShlZGdlLCBhLCBiLCByZXZlcnNlKSB7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgZWRnZSA9IHN3YXAoZWRnZSwgYSwgYik7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGIsIGEpO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBhLCBiKTtcbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgcmV0dXJuIG9yaWcgPT09IHYxID8gdjIgOiBvcmlnID09PSB2MiA/IHYxIDogb3JpZztcbn1cblxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogdiA9PT0gJ2VuZCcgPyBlbmQgOiB2O1xufVxuXG5mdW5jdGlvbiBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIHtpbmZsYXRlQW1vdW50fSwgcmF0aW8pIHtcbiAgcHJvcGVydGllcy5pbmZsYXRlQW1vdW50ID0gaW5mbGF0ZUFtb3VudCA9PT0gJ2F1dG8nXG4gICAgPyByYXRpbyA9PT0gMSA/IDAuMzMgOiAwXG4gICAgOiBpbmZsYXRlQW1vdW50O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdiYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgZGF0YUVsZW1lbnRUeXBlOiAnYmFyJyxcblxuICAgIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICAgIGJhclBlcmNlbnRhZ2U6IDAuOSxcbiAgICBncm91cGVkOiB0cnVlLFxuXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYmFzZScsICd3aWR0aCcsICdoZWlnaHQnXVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgICAgYmVnaW5BdFplcm86IHRydWUsXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG5cdCAqIE92ZXJyaWRpbmcgcHJpbWl0aXZlIGRhdGEgcGFyc2luZyBzaW5jZSB3ZSBzdXBwb3J0IG1peGVkIHByaW1pdGl2ZS9hcnJheVxuXHQgKiBkYXRhIGZvciBmbG9hdCBiYXJzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBhcnJheSBkYXRhIHBhcnNpbmcgc2luY2Ugd2Ugc3VwcG9ydCBtaXhlZCBwcmltaXRpdmUvYXJyYXlcblx0ICogZGF0YSBmb3IgZmxvYXQgYmFyc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cblxuICAvKipcblx0ICogT3ZlcnJpZGluZyBvYmplY3QgZGF0YSBwYXJzaW5nIHNpbmNlIHdlIHN1cHBvcnQgbWl4ZWQgcHJpbWl0aXZlL2FycmF5XG5cdCAqIHZhbHVlLXNjYWxlIGRhdGEgZm9yIGZsb2F0IGJhcnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIG9iajtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9iaiA9IGRhdGFbaV07XG4gICAgICBpdGVtID0ge307XG4gICAgICBpdGVtW2lTY2FsZS5heGlzXSA9IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgaUF4aXNLZXkpLCBpKTtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUocmVzb2x2ZU9iamVjdEtleShvYmosIHZBeGlzS2V5KSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIHN1cGVyLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XG4gICAgICAvLyBmbG9hdCBiYXI6IG9ubHkgb25lIGVuZCBvZiB0aGUgYmFyIGlzIGNvbnNpZGVyZWQgYnkgYHN1cGVyYFxuICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge251bWJlcnxib29sZWFufVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pXG4gICAgICA/ICdbJyArIGN1c3RvbS5zdGFydCArICcsICcgKyBjdXN0b20uZW5kICsgJ10nXG4gICAgICA6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG5cbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG5cbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMobWV0YS5kYXRhLCAwLCBtZXRhLmRhdGEubGVuZ3RoLCBtb2RlKTtcbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aW5kZXgsIF9jYWNoZWRNZXRhOiB7dlNjYWxlfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJhc2UgPSB2U2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgY29uc3QgaG9yaXpvbnRhbCA9IHZTY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHZwaXhlbHMgPSByZXNldCB8fCBpc051bGxPclVuZGVmKHBhcnNlZFt2U2NhbGUuYXhpc10pID8ge2Jhc2UsIGhlYWQ6IGJhc2V9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xuICAgICAgY29uc3Qgc3RhY2sgPSAocGFyc2VkLl9zdGFja3MgfHwge30pW3ZTY2FsZS5heGlzXTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgYmFzZTogdnBpeGVscy5iYXNlLFxuICAgICAgICBlbmFibGVCb3JkZXJSYWRpdXM6ICFzdGFjayB8fCBpc0Zsb2F0QmFyKHBhcnNlZC5fY3VzdG9tKSB8fCAoaW5kZXggPT09IHN0YWNrLl90b3AgfHwgaW5kZXggPT09IHN0YWNrLl9ib3R0b20pLFxuICAgICAgICB4OiBob3Jpem9udGFsID8gdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXIsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcbiAgICAgICAgaGVpZ2h0OiBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogTWF0aC5hYnModnBpeGVscy5zaXplKSxcbiAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyBNYXRoLmFicyh2cGl4ZWxzLnNpemUpIDogaXBpeGVscy5zaXplXG4gICAgICB9O1xuXG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYmFyc1tpXS5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHByb3BlcnRpZXMub3B0aW9ucyB8fCBiYXJzW2ldLm9wdGlvbnM7XG4gICAgICBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCk7XG4gICAgICBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIG9wdGlvbnMsIHJ1bGVyLnJhdGlvKTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChiYXJzW2ldLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgc3RhY2tzIGJhc2VkIG9uIGdyb3VwcyBhbmQgYmFyIHZpc2liaWxpdHkuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbGFzdF0gLSBUaGUgZGF0YXNldCBpbmRleFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2RhdGFJbmRleF0gLSBUaGUgZGF0YSBpbmRleCBvZiB0aGUgcnVsZXJcblx0ICogQHJldHVybnMge3N0cmluZ1tdfSBUaGUgbGlzdCBvZiBzdGFjayBJRHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja3MobGFzdCwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qge2lTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gaVNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpXG4gICAgICAuZmlsdGVyKG1ldGEgPT4gbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IGlTY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgY29uc3QgY3VycmVudFBhcnNlZCA9IHRoaXMuX2NhY2hlZE1ldGEuY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KTtcbiAgICBjb25zdCBpU2NhbGVWYWx1ZSA9IGN1cnJlbnRQYXJzZWQgJiYgY3VycmVudFBhcnNlZFtpU2NhbGUuYXhpc107XG5cbiAgICBjb25zdCBza2lwTnVsbCA9IChtZXRhKSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSBtZXRhLl9wYXJzZWQuZmluZChpdGVtID0+IGl0ZW1baVNjYWxlLmF4aXNdID09PSBpU2NhbGVWYWx1ZSk7XG4gICAgICBjb25zdCB2YWwgPSBwYXJzZWQgJiYgcGFyc2VkW21ldGEudlNjYWxlLmF4aXNdO1xuXG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWwpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgbWV0YSBvZiBtZXRhc2V0cykge1xuICAgICAgaWYgKGRhdGFJbmRleCAhPT0gdW5kZWZpbmVkICYmIHNraXBOdWxsKG1ldGEpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBzdGFja2VkICAgfCBtZXRhLnN0YWNrXG4gICAgICAvLyAgICAgICAgICAgfCBmb3VuZCB8IG5vdCBmb3VuZCB8IHVuZGVmaW5lZFxuICAgICAgLy8gZmFsc2UgICAgIHwgICB4ICAgfCAgICAgeCAgICAgfCAgICAgeFxuICAgICAgLy8gdHJ1ZSAgICAgIHwgICAgICAgfCAgICAgeCAgICAgfFxuICAgICAgLy8gdW5kZWZpbmVkIHwgICAgICAgfCAgICAgeCAgICAgfCAgICAgeFxuICAgICAgaWYgKHN0YWNrZWQgPT09IGZhbHNlIHx8IHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAobWV0YS5pbmRleCA9PT0gbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBzdGFja3M/IHRoYXQgbWVhbnMgdGhlcmUgaXMgbm8gdmlzaWJsZSBkYXRhLiBMZXQncyBzdGlsbCBpbml0aWFsaXplIGFuIGB1bmRlZmluZWRgXG4gICAgLy8gc3RhY2sgd2hlcmUgcG9zc2libGUgaW52aXNpYmxlIGJhcnMgd2lsbCBiZSBsb2NhdGVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy82MzY4XG4gICAgaWYgKCFzdGFja3MubGVuZ3RoKSB7XG4gICAgICBzdGFja3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgZWZmZWN0aXZlIG51bWJlciBvZiBzdGFja3MgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRTdGFja0NvdW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gIH1cblxuICBfZ2V0QXhpc0NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBeGlzKCkubGVuZ3RoO1xuICB9XG5cbiAgZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzKCkge1xuICAgIGNvbnN0IHNjYWxlcyA9IHRoaXMuY2hhcnQuc2NhbGVzO1xuICAgIGNvbnN0IGluZGV4U2NhbGVJZCA9IHRoaXMuY2hhcnQub3B0aW9ucy5pbmRleEF4aXM7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBpbmRleFNjYWxlSWQpLnNoaWZ0KCk7XG4gIH1cblxuICBfZ2V0QXhpcygpIHtcbiAgICBjb25zdCBheGlzID0ge307XG4gICAgY29uc3QgZmlyc3RTY2FsZUF4aXNJZCA9IHRoaXMuZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzKCk7XG4gICAgZm9yIChjb25zdCBkYXRhc2V0IG9mIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cykge1xuICAgICAgYXhpc1t2YWx1ZU9yRGVmYXVsdChcbiAgICAgICAgdGhpcy5jaGFydC5vcHRpb25zLmluZGV4QXhpcyA9PT0gJ3gnID8gZGF0YXNldC54QXhpc0lEIDogZGF0YXNldC55QXhpc0lELCBmaXJzdFNjYWxlQXhpc0lkXG4gICAgICApXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhheGlzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdGFjayBpbmRleCBmb3IgdGhlIGdpdmVuIGRhdGFzZXQgYmFzZWQgb24gZ3JvdXBzIGFuZCBiYXIgdmlzaWJpbGl0eS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhc2V0SW5kZXhdIC0gVGhlIGRhdGFzZXQgaW5kZXhcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSAtIFRoZSBzdGFjayBuYW1lIHRvIGZpbmRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXRhSW5kZXhdXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBzdGFjayBpbmRleFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBuYW1lLCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpO1xuICAgIGNvbnN0IGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgID8gc3RhY2tzLmluZGV4T2YobmFtZSlcbiAgICAgIDogLTE7IC8vIGluZGV4T2YgcmV0dXJucyAtMSBpZiBlbGVtZW50IGlzIG5vdCBwcmVzZW50XG5cbiAgICByZXR1cm4gKGluZGV4ID09PSAtMSlcbiAgICAgID8gc3RhY2tzLmxlbmd0aCAtIDFcbiAgICAgIDogaW5kZXg7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSdWxlcigpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHBpeGVscyA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBpeGVscy5wdXNoKGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpW2lTY2FsZS5heGlzXSwgaSkpO1xuICAgIH1cblxuICAgIGNvbnN0IGJhclRoaWNrbmVzcyA9IG9wdHMuYmFyVGhpY2tuZXNzO1xuICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKTtcblxuICAgIHJldHVybiB7XG4gICAgICBtaW4sXG4gICAgICBwaXhlbHMsXG4gICAgICBzdGFydDogaVNjYWxlLl9zdGFydFBpeGVsLFxuICAgICAgZW5kOiBpU2NhbGUuX2VuZFBpeGVsLFxuICAgICAgc3RhY2tDb3VudDogdGhpcy5fZ2V0U3RhY2tDb3VudCgpLFxuICAgICAgc2NhbGU6IGlTY2FsZSxcbiAgICAgIGdyb3VwZWQ6IG9wdHMuZ3JvdXBlZCxcbiAgICAgIC8vIGJhciB0aGlja25lc3MgcmF0aW8gdXNlZCBmb3Igbm9uLWdyb3VwZWQgYmFyc1xuICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogTm90ZTogcGl4ZWwgdmFsdWVzIGFyZSBub3QgY2xhbXBlZCB0byB0aGUgc2NhbGUgYXJlYS5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpbmRleCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YToge3ZTY2FsZSwgX3N0YWNrZWQsIGluZGV4OiBkYXRhc2V0SW5kZXh9LCBvcHRpb25zOiB7YmFzZTogYmFzZVZhbHVlLCBtaW5CYXJMZW5ndGh9fSA9IHRoaXM7XG4gICAgY29uc3QgYWN0dWFsQmFzZSA9IGJhc2VWYWx1ZSB8fCAwO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCBmbG9hdGluZyA9IGlzRmxvYXRCYXIoY3VzdG9tKTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRbdlNjYWxlLmF4aXNdO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGxlbmd0aCA9IF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiB2YWx1ZTtcbiAgICBsZXQgaGVhZCwgc2l6ZTtcblxuICAgIGlmIChsZW5ndGggIT09IHZhbHVlKSB7XG4gICAgICBzdGFydCA9IGxlbmd0aCAtIHZhbHVlO1xuICAgICAgbGVuZ3RoID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICB2YWx1ZSA9IGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGxlbmd0aCA9IGN1c3RvbS5iYXJFbmQgLSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICAvLyBiYXJzIGNyb3NzaW5nIG9yaWdpbiBhcmUgbm90IHN0YWNrZWRcbiAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiBzaWduKHZhbHVlKSAhPT0gc2lnbihjdXN0b20uYmFyRW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCArPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydFZhbHVlID0gIWlzTnVsbE9yVW5kZWYoYmFzZVZhbHVlKSAmJiAhZmxvYXRpbmcgPyBiYXNlVmFsdWUgOiBzdGFydDtcbiAgICBsZXQgYmFzZSA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0VmFsdWUpO1xuXG4gICAgaWYgKHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICBoZWFkID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIG5vdCB2aXNpYmxlLCBubyBoZWlnaHRcbiAgICAgIGhlYWQgPSBiYXNlO1xuICAgIH1cblxuICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcblxuICAgIGlmIChNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuICAgICAgc2l6ZSA9IGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSAqIG1pbkJhckxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gYWN0dWFsQmFzZSkge1xuICAgICAgICBiYXNlIC09IHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMCk7XG4gICAgICBjb25zdCBlbmRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMSk7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBiYXNlID0gTWF0aC5tYXgoTWF0aC5taW4oYmFzZSwgbWF4KSwgbWluKTtcbiAgICAgIGhlYWQgPSBiYXNlICsgc2l6ZTtcblxuICAgICAgaWYgKF9zdGFja2VkICYmICFmbG9hdGluZykge1xuICAgICAgICAvLyB2aXN1YWwgZGF0YSBjb29yZGluYXRlcyBhZnRlciBhcHBseWluZyBtaW5CYXJMZW5ndGhcbiAgICAgICAgcGFyc2VkLl9zdGFja3NbdlNjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZTY2FsZS5nZXRWYWx1ZUZvclBpeGVsKGhlYWQpIC0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoYmFzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemUsXG4gICAgICBiYXNlLFxuICAgICAgaGVhZCxcbiAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGluZGV4LCBydWxlcikge1xuICAgIGNvbnN0IHNjYWxlID0gcnVsZXIuc2NhbGU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBza2lwTnVsbCA9IG9wdGlvbnMuc2tpcE51bGw7XG4gICAgY29uc3QgbWF4QmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KTtcbiAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgIGNvbnN0IGF4aXNDb3VudCA9IHRoaXMuX2dldEF4aXNDb3VudCgpO1xuICAgIGlmIChydWxlci5ncm91cGVkKSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gc2tpcE51bGwgPyB0aGlzLl9nZXRTdGFja0NvdW50KGluZGV4KSA6IHJ1bGVyLnN0YWNrQ291bnQ7XG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcbiAgICAgICAgPyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCAqIGF4aXNDb3VudClcbiAgICAgICAgOiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50ICogYXhpc0NvdW50KTtcbiAgICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuY2hhcnQub3B0aW9ucy5pbmRleEF4aXMgPT09ICd4JyA/IHRoaXMuZ2V0RGF0YXNldCgpLnhBeGlzSUQgOiB0aGlzLmdldERhdGFzZXQoKS55QXhpc0lEO1xuICAgICAgY29uc3QgYXhpc051bWJlciA9IHRoaXMuX2dldEF4aXMoKS5pbmRleE9mKHZhbHVlT3JEZWZhdWx0KGF4aXNJRCwgdGhpcy5nZXRGaXJzdFNjYWxlSWRGb3JJbmRleEF4aXMoKSkpO1xuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHRoaXMuX2dldFN0YWNrSW5kZXgodGhpcy5pbmRleCwgdGhpcy5fY2FjaGVkTWV0YS5zdGFjaywgc2tpcE51bGwgPyBpbmRleCA6IHVuZGVmaW5lZCkgKyBheGlzTnVtYmVyO1xuICAgICAgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBub24tZ3JvdXBlZCBiYXIgY2hhcnRzLCBleGFjdCBwaXhlbCB2YWx1ZXMgYXJlIHVzZWRcbiAgICAgIGNlbnRlciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgYmFzZTogY2VudGVyIC0gc2l6ZSAvIDIsXG4gICAgICBoZWFkOiBjZW50ZXIgKyBzaXplIC8gMixcbiAgICAgIGNlbnRlcixcbiAgICAgIHNpemVcbiAgICB9O1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCByZWN0cyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAodGhpcy5nZXRQYXJzZWQoaSlbdlNjYWxlLmF4aXNdICE9PSBudWxsICYmICFyZWN0c1tpXS5oaWRkZW4pIHtcbiAgICAgICAgcmVjdHNbaV0uZHJhdyh0aGlzLl9jdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2J1YmJsZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG5cbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnXVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFBhcnNlIGFycmF5IG9mIHByaW1pdGl2ZSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBhcnJheXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbVsyXSwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBQYXJzZSBhcnJheSBvZiBvYmplY3RzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuXG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG4gICAgY29uc3QgciA9IHBhcnNlZC5fY3VzdG9tO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG5cbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zLnJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbW9kZV1cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBsZXQgdmFsdWVzID0gc3VwZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSk7XG5cbiAgICAvLyBJbiBjYXNlIHZhbHVlcyB3ZXJlIGNhY2hlZCAoYW5kIHRodXMgZnJvemVuKSwgd2UgbmVlZCB0byBjbG9uZSB0aGUgdmFsdWVzXG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXMsIHskc2hhcmVkOiBmYWxzZX0pO1xuICAgIH1cblxuICAgIC8vIEN1c3RvbSByYWRpdXMgcmVzb2x1dGlvblxuICAgIGNvbnN0IHJhZGl1cyA9IHZhbHVlcy5yYWRpdXM7XG4gICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICB9XG4gICAgdmFsdWVzLnJhZGl1cyArPSB2YWx1ZU9yRGVmYXVsdChwYXJzZWQgJiYgcGFyc2VkLl9jdXN0b20sIHJhZGl1cyk7XG5cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG4iLCAiaW1wb3J0IERhdGFzZXRDb250cm9sbGVyIGZyb20gJy4uL2NvcmUvY29yZS5kYXRhc2V0Q29udHJvbGxlci5qcyc7XG5pbXBvcnQge2lzT2JqZWN0LCByZXNvbHZlT2JqZWN0S2V5LCB0b1BlcmNlbnRhZ2UsIHRvRGltZW5zaW9uLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtmb3JtYXROdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5pbnRsLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgVEFVLCBIQUxGX1BJLCBfYW5nbGVCZXR3ZWVufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xuICBsZXQgcmF0aW9YID0gMTtcbiAgbGV0IHJhdGlvWSA9IDE7XG4gIGxldCBvZmZzZXRYID0gMDtcbiAgbGV0IG9mZnNldFkgPSAwO1xuICAvLyBJZiB0aGUgY2hhcnQncyBjaXJjdW1mZXJlbmNlIGlzbid0IGEgZnVsbCBjaXJjbGUsIGNhbGN1bGF0ZSBzaXplIGFzIGEgcmF0aW8gb2YgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgYXJjXG4gIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHJvdGF0aW9uO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2U7XG4gICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgZW5kWCA9IE1hdGguY29zKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgIGNvbnN0IGNhbGNNYXggPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IDEgOiBNYXRoLm1heChhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAtMSA6IE1hdGgubWluKGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFggPSBjYWxjTWF4KDAsIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICBjb25zdCBtaW5YID0gY2FsY01pbihQSSwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtaW5ZID0gY2FsY01pbihQSSArIEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgcmF0aW9ZID0gKG1heFkgLSBtaW5ZKSAvIDI7XG4gICAgb2Zmc2V0WCA9IC0obWF4WCArIG1pblgpIC8gMjtcbiAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICB9XG4gIHJldHVybiB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2RvdWdobnV0JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHRoZSByb3RhdGlvbiBvZiB0aGUgRG91Z2hudXRcbiAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICAvLyBCb29sZWFuIC0gV2hldGhlciB3ZSBhbmltYXRlIHNjYWxpbmcgdGhlIERvdWdobnV0IGZyb20gdGhlIGNlbnRyZVxuICAgICAgYW5pbWF0ZVNjYWxlOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBUaGUgcGVyY2VudGFnZSBvZiB0aGUgY2hhcnQgdGhhdCB3ZSBjdXQgb3V0IG9mIHRoZSBtaWRkbGUuXG4gICAgY3V0b3V0OiAnNTAlJyxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJyxcblxuICAgIC8vIFNwYWNpbmcgYmV0d2VlbiBhcmNzXG4gICAgc3BhY2luZzogMCxcblxuICAgIGluZGV4QXhpczogJ3InLFxuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ3NwYWNpbmcnICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2JvcmRlckRhc2gnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdob3ZlckJvcmRlckRhc2gnKSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgYXNwZWN0UmF0aW86IDEsXG5cbiAgICAvLyBOZWVkIHRvIG92ZXJyaWRlIHRoZXNlIHRvIGdpdmUgYSBuaWNlIGRlZmF1bHRcbiAgICBwbHVnaW5zOiB7XG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjb25zdCB7bGFiZWxzOiB7cG9pbnRTdHlsZSwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKGkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcblxuICAgICAgICAgICAgICAgICAgLy8gRXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgY29ycmVjdCBpdGVtXG4gICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuXG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxpbmtTY2FsZXMoKSB7fVxuXG4gIC8qKlxuXHQgKiBPdmVycmlkZSBkYXRhIHBhcnNpbmcsIHNpbmNlIHdlIGFyZSBub3QgdXNpbmcgc2NhbGVzXG5cdCAqL1xuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcblxuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGdldHRlciA9IChpKSA9PiArZGF0YVtpXTtcblxuICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBjb25zdCB7a2V5ID0gJ3ZhbHVlJ30gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBnZXR0ZXIgPSAoaSkgPT4gK3Jlc29sdmVPYmplY3RLZXkoZGF0YVtpXSwga2V5KTtcbiAgICAgIH1cblxuICAgICAgbGV0IGksIGlsZW47XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2ldID0gZ2V0dGVyKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLnJvdGF0aW9uIC0gOTApO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0Q2lyY3VtZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgdGhlIG1heGltYWwgcm90YXRpb24gJiBjaXJjdW1mZXJlbmNlIGV4dGVudHNcblx0ICogYWNyb3NzIGFsbCB2aXNpYmxlIGRhdGFzZXRzLlxuXHQgKi9cbiAgX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICBsZXQgbWluID0gVEFVO1xuICAgIGxldCBtYXggPSAtVEFVO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkgJiYgdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShpKS50eXBlID09PSB0aGlzLl90eXBlKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gY29udHJvbGxlci5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IGNvbnRyb2xsZXIuX2dldENpcmN1bWZlcmVuY2UoKTtcblxuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJvdGF0aW9uKTtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByb3RhdGlvbiArIGNpcmN1bWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByb3RhdGlvbjogbWluLFxuICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVcblx0ICovXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHtjaGFydEFyZWF9ID0gY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXRNYXhCb3JkZXJXaWR0aCgpICsgdGhpcy5nZXRNYXhPZmZzZXQoYXJjcykgKyB0aGlzLm9wdGlvbnMuc3BhY2luZztcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xuICAgIGNvbnN0IGN1dG91dCA9IE1hdGgubWluKHRvUGVyY2VudGFnZSh0aGlzLm9wdGlvbnMuY3V0b3V0LCBtYXhTaXplKSwgMSk7XG4gICAgY29uc3QgY2hhcnRXZWlnaHQgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbWF4aW1hbCByb3RhdGlvbiAmIGNpcmN1bWZlcmVuY2UgbGltaXRzLlxuICAgIC8vIElmIHdlIG9ubHkgY29uc2lkZXIgb3VyIGRhdGFzZXQsIHRoaXMgY2FuIGNhdXNlIHByb2JsZW1zIHdoZW4gdHdvIGRhdGFzZXRzXG4gICAgLy8gYXJlIGJvdGggbGVzcyB0aGFuIGEgY2lyY2xlIHdpdGggZGlmZmVyZW50IHJvdGF0aW9ucyAoc3RhcnRpbmcgYW5nbGVzKVxuICAgIGNvbnN0IHtjaXJjdW1mZXJlbmNlLCByb3RhdGlvbn0gPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKTtcbiAgICBjb25zdCB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9ID0gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSAoY2hhcnRBcmVhLndpZHRoIC0gc3BhY2luZykgLyByYXRpb1g7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5oZWlnaHQgLSBzcGFjaW5nKSAvIHJhdGlvWTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdG9EaW1lbnNpb24odGhpcy5vcHRpb25zLnJhZGl1cywgbWF4UmFkaXVzKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG91dGVyUmFkaXVzICogY3V0b3V0LCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0aGlzLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WCAqIG91dGVyUmFkaXVzO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFkgKiBvdXRlclJhZGl1cztcblxuICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG5cbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIGlmICgocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSkgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgfHwgbWV0YS5fcGFyc2VkW2ldID09PSBudWxsIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG4gICAgY29uc3QgYW5pbWF0ZVNjYWxlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5pbm5lclJhZGl1cztcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLm91dGVyUmFkaXVzO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBsZXQgc3RhcnRBbmdsZSA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgc3RhcnRBbmdsZSArPSB0aGlzLl9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IGNlbnRlclkgKyB0aGlzLm9mZnNldFksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgc3RhcnRBbmdsZSArPSBjaXJjdW1mZXJlbmNlO1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBjYWxjdWxhdGVUb3RhbCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICBsZXQgdG90YWwgPSAwO1xuICAgIGxldCBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG5cbiAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5fY2FjaGVkTWV0YS50b3RhbDtcbiAgICBpZiAodG90YWwgPiAwICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBUQVUgKiAoTWF0aC5hYnModmFsdWUpIC8gdG90YWwpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XSwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIGdldE1heEJvcmRlcldpZHRoKGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGV0IGksIGlsZW4sIG1ldGEsIGNvbnRyb2xsZXIsIG9wdGlvbnM7XG5cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIC8vIEZpbmQgdGhlIG91dG1vc3QgdmlzaWJsZSBkYXRhc2V0XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICAgICAgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9wdGlvbnMgPSBjb250cm9sbGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3JkZXJBbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG5cbiAgZ2V0TWF4T2Zmc2V0KGFyY3MpIHtcbiAgICBsZXQgbWF4ID0gMDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cblxuICAvKipcblx0ICogR2V0IHJhZGl1cyBsZW5ndGggb2Zmc2V0IG9mIHRoZSBkYXRhc2V0IGluIHJlbGF0aW9uIHRvIHRoZSB2aXNpYmxlIGRhdGFzZXRzIHdlaWdodHMuIFRoaXMgYWxsb3dzIGRldGVybWluaW5nIHRoZSBpbm5lciBhbmQgb3V0ZXIgcmFkaXVzIGNvcnJlY3RseVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJpbmdXZWlnaHRPZmZzZXQoZGF0YXNldEluZGV4KSB7XG4gICAgbGV0IHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICByaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJpbmdXZWlnaHRPZmZzZXQ7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdW0gb2YgYWxsIHZpc2libGUgZGF0YSBzZXQgd2VpZ2h0cy5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7aXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQge19nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzLCBfc2NhbGVSYW5nZXNDaGFuZ2VkfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuZXh0cmFzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmUnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcblxuICAgIHNob3dMaW5lOiB0cnVlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgc2NhbGVzOiB7XG4gICAgICBfaW5kZXhfOiB7XG4gICAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICB9LFxuICAgICAgX3ZhbHVlXzoge1xuICAgICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIH0sXG4gICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG5cbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcblxuICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIExpbmVcbiAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG5cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICB9XG4gICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICBvcHRpb25zXG4gICAgfSwgbW9kZSk7XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgY29uc3QgcG9pbnRzQ291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG5cbiAgICAgIGlmIChpIDwgc3RhcnQgfHwgaSA+PSBlbmQpIHtcbiAgICAgICAgcHJvcGVydGllcy5za2lwID0gdHJ1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG5cbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWRpcmVjdFVwZGF0ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi4vY29yZS9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCB7dG9SYWRpYW5zLCBQSSwgZm9ybWF0TnVtYmVyLCBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuXG4gIHN0YXRpYyBpZCA9ICdwb2xhckFyZWEnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ11cbiAgICAgIH0sXG4gICAgfSxcbiAgICBpbmRleEF4aXM6ICdyJyxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICBhc3BlY3RSYXRpbzogMSxcblxuICAgIHBsdWdpbnM6IHtcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlLCBjb2xvcn19ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IHN0eWxlLmJvcmRlcldpZHRoLFxuICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuXG4gICAgICAgICAgICAgICAgICAvLyBFeHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBjb3JyZWN0IGl0ZW1cbiAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzY2FsZXM6IHtcbiAgICAgIHI6IHtcbiAgICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRBbmdsZTogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG5cbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcblxuICAgIHRoaXMuX3VwZGF0ZVJhZGl1cygpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldE1pbk1heCgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCkucjtcblxuICAgICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChwYXJzZWQgPCByYW5nZS5taW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBwYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VkID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBtaW5TaXplID0gTWF0aC5taW4oY2hhcnRBcmVhLnJpZ2h0IC0gY2hhcnRBcmVhLmxlZnQsIGNoYXJ0QXJlYS5ib3R0b20gLSBjaGFydEFyZWEudG9wKTtcblxuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKG91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuXG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICBjb25zdCBhbmltYXRpb25PcHRzID0gb3B0cy5hbmltYXRpb247XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2NhbGUueENlbnRlcjtcbiAgICBjb25zdCBjZW50ZXJZID0gc2NhbGUueUNlbnRlcjtcbiAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcbiAgICBsZXQgYW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICBsZXQgaTtcblxuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSkucikgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcblxuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVTY2FsZSkge1xuICAgICAgICAgIG91dGVyUmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cblxuICBjb3VudFZpc2libGVFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleClcbiAgICAgID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKVxuICAgICAgOiAwO1xuICB9XG59XG4iLCAiaW1wb3J0IERvdWdobnV0Q29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXIuZG91Z2hudXQuanMnO1xuXG4vLyBQaWUgY2hhcnRzIGFyZSBEb3VnaG51dCBjaGFydCB3aXRoIGRpZmZlcmVudCBkZWZhdWx0c1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3BpZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLy8gVGhlIHBlcmNlbnRhZ2Ugb2YgdGhlIGNoYXJ0IHRoYXQgd2UgY3V0IG91dCBvZiB0aGUgbWlkZGxlLlxuICAgIGN1dG91dDogMCxcblxuICAgIC8vIFRoZSByb3RhdGlvbiBvZiB0aGUgY2hhcnQsIHdoZXJlIHRoZSBmaXJzdCBkYXRhIGFyYyBiZWdpbnMuXG4gICAgcm90YXRpb246IDAsXG5cbiAgICAvLyBUaGUgdG90YWwgY2lyY3VtZmVyZW5jZSBvZiB0aGUgY2hhcnQuXG4gICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuXG4gICAgLy8gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgY2hhcnRcbiAgICByYWRpdXM6ICcxMDAlJ1xuICB9O1xufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG5cbiAgc3RhdGljIGlkID0gJ3JhZGFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgaW5kZXhBeGlzOiAncicsXG4gICAgc2hvd0xpbmU6IHRydWUsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgICAgfVxuICAgIH0sXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgIGFzcGVjdFJhdGlvOiAxLFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICByOiB7XG4gICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IHZTY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuXG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBwb2ludHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG5cbiAgICAvLyBVcGRhdGUgTGluZVxuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIC8vIEluIHJlc2l6ZSBtb2RlIG9ubHkgcG9pbnQgbG9jYXRpb25zIGNoYW5nZSwgc28gbm8gbmVlZCB0byBzZXQgdGhlIHBvaW50cyBvciBvcHRpb25zLlxuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgX2Z1bGxMb29wOiBsYWJlbHMubGVuZ3RoID09PSBwb2ludHMubGVuZ3RoLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcblxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHRoaXMuZ2V0UGFyc2VkKGkpLnIpO1xuXG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcblxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCBEYXRhc2V0Q29udHJvbGxlciBmcm9tICcuLi9jb3JlL2NvcmUuZGF0YXNldENvbnRyb2xsZXIuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIF9zY2FsZVJhbmdlc0NoYW5nZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcblxuICBzdGF0aWMgaWQgPSAnc2NhdHRlcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgc2hvd0xpbmU6IGZhbHNlLFxuICAgIGZpbGw6IGZhbHNlXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuXG4gICAgaW50ZXJhY3Rpb246IHtcbiAgICAgIG1vZGU6ICdwb2ludCdcbiAgICB9LFxuXG4gICAgc2NhbGVzOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB0eXBlOiAnbGluZWFyJ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcblxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlOiAnKCcgKyB4ICsgJywgJyArIHkgKyAnKSdcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YTogcG9pbnRzID0gW119ID0gbWV0YTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcblxuICAgIHRoaXMuX2RyYXdTdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuXG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8xMTMzM1xuICAgICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgX2RhdGFzZXR9ID0gbWV0YTtcblxuICAgICAgLy8gVXBkYXRlIExpbmVcbiAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGxpbmUsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgbW9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzExMzMzXG4gICAgICBkZWxldGUgbWV0YS5kYXRhc2V0O1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgUG9pbnRzXG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cblxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB7c2hvd0xpbmV9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSAmJiBzaG93TGluZSkge1xuICAgICAgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgPSB0aGlzLmNoYXJ0LnJlZ2lzdHJ5LmdldEVsZW1lbnQoJ2xpbmUnKTtcbiAgICB9XG5cbiAgICBzdXBlci5hZGRFbGVtZW50cygpO1xuICB9XG5cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBfc3RhY2tlZCwgX2RhdGFzZXR9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IHtzcGFuR2Fwcywgc2VnbWVudH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbWF4R2FwTGVuZ3RoID0gaXNOdW1iZXIoc3BhbkdhcHMpID8gc3BhbkdhcHMgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcblxuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YSB8fCBbXTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBsZXQgbWF4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcblxuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxufVxuIiwgIi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5fYWRhcHRlcnNcbiAqIEBzaW5jZSAyLjguMFxuICogQHByaXZhdGVcbiAqL1xuXG5pbXBvcnQgdHlwZSB7QW55T2JqZWN0fSBmcm9tICcuLi90eXBlcy9iYXNpYy5qcyc7XG5pbXBvcnQgdHlwZSB7Q2hhcnRPcHRpb25zfSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmV4cG9ydCB0eXBlIFRpbWVVbml0ID0gJ21pbGxpc2Vjb25kJyB8ICdzZWNvbmQnIHwgJ21pbnV0ZScgfCAnaG91cicgfCAnZGF5JyB8ICd3ZWVrJyB8ICdtb250aCcgfCAncXVhcnRlcicgfCAneWVhcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZUFkYXB0ZXI8VCBleHRlbmRzIEFueU9iamVjdCA9IEFueU9iamVjdD4ge1xuICByZWFkb25seSBvcHRpb25zOiBUO1xuICAvKipcbiAgICogV2lsbCBjYWxsZWQgd2l0aCBjaGFydCBvcHRpb25zIGFmdGVyIGFkYXB0ZXIgY3JlYXRpb24uXG4gICAqL1xuICBpbml0KHRoaXM6IERhdGVBZGFwdGVyPFQ+LCBjaGFydE9wdGlvbnM6IENoYXJ0T3B0aW9ucyk6IHZvaWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbWFwIG9mIHRpbWUgZm9ybWF0cyBmb3IgdGhlIHN1cHBvcnRlZCBmb3JtYXR0aW5nIHVuaXRzIGRlZmluZWRcbiAgICogaW4gVW5pdCBhcyB3ZWxsIGFzICdkYXRldGltZScgcmVwcmVzZW50aW5nIGEgZGV0YWlsZWQgZGF0ZS90aW1lIHN0cmluZy5cbiAgICovXG4gIGZvcm1hdHModGhpczogRGF0ZUFkYXB0ZXI8VD4pOiBSZWNvcmQ8VGltZVVuaXQgfCAnZGF0ZXRpbWUnLCBzdHJpbmc+O1xuICAvKipcbiAgICogUGFyc2VzIHRoZSBnaXZlbiBgdmFsdWVgIGFuZCByZXR1cm4gdGhlIGFzc29jaWF0ZWQgdGltZXN0YW1wLlxuICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gcGFyc2UgKHVzdWFsbHkgY29tZXMgZnJvbSB0aGUgZGF0YSlcbiAgICogQHBhcmFtIFtmb3JtYXRdIC0gdGhlIGV4cGVjdGVkIGRhdGEgZm9ybWF0XG4gICAqL1xuICBwYXJzZSh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdmFsdWU6IHVua25vd24sIGZvcm1hdD86IHN0cmluZyk6IG51bWJlciB8IG51bGw7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBpbiB0aGUgc3BlY2lmaWVkIGBmb3JtYXRgIGZvciBhIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIHRpbWVzdGFtcCB0byBmb3JtYXRcbiAgICogQHBhcmFtIGZvcm1hdCAtIHRoZSBkYXRlL3RpbWUgdG9rZW5cbiAgICovXG4gIGZvcm1hdCh0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIGZvcm1hdDogc3RyaW5nKTogc3RyaW5nO1xuICAvKipcbiAgICogQWRkcyB0aGUgc3BlY2lmaWVkIGBhbW91bnRgIG9mIGB1bml0YCB0byB0aGUgZ2l2ZW4gYHRpbWVzdGFtcGAuXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgLSB0aGUgaW5wdXQgdGltZXN0YW1wXG4gICAqIEBwYXJhbSBhbW91bnQgLSB0aGUgYW1vdW50IHRvIGFkZFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgYWRkKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCB0aW1lc3RhbXA6IG51bWJlciwgYW1vdW50OiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0KTogbnVtYmVyO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGB1bml0YCBiZXR3ZWVuIHRoZSBnaXZlbiB0aW1lc3RhbXBzLlxuICAgKiBAcGFyYW0gYSAtIHRoZSBpbnB1dCB0aW1lc3RhbXAgKHJlZmVyZW5jZSlcbiAgICogQHBhcmFtIGIgLSB0aGUgdGltZXN0YW1wIHRvIHN1YnRyYWN0XG4gICAqIEBwYXJhbSB1bml0IC0gdGhlIHVuaXQgYXMgc3RyaW5nXG4gICAqL1xuICBkaWZmKHRoaXM6IERhdGVBZGFwdGVyPFQ+LCBhOiBudW1iZXIsIGI6IG51bWJlciwgdW5pdDogVGltZVVuaXQpOiBudW1iZXI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHN0YXJ0IG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKiBAcGFyYW0gW3dlZWtkYXldIC0gdGhlIElTTyBkYXkgb2YgdGhlIHdlZWsgd2l0aCAxIGJlaW5nIE1vbmRheVxuICAgKiBhbmQgNyBiZWluZyBTdW5kYXkgKG9ubHkgbmVlZGVkIGlmIHBhcmFtICp1bml0KiBpcyBgaXNvV2Vla2ApLlxuICAgKi9cbiAgc3RhcnRPZih0aGlzOiBEYXRlQWRhcHRlcjxUPiwgdGltZXN0YW1wOiBudW1iZXIsIHVuaXQ6IFRpbWVVbml0IHwgJ2lzb1dlZWsnLCB3ZWVrZGF5PzogbnVtYmVyIHwgYm9vbGVhbik6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJldHVybnMgZW5kIG9mIGB1bml0YCBmb3IgdGhlIGdpdmVuIGB0aW1lc3RhbXBgLlxuICAgKiBAcGFyYW0gdGltZXN0YW1wIC0gdGhlIGlucHV0IHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gdW5pdCAtIHRoZSB1bml0IGFzIHN0cmluZ1xuICAgKi9cbiAgZW5kT2YodGhpczogRGF0ZUFkYXB0ZXI8VD4sIHRpbWVzdGFtcDogbnVtYmVyLCB1bml0OiBUaW1lVW5pdCk6IG51bWJlcjtcbn1cblxuZnVuY3Rpb24gYWJzdHJhY3Q8VCA9IHZvaWQ+KCk6IFQge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZDogQ2hlY2sgdGhhdCBhIGNvbXBsZXRlIGRhdGUgYWRhcHRlciBpcyBwcm92aWRlZC4nKTtcbn1cblxuLyoqXG4gKiBEYXRlIGFkYXB0ZXIgKGN1cnJlbnQgdXNlZCBieSB0aGUgdGltZSBzY2FsZSlcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBEYXRlQWRhcHRlckJhc2UgaW1wbGVtZW50cyBEYXRlQWRhcHRlciB7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGRlZmF1bHQgZGF0ZSBhZGFwdGVyIG1ldGhvZHMuXG4gICAqIEFjY2VwdHMgdHlwZSBwYXJhbWV0ZXIgdG8gZGVmaW5lIG9wdGlvbnMgdHlwZS5cbiAgICogQGV4YW1wbGVcbiAgICogQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlPHtteUFkYXB0ZXJPcHRpb246IHN0cmluZ30+KHtcbiAgICogICBpbml0KCkge1xuICAgKiAgICAgY29uc29sZS5sb2codGhpcy5vcHRpb25zLm15QWRhcHRlck9wdGlvbik7XG4gICAqICAgfVxuICAgKiB9KVxuICAgKi9cbiAgc3RhdGljIG92ZXJyaWRlPFQgZXh0ZW5kcyBBbnlPYmplY3QgPSBBbnlPYmplY3Q+KFxuICAgIG1lbWJlcnM6IFBhcnRpYWw8T21pdDxEYXRlQWRhcHRlcjxUPiwgJ29wdGlvbnMnPj5cbiAgKSB7XG4gICAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlckJhc2UucHJvdG90eXBlLCBtZW1iZXJzKTtcbiAgfVxuXG4gIHJlYWRvbmx5IG9wdGlvbnM6IEFueU9iamVjdDtcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzogQW55T2JqZWN0KSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbiAgaW5pdCgpIHt9XG5cbiAgZm9ybWF0cygpOiBSZWNvcmQ8VGltZVVuaXQgfCAnZGF0ZXRpbWUnLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIHBhcnNlKCk6IG51bWJlciB8IG51bGwge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG5cbiAgZm9ybWF0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cblxuICBhZGQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGRpZmYoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIHN0YXJ0T2YoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuXG4gIGVuZE9mKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfZGF0ZTogRGF0ZUFkYXB0ZXJCYXNlIGFzIHtcbiAgICBuZXcgKG9wdGlvbnM/OiBBbnlPYmplY3QpOiBEYXRlQWRhcHRlcjtcbiAgICBvdmVycmlkZTxUIGV4dGVuZHMgQW55T2JqZWN0ID0gQW55T2JqZWN0PihcbiAgICAgIG1lbWJlcnM6IFBhcnRpYWw8T21pdDxEYXRlQWRhcHRlcjxUPiwgJ29wdGlvbnMnPj5cbiAgICApOiB2b2lkO1xuICB9XG59O1xuIiwgImltcG9ydCB7X2xvb2t1cEJ5S2V5LCBfcmxvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5pbXBvcnQge2dldFJlbGF0aXZlUG9zaXRpb259IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHtfYW5nbGVCZXR3ZWVuLCBnZXRBbmdsZUZyb21Qb2ludH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfaXNQb2ludEluQXJlYSwgaXNOdWxsT3JVbmRlZn0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydEV2ZW50IH0gQ2hhcnRFdmVudFxuICogQHR5cGVkZWYge3theGlzPzogc3RyaW5nLCBpbnRlcnNlY3Q/OiBib29sZWFuLCBpbmNsdWRlSW52aXNpYmxlPzogYm9vbGVhbn19IEludGVyYWN0aW9uT3B0aW9uc1xuICogQHR5cGVkZWYge3tkYXRhc2V0SW5kZXg6IG51bWJlciwgaW5kZXg6IG51bWJlciwgZWxlbWVudDogaW1wb3J0KCcuL2NvcmUuZWxlbWVudC5qcycpLmRlZmF1bHR9fSBJbnRlcmFjdGlvbkl0ZW1cbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLlBvaW50IH0gUG9pbnRcbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBkbyBiaW5hcnkgc2VhcmNoIHdoZW4gcG9zc2libGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhc2V0IC0gdGhlIGRhdGFzZXQgbWV0YVxuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyBtb2RlLiB4fHl8eHl8clxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIGZpbmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ludGVyc2VjdF0gLSBzaG91bGQgdGhlIGVsZW1lbnQgaW50ZXJzZWN0XG4gKiBAcmV0dXJucyB7e2xvOm51bWJlciwgaGk6bnVtYmVyfX0gaW5kaWNlcyB0byBzZWFyY2ggZGF0YSBhcnJheSBiZXR3ZWVuXG4gKi9cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChtZXRhc2V0LCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KSB7XG4gIGNvbnN0IHtjb250cm9sbGVyLCBkYXRhLCBfc29ydGVkfSA9IG1ldGFzZXQ7XG4gIGNvbnN0IGlTY2FsZSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGEuaVNjYWxlO1xuICBjb25zdCBzcGFuR2FwcyA9IG1ldGFzZXQuZGF0YXNldCA/IG1ldGFzZXQuZGF0YXNldC5vcHRpb25zID8gbWV0YXNldC5kYXRhc2V0Lm9wdGlvbnMuc3BhbkdhcHMgOiBudWxsIDogbnVsbDtcblxuICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgY29uc3QgbG9va3VwTWV0aG9kID0gaVNjYWxlLl9yZXZlcnNlUGl4ZWxzID8gX3Jsb29rdXBCeUtleSA6IF9sb29rdXBCeUtleTtcbiAgICBpZiAoIWludGVyc2VjdCkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcbiAgICAgIGlmIChzcGFuR2Fwcykge1xuICAgICAgICBjb25zdCB7dlNjYWxlfSA9IGNvbnRyb2xsZXIuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IHtfcGFyc2VkfSA9IG1ldGFzZXQ7XG5cbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRMbyA9IChfcGFyc2VkXG4gICAgICAgICAgLnNsaWNlKDAsIHJlc3VsdC5sbyArIDEpXG4gICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIHJlc3VsdC5sbyAtPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZExvKTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZEhpID0gKF9wYXJzZWRcbiAgICAgICAgICAuc2xpY2UocmVzdWx0LmhpKVxuICAgICAgICAgIC5maW5kSW5kZXgoXG4gICAgICAgICAgICBwb2ludCA9PiAhaXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKSk7XG4gICAgICAgIHJlc3VsdC5oaSArPSBNYXRoLm1heCgwLCBkaXN0YW5jZVRvRGVmaW5lZEhpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICAvLyBfc2hhcmVkT3B0aW9ucyBpbmRpY2F0ZXMgdGhhdCBlYWNoIGVsZW1lbnQgaGFzIGVxdWFsIG9wdGlvbnMgLT4gZXF1YWwgcHJvcG9ydGlvbnNcbiAgICAgIC8vIFNvIHdlIGNhbiBkbyBhIHJhbmdlZCBiaW5hcnkgc2VhcmNoIGJhc2VkIG9uIHRoZSByYW5nZSBvZiBmaXJzdCBlbGVtZW50IGFuZFxuICAgICAgLy8gYmUgY29uZmlkZW50IHRvIGdldCB0aGUgZnVsbCByYW5nZSBvZiBpbmRpY2VzIHRoYXQgY2FuIGludGVyc2VjdCB3aXRoIHRoZSB2YWx1ZS5cbiAgICAgIGNvbnN0IGVsID0gZGF0YVswXTtcbiAgICAgIGNvbnN0IHJhbmdlID0gdHlwZW9mIGVsLmdldFJhbmdlID09PSAnZnVuY3Rpb24nICYmIGVsLmdldFJhbmdlKGF4aXMpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlIC0gcmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XG4gICAgICAgIHJldHVybiB7bG86IHN0YXJ0LmxvLCBoaTogZW5kLmhpfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRGVmYXVsdCB0byBhbGwgZWxlbWVudHMsIHdoZW4gYmluYXJ5IHNlYXJjaCBjYW4gbm90IGJlIHVzZWQuXG4gIHJldHVybiB7bG86IDAsIGhpOiBkYXRhLmxlbmd0aCAtIDF9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzZWxlY3QgY2FuZGlkYXRlIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4aXMgbW9kZS4geHx5fHh5fHJcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gdGhlIGNhbGxiYWNrIHRvIGV4ZWN1dGUgZm9yIGVhY2ggdmlzaWJsZSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gY29uc2lkZXIgaW50ZXJzZWN0aW5nIGl0ZW1zXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCBhIGRpc3RhbmNlIG1ldHJpYyBmdW5jdGlvbiBmb3IgdHdvIHBvaW50cyBiYXNlZCBvbiB0aGVcbiAqIGF4aXMgbW9kZSBzZXR0aW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIHRoYXQgaW50ZXJzZWN0IHRoZSBldmVudCBwb3NpdGlvblxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7UG9pbnR9IHBvc2l0aW9uIC0gdGhlIHBvaW50IHRvIGJlIG5lYXJlc3QgdG8sIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXhpcyAtIHRoZSBheGlzIG1vZGUuIHh8eXx4eXxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG5cbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jLCB0cnVlKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIHJhZGlhbCBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBsZXQgaXRlbXMgPSBbXTtcblxuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlfSA9IGVsZW1lbnQuZ2V0UHJvcHMoWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZX0gPSBnZXRBbmdsZUZyb21Qb2ludChlbGVtZW50LCB7eDogcG9zaXRpb24ueCwgeTogcG9zaXRpb24ueX0pO1xuXG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uIGZvciBhIGNhcnRlc2lhbiBjaGFydFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhlcyBhbG9uZyB3aGljaCB0byBtZWFzdXJlIGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnRlcnNlY3RdIC0gaWYgdHJ1ZSwgb25seSBjb25zaWRlciBpdGVtcyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIHRoZSBlbGVtZW50J3MgYW5pbWF0aW9uIHRhcmdldCBpbnN0ZWFkIG9mIGN1cnJlbnQgcG9zaXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luY2x1ZGVJbnZpc2libGVdIC0gaW5jbHVkZSBpbnZpc2libGUgcG9pbnRzIHRoYXQgYXJlIG91dHNpZGUgb2YgdGhlIGNoYXJ0IGFyZWFcbiAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSB0aGUgbmVhcmVzdCBpdGVtc1xuICovXG5mdW5jdGlvbiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgcG9pbnRJbkFyZWEgPSAhIWluY2x1ZGVJbnZpc2libGUgfHwgY2hhcnQuaXNQb2ludEluQXJlYShjZW50ZXIpO1xuICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcyA9IFt7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH1dO1xuICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlID09PSBtaW5EaXN0YW5jZSkge1xuICAgICAgLy8gQ2FuIGhhdmUgbXVsdGlwbGUgaXRlbXMgYXQgdGhlIHNhbWUgZGlzdGFuY2UgaW4gd2hpY2ggY2FzZSB3ZSBzb3J0IGJ5IHNpemVcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cblxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBpdGVtcyBuZWFyZXN0IHRvIHRoZSBldmVudCBwb3NpdGlvbiBjb25zaWRlcmluZyBhbGwgdmlzaWJsZSBpdGVtcyBpbiB0aGUgY2hhcnRcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIGxvb2sgYXQgZWxlbWVudHMgZnJvbVxuICogQHBhcmFtIHtQb2ludH0gcG9zaXRpb24gLSB0aGUgcG9pbnQgdG8gYmUgbmVhcmVzdCB0bywgaW4gcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBheGlzIC0gdGhlIGF4ZXMgYWxvbmcgd2hpY2ggdG8gbWVhc3VyZSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbmNsdWRlSW52aXNpYmxlXSAtIGluY2x1ZGUgaW52aXNpYmxlIHBvaW50cyB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBjaGFydCBhcmVhXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gYXhpcyA9PT0gJ3InICYmICFpbnRlcnNlY3RcbiAgICA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgOiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGl0ZW1zIG1hdGNoaW5nIGFsb25nIHRoZSBnaXZlbiBYIG9yIFkgYXhpc1xuICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gbG9vayBhdCBlbGVtZW50cyBmcm9tXG4gKiBAcGFyYW0ge1BvaW50fSBwb3NpdGlvbiAtIHRoZSBwb2ludCB0byBiZSBuZWFyZXN0IHRvLCBpbiByZWxhdGl2ZSBjb29yZGluYXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IGF4aXMgLSB0aGUgYXhpcyB0byBtYXRjaFxuICogQHBhcmFtIHtib29sZWFufSBbaW50ZXJzZWN0XSAtIGlmIHRydWUsIG9ubHkgY29uc2lkZXIgaXRlbXMgdGhhdCBpbnRlcnNlY3QgdGhlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSB0aGUgZWxlbWVudCdzIGFuaW1hdGlvbiB0YXJnZXQgaW5zdGVhZCBvZiBjdXJyZW50IHBvc2l0aW9uXG4gKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gdGhlIG5lYXJlc3QgaXRlbXNcbiAqL1xuZnVuY3Rpb24gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHJhbmdlTWV0aG9kID0gYXhpcyA9PT0gJ3gnID8gJ2luWFJhbmdlJyA6ICdpbllSYW5nZSc7XG4gIGxldCBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuXG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIChlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSA9PiB7XG4gICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdICYmIGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9KTtcblxuICAvLyBJZiB3ZSB3YW50IHRvIHRyaWdnZXIgb24gYW4gaW50ZXJzZWN0IGFuZCB3ZSBkb24ndCBoYXZlIGFueSBpdGVtc1xuICAvLyB0aGF0IGludGVyc2VjdCB0aGUgcG9zaXRpb24sIHJldHVybiBub3RoaW5nXG4gIGlmIChpbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuLyoqXG4gKiBDb250YWlucyBpbnRlcmFjdGlvbiByZWxhdGVkIGZ1bmN0aW9uc1xuICogQG5hbWVzcGFjZSBDaGFydC5JbnRlcmFjdGlvblxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIFBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgdG8gZmFjaWxpdGF0ZSBkZXZlbG9wZXJzIGNyZWF0aW5nIHRoZWlyIG93biBtb2Rlc1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMsXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciBkaWZmZXJlbnQgbW9kZXNcbiAgbW9kZXM6IHtcbiAgICAvKipcblx0XHQgKiBSZXR1cm5zIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4LiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgcGFyYW1ldGVyIGlzIHRydWUsIHdlIG9ubHkgcmV0dXJuIGl0ZW1zIGlmIHdlIGludGVyc2VjdCBzb21ldGhpbmdcblx0XHQgKiBJZiB0aGUgb3B0aW9ucy5pbnRlcnNlY3QgbW9kZSBpcyBmYWxzZSwgd2UgZmluZCB0aGUgbmVhcmVzdCBpdGVtIGFuZCByZXR1cm4gdGhlIGl0ZW1zIGF0IHRoZSBzYW1lIGluZGV4IGFzIHRoYXQgaXRlbVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbmRleFxuXHRcdCAqIEBzaW5jZSB2Mi40LjBcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgaW5kZXgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICAvLyBEZWZhdWx0IGF4aXMgZm9yIGluZGV4IG1vZGUgaXMgJ3gnIHRvIG1hdGNoIG9sZCBiZWhhdmlvdXJcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gbWV0YS5kYXRhW2luZGV4XTtcblxuICAgICAgICAvLyBkb24ndCBjb3VudCBpdGVtcyB0aGF0IGFyZSBza2lwcGVkIChudWxsIGRhdGEpXG4gICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXgsIGluZGV4fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIFJldHVybnMgaXRlbXMgaW4gdGhlIHNhbWUgZGF0YXNldC4gSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IHBhcmFtZXRlciBpcyB0cnVlLCB3ZSBvbmx5IHJldHVybiBpdGVtcyBpZiB3ZSBpbnRlcnNlY3Qgc29tZXRoaW5nXG5cdFx0ICogSWYgdGhlIG9wdGlvbnMuaW50ZXJzZWN0IGlzIGZhbHNlLCB3ZSBmaW5kIHRoZSBuZWFyZXN0IGl0ZW0gYW5kIHJldHVybiB0aGUgaXRlbXMgaW4gdGhhdCBkYXRhc2V0XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmRhdGFzZXRcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgZGF0YXNldChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IGl0ZW1zWzBdLmRhdGFzZXRJbmRleDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuZGF0YTtcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudDogZGF0YVtpXSwgZGF0YXNldEluZGV4LCBpbmRleDogaX0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuXG4gICAgLyoqXG5cdFx0ICogUG9pbnQgbW9kZSByZXR1cm5zIGFsbCBlbGVtZW50cyB0aGF0IGhpdCB0ZXN0IGJhc2VkIG9uIHRoZSBldmVudCBwb3NpdGlvblxuXHRcdCAqIG9mIHRoZSBldmVudFxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy5pbnRlcnNlY3Rcblx0XHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIHRoZSBjaGFydCB3ZSBhcmUgcmV0dXJuaW5nIGl0ZW1zIGZyb21cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBlIC0gdGhlIGV2ZW50IHdlIGFyZSBmaW5kIHRoaW5ncyBhdFxuXHRcdCAqIEBwYXJhbSB7SW50ZXJhY3Rpb25PcHRpb25zfSBvcHRpb25zIC0gb3B0aW9ucyB0byB1c2Vcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXSAtIHVzZSBmaW5hbCBlbGVtZW50IHBvc2l0aW9uIChhbmltYXRpb24gdGFyZ2V0KVxuXHRcdCAqIEByZXR1cm4ge0ludGVyYWN0aW9uSXRlbVtdfSAtIGl0ZW1zIHRoYXQgYXJlIGZvdW5kXG5cdFx0ICovXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIG5lYXJlc3QgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50IGNsb3Nlc3QgdG8gdGhlIHBvaW50XG5cdFx0ICogQGZ1bmN0aW9uIENoYXJ0LkludGVyYWN0aW9uLm1vZGVzLmludGVyc2VjdFxuXHRcdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHdlIGFyZSByZXR1cm5pbmcgaXRlbXMgZnJvbVxuXHRcdCAqIEBwYXJhbSB7RXZlbnR9IGUgLSB0aGUgZXZlbnQgd2UgYXJlIGZpbmQgdGhpbmdzIGF0XG5cdFx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBvcHRpb25zIHRvIHVzZVxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZUZpbmFsUG9zaXRpb25dIC0gdXNlIGZpbmFsIGVsZW1lbnQgcG9zaXRpb24gKGFuaW1hdGlvbiB0YXJnZXQpXG5cdFx0ICogQHJldHVybiB7SW50ZXJhY3Rpb25JdGVtW119IC0gaXRlbXMgdGhhdCBhcmUgZm91bmRcblx0XHQgKi9cbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHggbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHggY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy54XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHgoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3gnLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuXHRcdCAqIHkgbW9kZSByZXR1cm5zIHRoZSBlbGVtZW50cyB0aGF0IGhpdC10ZXN0IGF0IHRoZSBjdXJyZW50IHkgY29vcmRpbmF0ZVxuXHRcdCAqIEBmdW5jdGlvbiBDaGFydC5JbnRlcmFjdGlvbi5tb2Rlcy55XG5cdFx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgd2UgYXJlIHJldHVybmluZyBpdGVtcyBmcm9tXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZSAtIHRoZSBldmVudCB3ZSBhcmUgZmluZCB0aGluZ3MgYXRcblx0XHQgKiBAcGFyYW0ge0ludGVyYWN0aW9uT3B0aW9uc30gb3B0aW9ucyAtIG9wdGlvbnMgdG8gdXNlXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbdXNlRmluYWxQb3NpdGlvbl0gLSB1c2UgZmluYWwgZWxlbWVudCBwb3NpdGlvbiAoYW5pbWF0aW9uIHRhcmdldClcblx0XHQgKiBAcmV0dXJuIHtJbnRlcmFjdGlvbkl0ZW1bXX0gLSBpdGVtcyB0aGF0IGFyZSBmb3VuZFxuXHRcdCAqL1xuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3knLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG59O1xuIiwgImltcG9ydCB7ZGVmaW5lZCwgZWFjaCwgaXNPYmplY3R9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7dG9QYWRkaW5nfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuY29uc3QgU1RBVElDX1BPU0lUSU9OUyA9IFsnbGVmdCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJ107XG5cbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnBvcyA9PT0gcG9zaXRpb24pO1xufVxuXG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcbiAgcmV0dXJuIGFycmF5LnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB2MCA9IHJldmVyc2UgPyBiIDogYTtcbiAgICBjb25zdCB2MSA9IHJldmVyc2UgPyBhIDogYjtcbiAgICByZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgP1xuICAgICAgdjAuaW5kZXggLSB2MS5pbmRleCA6XG4gICAgICB2MC53ZWlnaHQgLSB2MS53ZWlnaHQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwQm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGJveCwgcG9zLCBzdGFjaywgc3RhY2tXZWlnaHQ7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cblxuZnVuY3Rpb24gYnVpbGRTdGFja3MobGF5b3V0cykge1xuICBjb25zdCBzdGFja3MgPSB7fTtcbiAgZm9yIChjb25zdCB3cmFwIG9mIGxheW91dHMpIHtcbiAgICBjb25zdCB7c3RhY2ssIHBvcywgc3RhY2tXZWlnaHR9ID0gd3JhcDtcbiAgICBpZiAoIXN0YWNrIHx8ICFTVEFUSUNfUE9TSVRJT05TLmluY2x1ZGVzKHBvcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBfc3RhY2sgPSBzdGFja3Nbc3RhY2tdIHx8IChzdGFja3Nbc3RhY2tdID0ge2NvdW50OiAwLCBwbGFjZWQ6IDAsIHdlaWdodDogMCwgc2l6ZTogMH0pO1xuICAgIF9zdGFjay5jb3VudCsrO1xuICAgIF9zdGFjay53ZWlnaHQgKz0gc3RhY2tXZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cblxuLyoqXG4gKiBzdG9yZSBkaW1lbnNpb25zIHVzZWQgaW5zdGVhZCBvZiBhdmFpbGFibGUgY2hhcnRBcmVhIGluIGZpdEJveGVzXG4gKiovXG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuXG5mdW5jdGlvbiBidWlsZExheW91dEJveGVzKGJveGVzKSB7XG4gIGNvbnN0IGxheW91dEJveGVzID0gd3JhcEJveGVzKGJveGVzKTtcbiAgY29uc3QgZnVsbFNpemUgPSBzb3J0QnlXZWlnaHQobGF5b3V0Qm94ZXMuZmlsdGVyKHdyYXAgPT4gd3JhcC5ib3guZnVsbFNpemUpLCB0cnVlKTtcbiAgY29uc3QgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcbiAgY29uc3QgcmlnaHQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3JpZ2h0JykpO1xuICBjb25zdCB0b3AgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ3RvcCcpLCB0cnVlKTtcbiAgY29uc3QgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG4gIGNvbnN0IGNlbnRlckhvcml6b250YWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd4Jyk7XG4gIGNvbnN0IGNlbnRlclZlcnRpY2FsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneScpO1xuXG4gIHJldHVybiB7XG4gICAgZnVsbFNpemUsXG4gICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcbiAgICByaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGNlbnRlclZlcnRpY2FsKS5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbCksXG4gICAgY2hhcnRBcmVhOiBmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnY2hhcnRBcmVhJyksXG4gICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxuICAgIGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3hQYWRkaW5nKSB7XG4gIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcbiAgbWF4UGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5sZWZ0LCBib3hQYWRkaW5nLmxlZnQpO1xuICBtYXhQYWRkaW5nLmJvdHRvbSA9IE1hdGgubWF4KG1heFBhZGRpbmcuYm90dG9tLCBib3hQYWRkaW5nLmJvdHRvbSk7XG4gIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpIHtcbiAgY29uc3Qge3BvcywgYm94fSA9IGxheW91dDtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuXG4gIC8vIGR5bmFtaWNhbGx5IHBsYWNlZCBib3hlcyBzaXplIGlzIG5vdCBjb25zaWRlcmVkXG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgLy8gdGhpcyBsYXlvdXQgd2FzIGFscmVhZHkgY291bnRlZCBmb3IsIGxldHMgZmlyc3QgcmVkdWNlIG9sZCBzaXplXG4gICAgICBjaGFydEFyZWFbcG9zXSAtPSBsYXlvdXQuc2l6ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7c2l6ZTogMCwgY291bnQ6IDF9O1xuICAgIHN0YWNrLnNpemUgPSBNYXRoLm1heChzdGFjay5zaXplLCBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGgpO1xuICAgIGxheW91dC5zaXplID0gc3RhY2suc2l6ZSAvIHN0YWNrLmNvdW50O1xuICAgIGNoYXJ0QXJlYVtwb3NdICs9IGxheW91dC5zaXplO1xuICB9XG5cbiAgaWYgKGJveC5nZXRQYWRkaW5nKSB7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3guZ2V0UGFkZGluZygpKTtcbiAgfVxuXG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcblxuICAvLyByZXR1cm4gYm9vbGVhbnMgb24gdGhlIGNoYW5nZXMgcGVyIGRpcmVjdGlvblxuICByZXR1cm4gbGF5b3V0Lmhvcml6b250YWxcbiAgICA/IHtzYW1lOiB3aWR0aENoYW5nZWQsIG90aGVyOiBoZWlnaHRDaGFuZ2VkfVxuICAgIDoge3NhbWU6IGhlaWdodENoYW5nZWQsIG90aGVyOiB3aWR0aENoYW5nZWR9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuXG5mdW5jdGlvbiBnZXRNYXJnaW5zKGhvcml6b250YWwsIGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG5cbiAgZnVuY3Rpb24gbWFyZ2luRm9yUG9zaXRpb25zKHBvc2l0aW9ucykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcbiAgICAgIG1hcmdpbltwb3NdID0gTWF0aC5tYXgoY2hhcnRBcmVhW3Bvc10sIG1heFBhZGRpbmdbcG9zXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmdpbjtcbiAgfVxuXG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuXG5mdW5jdGlvbiBmaXRCb3hlcyhib3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykge1xuICBjb25zdCByZWZpdEJveGVzID0gW107XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQsIGJveCwgcmVmaXQsIGNoYW5nZWQ7XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aCwgcmVmaXQgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gYm94ZXNbaV07XG4gICAgYm94ID0gbGF5b3V0LmJveDtcblxuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcblxuICAgIC8vIERpbWVuc2lvbnMgY2hhbmdlZCBhbmQgdGhlcmUgd2VyZSBub24gZnVsbCB3aWR0aCBib3hlcyBiZWZvcmUgdGhpc1xuICAgIC8vIC0+IHdlIGhhdmUgdG8gcmVmaXQgdGhvc2VcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuXG4gICAgLy8gQ2hhcnQgYXJlYSBjaGFuZ2VkIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBvdGhlcjtcblxuICAgIGlmICghYm94LmZ1bGxTaXplKSB7IC8vIGZ1bGxTaXplIGJveGVzIGRvbid0IG5lZWQgdG8gYmUgcmUtZml0dGVkIGluIGFueSBjYXNlXG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVmaXQgJiYgZml0Qm94ZXMocmVmaXRCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykgfHwgY2hhbmdlZDtcbn1cblxuZnVuY3Rpb24gc2V0Qm94RGltcyhib3gsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICBib3gudG9wID0gdG9wO1xuICBib3gubGVmdCA9IGxlZnQ7XG4gIGJveC5yaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgYm94LndpZHRoID0gd2lkdGg7XG4gIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcblxuICBmb3IgKGNvbnN0IGxheW91dCBvZiBib3hlcykge1xuICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXSB8fCB7Y291bnQ6IDEsIHBsYWNlZDogMCwgd2VpZ2h0OiAxfTtcbiAgICBjb25zdCB3ZWlnaHQgPSAobGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0KSB8fCAxO1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBjaGFydEFyZWEudyAqIHdlaWdodDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHN0YWNrLnNpemUgfHwgYm94LmhlaWdodDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB5ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB1c2VyUGFkZGluZy5sZWZ0LCB5LCBwYXJhbXMub3V0ZXJXaWR0aCAtIHVzZXJQYWRkaW5nLnJpZ2h0IC0gdXNlclBhZGRpbmcubGVmdCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHk7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XG4gICAgICB5ID0gYm94LmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gY2hhcnRBcmVhLmggKiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3aWR0aCA9IHN0YWNrLnNpemUgfHwgYm94LndpZHRoO1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHggPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIHVzZXJQYWRkaW5nLnRvcCwgd2lkdGgsIHBhcmFtcy5vdXRlckhlaWdodCAtIHVzZXJQYWRkaW5nLmJvdHRvbSAtIHVzZXJQYWRkaW5nLnRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgY2hhcnRBcmVhLnRvcCArIHN0YWNrLnBsYWNlZCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgICBzdGFjay5zdGFydCA9IHg7XG4gICAgICBzdGFjay5wbGFjZWQgKz0gaGVpZ2h0O1xuICAgICAgeCA9IGJveC5yaWdodDtcbiAgICB9XG4gIH1cblxuICBjaGFydEFyZWEueCA9IHg7XG4gIGNoYXJ0QXJlYS55ID0geTtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIExheW91dEl0ZW1cbiAqIEB0eXBlZGVmIHtvYmplY3R9IExheW91dEl0ZW1cbiAqIEBwcm9wIHtzdHJpbmd9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIGluIHRoZSBjaGFydCBsYXlvdXQuIFBvc3NpYmxlIHZhbHVlcyBhcmVcbiAqICdsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCBhbmQgJ2NoYXJ0QXJlYSdcbiAqIEBwcm9wIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB3ZWlnaHQgdXNlZCB0byBzb3J0IHRoZSBpdGVtLiBIaWdoZXIgd2VpZ2h0cyBhcmUgZnVydGhlciBhd2F5IGZyb20gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwcm9wIHtib29sZWFufSBmdWxsU2l6ZSAtIGlmIHRydWUsIGFuZCB0aGUgaXRlbSBpcyBob3Jpem9udGFsLCB0aGVuIHB1c2ggdmVydGljYWwgYm94ZXMgZG93blxuICogQHByb3Age2Z1bmN0aW9ufSBpc0hvcml6b250YWwgLSByZXR1cm5zIHRydWUgaWYgdGhlIGxheW91dCBpdGVtIGlzIGhvcml6b250YWwgKGllLiB0b3Agb3IgYm90dG9tKVxuICogQHByb3Age2Z1bmN0aW9ufSB1cGRhdGUgLSBUYWtlcyB0d28gcGFyYW1ldGVyczogd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBzaXplIG9mIGl0ZW1cbiAqIEBwcm9wIHtmdW5jdGlvbn0gZHJhdyAtIERyYXdzIHRoZSBlbGVtZW50XG4gKiBAcHJvcCB7ZnVuY3Rpb259IFtnZXRQYWRkaW5nXSAtICBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHBhZGRpbmcgb24gdGhlIGVkZ2VzXG4gKiBAcHJvcCB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIGl0ZW0uIE11c3QgYmUgdmFsaWQgYWZ0ZXIgdXBkYXRlKClcbiAqIEBwcm9wIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiBpdGVtLiBNdXN0IGJlIHZhbGlkIGFmdGVyIHVwZGF0ZSgpXG4gKiBAcHJvcCB7bnVtYmVyfSBsZWZ0IC0gTGVmdCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSB0b3AgLSBUb3AgZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICogQHByb3Age251bWJlcn0gcmlnaHQgLSBSaWdodCBlZGdlIG9mIHRoZSBpdGVtLiBTZXQgYnkgbGF5b3V0IHN5c3RlbSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gdXBkYXRlXG4gKiBAcHJvcCB7bnVtYmVyfSBib3R0b20gLSBCb3R0b20gZWRnZSBvZiB0aGUgaXRlbS4gU2V0IGJ5IGxheW91dCBzeXN0ZW0gYW5kIGNhbm5vdCBiZSB1c2VkIGluIHVwZGF0ZVxuICovXG5cbi8vIFRoZSBsYXlvdXQgc2VydmljZSBpcyB2ZXJ5IHNlbGYgZXhwbGFuYXRvcnkuICBJdCdzIHJlc3BvbnNpYmxlIGZvciB0aGUgbGF5b3V0IHdpdGhpbiBhIGNoYXJ0LlxuLy8gU2NhbGVzLCBMZWdlbmRzIGFuZCBQbHVnaW5zIGFsbCByZWx5IG9uIHRoZSBsYXlvdXQgc2VydmljZSBhbmQgY2FuIGVhc2lseSByZWdpc3RlciB0byBiZSBwbGFjZWQgYW55d2hlcmUgdGhleSBuZWVkXG4vLyBJdCBpcyB0aGlzIHNlcnZpY2UncyByZXNwb25zaWJpbGl0eSBvZiBjYXJyeWluZyBvdXQgdGhhdCBsYXlvdXQuXG5leHBvcnQgZGVmYXVsdCB7XG5cbiAgLyoqXG5cdCAqIFJlZ2lzdGVyIGEgYm94IHRvIGEgY2hhcnQuXG5cdCAqIEEgYm94IGlzIHNpbXBseSBhIHJlZmVyZW5jZSB0byBhbiBvYmplY3QgdGhhdCByZXF1aXJlcyBsYXlvdXQuIGVnLiBTY2FsZXMsIExlZ2VuZCwgVGl0bGUuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IHRvIHVzZVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBhZGQgdG8gYmUgbGFpZCBvdXRcblx0ICovXG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBpdGVtIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICBpdGVtLmZ1bGxTaXplID0gaXRlbS5mdWxsU2l6ZSB8fCBmYWxzZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcbiAgICBpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGl0ZW0uX2xheWVycyA9IGl0ZW0uX2xheWVycyB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbe1xuICAgICAgICB6OiAwLFxuICAgICAgICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgICAgICAgIGl0ZW0uZHJhdyhjaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICB9XTtcbiAgICB9O1xuXG4gICAgY2hhcnQuYm94ZXMucHVzaChpdGVtKTtcbiAgfSxcblxuICAvKipcblx0ICogUmVtb3ZlIGEgbGF5b3V0SXRlbSBmcm9tIGEgY2hhcnRcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnQgdG8gcmVtb3ZlIHRoZSBib3ggZnJvbVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGxheW91dEl0ZW0gLSB0aGUgaXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGF5b3V0XG5cdCAqL1xuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuXHQgKiBTZXRzIChvciB1cGRhdGVzKSBvcHRpb25zIG9uIHRoZSBnaXZlbiBgaXRlbWAuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gdGhlIGNoYXJ0IGluIHdoaWNoIHRoZSBpdGVtIGxpdmVzIChvciB3aWxsIGJlIGFkZGVkIHRvKVxuXHQgKiBAcGFyYW0ge0xheW91dEl0ZW19IGl0ZW0gLSB0aGUgaXRlbSB0byBjb25maWd1cmUgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9uc1xuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIHRoZSBuZXcgaXRlbSBvcHRpb25zLlxuXHQgKi9cbiAgY29uZmlndXJlKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgaXRlbS5mdWxsU2l6ZSA9IG9wdGlvbnMuZnVsbFNpemU7XG4gICAgaXRlbS5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgaXRlbS53ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgfSxcblxuICAvKipcblx0ICogRml0cyBib3hlcyBvZiB0aGUgZ2l2ZW4gY2hhcnQgaW50byB0aGUgZ2l2ZW4gc2l6ZSBieSBoYXZpbmcgZWFjaCBib3ggbWVhc3VyZSBpdHNlbGZcblx0ICogdGhlbiBydW5uaW5nIGEgZml0dGluZyBhbGdvcml0aG1cblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnQgLSB0aGUgY2hhcnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIHRvIGZpdCBpbnRvXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IHRvIGZpdCBpbnRvXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5QYWRkaW5nIC0gbWluaW11bSBwYWRkaW5nIHJlcXVpcmVkIGZvciBlYWNoIHNpZGUgb2YgY2hhcnQgYXJlYVxuXHQgKi9cbiAgdXBkYXRlKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0LCBtaW5QYWRkaW5nKSB7XG4gICAgaWYgKCFjaGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuXG4gICAgLy8gQmVmb3JlIGFueSBjaGFuZ2VzIGFyZSBtYWRlLCBub3RpZnkgYm94ZXMgdGhhdCBhbiB1cGRhdGUgaXMgYWJvdXQgdG8gYmVpbmdcbiAgICAvLyBUaGlzIGlzIHVzZWQgdG8gY2xlYXIgYW55IGNhY2hlZCBkYXRhIChlLmcuIHNjYWxlIGxpbWl0cylcbiAgICBlYWNoKGNoYXJ0LmJveGVzLCBib3ggPT4ge1xuICAgICAgaWYgKHR5cGVvZiBib3guYmVmb3JlTGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGJveC5iZWZvcmVMYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEVzc2VudGlhbGx5IHdlIG5vdyBoYXZlIGFueSBudW1iZXIgb2YgYm94ZXMgb24gZWFjaCBvZiB0aGUgNCBzaWRlcy5cbiAgICAvLyBPdXIgY2FudmFzIGxvb2tzIGxpa2UgdGhlIGZvbGxvd2luZy5cbiAgICAvLyBUaGUgYXJlYXMgTDEgYW5kIEwyIGFyZSB0aGUgbGVmdCBheGVzLiBSMSBpcyB0aGUgcmlnaHQgYXhpcywgVDEgaXMgdGhlIHRvcCBheGlzIGFuZFxuICAgIC8vIEIxIGlzIHRoZSBib3R0b20gYXhpc1xuICAgIC8vIFRoZXJlIGFyZSBhbHNvIDQgcXVhZHJhbnQtbGlrZSBsb2NhdGlvbnMgKGxlZnQgdG8gcmlnaHQgaW5zdGVhZCBvZiBjbG9ja3dpc2UpIHJlc2VydmVkIGZvciBjaGFydCBvdmVybGF5c1xuICAgIC8vIFRoZXNlIGxvY2F0aW9ucyBhcmUgc2luZ2xlLWJveCBsb2NhdGlvbnMgb25seSwgd2hlbiB0cnlpbmcgdG8gcmVnaXN0ZXIgYSBjaGFydEFyZWEgbG9jYXRpb24gdGhhdCBpcyBhbHJlYWR5IHRha2VuLFxuICAgIC8vIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgIC8vXG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgIFQxIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIFQyICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgQzEgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzIgfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCBMMSB8IEwyIHwgICAgICAgICAgIENoYXJ0QXJlYSAoQzApICAgICAgICAgICAgfCBSMSB8XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwtLS0tfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tfCAgICB8XG4gICAgLy8gfCAgICB8ICAgIHwgQzMgfCAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgQzQgfCAgICB8XG4gICAgLy8gfCAgICB8LS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS18XG4gICAgLy8gfCAgICB8ICAgIHwgICAgICAgICAgICAgICAgIEIxICAgICAgICAgICAgICAgICAgfCAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgIEIyIChGdWxsIFdpZHRoKSAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgLy9cblxuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgIHBhZGRpbmcsXG4gICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgfSk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIHBhZGRpbmcpO1xuICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIG1heFBhZGRpbmcsXG4gICAgICB3OiBhdmFpbGFibGVXaWR0aCxcbiAgICAgIGg6IGF2YWlsYWJsZUhlaWdodCxcbiAgICAgIHg6IHBhZGRpbmcubGVmdCxcbiAgICAgIHk6IHBhZGRpbmcudG9wXG4gICAgfSwgcGFkZGluZyk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XG5cbiAgICAvLyBGaXJzdCBmaXQgdGhlIGZ1bGxTaXplIGJveGVzLCB0byByZWR1Y2UgcHJvYmFiaWxpdHkgb2YgcmUtZml0dGluZy5cbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG5cbiAgICAvLyBUaGVuIGZpdCB2ZXJ0aWNhbCBib3hlc1xuICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gVGhlbiBmaXQgaG9yaXpvbnRhbCBib3hlc1xuICAgIGlmIChmaXRCb3hlcyhob3Jpem9udGFsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpKSB7XG4gICAgICAvLyBpZiB0aGUgYXJlYSBjaGFuZ2VkLCByZS1maXQgdmVydGljYWwgYm94ZXNcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cblxuICAgIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKTtcblxuICAgIC8vIEZpbmFsbHkgcGxhY2UgdGhlIGJveGVzIHRvIGNvcnJlY3QgY29vcmRpbmF0ZXNcbiAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuXG4gICAgLy8gTW92ZSB0byBvcHBvc2l0ZSBzaWRlIG9mIGNoYXJ0XG4gICAgY2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XG4gICAgY2hhcnRBcmVhLnkgKz0gY2hhcnRBcmVhLmg7XG5cbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcblxuICAgIGNoYXJ0LmNoYXJ0QXJlYSA9IHtcbiAgICAgIGxlZnQ6IGNoYXJ0QXJlYS5sZWZ0LFxuICAgICAgdG9wOiBjaGFydEFyZWEudG9wLFxuICAgICAgcmlnaHQ6IGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLncsXG4gICAgICBib3R0b206IGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuaCxcbiAgICAgIGhlaWdodDogY2hhcnRBcmVhLmgsXG4gICAgICB3aWR0aDogY2hhcnRBcmVhLncsXG4gICAgfTtcblxuICAgIC8vIEZpbmFsbHkgdXBkYXRlIGJveGVzIGluIGNoYXJ0QXJlYSAocmFkaWFsIHNjYWxlIGZvciBleGFtcGxlKVxuICAgIGVhY2goYm94ZXMuY2hhcnRBcmVhLCAobGF5b3V0KSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgICAgT2JqZWN0LmFzc2lnbihib3gsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICBib3gudXBkYXRlKGNoYXJ0QXJlYS53LCBjaGFydEFyZWEuaCwge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwgIlxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqL1xuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgYWxsb3dzIGFic3RyYWN0aW5nIHBsYXRmb3JtIGRlcGVuZGVuY2llcyBhd2F5IGZyb20gdGhlIGNoYXJ0LlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlUGxhdGZvcm0ge1xuICAvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGNvbnN0cnVjdGlvbiB0aW1lLCByZXR1cm5zIGEgY29udGV4dDJkIGluc3RhbmNlIGltcGxlbWVudGluZ1xuXHQgKiB0aGUgW1czQyBDYW52YXMgMkQgQ29udGV4dCBBUEkgc3RhbmRhcmRde0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvfS5cblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gVGhlIGNhbnZhcyBmcm9tIHdoaWNoIHRvIGFjcXVpcmUgY29udGV4dCAocGxhdGZvcm0gc3BlY2lmaWMpXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gVGhlIGNoYXJ0IG9wdGlvbnNcblx0ICovXG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogQ2FsbGVkIGF0IGNoYXJ0IGRlc3RydWN0aW9uIHRpbWUsIHJlbGVhc2VzIGFueSByZXNvdXJjZXMgYXNzb2NpYXRlZCB0byB0aGUgY29udGV4dFxuXHQgKiBwcmV2aW91c2x5IHJldHVybmVkIGJ5IHRoZSBhY3F1aXJlQ29udGV4dCgpIG1ldGhvZC5cblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHQgLSBUaGUgY29udGV4dDJkIGluc3RhbmNlXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBtZXRob2Qgc3VjY2VlZGVkLCBlbHNlIGZhbHNlXG5cdCAqL1xuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcblx0ICogUmVnaXN0ZXJzIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIgb24gdGhlIGdpdmVuIGNoYXJ0LlxuXHQgKiBAcGFyYW0ge0NoYXJ0fSBjaGFydCAtIENoYXJ0IGZyb20gd2hpY2ggdG8gbGlzdGVuIGZvciBldmVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSAoe0BsaW5rIENoYXJ0RXZlbnR9KSB0eXBlIHRvIGxpc3RlbiBmb3Jcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgLSBSZWNlaXZlcyBhIG5vdGlmaWNhdGlvbiAoYW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50c1xuXHQgKiB0aGUge0BsaW5rIENoYXJ0RXZlbnR9IGludGVyZmFjZSkgd2hlbiBhbiBldmVudCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgb2NjdXJzLlxuXHQgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKipcblx0ICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGxpc3RlbmVyIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCB3aXRoIGFkZEV2ZW50TGlzdGVuZXIuXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gQ2hhcnQgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGxpc3RlbmVyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlICh7QGxpbmsgQ2hhcnRFdmVudH0pIHR5cGUgdG8gcmVtb3ZlXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudCB0YXJnZXQuXG5cdCAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgY3VycmVudCBkZXZpY2VQaXhlbFJhdGlvIG9mIHRoZSBkZXZpY2UgdGhpcyBwbGF0Zm9ybSBpcyBjb25uZWN0ZWQgdG8uXG5cdCAqL1xuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gc2l6ZSBpbiBwaXhlbHMgb2YgZ2l2ZW4gY2FudmFzIGVsZW1lbnQuXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGVsZW1lbnRcblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF0gLSBjb250ZW50IHdpZHRoIG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0XSAtIGNvbnRlbnQgaGVpZ2h0IG9mIHBhcmVudCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dIC0gYXNwZWN0IHJhdGlvIHRvIG1haW50YWluXG5cdCAqL1xuICBnZXRNYXhpbXVtU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggfHwgZWxlbWVudC53aWR0aCk7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0KVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBjYW52YXMgaXMgYXR0YWNoZWQgdG8gdGhlIHBsYXRmb3JtLCBmYWxzZSBpZiBub3QuXG5cdCAqL1xuICBpc0F0dGFjaGVkKGNhbnZhcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBjb25maWcgd2l0aCBwbGF0Zm9ybSBzcGVjaWZpYyByZXF1aXJlbWVudHNcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uL2NvcmUvY29yZS5jb25maWcuanMnKS5kZWZhdWx0fSBjb25maWdcbiAgICovXG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIC8vIG5vLW9wXG4gIH1cbn1cbiIsICIvKipcbiAqIFBsYXRmb3JtIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIChtaW5pbWFsKS5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTkxI2lzc3VlY29tbWVudC0zMTk1NzU5MzlcbiAqL1xuXG5pbXBvcnQgQmFzZVBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm0uYmFzZS5qcyc7XG5cbi8qKlxuICogUGxhdGZvcm0gY2xhc3MgZm9yIGNoYXJ0cyB3aXRob3V0IGFjY2VzcyB0byB0aGUgRE9NIG9yIHRvIG1hbnkgZWxlbWVudCBwcm9wZXJ0aWVzXG4gKiBUaGlzIHBsYXRmb3JtIGlzIHVzZWQgYnkgZGVmYXVsdCBmb3IgYW55IGNoYXJ0IHBhc3NlZCBhbiBPZmZzY3JlZW5DYW52YXMuXG4gKiBAZXh0ZW5kcyBCYXNlUGxhdGZvcm1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG4gICAgLy8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cbn1cbiIsICIvKipcbiAqIENoYXJ0LlBsYXRmb3JtIGltcGxlbWVudGF0aW9uIGZvciB0YXJnZXRpbmcgYSB3ZWIgYnJvd3NlclxuICovXG5cbmltcG9ydCBCYXNlUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNlLmpzJztcbmltcG9ydCB7X2dldFBhcmVudE5vZGUsIGdldFJlbGF0aXZlUG9zaXRpb24sIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsIHJlYWRVc2VkU2l6ZSwgZ2V0TWF4aW11bVNpemV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5kb20uanMnO1xuaW1wb3J0IHt0aHJvdHRsZWR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL2NvcmUvY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKi9cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuXG4vKipcbiAqIERPTSBldmVudCB0eXBlcyAtPiBDaGFydC5qcyBldmVudCB0eXBlcy5cbiAqIE5vdGU6IG9ubHkgZXZlbnRzIHdpdGggZGlmZmVyZW50IHR5cGVzIGFyZSBtYXBwZWQuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50c1xuICovXG5jb25zdCBFVkVOVF9UWVBFUyA9IHtcbiAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gIHRvdWNobW92ZTogJ21vdXNlbW92ZScsXG4gIHRvdWNoZW5kOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICBwb2ludGVyZG93bjogJ21vdXNlZG93bicsXG4gIHBvaW50ZXJtb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gIHBvaW50ZXJsZWF2ZTogJ21vdXNlb3V0JyxcbiAgcG9pbnRlcm91dDogJ21vdXNlb3V0J1xufTtcblxuY29uc3QgaXNOdWxsT3JFbXB0eSA9IHZhbHVlID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJztcbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNhbnZhcyBzdHlsZSBhbmQgcmVuZGVyIHNpemUgd2l0aG91dCBtb2RpZnlpbmcgdGhlIGNhbnZhcyBkaXNwbGF5IHNpemUsXG4gKiBzaW5jZSByZXNwb25zaXZlbmVzcyBpcyBoYW5kbGVkIGJ5IHRoZSBjb250cm9sbGVyLnJlc2l6ZSgpIG1ldGhvZC4gVGhlIGNvbmZpZyBpcyB1c2VkXG4gKiB0byBkZXRlcm1pbmUgdGhlIGFzcGVjdCByYXRpbyB0byBhcHBseSBpbiBjYXNlIG5vIGV4cGxpY2l0IGhlaWdodCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNwZWN0UmF0aW9dXG4gKi9cbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcblxuICAvLyBOT1RFKFNCKSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpICE9PSBjYW52YXMud2lkdGg6IGluIHRoZSBmaXJzdCBjYXNlIGl0XG4gIC8vIHJldHVybnMgbnVsbCBvciAnJyBpZiBubyBleHBsaWNpdCB2YWx1ZSBoYXMgYmVlbiBzZXQgdG8gdGhlIGNhbnZhcyBhdHRyaWJ1dGUuXG4gIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICBjb25zdCByZW5kZXJXaWR0aCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG5cbiAgLy8gQ2hhcnQuanMgbW9kaWZpZXMgc29tZSBjYW52YXMgdmFsdWVzIHRoYXQgd2Ugd2FudCB0byByZXN0b3JlIG9uIGRlc3Ryb3lcbiAgY2FudmFzW0VYUEFORE9fS0VZXSA9IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBoZWlnaHQ6IHJlbmRlckhlaWdodCxcbiAgICAgIHdpZHRoOiByZW5kZXJXaWR0aCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG4gICAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogc3R5bGUud2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gRm9yY2UgY2FudmFzIHRvIGRpc3BsYXkgYXMgYmxvY2sgdG8gYXZvaWQgZXh0cmEgc3BhY2UgY2F1c2VkIGJ5IGlubGluZVxuICAvLyBlbGVtZW50cywgd2hpY2ggd291bGQgaW50ZXJmZXJlIHdpdGggdGhlIHJlc3BvbnNpdmUgcmVzaXplIHByb2Nlc3MuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8yNTM4XG4gIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gIC8vIEluY2x1ZGUgcG9zc2libGUgYm9yZGVycyBpbiB0aGUgc2l6ZVxuICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuXG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlcldpZHRoKSkge1xuICAgIGNvbnN0IGRpc3BsYXlXaWR0aCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICd3aWR0aCcpO1xuICAgIGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgIC8vIElmIG5vIGV4cGxpY2l0IHJlbmRlciBoZWlnaHQgYW5kIHN0eWxlIGhlaWdodCwgbGV0J3MgYXBwbHkgdGhlIGFzcGVjdCByYXRpbyxcbiAgICAgIC8vIHdoaWNoIG9uZSBjYW4gYmUgc3BlY2lmaWVkIGJ5IHRoZSB1c2VyIGJ1dCBhbHNvIGJ5IGNoYXJ0cyBhcyBkZWZhdWx0IG9wdGlvblxuICAgICAgLy8gKGkuZS4gb3B0aW9ucy5hc3BlY3RSYXRpbykuIElmIG5vdCBzcGVjaWZpZWQsIHVzZSBjYW52YXMgYXNwZWN0IHJhdGlvIG9mIDIuXG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGFzcGVjdFJhdGlvIHx8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuICAgICAgaWYgKGRpc3BsYXlIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2FudmFzO1xufVxuXG4vLyBEZWZhdWx0IHBhc3NpdmUgdG8gdHJ1ZSBhcyBleHBlY3RlZCBieSBDaHJvbWUgZm9yICd0b3VjaHN0YXJ0JyBhbmQgJ3RvdWNoZW5kJyBldmVudHMuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDI4N1xuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmIChub2RlKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmIChjaGFydCAmJiBjaGFydC5jYW52YXMpIHtcbiAgICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcbiAgY29uc3QgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gIGNvbnN0IHt4LCB5fSA9IGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vZGVMaXN0Q29udGFpbnMobm9kZUxpc3QsIGNhbnZhcykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3QpIHtcbiAgICBpZiAobm9kZSA9PT0gY2FudmFzIHx8IG5vZGUuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUF0dGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURldGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcblxuZnVuY3Rpb24gb25XaW5kb3dSZXNpemUoKSB7XG4gIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBpZiAoZHByID09PSBvbGREZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG9sZERldmljZVBpeGVsUmF0aW8gPSBkcHI7XG4gIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KSA9PiB7XG4gICAgaWYgKGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvICE9PSBkcHIpIHtcbiAgICAgIHJlc2l6ZSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLnNldChjaGFydCwgcmVzaXplKTtcbn1cblxuZnVuY3Rpb24gdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCkge1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzaXplT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGNvbnN0IHcgPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICAgIC8vIElmIHRoZSBjb250YWluZXIgc2l6ZSBzaHJhbmsgZHVyaW5nIGNoYXJ0IHJlc2l6ZSwgbGV0J3MgYXNzdW1lXG4gICAgICAvLyBzY3JvbGxiYXIgYXBwZWFyZWQuIFNvIHdlIHJlc2l6ZSBhZ2FpbiB3aXRoIHRoZSBzY3JvbGxiYXIgdmlzaWJsZSAtXG4gICAgICAvLyBlZmZlY3RpdmVseSBtYWtpbmcgY2hhcnQgc21hbGxlciBhbmQgdGhlIHNjcm9sbGJhciBoaWRkZW4gYWdhaW4uXG4gICAgICAvLyBCZWNhdXNlIHdlIGFyZSBpbnNpZGUgYHRocm90dGxlZGAsIGFuZCBjdXJyZW50bHkgYHRpY2tpbmdgLCBzY3JvbGxcbiAgICAgIC8vIGV2ZW50cyBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyB3aG9sZSAyIHJlc2l6ZSBwcm9jZXNzLlxuICAgICAgLy8gSWYgd2UgYXNzdW1lZCB3cm9uZyBhbmQgc29tZXRoaW5nIGVsc2UgaGFwcGVuZWQsIHdlIGFyZSByZXNpemluZ1xuICAgICAgLy8gdHdpY2UgaW4gYSBmcmFtZSAocG90ZW50aWFsIHBlcmZvcm1hbmNlIGlzc3VlKVxuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHdpbmRvdyk7XG5cbiAgLy8gQHRzLWlnbm9yZSB1bnRpbCBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM3ODYxIGltcGxlbWVudGVkXG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICAvLyBXaGVuIGl0cyBjb250YWluZXIncyBkaXNwbGF5IGlzIHNldCB0byAnbm9uZScgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYVxuICAgIC8vIHNpemUgb2YgKDAsIDApLCB3aGljaCB3aWxsIGNhdXNlIHRoZSBjaGFydCB0byBsb3NlIGl0cyBvcmlnaW5hbCBoZWlnaHQsIHNvIHNraXBcbiAgICAvLyByZXNpemluZyBpbiBzdWNoIGNhc2UuXG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuXG4gIHJldHVybiBvYnNlcnZlcjtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBvYnNlcnZlcikge1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG4gICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3QgcHJveHkgPSB0aHJvdHRsZWQoKGV2ZW50KSA9PiB7XG4gICAgLy8gVGhpcyBjYXNlIGNhbiBvY2N1ciBpZiB0aGUgY2hhcnQgaXMgZGVzdHJveWVkIHdoaWxlIHdhaXRpbmdcbiAgICAvLyBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB0byBvY2N1ci4gV2UgcHJldmVudCBjcmFzaGVzIGJ5IGNoZWNraW5nXG4gICAgLy8gZm9yIGEgZGVzdHJveWVkIGNoYXJ0XG4gICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgIH1cbiAgfSwgY2hhcnQpO1xuXG4gIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuXG4gIHJldHVybiBwcm94eTtcbn1cblxuLyoqXG4gKiBQbGF0Zm9ybSBjbGFzcyBmb3IgY2hhcnRzIHRoYXQgY2FuIGFjY2VzcyB0aGUgRE9NIGFuZCBnbG9iYWwgd2luZG93L2RvY3VtZW50IHByb3BlcnRpZXNcbiAqIEBleHRlbmRzIEJhc2VQbGF0Zm9ybVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXVxuXHQgKiBAcmV0dXJuIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH1cblx0ICovXG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBmaW5nZXJwcmludGluZywgc29tZSBhZGQtb25zIHVuZGVmaW5lIHRoZSBnZXRDb250ZXh0XG4gICAgLy8gbWV0aG9kLCBmb3IgZXhhbXBsZTogaHR0cHM6Ly9naXRodWIuY29tL2trYXBzbmVyL0NhbnZhc0Jsb2NrZXJcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjgwN1xuICAgIGNvbnN0IGNvbnRleHQgPSBjYW52YXMgJiYgY2FudmFzLmdldENvbnRleHQgJiYgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyBgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudC9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkRgIGZhaWxzIHdoZW4gdGhlIGNhbnZhcyBpc1xuICAgIC8vIGluc2lkZSBhbiBpZnJhbWUgb3Igd2hlbiBydW5uaW5nIGluIGEgcHJvdGVjdGVkIGVudmlyb25tZW50LiBXZSBjb3VsZCBndWVzcyB0aGVcbiAgICAvLyB0eXBlcyBmcm9tIHRoZWlyIHRvU3RyaW5nKCkgdmFsdWUgYnV0IGxldCdzIGtlZXAgdGhpbmdzIGZsZXhpYmxlIGFuZCBhc3N1bWUgaXQnc1xuICAgIC8vIGEgc3VmZmljaWVudCBjb25kaXRpb24gaWYgdGhlIGNhbnZhcyBoYXMgYSBjb250ZXh0MkQgd2hpY2ggaGFzIGNhbnZhcyBhcyBgY2FudmFzYC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMzg4N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80MTAyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNTJcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICAvLyBMb2FkIHBsYXRmb3JtIHJlc291cmNlcyBvbiBmaXJzdCBjaGFydCBjcmVhdGlvbiwgdG8gbWFrZSBpdCBwb3NzaWJsZSB0b1xuICAgICAgLy8gaW1wb3J0IHRoZSBsaWJyYXJ5IGJlZm9yZSBzZXR0aW5nIHBsYXRmb3JtIG9wdGlvbnMuXG4gICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHRcblx0ICovXG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICBpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuICAgIFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBjYW52YXMuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgfSk7XG5cbiAgICAvLyBUaGUgY2FudmFzIHJlbmRlciBzaXplIG1pZ2h0IGhhdmUgYmVlbiBjaGFuZ2VkIChhbmQgdGh1cyB0aGUgc3RhdGUgc3RhY2sgZGlzY2FyZGVkKSxcbiAgICAvLyB3ZSBjYW4ndCB1c2Ugc2F2ZSgpIGFuZCByZXN0b3JlKCkgdG8gcmVzdG9yZSB0aGUgaW5pdGlhbCBzdGF0ZS4gU28gbWFrZSBzdXJlIHRoYXQgYXRcbiAgICAvLyBsZWFzdCB0aGUgY2FudmFzIGNvbnRleHQgaXMgcmVzZXQgdG8gdGhlIGRlZmF1bHQgc3RhdGUgYnkgc2V0dGluZyB0aGUgY2FudmFzIHdpZHRoLlxuICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwNTI1L3RoZS1jYW52YXMtZWxlbWVudC5odG1sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuXG4gICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcblx0ICpcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXJcblx0ICovXG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgLy8gQ2FuIGhhdmUgb25seSBvbmUgbGlzdGVuZXIgcGVyIHR5cGUsIHNvIG1ha2Ugc3VyZSBwcmV2aW91cyBpcyByZW1vdmVkXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlKTtcblxuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IGNyZWF0ZUF0dGFjaE9ic2VydmVyLFxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogY3JlYXRlUmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcbiAgICBwcm94aWVzW3R5cGVdID0gaGFuZGxlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcblx0ICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IHByb3h5ID0gcHJveGllc1t0eXBlXTtcblxuICAgIGlmICghcHJveHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgZGV0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICByZXNpemU6IHJlbGVhc2VPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgIGhhbmRsZXIoY2hhcnQsIHR5cGUsIHByb3h5KTtcbiAgICBwcm94aWVzW3R5cGVdID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGhdIC0gY29udGVudCB3aWR0aCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2hlaWdodF0gLSBjb250ZW50IGhlaWdodCBvZiBwYXJlbnQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2FzcGVjdFJhdGlvXSAtIGFzcGVjdCByYXRpbyB0byBtYWludGFpblxuXHQgKi9cbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHJldHVybiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcblx0ICovXG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gY2FudmFzICYmIF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgcmV0dXJuICEhKGNvbnRhaW5lciAmJiBjb250YWluZXIuaXNDb25uZWN0ZWQpO1xuICB9XG59XG4iLCAiaW1wb3J0IHtfaXNEb21TdXBwb3J0ZWR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IEJhc2VQbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3JtLmJhc2UuanMnO1xuaW1wb3J0IEJhc2ljUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5iYXNpYy5qcyc7XG5pbXBvcnQgRG9tUGxhdGZvcm0gZnJvbSAnLi9wbGF0Zm9ybS5kb20uanMnO1xuXG5leHBvcnQgZnVuY3Rpb24gX2RldGVjdFBsYXRmb3JtKGNhbnZhcykge1xuICBpZiAoIV9pc0RvbVN1cHBvcnRlZCgpIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpKSB7XG4gICAgcmV0dXJuIEJhc2ljUGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIERvbVBsYXRmb3JtO1xufVxuXG5leHBvcnQge0Jhc2VQbGF0Zm9ybSwgQmFzaWNQbGF0Zm9ybSwgRG9tUGxhdGZvcm19O1xuIiwgImltcG9ydCB0eXBlIHtBbnlPYmplY3R9IGZyb20gJy4uL3R5cGVzL2Jhc2ljLmpzJztcbmltcG9ydCB0eXBlIHtQb2ludH0gZnJvbSAnLi4vdHlwZXMvZ2VvbWV0cmljLmpzJztcbmltcG9ydCB0eXBlIHtBbmltYXRpb259IGZyb20gJy4uL3R5cGVzL2FuaW1hdGlvbi5qcyc7XG5pbXBvcnQge2lzTnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnQ8VCA9IEFueU9iamVjdCwgTyA9IEFueU9iamVjdD4ge1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHt9O1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcblxuICB4OiBudW1iZXI7XG4gIHk6IG51bWJlcjtcbiAgYWN0aXZlID0gZmFsc2U7XG4gIG9wdGlvbnM6IE87XG4gICRhbmltYXRpb25zOiBSZWNvcmQ8a2V5b2YgVCwgQW5pbWF0aW9uPjtcblxuICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbjogYm9vbGVhbik6IFBvaW50IHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX0gYXMgUG9pbnQ7XG4gIH1cblxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gaXNOdW1iZXIodGhpcy54KSAmJiBpc051bWJlcih0aGlzLnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgb3IgZmluYWwgdmFsdWUgb2YgZWFjaCBwcm9wLiBDYW4gcmV0dXJuIGV4dHJhIHByb3BlcnRpZXMgKHdob2xlIG9iamVjdCkuXG4gICAqIEBwYXJhbSBwcm9wcyAtIHByb3BlcnRpZXMgdG8gZ2V0XG4gICAqIEBwYXJhbSBbZmluYWxdIC0gZ2V0IHRoZSBmaW5hbCB2YWx1ZSAoYW5pbWF0aW9uIHRhcmdldClcbiAgICovXG4gIGdldFByb3BzPFAgZXh0ZW5kcyAoa2V5b2YgVClbXT4ocHJvcHM6IFAsIGZpbmFsPzogYm9vbGVhbik6IFBpY2s8VCwgUFtudW1iZXJdPjtcbiAgZ2V0UHJvcHM8UCBleHRlbmRzIHN0cmluZz4ocHJvcHM6IFBbXSwgZmluYWw/OiBib29sZWFuKTogUGFydGlhbDxSZWNvcmQ8UCwgdW5rbm93bj4+O1xuICBnZXRQcm9wcyhwcm9wczogc3RyaW5nW10sIGZpbmFsPzogYm9vbGVhbik6IFBhcnRpYWw8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+IHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcbiAgICAgIC8vIGxldCdzIG5vdCBjcmVhdGUgYW4gb2JqZWN0LCBpZiBub3QgbmVlZGVkXG4gICAgICByZXR1cm4gdGhpcyBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICB9XG4gICAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIHJldFtwcm9wXSA9IGFuaW1zW3Byb3BdICYmIGFuaW1zW3Byb3BdLmFjdGl2ZSgpID8gYW5pbXNbcHJvcF0uX3RvIDogdGhpc1twcm9wIGFzIHN0cmluZ107XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNOdWxsT3JVbmRlZiwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7X2ZhY3Rvcml6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuXG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4vY29yZS5jb250cm9sbGVyLmpzJykuZGVmYXVsdCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7e3ZhbHVlOm51bWJlciB8IHN0cmluZywgbGFiZWw/OnN0cmluZywgbWFqb3I/OmJvb2xlYW4sICRjb250ZXh0Pzphbnl9fSBUaWNrXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3Vic2V0IG9mIHRpY2tzIHRvIGJlIHBsb3R0ZWQgdG8gYXZvaWQgb3ZlcmxhcHBpbmcgbGFiZWxzLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vY29yZS5zY2FsZS5qcycpLmRlZmF1bHR9IHNjYWxlXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEByZXR1cm4ge1RpY2tbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdXRvU2tpcChzY2FsZSwgdGlja3MpIHtcbiAgY29uc3QgdGlja09wdHMgPSBzY2FsZS5vcHRpb25zLnRpY2tzO1xuICBjb25zdCBkZXRlcm1pbmVkTWF4VGlja3MgPSBkZXRlcm1pbmVNYXhUaWNrcyhzY2FsZSk7XG4gIGNvbnN0IHRpY2tzTGltaXQgPSBNYXRoLm1pbih0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGRldGVybWluZWRNYXhUaWNrcywgZGV0ZXJtaW5lZE1heFRpY2tzKTtcbiAgY29uc3QgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcbiAgY29uc3QgbnVtTWFqb3JJbmRpY2VzID0gbWFqb3JJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3QgZmlyc3QgPSBtYWpvckluZGljZXNbMF07XG4gIGNvbnN0IGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XG4gIGNvbnN0IG5ld1RpY2tzID0gW107XG5cbiAgLy8gSWYgdGhlcmUgYXJlIHRvbyBtYW55IG1ham9yIHRpY2tzIHRvIGRpc3BsYXkgdGhlbSBhbGxcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IHRpY2tzTGltaXQpIHtcbiAgICBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBudW1NYWpvckluZGljZXMgLyB0aWNrc0xpbWl0KTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cblxuICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcblxuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGF2Z01ham9yU3BhY2luZyA9IG51bU1ham9ySW5kaWNlcyA+IDEgPyBNYXRoLnJvdW5kKChsYXN0IC0gZmlyc3QpIC8gKG51bU1ham9ySW5kaWNlcyAtIDEpKSA6IG51bGw7XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBudW1NYWpvckluZGljZXMgLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JJbmRpY2VzW2ldLCBtYWpvckluZGljZXNbaSArIDFdKTtcbiAgICB9XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGxhc3QsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZyk7XG4gIHJldHVybiBuZXdUaWNrcztcbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2NhbGUub3B0aW9ucy5vZmZzZXQ7XG4gIGNvbnN0IHRpY2tMZW5ndGggPSBzY2FsZS5fdGlja1NpemUoKTtcbiAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XG4gIGNvbnN0IG1heENoYXJ0ID0gc2NhbGUuX21heExlbmd0aCAvIHRpY2tMZW5ndGg7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKG1heFNjYWxlLCBtYXhDaGFydCkpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IG1ham9ySW5kaWNlc1xuICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gdGlja3NMaW1pdFxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcbiAgY29uc3QgZXZlbk1ham9yU3BhY2luZyA9IGdldEV2ZW5TcGFjaW5nKG1ham9ySW5kaWNlcyk7XG4gIGNvbnN0IHNwYWNpbmcgPSB0aWNrcy5sZW5ndGggLyB0aWNrc0xpbWl0O1xuXG4gIC8vIElmIHRoZSBtYWpvciB0aWNrcyBhcmUgZXZlbmx5IHNwYWNlZCBhcGFydCwgcGxhY2UgdGhlIG1pbm9yIHRpY2tzXG4gIC8vIHNvIHRoYXQgdGhleSBkaXZpZGUgdGhlIG1ham9yIHRpY2tzIGludG8gZXZlbiBjaHVua3NcbiAgaWYgKCFldmVuTWFqb3JTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xuICB9XG5cbiAgY29uc3QgZmFjdG9ycyA9IF9mYWN0b3JpemUoZXZlbk1ham9yU3BhY2luZyk7XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgY29uc3QgZmFjdG9yID0gZmFjdG9yc1tpXTtcbiAgICBpZiAoZmFjdG9yID4gc3BhY2luZykge1xuICAgICAgcmV0dXJuIGZhY3RvcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICovXG5mdW5jdGlvbiBnZXRNYWpvckluZGljZXModGlja3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgaWYgKHRpY2tzW2ldLm1ham9yKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpY2tbXX0gdGlja3NcbiAqIEBwYXJhbSB7VGlja1tdfSBuZXdUaWNrc1xuICogQHBhcmFtIHtudW1iZXJbXX0gbWFqb3JJbmRpY2VzXG4gKiBAcGFyYW0ge251bWJlcn0gc3BhY2luZ1xuICovXG5mdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBuZXh0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICBsZXQgaTtcblxuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGlja1tdfSB0aWNrc1xuICogQHBhcmFtIHtUaWNrW119IG5ld1RpY2tzXG4gKiBAcGFyYW0ge251bWJlcn0gc3BhY2luZ1xuICogQHBhcmFtIHtudW1iZXJ9IFttYWpvclN0YXJ0XVxuICogQHBhcmFtIHtudW1iZXJ9IFttYWpvckVuZF1cbiAqL1xuZnVuY3Rpb24gc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9yU3RhcnQsIG1ham9yRW5kKSB7XG4gIGNvbnN0IHN0YXJ0ID0gdmFsdWVPckRlZmF1bHQobWFqb3JTdGFydCwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0KG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbGVuZ3RoLCBpLCBuZXh0O1xuXG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGlmIChtYWpvckVuZCkge1xuICAgIGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcbiAgICBzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcbiAgfVxuXG4gIG5leHQgPSBzdGFydDtcblxuICB3aGlsZSAobmV4dCA8IDApIHtcbiAgICBjb3VudCsrO1xuICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgfVxuXG4gIGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyW119IGFyclxuICovXG5mdW5jdGlvbiBnZXRFdmVuU3BhY2luZyhhcnIpIHtcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGksIGRpZmY7XG5cbiAgaWYgKGxlbiA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGRpZmYgPSBhcnJbMF0sIGkgPSAxOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldIC0gYXJyW2kgLSAxXSAhPT0gZGlmZikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZjtcbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19hbGlnblBpeGVsLCBfbWVhc3VyZVRleHQsIHJlbmRlclRleHQsIGNsaXBBcmVhLCB1bmNsaXBBcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbCwgZWFjaCwgZmluaXRlT3JEZWZhdWx0LCBpc0FycmF5LCBpc0Zpbml0ZSwgaXNOdWxsT3JVbmRlZiwgaXNPYmplY3QsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge3RvRGVncmVlcywgdG9SYWRpYW5zLCBfaW50MTZSYW5nZSwgX2xpbWl0VmFsdWUsIEhBTEZfUEl9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCB7X2FsaWduU3RhcnRFbmQsIF90b0xlZnRSaWdodENlbnRlcn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHRvRm9udCwgdG9QYWRkaW5nLCBfYWRkR3JhY2V9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5vcHRpb25zLmpzJztcbmltcG9ydCB7YXV0b1NraXB9IGZyb20gJy4vY29yZS5zY2FsZS5hdXRvc2tpcC5qcyc7XG5cbmNvbnN0IHJldmVyc2VBbGlnbiA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6IGFsaWduO1xuY29uc3Qgb2Zmc2V0RnJvbUVkZ2UgPSAoc2NhbGUsIGVkZ2UsIG9mZnNldCkgPT4gZWRnZSA9PT0gJ3RvcCcgfHwgZWRnZSA9PT0gJ2xlZnQnID8gc2NhbGVbZWRnZV0gKyBvZmZzZXQgOiBzY2FsZVtlZGdlXSAtIG9mZnNldDtcbmNvbnN0IGdldFRpY2tzTGltaXQgPSAodGlja3NMZW5ndGgsIG1heFRpY2tzTGltaXQpID0+IE1hdGgubWluKG1heFRpY2tzTGltaXQgfHwgdGlja3NMZW5ndGgsIHRpY2tzTGVuZ3RoKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5DaGFydCB9IENoYXJ0XG4gKiBAdHlwZWRlZiB7e3ZhbHVlOm51bWJlciB8IHN0cmluZywgbGFiZWw/OnN0cmluZywgbWFqb3I/OmJvb2xlYW4sICRjb250ZXh0Pzphbnl9fSBUaWNrXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgbnVtSXRlbXMgZnJvbSBhcnJcbiAqIEBwYXJhbSB7YW55W119IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IG51bUl0ZW1zXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBpbmNyZW1lbnQgPSBhcnIubGVuZ3RoIC8gbnVtSXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKDsgaSA8IGxlbjsgaSArPSBpbmNyZW1lbnQpIHtcbiAgICByZXN1bHQucHVzaChhcnJbTWF0aC5mbG9vcihpKV0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtib29sZWFufSBvZmZzZXRHcmlkTGluZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS50aWNrcy5sZW5ndGg7XG4gIGNvbnN0IHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gIGNvbnN0IHN0YXJ0ID0gc2NhbGUuX3N0YXJ0UGl4ZWw7XG4gIGNvbnN0IGVuZCA9IHNjYWxlLl9lbmRQaXhlbDtcbiAgY29uc3QgZXBzaWxvbiA9IDFlLTY7IC8vIDFlLTYgaXMgbWFyZ2luIGluIHBpeGVscyBmb3IgYWNjdW11bGF0ZWQgZXJyb3IuXG4gIGxldCBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCk7XG4gIGxldCBvZmZzZXQ7XG5cbiAgaWYgKG9mZnNldEdyaWRMaW5lcykge1xuICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIG9mZnNldCA9IChzY2FsZS5nZXRQaXhlbEZvclRpY2soMSkgLSBsaW5lVmFsdWUpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gKGxpbmVWYWx1ZSAtIHNjYWxlLmdldFBpeGVsRm9yVGljayh2YWxpZEluZGV4IC0gMSkpIC8gMjtcbiAgICB9XG4gICAgbGluZVZhbHVlICs9IHZhbGlkSW5kZXggPCBpbmRleCA/IG9mZnNldCA6IC1vZmZzZXQ7XG5cbiAgICAvLyBSZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBwaXhlbCBpcyBvdXQgb2YgdGhlIHJhbmdlXG4gICAgaWYgKGxpbmVWYWx1ZSA8IHN0YXJ0IC0gZXBzaWxvbiB8fCBsaW5lVmFsdWUgPiBlbmQgKyBlcHNpbG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJldHVybiBsaW5lVmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNhY2hlc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiBnYXJiYWdlQ29sbGVjdChjYWNoZXMsIGxlbmd0aCkge1xuICBlYWNoKGNhY2hlcywgKGNhY2hlKSA9PiB7XG4gICAgY29uc3QgZ2MgPSBjYWNoZS5nYztcbiAgICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gICAgbGV0IGk7XG4gICAgaWYgKGdjTGVuID4gbGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47ICsraSkge1xuICAgICAgICBkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XG4gICAgICB9XG4gICAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kcmF3VGlja3MgPyBvcHRpb25zLnRpY2tMZW5ndGggOiAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb25zdCBmb250ID0gdG9Gb250KG9wdGlvbnMuZm9udCwgZmFsbGJhY2spO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheShvcHRpb25zLnRleHQpID8gb3B0aW9ucy50ZXh0Lmxlbmd0aCA6IDE7XG5cbiAgcmV0dXJuIChsaW5lcyAqIGZvbnQubGluZUhlaWdodCkgKyBwYWRkaW5nLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2NhbGVDb250ZXh0KHBhcmVudCwgc2NhbGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgc2NhbGUsXG4gICAgdHlwZTogJ3NjYWxlJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGlja0NvbnRleHQocGFyZW50LCBpbmRleCwgdGljaykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0aWNrLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICd0aWNrJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpIHtcbiAgLyoqIEB0eXBlIHtDYW52YXNUZXh0QWxpZ259ICovXG4gIGxldCByZXQgPSBfdG9MZWZ0UmlnaHRDZW50ZXIoYWxpZ24pO1xuICBpZiAoKHJldmVyc2UgJiYgcG9zaXRpb24gIT09ICdyaWdodCcpIHx8ICghcmV2ZXJzZSAmJiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICByZXQgPSByZXZlcnNlQWxpZ24ocmV0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB0aXRsZUFyZ3Moc2NhbGUsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKSB7XG4gIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIGNoYXJ0fSA9IHNjYWxlO1xuICBjb25zdCB7Y2hhcnRBcmVhLCBzY2FsZXN9ID0gY2hhcnQ7XG4gIGxldCByb3RhdGlvbiA9IDA7XG4gIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG5cbiAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcblxuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVkgPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVkgPSAoY2hhcnRBcmVhLmJvdHRvbSArIGNoYXJ0QXJlYS50b3ApIC8gMiArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVZID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVYID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMiAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVggPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgcm90YXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICB9XG4gIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjYWxlIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmlkID0gY2ZnLmlkO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMudHlwZSA9IGNmZy50eXBlO1xuICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gKi9cbiAgICB0aGlzLmN0eCA9IGNmZy5jdHg7XG4gICAgLyoqIEB0eXBlIHtDaGFydH0gKi9cbiAgICB0aGlzLmNoYXJ0ID0gY2ZnLmNoYXJ0O1xuXG4gICAgLy8gaW1wbGVtZW50cyBib3hcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5wYWRkaW5nVG9wID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gc2NhbGUtc3BlY2lmaWMgcHJvcGVydGllc1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nPX0gKi9cbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXI9fSAqL1xuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge1RpY2tbXX0gKi9cbiAgICB0aGlzLnRpY2tzID0gW107XG4gICAgLyoqIEB0eXBlIHtvYmplY3RbXXxudWxsfSAqL1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7b2JqZWN0W118bnVsbH0gKi9cbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICAvKiogQHR5cGUge29iamVjdHxudWxsfSAqL1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gMDtcbiAgICB0aGlzLl9sb25nZXN0VGV4dENhY2hlID0ge307XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9lbmRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlck1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl91c2VyTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSAwO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gMDtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7YW55fSBvcHRpb25zXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG5cbiAgICB0aGlzLmF4aXMgPSBvcHRpb25zLmF4aXM7XG5cbiAgICAvLyBwYXJzZSBtaW4vbWF4IHZhbHVlLCBzbyB3ZSBjYW4gcHJvcGVybHkgZGV0ZXJtaW5lIG1pbi9tYXggZm9yIG90aGVyIHNjYWxlc1xuICAgIHRoaXMuX3VzZXJNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMubWluKTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLm1heCk7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1pbik7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1heCk7XG4gIH1cblxuICAvKipcblx0ICogUGFyc2UgYSBzdXBwb3J0ZWQgaW5wdXQgdmFsdWUgdG8gaW50ZXJuYWwgcmVwcmVzZW50YXRpb24uXG5cdCAqIEBwYXJhbSB7Kn0gcmF3XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdXG5cdCAqIEBzaW5jZSAzLjBcblx0ICovXG4gIHBhcnNlKHJhdywgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiByYXc7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7e21pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgbWluRGVmaW5lZDogYm9vbGVhbiwgbWF4RGVmaW5lZDogYm9vbGVhbn19XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHNpbmNlIDMuMFxuXHQgKi9cbiAgZ2V0VXNlckJvdW5kcygpIHtcbiAgICBsZXQge191c2VyTWluLCBfdXNlck1heCwgX3N1Z2dlc3RlZE1pbiwgX3N1Z2dlc3RlZE1heH0gPSB0aGlzO1xuICAgIF91c2VyTWluID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF91c2VyTWF4ID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWF4ID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBfc3VnZ2VzdGVkTWluKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBfc3VnZ2VzdGVkTWF4KSxcbiAgICAgIG1pbkRlZmluZWQ6IGlzRmluaXRlKF91c2VyTWluKSxcbiAgICAgIG1heERlZmluZWQ6IGlzRmluaXRlKF91c2VyTWF4KVxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtib29sZWFufSBjYW5TdGFja1xuXHQgKiBAcmV0dXJuIHt7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfX1cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAc2luY2UgMy4wXG5cdCAqL1xuICBnZXRNaW5NYXgoY2FuU3RhY2spIHtcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCByYW5nZTtcblxuICAgIGlmIChtaW5EZWZpbmVkICYmIG1heERlZmluZWQpIHtcbiAgICAgIHJldHVybiB7bWluLCBtYXh9O1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICByYW5nZSA9IG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0TWluTWF4KHRoaXMsIGNhblN0YWNrKTtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJhbmdlLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByYW5nZS5tYXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBtaW4gPD0gbWF4IHdoZW4gb25seSBtaW4gb3IgbWF4IGlzIGRlZmluZWQgYnkgdXNlciBhbmQgdGhlIGRhdGEgaXMgb3V0c2lkZSB0aGF0IHJhbmdlXG4gICAgbWluID0gbWF4RGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtYXggOiBtaW47XG4gICAgbWF4ID0gbWluRGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtaW4gOiBtYXg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQobWluLCBmaW5pdGVPckRlZmF1bHQobWF4LCBtaW4pKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KG1heCwgZmluaXRlT3JEZWZhdWx0KG1pbiwgbWF4KSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldCB0aGUgcGFkZGluZyBuZWVkZWQgZm9yIHRoZSBzY2FsZVxuXHQgKiBAcmV0dXJuIHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fSB0aGUgbmVjZXNzYXJ5IHBhZGRpbmdcblx0ICogQHByaXZhdGVcblx0ICovXG4gIGdldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgIHRvcDogdGhpcy5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICByaWdodDogdGhpcy5wYWRkaW5nUmlnaHQgfHwgMCxcbiAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHNjYWxlIHRpY2sgb2JqZWN0c1xuXHQgKiBAcmV0dXJuIHtUaWNrW119XG5cdCAqIEBzaW5jZSAyLjdcblx0ICovXG4gIGdldFRpY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3N0cmluZ1tdfVxuXHQgKi9cbiAgZ2V0TGFiZWxzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5MYWJlbEl0ZW1bXX1cbiAgICovXG4gIGdldExhYmVsSXRlbXMoY2hhcnRBcmVhID0gdGhpcy5jaGFydC5jaGFydEFyZWEpIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xhYmVsSXRlbXMgfHwgKHRoaXMuX2xhYmVsSXRlbXMgPSB0aGlzLl9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpKTtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICAvLyBXaGVuIGEgbmV3IGxheW91dCBpcyBjcmVhdGVkLCByZXNldCB0aGUgZGF0YSBsaW1pdHMgY2FjaGVcbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICB9XG5cbiAgLy8gVGhlc2UgbWV0aG9kcyBhcmUgb3JkZXJlZCBieSBsaWZlY3ljbGUuIFV0aWxpdGllcyB0aGVuIGZvbGxvdy5cbiAgLy8gQW55IGZ1bmN0aW9uIGRlZmluZWQgaGVyZSBpcyBpbmhlcml0ZWQgYnkgYWxsIHNjYWxlIHR5cGVzLlxuICAvLyBBbnkgZnVuY3Rpb24gY2FuIGJlIGV4dGVuZGVkIGJ5IHRoZSBzY2FsZSB0eXBlXG5cbiAgYmVmb3JlVXBkYXRlKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4V2lkdGggLSB0aGUgbWF4IHdpZHRoIGluIHBpeGVsc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gdGhlIG1heCBoZWlnaHQgaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCByaWdodDogbnVtYmVyfX0gbWFyZ2lucyAtIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBlZGdlIG9mIHRoZSBvdGhlciBzY2FsZXMgYW5kIGVkZ2Ugb2YgdGhlIGNoYXJ0XG5cdCAqICAgVGhpcyBzcGFjZSBjb21lcyBmcm9tIHR3byBzb3VyY2VzOlxuXHQgKiAgICAgLSBwYWRkaW5nIC0gc3BhY2UgdGhhdCdzIHJlcXVpcmVkIHRvIHNob3cgdGhlIGxhYmVscyBhdCB0aGUgZWRnZXMgb2YgdGhlIHNjYWxlXG5cdCAqICAgICAtIHRoaWNrbmVzcyBvZiBzY2FsZXMgb3IgbGVnZW5kcyBpbiBhbm90aGVyIG9yaWVudGF0aW9uXG5cdCAqL1xuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVybywgZ3JhY2UsIHRpY2tzOiB0aWNrT3B0c30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG5cbiAgICAvLyBVcGRhdGUgTGlmZWN5Y2xlIC0gUHJvYmFibHkgZG9uJ3Qgd2FudCB0byBldmVyIGV4dGVuZCBvciBvdmVyd3JpdGUgdGhpcyBmdW5jdGlvbiA7KVxuICAgIHRoaXMuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICAvLyBBYnNvcmIgdGhlIG1hc3RlciBtZWFzdXJlbWVudHNcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sIG1hcmdpbnMpO1xuXG4gICAgdGhpcy50aWNrcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG5cbiAgICAvLyBEaW1lbnNpb25zXG4gICAgdGhpcy5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5hZnRlclNldERpbWVuc2lvbnMoKTtcblxuICAgIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gdGhpcy53aWR0aCArIG1hcmdpbnMubGVmdCArIG1hcmdpbnMucmlnaHRcbiAgICAgIDogdGhpcy5oZWlnaHQgKyBtYXJnaW5zLnRvcCArIG1hcmdpbnMuYm90dG9tO1xuXG4gICAgLy8gRGF0YSBtaW4vbWF4XG4gICAgaWYgKCF0aGlzLl9kYXRhTGltaXRzQ2FjaGVkKSB7XG4gICAgICB0aGlzLmJlZm9yZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5hZnRlckRhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuX3JhbmdlID0gX2FkZEdyYWNlKHRoaXMsIGdyYWNlLCBiZWdpbkF0WmVybyk7XG4gICAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmJlZm9yZUJ1aWxkVGlja3MoKTtcblxuICAgIHRoaXMudGlja3MgPSB0aGlzLmJ1aWxkVGlja3MoKSB8fCBbXTtcblxuICAgIC8vIEFsbG93IG1vZGlmaWNhdGlvbiBvZiB0aWNrcyBpbiBjYWxsYmFjay5cbiAgICB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aWNrIHJvdGF0aW9uIGFuZCBmaXQgdXNpbmcgYSBzYW1wbGVkIHN1YnNldCBvZiBsYWJlbHNcbiAgICAvLyBXZSBnZW5lcmFsbHkgZG9uJ3QgbmVlZCB0byBjb21wdXRlIHRoZSBzaXplIG9mIGV2ZXJ5IHNpbmdsZSBsYWJlbCBmb3IgZGV0ZXJtaW5pbmcgc2NhbGUgc2l6ZVxuICAgIGNvbnN0IHNhbXBsaW5nRW5hYmxlZCA9IHNhbXBsZVNpemUgPCB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGhpcy50aWNrcywgc2FtcGxlU2l6ZSkgOiB0aGlzLnRpY2tzKTtcblxuICAgIC8vIGNvbmZpZ3VyZSBpcyBjYWxsZWQgdHdpY2UsIG9uY2UgaGVyZSwgb25jZSBmcm9tIGNvcmUuY29udHJvbGxlci51cGRhdGVMYXlvdXQuXG4gICAgLy8gSGVyZSB3ZSBoYXZlbid0IGJlZW4gcG9zaXRpb25lZCB5ZXQsIGJ1dCBkaW1lbnNpb25zIGFyZSBjb3JyZWN0LlxuICAgIC8vIFZhcmlhYmxlcyBzZXQgaW4gY29uZmlndXJlIGFyZSBuZWVkZWQgZm9yIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIGFuZFxuICAgIC8vIGl0J3Mgb2sgdGhhdCBjb29yZGluYXRlcyBhcmUgbm90IGNvcnJlY3QgdGhlcmUsIG9ubHkgZGltZW5zaW9ucyBtYXR0ZXIuXG4gICAgdGhpcy5jb25maWd1cmUoKTtcblxuICAgIC8vIFRpY2sgUm90YXRpb25cbiAgICB0aGlzLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTsgLy8gUHJlY29uZGl0aW9uczogbnVtYmVyIG9mIHRpY2tzIGFuZCBzaXplcyBvZiBsYXJnZXN0IGxhYmVscyBtdXN0IGJlIGNhbGN1bGF0ZWQgYmVmb3JlaGFuZFxuICAgIHRoaXMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG5cbiAgICAvLyBBdXRvLXNraXBcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XG4gICAgICB0aGlzLnRpY2tzID0gYXV0b1NraXAodGhpcywgdGhpcy50aWNrcyk7XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICAgIHRoaXMuYWZ0ZXJBdXRvU2tpcCgpO1xuICAgIH1cblxuICAgIGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcbiAgICAgIC8vIEdlbmVyYXRlIGxhYmVscyB1c2luZyBhbGwgbm9uLXNraXBwZWQgdGlja3NcbiAgICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRoaXMudGlja3MpO1xuICAgIH1cblxuICAgIHRoaXMuYmVmb3JlRml0KCk7XG4gICAgdGhpcy5maXQoKTsgLy8gUHJlY29uZGl0aW9uczogbGFiZWwgcm90YXRpb24gYW5kIGxhYmVsIHNpemVzIG11c3QgYmUgY2FsY3VsYXRlZCBiZWZvcmVoYW5kXG4gICAgdGhpcy5hZnRlckZpdCgpO1xuXG4gICAgLy8gSU1QT1JUQU5UOiBhZnRlciB0aGlzIHBvaW50LCB3ZSBjb25zaWRlciB0aGF0IGB0aGlzLnRpY2tzYCB3aWxsIE5FVkVSIGNoYW5nZSFcblxuICAgIHRoaXMuYWZ0ZXJVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgbGV0IHJldmVyc2VQaXhlbHMgPSB0aGlzLm9wdGlvbnMucmV2ZXJzZTtcbiAgICBsZXQgc3RhcnRQaXhlbCwgZW5kUGl4ZWw7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMubGVmdDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMudG9wO1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLmJvdHRvbTtcbiAgICAgIC8vIGJ5IGRlZmF1bHQgdmVydGljYWwgc2NhbGVzIGFyZSBmcm9tIGJvdHRvbSB0byB0b3AsIHNvIHBpeGVscyBhcmUgcmV2ZXJzZWRcbiAgICAgIHJldmVyc2VQaXhlbHMgPSAhcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcbiAgICB0aGlzLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fYWxpZ25Ub1BpeGVscyA9IHRoaXMub3B0aW9ucy5hbGlnblRvUGl4ZWxzO1xuICB9XG5cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFt0aGlzXSk7XG4gIH1cblxuICAvL1xuXG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIC8vIFNldCB0aGUgdW5jb25zdHJhaW5lZCBkaW1lbnNpb24gYmVmb3JlIGxhYmVsIHJvdGF0aW9uXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG5cbiAgICAgIC8vIFJlc2V0IHBvc2l0aW9uIGJlZm9yZSBjYWxjdWxhdGluZyByb3RhdGlvblxuICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBwYWRkaW5nXG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgfVxuICBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG5cbiAgX2NhbGxIb29rcyhuYW1lKSB7XG4gICAgdGhpcy5jaGFydC5ub3RpZnlQbHVnaW5zKG5hbWUsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjYWxsKHRoaXMub3B0aW9uc1tuYW1lXSwgW3RoaXNdKTtcbiAgfVxuXG4gIC8vIERhdGEgbGltaXRzXG4gIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xuICB9XG5cbiAgLy9cbiAgYmVmb3JlQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2JlZm9yZUJ1aWxkVGlja3MnKTtcbiAgfVxuICAvKipcblx0ICogQHJldHVybiB7b2JqZWN0W119IHRoZSB0aWNrc1xuXHQgKi9cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XG4gIH1cblxuICBiZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIC8qKlxuXHQgKiBDb252ZXJ0IHRpY2tzIHRvIGxhYmVsIHN0cmluZ3Ncblx0ICogQHBhcmFtIHtUaWNrW119IHRpY2tzXG5cdCAqL1xuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gY2FsbCh0aWNrT3B0cy5jYWxsYmFjaywgW3RpY2sudmFsdWUsIGksIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG5cbiAgLy9cblxuICBiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGwodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCBudW1UaWNrcyA9IGdldFRpY2tzTGltaXQodGhpcy50aWNrcy5sZW5ndGgsIG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCk7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwO1xuICAgIGNvbnN0IG1heFJvdGF0aW9uID0gdGlja09wdHMubWF4Um90YXRpb247XG4gICAgbGV0IGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICBsZXQgdGlja1dpZHRoLCBtYXhIZWlnaHQsIG1heExhYmVsRGlhZ29uYWw7XG5cbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcblxuICAgIC8vIEVzdGltYXRlIHRoZSB3aWR0aCBvZiBlYWNoIGdyaWQgYmFzZWQgb24gdGhlIGNhbnZhcyB3aWR0aCwgdGhlIG1heGltdW1cbiAgICAvLyBsYWJlbCB3aWR0aCBhbmQgdGhlIG51bWJlciBvZiB0aWNrIGludGVydmFsc1xuICAgIGNvbnN0IG1heFdpZHRoID0gX2xpbWl0VmFsdWUodGhpcy5jaGFydC53aWR0aCAtIG1heExhYmVsV2lkdGgsIDAsIHRoaXMubWF4V2lkdGgpO1xuICAgIHRpY2tXaWR0aCA9IG9wdGlvbnMub2Zmc2V0ID8gdGhpcy5tYXhXaWR0aCAvIG51bVRpY2tzIDogbWF4V2lkdGggLyAobnVtVGlja3MgLSAxKTtcblxuICAgIC8vIEFsbG93IDMgcGl4ZWxzIHgyIHBhZGRpbmcgZWl0aGVyIHNpZGUgZm9yIGxhYmVsIHJlYWRhYmlsaXR5XG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XG4gICAgICB0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcbiAgICAgIG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKVxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRUaXRsZUhlaWdodChvcHRpb25zLnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gdG9EZWdyZWVzKE1hdGgubWluKFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpXG4gICAgICApKTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcbiAgICB9XG5cbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSBsYWJlbFJvdGF0aW9uO1xuICB9XG4gIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjYWxsKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHt9XG5cbiAgLy9cblxuICBiZWZvcmVGaXQoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuICB9XG4gIGZpdCgpIHtcbiAgICAvLyBSZXNldFxuICAgIGNvbnN0IG1pblNpemUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG5cbiAgICBjb25zdCB7Y2hhcnQsIG9wdGlvbnM6IHt0aWNrczogdGlja09wdHMsIHRpdGxlOiB0aXRsZU9wdHMsIGdyaWQ6IGdyaWRPcHRzfX0gPSB0aGlzO1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLl9pc1Zpc2libGUoKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuXG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gZ2V0VGl0bGVIZWlnaHQodGl0bGVPcHRzLCBjaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBtaW5TaXplLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7IC8vIGZpbGwgYWxsIHRoZSBoZWlnaHRcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBib3RoZXIgZml0dGluZyB0aGUgdGlja3MgaWYgd2UgYXJlIG5vdCBzaG93aW5nIHRoZSBsYWJlbHNcbiAgICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIHRoaXMudGlja3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0fSA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nICogMjtcbiAgICAgICAgY29uc3QgYW5nbGVSYWRpYW5zID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG5cbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAvLyBBIGhvcml6b250YWwgYXhpcyBpcyBtb3JlIGNvbnN0cmFpbmVkIGJ5IHRoZSBoZWlnaHQuXG4gICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgbWluU2l6ZS5oZWlnaHQgKyBsYWJlbEhlaWdodCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQSB2ZXJ0aWNhbCBheGlzIGlzIG1vcmUgY29uc3RyYWluZWQgYnkgdGhlIHdpZHRoLiBMYWJlbHMgYXJlIHRoZVxuICAgICAgICAvLyBkb21pbmFudCBmYWN0b3IgaGVyZSwgc28gZ2V0IHRoYXQgbGVuZ3RoIGZpcnN0IGFuZCBhY2NvdW50IGZvciBwYWRkaW5nXG4gICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBjb3MgKiB3aWRlc3Qud2lkdGggKyBzaW4gKiBoaWdoZXN0LmhlaWdodDtcblxuICAgICAgICAgIG1pblNpemUud2lkdGggPSBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCBtaW5TaXplLndpZHRoICsgbGFiZWxXaWR0aCArIHRpY2tQYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faGFuZGxlTWFyZ2lucygpO1xuXG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LndpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSBtaW5TaXplLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9sZW5ndGggPSBjaGFydC5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgIGNvbnN0IHt0aWNrczoge2FsaWduLCBwYWRkaW5nfSwgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGlzUm90YXRlZCA9IHRoaXMubGFiZWxSb3RhdGlvbiAhPT0gMDtcbiAgICBjb25zdCBsYWJlbHNCZWxvd1RpY2tzID0gcG9zaXRpb24gIT09ICd0b3AnICYmIHRoaXMuYXhpcyA9PT0gJ3gnO1xuXG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSB0aGlzLmdldFBpeGVsRm9yVGljaygwKSAtIHRoaXMubGVmdDtcbiAgICAgIGNvbnN0IG9mZnNldFJpZ2h0ID0gdGhpcy5yaWdodCAtIHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKHRoaXMudGlja3MubGVuZ3RoIC0gMSk7XG4gICAgICBsZXQgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgbGV0IHBhZGRpbmdSaWdodCA9IDA7XG5cbiAgICAgIC8vIEVuc3VyZSB0aGF0IG91ciB0aWNrcyBhcmUgYWx3YXlzIGluc2lkZSB0aGUgY2FudmFzLiBXaGVuIHJvdGF0ZWQsIHRpY2tzIGFyZSByaWdodCBhbGlnbmVkXG4gICAgICAvLyB3aGljaCBtZWFucyB0aGF0IHRoZSByaWdodCBwYWRkaW5nIGlzIGRvbWluYXRlZCBieSB0aGUgZm9udCBoZWlnaHRcbiAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IGNvcyAqIGZpcnN0LndpZHRoO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHNpbiAqIGxhc3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gc2luICogZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGNvcyAqIGxhc3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRqdXN0IHBhZGRpbmcgdGFraW5nIGludG8gYWNjb3VudCBjaGFuZ2VzIGluIG9mZnNldHNcbiAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XG4gICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KChwYWRkaW5nUmlnaHQgLSBvZmZzZXRSaWdodCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG5cbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwYWRkaW5nVG9wID0gMDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodDtcbiAgICAgICAgcGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nO1xuICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbSArIHBhZGRpbmc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEhhbmRsZSBtYXJnaW5zIGFuZCBwYWRkaW5nIGludGVyYWN0aW9uc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgaWYgKHRoaXMuX21hcmdpbnMpIHtcbiAgICAgIHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1RvcCwgdGhpcy5fbWFyZ2lucy50b3ApO1xuICAgICAgdGhpcy5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1JpZ2h0LCB0aGlzLl9tYXJnaW5zLnJpZ2h0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJGaXQoKSB7XG4gICAgY2FsbCh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG4gIH1cblxuICAvLyBTaGFyZWQgTWV0aG9kc1xuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCB7YXhpcywgcG9zaXRpb259ID0gdGhpcy5vcHRpb25zO1xuICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IGF4aXMgPT09ICd4JztcbiAgfVxuICAvKipcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG4gIGlzRnVsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge1RpY2tbXX0gdGlja3Ncblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykge1xuICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG5cbiAgICB0aGlzLmdlbmVyYXRlVGlja0xhYmVscyh0aWNrcyk7XG5cbiAgICAvLyBUaWNrcyBzaG91bGQgYmUgc2tpcHBlZCB3aGVuIGNhbGxiYWNrIHJldHVybnMgbnVsbCBvciB1bmRlZiwgc28gbGV0cyByZW1vdmUgdGhvc2UuXG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodGlja3NbaV0ubGFiZWwpKSB7XG4gICAgICAgIHRpY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaWxlbi0tO1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEByZXR1cm4ge3sgZmlyc3Q6IG9iamVjdCwgbGFzdDogb2JqZWN0LCB3aWRlc3Q6IG9iamVjdCwgaGlnaGVzdDogb2JqZWN0LCB3aWR0aHM6IEFycmF5LCBoZWlnaHRzOiBhcnJheSB9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xuXG4gICAgaWYgKCFsYWJlbFNpemVzKSB7XG4gICAgICBjb25zdCBzYW1wbGVTaXplID0gdGhpcy5vcHRpb25zLnRpY2tzLnNhbXBsZVNpemU7XG4gICAgICBsZXQgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgaWYgKHNhbXBsZVNpemUgPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgdGlja3MgPSBzYW1wbGUodGlja3MsIHNhbXBsZVNpemUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IHRoaXMuX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCB0aWNrcy5sZW5ndGgsIHRoaXMub3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWxTaXplcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHt3aWR0aCwgaGVpZ2h0LCBvZmZzZXR9IG9iamVjdHMgZm9yIHRoZSBmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0IHRpY2tcblx0ICogbGFiZWxzIHdoZXJlIG9mZnNldCBpbmRpY2F0ZXMgdGhlIGFuY2hvciBwb2ludCBvZmZzZXQgZnJvbSB0aGUgdG9wIGluIHBpeGVscy5cblx0ICogQHJldHVybiB7eyBmaXJzdDogb2JqZWN0LCBsYXN0OiBvYmplY3QsIHdpZGVzdDogb2JqZWN0LCBoaWdoZXN0OiBvYmplY3QsIHdpZHRoczogQXJyYXksIGhlaWdodHM6IGFycmF5IH19XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIGxlbmd0aCwgbWF4VGlja3NMaW1pdCkge1xuICAgIGNvbnN0IHtjdHgsIF9sb25nZXN0VGV4dENhY2hlOiBjYWNoZXN9ID0gdGhpcztcbiAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRzID0gW107XG4gICAgY29uc3QgaW5jcmVtZW50ID0gTWF0aC5mbG9vcihsZW5ndGggLyBnZXRUaWNrc0xpbWl0KGxlbmd0aCwgbWF4VGlja3NMaW1pdCkpO1xuICAgIGxldCB3aWRlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBoaWdoZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaSwgaiwgamxlbiwgbGFiZWwsIHRpY2tGb250LCBmb250U3RyaW5nLCBjYWNoZSwgbGluZUhlaWdodCwgd2lkdGgsIGhlaWdodCwgbmVzdGVkTGFiZWw7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGluY3JlbWVudCkge1xuICAgICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcbiAgICAgIHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgLy8gVW5kZWZpbmVkIGxhYmVscyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihsYWJlbCkgJiYgIWlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XG4gICAgICAgIGhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldCdzIG1lYXN1cmUgZWFjaCBlbGVtZW50XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBuZXN0ZWRMYWJlbCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAobGFiZWxbal0pO1xuICAgICAgICAgIC8vIFVuZGVmaW5lZCBsYWJlbHMgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuXG4gICAgY29uc3Qgd2lkZXN0ID0gd2lkdGhzLmluZGV4T2Yod2lkZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCBoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKGhpZ2hlc3RMYWJlbFNpemUpO1xuXG4gICAgY29uc3QgdmFsdWVBdCA9IChpZHgpID0+ICh7d2lkdGg6IHdpZHRoc1tpZHhdIHx8IDAsIGhlaWdodDogaGVpZ2h0c1tpZHhdIHx8IDB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICB3aWR0aHMsXG4gICAgICBoZWlnaHRzLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIGxhYmVsIHRvIGRpc3BsYXkgaW4gdGhlIHRvb2x0aXAgZm9yIHRoZSBnaXZlbiB2YWx1ZVxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB0aGUgbG9jYXRpb24gb2YgdGhlIGdpdmVuIGRhdGEgcG9pbnQuIFZhbHVlIGNhbiBlaXRoZXIgYmUgYW4gaW5kZXggb3IgYSBudW1lcmljYWwgdmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSwgaW5kZXgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICAvKipcblx0ICogVXNlZCB0byBnZXQgdGhlIGRhdGEgdmFsdWUgZnJvbSBhIGdpdmVuIHBpeGVsLiBUaGlzIGlzIHRoZSBpbnZlcnNlIG9mIGdldFBpeGVsRm9yVmFsdWVcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsb2NhdGlvbiBvZiB0aGUgdGljayBhdCB0aGUgZ2l2ZW4gaW5kZXhcblx0ICogVGhlIGNvb3JkaW5hdGUgKDAsIDApIGlzIGF0IHRoZSB1cHBlci1sZWZ0IGNvcm5lciBvZiB0aGUgY2FudmFzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogVXRpbGl0eSBmb3IgZ2V0dGluZyB0aGUgcGl4ZWwgbG9jYXRpb24gb2YgYSBwZXJjZW50YWdlIG9mIHNjYWxlXG5cdCAqIFRoZSBjb29yZGluYXRlICgwLCAwKSBpcyBhdCB0aGUgdXBwZXItbGVmdCBjb3JuZXIgb2YgdGhlIGNhbnZhc1xuXHQgKiBAcGFyYW0ge251bWJlcn0gZGVjaW1hbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRQaXhlbEZvckRlY2ltYWwoZGVjaW1hbCkge1xuICAgIGlmICh0aGlzLl9yZXZlcnNlUGl4ZWxzKSB7XG4gICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XG4gICAgfVxuXG4gICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gX2ludDE2UmFuZ2UodGhpcy5fYWxpZ25Ub1BpeGVscyA/IF9hbGlnblBpeGVsKHRoaXMuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHBpeGVsIGZvciB0aGUgbWluaW11bSBjaGFydCB2YWx1ZVxuXHQgKiBUaGUgY29vcmRpbmF0ZSAoMCwgMCkgaXMgYXQgdGhlIHVwcGVyLWxlZnQgY29ybmVyIG9mIHRoZSBjYW52YXNcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIG1pbiA8IDAgJiYgbWF4IDwgMCA/IG1heCA6XG4gICAgICBtaW4gPiAwICYmIG1heCA+IDAgPyBtaW4gOlxuICAgICAgMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzIHx8IFtdO1xuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgICByZXR1cm4gdGljay4kY29udGV4dCB8fFxuXHRcdFx0XHQodGljay4kY29udGV4dCA9IGNyZWF0ZVRpY2tDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgdGljaykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVTY2FsZUNvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdGlja1NpemUoKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG5cbiAgICAvLyBDYWxjdWxhdGUgc3BhY2UgbmVlZGVkIGJ5IGxhYmVsIGluIGF4aXMgZGlyZWN0aW9uLlxuICAgIGNvbnN0IHJvdCA9IHRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKHJvdCkpO1xuICAgIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdCkpO1xuXG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG4gICAgY29uc3QgdyA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLndpZGVzdC53aWR0aCArIHBhZGRpbmcgOiAwO1xuICAgIGNvbnN0IGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHNwYWNlIG5lZWRlZCBmb3IgMSB0aWNrIGluIGF4aXMgZGlyZWN0aW9uLlxuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IGggKiBjb3MgPiB3ICogc2luID8gdyAvIGNvcyA6IGggLyBzaW5cbiAgICAgIDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2lzVmlzaWJsZSgpIHtcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5vcHRpb25zLmRpc3BsYXk7XG5cbiAgICBpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gISFkaXNwbGF5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2dyaWQsIHBvc2l0aW9uLCBib3JkZXJ9ID0gb3B0aW9ucztcbiAgICBjb25zdCBvZmZzZXQgPSBncmlkLm9mZnNldDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXQgPyAxIDogMCk7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuXG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGJvcmRlci5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRpc3BsYXkgPyBib3JkZXJPcHRzLndpZHRoIDogMDtcbiAgICBjb25zdCBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcbiAgICBjb25zdCBhbGlnbkJvcmRlclZhbHVlID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XG4gICAgfTtcbiAgICBsZXQgYm9yZGVyVmFsdWUsIGksIGxpbmVWYWx1ZSwgYWxpZ25lZExpbmVWYWx1ZTtcbiAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmJvdHRvbSk7XG4gICAgICB0eTEgPSB0aGlzLmJvdHRvbSAtIHRsO1xuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMudG9wKTtcbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0aGlzLnRvcCArIHRsO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMucmlnaHQpO1xuICAgICAgdHgxID0gdGhpcy5yaWdodCAtIHRsO1xuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5sZWZ0KTtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0aGlzLmxlZnQgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyAwLjUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cblxuICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdHkxICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHR4MSAtIHRsO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH1cblxuICAgIGNvbnN0IGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0LCB0aWNrc0xlbmd0aCk7XG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0aWNrc0xlbmd0aCAvIGxpbWl0KSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRpY2tzTGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaSk7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG5cbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IG9wdHNBdEluZGV4LmxpbmVXaWR0aDtcbiAgICAgIGNvbnN0IGxpbmVDb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4Qm9yZGVyLmRhc2ggfHwgW107XG4gICAgICBjb25zdCBib3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaE9mZnNldDtcblxuICAgICAgY29uc3QgdGlja1dpZHRoID0gb3B0c0F0SW5kZXgudGlja1dpZHRoO1xuICAgICAgY29uc3QgdGlja0NvbG9yID0gb3B0c0F0SW5kZXgudGlja0NvbG9yO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2ggPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgIGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUodGhpcywgaSwgb2Zmc2V0KTtcblxuICAgICAgLy8gU2tpcCBpZiB0aGUgcGl4ZWwgaXMgb3V0IG9mIHRoZSByYW5nZVxuICAgICAgaWYgKGxpbmVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBhbGlnbmVkTGluZVZhbHVlID0gX2FsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcblxuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgdHgxLFxuICAgICAgICB0eTEsXG4gICAgICAgIHR4MixcbiAgICAgICAgdHkyLFxuICAgICAgICB4MSxcbiAgICAgICAgeTEsXG4gICAgICAgIHgyLFxuICAgICAgICB5MixcbiAgICAgICAgd2lkdGg6IGxpbmVXaWR0aCxcbiAgICAgICAgY29sb3I6IGxpbmVDb2xvcixcbiAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgdGlja1dpZHRoLFxuICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcblxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiBvcHRpb25UaWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHthbGlnbiwgY3Jvc3NBbGlnbiwgcGFkZGluZywgbWlycm9yfSA9IG9wdGlvblRpY2tzO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCBoVGlja0FuZFBhZGRpbmcgPSBtaXJyb3IgPyAtcGFkZGluZyA6IHRpY2tBbmRQYWRkaW5nO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XG4gICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgeSA9IHRoaXMuYm90dG9tIC0gaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB5ID0gdGhpcy50b3AgKyBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHkgPSAoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHkgPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0gKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKSAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB4ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkudGV4dEFsaWduO1xuICAgIH1cblxuICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgbGFiZWwgPSB0aWNrLmxhYmVsO1xuXG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIHBpeGVsID0gdGhpcy5nZXRQaXhlbEZvclRpY2soaSkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcbiAgICAgIGZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcbiAgICAgIGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGhhbGZDb3VudCA9IGxpbmVDb3VudCAvIDI7XG4gICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3I7XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aDtcbiAgICAgIGxldCB0aWNrVGV4dEFsaWduID0gdGV4dEFsaWduO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIHggPSBwaXhlbDtcblxuICAgICAgICBpZiAodGV4dEFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGlsZW4gLSAxKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGluZUNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lbHktaWZcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgICAgdGV4dE9mZnNldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm90YXRpb24gIT09IDAgJiYgIW9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgICAgeCArPSAobGluZUhlaWdodCAvIDIpICogTWF0aC5zaW4ocm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ID0gcGl4ZWw7XG4gICAgICAgIHRleHRPZmZzZXQgPSAoMSAtIGxpbmVDb3VudCkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgbGV0IGJhY2tkcm9wO1xuXG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxhYmVsU2l6ZXMuaGVpZ2h0c1tpXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYWJlbFNpemVzLndpZHRoc1tpXTtcblxuICAgICAgICBsZXQgdG9wID0gdGV4dE9mZnNldCAtIGxhYmVsUGFkZGluZy50b3A7XG4gICAgICAgIGxldCBsZWZ0ID0gMCAtIGxhYmVsUGFkZGluZy5sZWZ0O1xuXG4gICAgICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbm5lcic6XG4gICAgICAgICAgaWYgKGkgPT09IGlsZW4gLSAxKSB7XG4gICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGJhY2tkcm9wID0ge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGxhYmVsUGFkZGluZy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGxhYmVsUGFkZGluZy5oZWlnaHQsXG5cbiAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvcixcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmb250LFxuICAgICAgICB0ZXh0T2Zmc2V0LFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgdGV4dEFsaWduOiB0aWNrVGV4dEFsaWduLFxuICAgICAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgICAgICB0cmFuc2xhdGlvbjogW3gsIHldLFxuICAgICAgICAgIGJhY2tkcm9wLFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cblxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcblxuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuXG4gICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG5cbiAgICBpZiAodGlja3MuYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgYWxpZ24gPSAnaW5uZXInO1xuICAgIH1cblxuICAgIHJldHVybiBhbGlnbjtcbiAgfVxuXG4gIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKSB7XG4gICAgY29uc3Qge3Bvc2l0aW9uLCB0aWNrczoge2Nyb3NzQWxpZ24sIG1pcnJvciwgcGFkZGluZ319ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgY29uc3Qgd2lkZXN0ID0gbGFiZWxTaXplcy53aWRlc3Qud2lkdGg7XG5cbiAgICBsZXQgdGV4dEFsaWduO1xuICAgIGxldCB4O1xuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgKyBwYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggKz0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5yaWdodCAtIHRpY2tBbmRQYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggPSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuXG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggLT0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG5cbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gd2lkZXN0IC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgIHggPSB0aGlzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHt0ZXh0QWxpZ24sIHh9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZUxhYmVsQXJlYSgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRpY2tzLm1pcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogdGhpcy5sZWZ0LCBib3R0b206IGNoYXJ0LmhlaWdodCwgcmlnaHQ6IHRoaXMucmlnaHR9O1xuICAgIH0gaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiB7dG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge2JhY2tncm91bmRDb2xvcn0sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldExpbmVXaWR0aEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWdyaWQuZGlzcGxheSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCBpbmRleCA9IHRpY2tzLmZpbmRJbmRleCh0ID0+IHQudmFsdWUgPT09IHZhbHVlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgY29uc3Qgb3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIHJldHVybiBvcHRzLmxpbmVXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0dyaWQoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ3JpZExpbmVJdGVtcyB8fCAodGhpcy5fZ3JpZExpbmVJdGVtcyA9IHRoaXMuX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgY29uc3QgZHJhd0xpbmUgPSAocDEsIHAyLCBzdHlsZSkgPT4ge1xuICAgICAgaWYgKCFzdHlsZS53aWR0aCB8fCAhc3R5bGUuY29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHN0eWxlLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUuYm9yZGVyRGFzaE9mZnNldDtcblxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG5cbiAgICBpZiAoZ3JpZC5kaXNwbGF5KSB7XG4gICAgICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICBpZiAoZ3JpZC5kcmF3T25DaGFydEFyZWEpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLngxLCB5OiBpdGVtLnkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLngyLCB5OiBpdGVtLnkyfSxcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MiwgeTogaXRlbS50eTJ9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoOiBpdGVtLnRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaDogaXRlbS50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCB7Y2hhcnQsIGN0eCwgb3B0aW9uczoge2JvcmRlciwgZ3JpZH19ID0gdGhpcztcbiAgICBjb25zdCBib3JkZXJPcHRzID0gYm9yZGVyLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlci5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgaWYgKCFheGlzV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgIGxldCB4MSwgeDIsIHkxLCB5MjtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB4MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmxlZnQsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeDIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5yaWdodCwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHkxID0geTIgPSBib3JkZXJWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgeTEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy50b3AsIGF4aXNXaWR0aCkgLSBheGlzV2lkdGggLyAyO1xuICAgICAgeTIgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5ib3R0b20sIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB4MSA9IHgyID0gYm9yZGVyVmFsdWU7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlck9wdHMud2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyT3B0cy5jb2xvcjtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0xhYmVscyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcblxuICAgIGlmICghb3B0aW9uVGlja3MuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2NvbXB1dGVMYWJlbEFyZWEoKTtcbiAgICBpZiAoYXJlYSkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEpO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgY29uc3QgcmVuZGVyVGV4dE9wdGlvbnMgPSBpdGVtLm9wdGlvbnM7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IGl0ZW0uZm9udDtcbiAgICAgIGNvbnN0IGxhYmVsID0gaXRlbS5sYWJlbDtcbiAgICAgIGNvbnN0IHkgPSBpdGVtLnRleHRPZmZzZXQ7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGFiZWwsIDAsIHksIHRpY2tGb250LCByZW5kZXJUZXh0T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd1RpdGxlKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb3NpdGlvbiwgdGl0bGUsIHJldmVyc2V9fSA9IHRoaXM7XG5cbiAgICBpZiAoIXRpdGxlLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmb250ID0gdG9Gb250KHRpdGxlLmZvbnQpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGUucGFkZGluZyk7XG4gICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICBsZXQgb2Zmc2V0ID0gZm9udC5saW5lSGVpZ2h0IC8gMjtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb24gPT09ICdjZW50ZXInIHx8IGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcuYm90dG9tO1xuICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcbiAgICAgICAgb2Zmc2V0ICs9IGZvbnQubGluZUhlaWdodCAqICh0aXRsZS50ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy50b3A7XG4gICAgfVxuXG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcblxuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZS50ZXh0LCAwLCAwLCBmb250LCB7XG4gICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cblxuICBkcmF3KGNoYXJ0QXJlYSkge1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gIH1cblxuICAvKipcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdHogPSBvcHRzLnRpY2tzICYmIG9wdHMudGlja3MueiB8fCAwO1xuICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgY29uc3QgYnogPSB2YWx1ZU9yRGVmYXVsdChvcHRzLmJvcmRlciAmJiBvcHRzLmJvcmRlci56LCAwKTtcblxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eTogZHJhdyBoYXMgYmVlbiBvdmVycmlkZGVuIGJ5IGN1c3RvbSBzY2FsZVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IHR6LFxuICAgICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cblxuICAgIHJldHVybiBbe1xuICAgICAgejogZ3osXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGJ6LFxuICAgICAgZHJhdzogKCkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiB0eixcbiAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfV07XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyB2aXNpYmxlIGRhdGFzZXQgbWV0YXMgdGhhdCBhcmUgYXR0YWNoZWQgdG8gdGhpcyBzY2FsZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gaWYgc3BlY2lmaWVkLCBhbHNvIGZpbHRlciBieSBkYXRhc2V0IHR5cGVcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqL1xuICBnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKSB7XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBheGlzSUQgPSB0aGlzLmF4aXMgKyAnQXhpc0lEJztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICAgIGlmIChtZXRhW2F4aXNJRF0gPT09IHRoaXMuaWQgJiYgKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG5cdCAqIEByZXR1cm4ge29iamVjdH1cblx0ICogQHByb3RlY3RlZFxuIFx0ICovXG4gIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgIHJldHVybiB0b0ZvbnQob3B0cy5mb250KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfbWF4RGlnaXRzKCkge1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5saW5lSGVpZ2h0O1xuICAgIHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodCkgLyBmb250U2l6ZTtcbiAgfVxufVxuIiwgImltcG9ydCB7bWVyZ2V9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzfSBmcm9tICcuL2NvcmUuZGVmYXVsdHMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7aWQ6IHN0cmluZywgZGVmYXVsdHM6IGFueSwgb3ZlcnJpZGVzPzogYW55LCBkZWZhdWx0Um91dGVzOiBhbnl9fSBJQ2hhcnRDb21wb25lbnRcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzY29wZSB3aGVyZSBpdGVtcyBkZWZhdWx0cyB3ZXJlIHJlZ2lzdGVyZWQgdG8uXG5cdCAqL1xuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XG4gICAgbGV0IHBhcmVudFNjb3BlO1xuXG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJlbnQgaXMgcmVnaXN0ZXJlZCBhbmQgbm90ZSB0aGUgc2NvcGUgd2hlcmUgaXRzIGRlZmF1bHRzIGFyZS5cbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcblxuICAgIGlmICghaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xhc3MgZG9lcyBub3QgaGF2ZSBpZDogJyArIGl0ZW0pO1xuICAgIH1cblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgLy8gYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuXG4gICAgaXRlbXNbaWRdID0gaXRlbTtcbiAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgIGRlZmF1bHRzLm92ZXJyaWRlKGl0ZW0uaWQsIGl0ZW0ub3ZlcnJpZGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHtvYmplY3Q/fVxuXHQgKi9cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7SUNoYXJ0Q29tcG9uZW50fSBpdGVtXG5cdCAqL1xuICB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgY29uc3QgaWQgPSBpdGVtLmlkO1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcblxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSkge1xuICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkZWZhdWx0cyBhbmQga2VlcCBleGlzdGluZyBkZWZhdWx0c1xuICBjb25zdCBpdGVtRGVmYXVsdHMgPSBtZXJnZShPYmplY3QuY3JlYXRlKG51bGwpLCBbXG4gICAgcGFyZW50U2NvcGUgPyBkZWZhdWx0cy5nZXQocGFyZW50U2NvcGUpIDoge30sXG4gICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICBpdGVtLmRlZmF1bHRzXG4gIF0pO1xuXG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcblxuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuXG4gIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoc2NvcGUsIGl0ZW0uZGVzY3JpcHRvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cbiIsICJpbXBvcnQgRGF0YXNldENvbnRyb2xsZXIgZnJvbSAnLi9jb3JlLmRhdGFzZXRDb250cm9sbGVyLmpzJztcbmltcG9ydCBFbGVtZW50IGZyb20gJy4vY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IFR5cGVkUmVnaXN0cnkgZnJvbSAnLi9jb3JlLnR5cGVkUmVnaXN0cnkuanMnO1xuaW1wb3J0IHtlYWNoLCBjYWxsYmFjayBhcyBjYWxsLCBfY2FwaXRhbGl6ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIFBsZWFzZSB1c2UgdGhlIG1vZHVsZSdzIGRlZmF1bHQgZXhwb3J0IHdoaWNoIHByb3ZpZGVzIGEgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBOb3RlOiBjbGFzcyBpcyBleHBvcnRlZCBmb3IgdHlwZWRvY1xuICovXG5leHBvcnQgY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIC8vIE9yZGVyIGlzIGltcG9ydGFudCwgU2NhbGUgaGFzIEVsZW1lbnQgaW4gcHJvdG90eXBlIGNoYWluLFxuICAgIC8vIHNvIFNjYWxlcyBtdXN0IGJlIGJlZm9yZSBFbGVtZW50cy4gUGx1Z2lucyBhcmUgYSBmYWxsYmFjaywgc28gbm90IGxpc3RlZCBoZXJlLlxuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG5cdCAqL1xuICBhZGQoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncyk7XG4gIH1cblxuICByZW1vdmUoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9IGFyZ3Ncblx0ICovXG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBFbGVtZW50fSBhcmdzXG5cdCAqL1xuICBhZGRFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgU2NhbGV9IGFyZ3Ncblx0ICovXG4gIGFkZFNjYWxlcyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHt0eXBlb2YgRGF0YXNldENvbnRyb2xsZXJ9XG5cdCAqL1xuICBnZXRDb250cm9sbGVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBFbGVtZW50fVxuXHQgKi9cbiAgZ2V0RWxlbWVudChpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuZWxlbWVudHMsICdlbGVtZW50Jyk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdCAqL1xuICBnZXRQbHVnaW4oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnBsdWdpbnMsICdwbHVnaW4nKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWRcblx0ICogQHJldHVybnMge3R5cGVvZiBTY2FsZX1cblx0ICovXG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBEYXRhc2V0Q29udHJvbGxlcn0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi50eXBlb2YgRWxlbWVudH0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3Ncblx0ICovXG4gIHJlbW92ZVBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnBsdWdpbnMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSAgey4uLnR5cGVvZiBTY2FsZX0gYXJnc1xuXHQgKi9cbiAgcmVtb3ZlU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZWFjaChtZXRob2QsIGFyZ3MsIHR5cGVkUmVnaXN0cnkpIHtcbiAgICBbLi4uYXJnc10uZm9yRWFjaChhcmcgPT4ge1xuICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCAocmVnID09PSB0aGlzLnBsdWdpbnMgJiYgYXJnLmlkKSkge1xuICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIGxvb3BhYmxlIGFyZ3NcbiAgICAgICAgLy8gVXNlIGNhc2U6XG4gICAgICAgIC8vICBpbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy5qcyc7XG4gICAgICAgIC8vICBDaGFydC5yZWdpc3RlcihwbHVnaW5zKTtcbiAgICAgICAgZWFjaChhcmcsIGl0ZW0gPT4ge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtaXhlZCB0eXBlcyBpbiB0aGUgbG9vcGFibGUsIG1ha2Ugc3VyZSB0aG9zZSBhcmVcbiAgICAgICAgICAvLyByZWdpc3RlcmVkIGluIGNvcnJlY3QgcmVnaXN0cnlcbiAgICAgICAgICAvLyBVc2UgY2FzZTogKHRyZWVtYXAgZXhwb3J0aW5nIGNvbnRyb2xsZXIsIGVsZW1lbnRzIGV0YylcbiAgICAgICAgICAvLyAgaW1wb3J0ICogYXMgdHJlZW1hcCBmcm9tICdjaGFydGpzLWNoYXJ0LXRyZWVtYXAuanMnO1xuICAgICAgICAgIC8vICBDaGFydC5yZWdpc3Rlcih0cmVlbWFwKTtcblxuICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgaXRlbVJlZywgaXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbChjb21wb25lbnRbJ2JlZm9yZScgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpOyAvLyBiZWZvcmVSZWdpc3RlciAvIGJlZm9yZVVucmVnaXN0ZXJcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbChjb21wb25lbnRbJ2FmdGVyJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7IC8vIGFmdGVyUmVnaXN0ZXIgLyBhZnRlclVucmVnaXN0ZXJcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldFJlZ2lzdHJ5Rm9yVHlwZSh0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl90eXBlZFJlZ2lzdHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlZyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tpXTtcbiAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiByZWc7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBsdWdpbnMgaXMgdGhlIGZhbGxiYWNrIHJlZ2lzdHJ5XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldChpZCwgdHlwZWRSZWdpc3RyeSwgdHlwZSkge1xuICAgIGNvbnN0IGl0ZW0gPSB0eXBlZFJlZ2lzdHJ5LmdldChpZCk7XG4gICAgaWYgKGl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBpZCArICdcIiBpcyBub3QgYSByZWdpc3RlcmVkICcgKyB0eXBlICsgJy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxufVxuXG4vLyBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBkZWZhdWx0IC8qICNfX1BVUkVfXyAqLyBuZXcgUmVnaXN0cnkoKTtcbiIsICJpbXBvcnQgcmVnaXN0cnkgZnJvbSAnLi9jb3JlLnJlZ2lzdHJ5LmpzJztcbmltcG9ydCB7Y2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCBpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9wbHVnaW5zL3BsdWdpbi50b29sdGlwLmpzJykuZGVmYXVsdCB9IFRvb2x0aXBcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBmaWx0ZXJDYWxsYmFja1xuICogQHBhcmFtIHt7cGx1Z2luOiBvYmplY3QsIG9wdGlvbnM6IG9iamVjdH19IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gW2luZGV4XVxuICogQHBhcmFtIHthcnJheX0gW2FycmF5XVxuICogQHBhcmFtIHtvYmplY3R9IFt0aGlzQXJnXVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBsdWdpblNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9pbml0ID0gW107XG4gIH1cblxuICAvKipcblx0ICogQ2FsbHMgZW5hYmxlZCBwbHVnaW5zIGZvciBgY2hhcnRgIG9uIHRoZSBzcGVjaWZpZWQgaG9vayBhbmQgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICogVGhpcyBtZXRob2QgaW1tZWRpYXRlbHkgcmV0dXJucyBhcyBzb29uIGFzIGEgcGx1Z2luIGV4cGxpY2l0bHkgcmV0dXJucyBmYWxzZS4gVGhlXG5cdCAqIHJldHVybmVkIHZhbHVlIGNhbiBiZSB1c2VkLCBmb3IgaW5zdGFuY2UsIHRvIGludGVycnVwdCB0aGUgY3VycmVudCBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlIGZvciB3aGljaCBwbHVnaW5zIHNob3VsZCBiZSBjYWxsZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBob29rIC0gVGhlIG5hbWUgb2YgdGhlIHBsdWdpbiBtZXRob2QgdG8gY2FsbCAoZS5nLiAnYmVmb3JlVXBkYXRlJykuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbYXJnc10gLSBFeHRyYSBhcmd1bWVudHMgdG8gYXBwbHkgdG8gdGhlIGhvb2sgY2FsbC5cbiAgICogQHBhcmFtIHtmaWx0ZXJDYWxsYmFja30gW2ZpbHRlcl0gLSBGaWx0ZXJpbmcgZnVuY3Rpb24gZm9yIGxpbWl0aW5nIHdoaWNoIHBsdWdpbnMgYXJlIG5vdGlmaWVkXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCBlbHNlIHJldHVybnMgdHJ1ZS5cblx0ICovXG4gIG5vdGlmeShjaGFydCwgaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgaWYgKGhvb2sgPT09ICdiZWZvcmVJbml0Jykge1xuICAgICAgdGhpcy5faW5pdCA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB0cnVlKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ2luc3RhbGwnKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IGZpbHRlciA/IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KS5maWx0ZXIoZmlsdGVyKSA6IHRoaXMuX2Rlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKTtcblxuICAgIGlmIChob29rID09PSAnYWZ0ZXJEZXN0cm95Jykge1xuICAgICAgdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgJ3N0b3AnKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ3VuaW5zdGFsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgIGZvciAoY29uc3QgZGVzY3JpcHRvciBvZiBkZXNjcmlwdG9ycykge1xuICAgICAgY29uc3QgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICBjb25zdCBtZXRob2QgPSBwbHVnaW5baG9va107XG4gICAgICBjb25zdCBwYXJhbXMgPSBbY2hhcnQsIGFyZ3MsIGRlc2NyaXB0b3Iub3B0aW9uc107XG4gICAgICBpZiAoY2FsbENhbGxiYWNrKG1ldGhvZCwgcGFyYW1zLCBwbHVnaW4pID09PSBmYWxzZSAmJiBhcmdzLmNhbmNlbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICAvLyBXaGVuIHBsdWdpbnMgYXJlIHJlZ2lzdGVyZWQsIHRoZXJlIGlzIHRoZSBwb3NzaWJpbGl0eSBvZiBhIGRvdWJsZVxuICAgIC8vIGludmFsaWRhdGUgc2l0dWF0aW9uLiBJbiB0aGlzIGNhc2UsIHdlIG9ubHkgd2FudCB0byBpbnZhbGlkYXRlIG9uY2UuXG4gICAgLy8gSWYgd2UgaW52YWxpZGF0ZSBtdWx0aXBsZSB0aW1lcywgdGhlIGBfb2xkQ2FjaGVgIGlzIGxvc3QgYW5kIGFsbCBvZiB0aGVcbiAgICAvLyBwbHVnaW5zIGFyZSByZXN0YXJ0ZWQgd2l0aG91dCBiZWluZyBjb3JyZWN0bHkgc3RvcHBlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzgxNDdcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodGhpcy5fY2FjaGUpKSB7XG4gICAgICB0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgdGhpcy5fY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICBpZiAodGhpcy5fY2FjaGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQpO1xuXG4gICAgdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgfVxuXG4gIF9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgYWxsKSB7XG4gICAgY29uc3QgY29uZmlnID0gY2hhcnQgJiYgY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgY29uc3QgcGx1Z2lucyA9IGFsbFBsdWdpbnMoY29uZmlnKTtcbiAgICAvLyBvcHRpb25zID09PSBmYWxzZSA9PiBhbGwgcGx1Z2lucyBhcmUgZGlzYWJsZWRcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gZmFsc2UgJiYgIWFsbCA/IFtdIDogY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtDaGFydH0gY2hhcnRcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9ub3RpZnlTdGF0ZUNoYW5nZXMoY2hhcnQpIHtcbiAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZTtcbiAgICBjb25zdCBkaWZmID0gKGEsIGIpID0+IGEuZmlsdGVyKHggPT4gIWIuc29tZSh5ID0+IHgucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKHByZXZpb3VzRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKSwgY2hhcnQsICdzdG9wJyk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYoZGVzY3JpcHRvcnMsIHByZXZpb3VzRGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0YXJ0Jyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLmNvbmZpZy5qcycpLmRlZmF1bHR9IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBhbGxQbHVnaW5zKGNvbmZpZykge1xuICBjb25zdCBsb2NhbElkcyA9IHt9O1xuICBjb25zdCBwbHVnaW5zID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbHVnaW5zLml0ZW1zKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGx1Z2lucy5wdXNoKHJlZ2lzdHJ5LmdldFBsdWdpbihrZXlzW2ldKSk7XG4gIH1cblxuICBjb25zdCBsb2NhbCA9IGNvbmZpZy5wbHVnaW5zIHx8IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcGx1Z2luID0gbG9jYWxbaV07XG5cbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIGxvY2FsSWRzW3BsdWdpbi5pZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7cGx1Z2lucywgbG9jYWxJZHN9O1xufVxuXG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICBpZiAoIWFsbCAmJiBvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwge3BsdWdpbnMsIGxvY2FsSWRzfSwgb3B0aW9ucywgYWxsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBjb250ZXh0ID0gY2hhcnQuZ2V0Q29udGV4dCgpO1xuXG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCBvcHRzID0gZ2V0T3B0cyhvcHRpb25zW2lkXSwgYWxsKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHBsdWdpbixcbiAgICAgIG9wdGlvbnM6IHBsdWdpbk9wdHMoY2hhcnQuY29uZmlnLCB7cGx1Z2luLCBsb2NhbDogbG9jYWxJZHNbaWRdfSwgb3B0cywgY29udGV4dClcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCB7cGx1Z2luLCBsb2NhbH0sIG9wdHMsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhvcHRzLCBrZXlzKTtcbiAgaWYgKGxvY2FsICYmIHBsdWdpbi5kZWZhdWx0cykge1xuICAgIC8vIG1ha2Ugc3VyZSBwbHVnaW4gZGVmYXVsdHMgYXJlIGluIHNjb3BlcyBmb3IgbG9jYWwgKG5vdCByZWdpc3RlcmVkKSBwbHVnaW5zXG4gICAgc2NvcGVzLnB1c2gocGx1Z2luLmRlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgWycnXSwge1xuICAgIC8vIFRoZXNlIGFyZSBqdXN0IGRlZmF1bHRzIHRoYXQgcGx1Z2lucyBjYW4gb3ZlcnJpZGVcbiAgICBzY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBpbmRleGFibGU6IGZhbHNlLFxuICAgIGFsbEtleXM6IHRydWVcbiAgfSk7XG59XG4iLCAiaW1wb3J0IGRlZmF1bHRzLCB7b3ZlcnJpZGVzLCBkZXNjcmlwdG9yc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7bWVyZ2VJZiwgcmVzb2x2ZU9iamVjdEtleSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgdmFsdWVPckRlZmF1bHQsIGlzT2JqZWN0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge19hdHRhY2hDb250ZXh0LCBfY3JlYXRlUmVzb2x2ZXIsIF9kZXNjcmlwdG9yc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvbmZpZy5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucykge1xuICBjb25zdCBkYXRhc2V0RGVmYXVsdHMgPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fTtcbiAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gIHJldHVybiBkYXRhc2V0T3B0aW9ucy5pbmRleEF4aXMgfHwgb3B0aW9ucy5pbmRleEF4aXMgfHwgZGF0YXNldERlZmF1bHRzLmluZGV4QXhpcyB8fCAneCc7XG59XG5cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICBsZXQgYXhpcyA9IGlkO1xuICBpZiAoaWQgPT09ICdfaW5kZXhfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXM7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdfdmFsdWVfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgfVxuICByZXR1cm4gYXhpcztcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cblxuZnVuY3Rpb24gaWRNYXRjaGVzQXhpcyhpZCkge1xuICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knIHx8IGlkID09PSAncicpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXhpc0Zyb21Qb3NpdGlvbihwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgIHJldHVybiAneCc7XG4gIH1cbiAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICByZXR1cm4gJ3knO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmVBeGlzKGlkLCAuLi5zY2FsZU9wdGlvbnMpIHtcbiAgaWYgKGlkTWF0Y2hlc0F4aXMoaWQpKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIGZvciAoY29uc3Qgb3B0cyBvZiBzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBheGlzID0gb3B0cy5heGlzXG4gICAgICB8fCBheGlzRnJvbVBvc2l0aW9uKG9wdHMucG9zaXRpb24pXG4gICAgICB8fCBpZC5sZW5ndGggPiAxICYmIGlkTWF0Y2hlc0F4aXMoaWRbMF0udG9Mb3dlckNhc2UoKSk7XG4gICAgaWYgKGF4aXMpIHtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZXRlcm1pbmUgdHlwZSBvZiAnJHtpZH0nIGF4aXMuIFBsZWFzZSBwcm92aWRlICdheGlzJyBvciAncG9zaXRpb24nIG9wdGlvbi5gKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCBheGlzLCBkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gPT09IGlkKSB7XG4gICAgcmV0dXJuIHtheGlzfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMoaWQsIGNvbmZpZykge1xuICBpZiAoY29uZmlnLmRhdGEgJiYgY29uZmlnLmRhdGEuZGF0YXNldHMpIHtcbiAgICBjb25zdCBib3VuZERzID0gY29uZmlnLmRhdGEuZGF0YXNldHMuZmlsdGVyKChkKSA9PiBkLnhBeGlzSUQgPT09IGlkIHx8IGQueUF4aXNJRCA9PT0gaWQpO1xuICAgIGlmIChib3VuZERzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGdldEF4aXNGcm9tRGF0YXNldChpZCwgJ3gnLCBib3VuZERzWzBdKSB8fCBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd5JywgYm91bmREc1swXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge3NjYWxlczoge319O1xuICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgY29uc3QgY2hhcnRJbmRleEF4aXMgPSBnZXRJbmRleEF4aXMoY29uZmlnLnR5cGUsIG9wdGlvbnMpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vIEZpcnN0IGZpZ3VyZSBvdXQgZmlyc3Qgc2NhbGUgaWQncyBwZXIgYXhpcy5cbiAgT2JqZWN0LmtleXMoY29uZmlnU2NhbGVzKS5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgIGlmICghaXNPYmplY3Qoc2NhbGVDb25mKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZUNvbmYsIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSwgZGVmYXVsdHMuc2NhbGVzW3NjYWxlQ29uZi50eXBlXSk7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIHNjYWxlc1tpZF0gPSBtZXJnZUlmKE9iamVjdC5jcmVhdGUobnVsbCksIFt7YXhpc30sIHNjYWxlQ29uZiwgZGVmYXVsdFNjYWxlT3B0aW9uc1theGlzXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXSk7XG4gIH0pO1xuXG4gIC8vIFRoZW4gbWVyZ2UgZGF0YXNldCBkZWZhdWx0cyB0byBzY2FsZSBjb25maWdzXG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gYXBwbHkgc2NhbGUgZGVmYXVsdHMsIGlmIG5vdCBvdmVycmlkZGVuIGJ5IGRhdGFzZXQgZGVmYXVsdHNcbiAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBzY2FsZXNba2V5XTtcbiAgICBtZXJnZUlmKHNjYWxlLCBbZGVmYXVsdHMuc2NhbGVzW3NjYWxlLnR5cGVdLCBkZWZhdWx0cy5zY2FsZV0pO1xuICB9KTtcblxuICByZXR1cm4gc2NhbGVzO1xufVxuXG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcblxuICBvcHRpb25zLnBsdWdpbnMgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgb3B0aW9ucy5zY2FsZXMgPSBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGluaXREYXRhKGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICBkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcblxuICBpbml0T3B0aW9ucyhjb25maWcpO1xuXG4gIHJldHVybiBjb25maWc7XG59XG5cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gY2FjaGVkS2V5cyhjYWNoZUtleSwgZ2VuZXJhdGUpIHtcbiAgbGV0IGtleXMgPSBrZXlDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gZ2VuZXJhdGUoKTtcbiAgICBrZXlDYWNoZS5zZXQoY2FjaGVLZXksIGtleXMpO1xuICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuXG5jb25zdCBhZGRJZkZvdW5kID0gKHNldCwgb2JqLCBrZXkpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpO1xuICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0LmFkZChvcHRzKTtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGdldCBwbGF0Zm9ybSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICB9XG5cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgfVxuXG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG5cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuXG4gIGNsZWFyQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgb3B0aW9ucy5cbiAgICogVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXQgaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcmV0dXJuIHtzdHJpbmdbXVtdfVxuICAgKi9cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb24gc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIGRhdGFzZXQgYW5pbWF0aW9uIG9wdGlvbnMuXG4gICAqIFRoZXNlIGtleXMgZG8gbm90IGluY2x1ZGUgdGhlIGRhdGFzZXQgaXRzZWxmLCBiZWNhdXNlIGl0IGlzIG5vdCB1bmRlciBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YXNldFR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zaXRpb25cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbi4ke3RyYW5zaXRpb259YCxcbiAgICAgICgpID0+IFtcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgICBgdHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgIF0sXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlIHVzZWQgZm9yIGxvb2tpbmcgdXAgdGhlIGBhbmltYXRpb25zYCBhbmQgYGFuaW1hdGlvbmAga2V5c1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvcHRpb25zIHNjb3BlIGtleXMgZm9yIHJlc29sdmluZyBlbGVtZW50IG9wdGlvbnMgdGhhdCBiZWxvbmdcbiAgICogdG8gYW4gZGF0YXNldC4gVGhlc2Uga2V5cyBkbyBub3QgaW5jbHVkZSB0aGUgZGF0YXNldCBpdHNlbGYsIGJlY2F1c2UgaXRcbiAgICogaXMgbm90IHVuZGVyIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhc2V0VHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudFR5cGVcbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIGRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKGRhdGFzZXRUeXBlLCBlbGVtZW50VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS0ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0uZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICBgZWxlbWVudHMuJHtlbGVtZW50VHlwZX1gLFxuICAgICAgICAnJ1xuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9wdGlvbnMgc2NvcGUga2V5cyBmb3IgcmVzb2x2aW5nIHBsdWdpbiBvcHRpb25zLlxuICAgKiBAcGFyYW0ge3tpZDogc3RyaW5nLCBhZGRpdGlvbmFsT3B0aW9uU2NvcGVzPzogc3RyaW5nW119fSBwbHVnaW5cbiAgICogQHJldHVybiB7c3RyaW5nW11bXX1cbiAgICovXG4gIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50eXBlO1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsXG4gICAgICAoKSA9PiBbW1xuICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdLFxuICAgICAgXV0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIG9iamVjdHMgZnJvbSBvcHRpb25zIGFuZCBkZWZhdWx0cyBmb3Igb3B0aW9uIHZhbHVlIHJlc29sdXRpb24uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYWluU2NvcGUgLSBUaGUgbWFpbiBzY29wZSBvYmplY3QgZm9yIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmdbXVtdfSBrZXlMaXN0cyAtIFRoZSBhcnJheXMgb2Yga2V5cyBpbiByZXNvbHV0aW9uIG9yZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0Q2FjaGVdIC0gcmVzZXQgdGhlIGNhY2hlIGZvciB0aGlzIG1haW5TY29wZVxuICAgKi9cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBTZXQoKTtcblxuICAgIGtleUxpc3RzLmZvckVhY2goa2V5cyA9PiB7XG4gICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgIHNjb3Blcy5hZGQobWFpblNjb3BlKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgbWFpblNjb3BlLCBrZXkpKTtcbiAgICAgIH1cbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG9wdGlvbnMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlZmF1bHRzLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlc2NyaXB0b3JzLCBrZXkpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb3B0aW9uIHNjb3BlcyBmb3IgcmVzb2x2aW5nIGNoYXJ0IG9wdGlvbnNcbiAgICogQHJldHVybiB7b2JqZWN0W119XG4gICAqL1xuICBjaGFydE9wdGlvblNjb3BlcygpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSwgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzg1MzFcbiAgICAgIHt0eXBlfSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgZGVzY3JpcHRvcnNcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBuYW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufG9iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBbcHJlZml4ZXNdXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIHJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyRzaGFyZWQ6IHRydWV9O1xuICAgIGNvbnN0IHtyZXNvbHZlciwgc3ViUHJlZml4ZXN9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICBpZiAobmVlZENvbnRleHQocmVzb2x2ZXIsIG5hbWVzKSkge1xuICAgICAgcmVzdWx0LiRzaGFyZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGNvbnRleHQpID8gY29udGV4dCgpIDogY29udGV4dDtcbiAgICAgIC8vIHN1YlJlc29sdmVyIGlzIHBhc3NlZCB0byBzY3JpcHRhYmxlIG9wdGlvbnMuIEl0IHNob3VsZCBub3QgcmVzb2x2ZSB0byBob3ZlciBvcHRpb25zLlxuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgICByZXN1bHRbcHJvcF0gPSBvcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0W119IHNjb3Blc1xuICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IFtwcmVmaXhlc11cbiAgICogQHBhcmFtIHt7c2NyaXB0YWJsZTogYm9vbGVhbiwgaW5kZXhhYmxlOiBib29sZWFuLCBhbGxLZXlzPzogYm9vbGVhbn19IFtkZXNjcmlwdG9yRGVmYXVsdHNdXG4gICAqL1xuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJlc29sdmVyKHJlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpIHtcbiAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJlc29sdmVyQ2FjaGUuc2V0KHNjb3BlcywgY2FjaGUpO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJlZml4ZXMuam9pbigpO1xuICBsZXQgY2FjaGVkID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFjYWNoZWQpIHtcbiAgICBjb25zdCByZXNvbHZlciA9IF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzKTtcbiAgICBjYWNoZWQgPSB7XG4gICAgICByZXNvbHZlcixcbiAgICAgIHN1YlByZWZpeGVzOiBwcmVmaXhlcy5maWx0ZXIocCA9PiAhcC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdob3ZlcicpKVxuICAgIH07XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBjYWNoZWQpO1xuICB9XG4gIHJldHVybiBjYWNoZWQ7XG59XG5cbmNvbnN0IGhhc0Z1bmN0aW9uID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpXG4gICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5zb21lKChrZXkpID0+IGlzRnVuY3Rpb24odmFsdWVba2V5XSkpO1xuXG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcblxuICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICBjb25zdCBzY3JpcHRhYmxlID0gaXNTY3JpcHRhYmxlKHByb3ApO1xuICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgIGNvbnN0IHZhbHVlID0gKGluZGV4YWJsZSB8fCBzY3JpcHRhYmxlKSAmJiBwcm94eVtwcm9wXTtcbiAgICBpZiAoKHNjcmlwdGFibGUgJiYgKGlzRnVuY3Rpb24odmFsdWUpIHx8IGhhc0Z1bmN0aW9uKHZhbHVlKSkpXG4gICAgICB8fCAoaW5kZXhhYmxlICYmIGlzQXJyYXkodmFsdWUpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsICJpbXBvcnQgYW5pbWF0b3IgZnJvbSAnLi9jb3JlLmFuaW1hdG9yLmpzJztcbmltcG9ydCBkZWZhdWx0cywge292ZXJyaWRlc30gZnJvbSAnLi9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCBJbnRlcmFjdGlvbiBmcm9tICcuL2NvcmUuaW50ZXJhY3Rpb24uanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi9jb3JlLmxheW91dHMuanMnO1xuaW1wb3J0IHtfZGV0ZWN0UGxhdGZvcm19IGZyb20gJy4uL3BsYXRmb3JtL2luZGV4LmpzJztcbmltcG9ydCBQbHVnaW5TZXJ2aWNlIGZyb20gJy4vY29yZS5wbHVnaW5zLmpzJztcbmltcG9ydCByZWdpc3RyeSBmcm9tICcuL2NvcmUucmVnaXN0cnkuanMnO1xuaW1wb3J0IENvbmZpZywge2RldGVybWluZUF4aXMsIGdldEluZGV4QXhpc30gZnJvbSAnLi9jb3JlLmNvbmZpZy5qcyc7XG5pbXBvcnQge2VhY2gsIGNhbGxiYWNrIGFzIGNhbGxDYWxsYmFjaywgdWlkLCB2YWx1ZU9yRGVmYXVsdCwgX2VsZW1lbnRzRXF1YWwsIGlzTnVsbE9yVW5kZWYsIHNldHNFcXVhbCwgZGVmaW5lZCwgaXNGdW5jdGlvbiwgX2lzQ2xpY2tFdmVudH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHtjbGVhckNhbnZhcywgY2xpcEFyZWEsIGNyZWF0ZUNvbnRleHQsIHVuY2xpcEFyZWEsIF9pc1BvaW50SW5BcmVhLCBfaXNEb21TdXBwb3J0ZWQsIHJldGluYVNjYWxlLCBnZXREYXRhc2V0Q2xpcEFyZWF9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHtkZWJvdW5jZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLlBvaW50IH0gUG9pbnRcbiAqL1xuXG5jb25zdCBLTk9XTl9QT1NJVElPTlMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICdjaGFydEFyZWEnXTtcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uLCBheGlzKSB7XG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IChLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXVxuICAgICAgPyBhW2wyXSAtIGJbbDJdXG4gICAgICA6IGFbbDFdIC0gYltsMV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uc0NvbXBsZXRlKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG5cbiAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJSZW5kZXInKTtcbiAgY2FsbENhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cblxuZnVuY3Rpb24gb25BbmltYXRpb25Qcm9ncmVzcyhjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjYWxsQ2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uUHJvZ3Jlc3MsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuXG4vKipcbiAqIENoYXJ0LmpzIGNhbiB0YWtlIGEgc3RyaW5nIGlkIG9mIGEgY2FudmFzIGVsZW1lbnQsIGEgMmQgY29udGV4dCwgb3IgYSBjYW52YXMgZWxlbWVudCBpdHNlbGYuXG4gKiBBdHRlbXB0IHRvIHVud3JhcCB0aGUgaXRlbSBwYXNzZWQgaW50byB0aGUgY2hhcnQgY29uc3RydWN0b3Igc28gdGhhdCBpdCBpcyBhIGNhbnZhcyBlbGVtZW50IChpZiBwb3NzaWJsZSkuXG4gKi9cbmZ1bmN0aW9uIGdldENhbnZhcyhpdGVtKSB7XG4gIGlmIChfaXNEb21TdXBwb3J0ZWQoKSAmJiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycpIHtcbiAgICBpdGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSk7XG4gIH0gZWxzZSBpZiAoaXRlbSAmJiBpdGVtLmxlbmd0aCkge1xuICAgIC8vIFN1cHBvcnQgZm9yIGFycmF5IGJhc2VkIHF1ZXJpZXMgKHN1Y2ggYXMgalF1ZXJ5KVxuICAgIGl0ZW0gPSBpdGVtWzBdO1xuICB9XG5cbiAgaWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBhbnkgb2JqZWN0IGFzc29jaWF0ZWQgdG8gYSBjYW52YXMgKGluY2x1ZGluZyBhIGNvbnRleHQyZClcbiAgICBpdGVtID0gaXRlbS5jYW52YXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5cbmNvbnN0IGluc3RhbmNlcyA9IHt9O1xuY29uc3QgZ2V0Q2hhcnQgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcyhrZXkpO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYykgPT4gYy5jYW52YXMgPT09IGNhbnZhcykucG9wKCk7XG59O1xuXG5mdW5jdGlvbiBtb3ZlTnVtZXJpY0tleXMob2JqLCBzdGFydCwgbW92ZSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGludEtleSA9ICtrZXk7XG4gICAgaWYgKGludEtleSA+PSBzdGFydCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgIGlmIChtb3ZlID4gMCB8fCBpbnRLZXkgPiBzdGFydCkge1xuICAgICAgICBvYmpbaW50S2V5ICsgbW92ZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NoYXJ0RXZlbnR9IGVcbiAqIEBwYXJhbSB7Q2hhcnRFdmVudHxudWxsfSBsYXN0RXZlbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5DaGFydEFyZWFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNDbGlja1xuICogQHJldHVybnMge0NoYXJ0RXZlbnR8bnVsbH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIGxhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spIHtcbiAgaWYgKCFpbkNoYXJ0QXJlYSB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNDbGljaykge1xuICAgIHJldHVybiBsYXN0RXZlbnQ7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmNsYXNzIENoYXJ0IHtcblxuICBzdGF0aWMgZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgc3RhdGljIGluc3RhbmNlcyA9IGluc3RhbmNlcztcbiAgc3RhdGljIG92ZXJyaWRlcyA9IG92ZXJyaWRlcztcbiAgc3RhdGljIHJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gIHN0YXRpYyB2ZXJzaW9uID0gdmVyc2lvbjtcbiAgc3RhdGljIGdldENoYXJ0ID0gZ2V0Q2hhcnQ7XG5cbiAgc3RhdGljIHJlZ2lzdGVyKC4uLml0ZW1zKSB7XG4gICAgcmVnaXN0cnkuYWRkKC4uLml0ZW1zKTtcbiAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICB9XG5cbiAgc3RhdGljIHVucmVnaXN0ZXIoLi4uaXRlbXMpIHtcbiAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuXG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuXG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG5cbiAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyBTdG9yZSB0aGUgcHJldmlvdXNseSB1c2VkIGFzcGVjdCByYXRpbyB0byBkZXRlcm1pbmUgaWYgYSByZXNpemVcbiAgICAvLyBpcyBuZWVkZWQgZHVyaW5nIHVwZGF0ZXMuIERvIHRoaXMgYWZ0ZXIgX29wdGlvbnMgaXMgc2V0IHNpbmNlXG4gICAgLy8gYXNwZWN0UmF0aW8gdXNlcyBhIGdldHRlclxuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgLyoqIEB0eXBlIHs/e2F0dGFjaD86IGZ1bmN0aW9uLCBkZXRhY2g/OiBmdW5jdGlvbiwgcmVzaXplPzogZnVuY3Rpb259fSAqL1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuX3BsdWdpbnMgPSBuZXcgUGx1Z2luU2VydmljZSgpO1xuICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzID0ge307XG4gICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RvUmVzaXplID0gZGVib3VuY2UobW9kZSA9PiB0aGlzLnVwZGF0ZShtb2RlKSwgb3B0aW9ucy5yZXNpemVEZWxheSB8fCAwKTtcbiAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuXG4gICAgLy8gQWRkIHRoZSBjaGFydCBpbnN0YW5jZSB0byB0aGUgZ2xvYmFsIG5hbWVzcGFjZVxuICAgIGluc3RhbmNlc1t0aGlzLmlkXSA9IHRoaXM7XG5cbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgLy8gVGhlIGdpdmVuIGl0ZW0gaXMgbm90IGEgY29tcGF0aWJsZSBjb250ZXh0MmQgZWxlbWVudCwgbGV0J3MgcmV0dXJuIGJlZm9yZSBmaW5hbGl6aW5nXG4gICAgICAvLyB0aGUgY2hhcnQgaW5pdGlhbGl6YXRpb24gYnV0IGFmdGVyIHNldHRpbmcgYmFzaWMgY2hhcnQgLyBjb250cm9sbGVyIHByb3BlcnRpZXMgdGhhdFxuICAgICAgLy8gY2FuIGhlbHAgdG8gZmlndXJlIG91dCB0aGF0IHRoZSBjaGFydCBpcyBub3QgdmFsaWQgKGUuZyBjaGFydC5jYW52YXMgIT09IG51bGwpO1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzI4MDdcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNoYXJ0OiBjYW4ndCBhY3F1aXJlIGNvbnRleHQgZnJvbSB0aGUgZ2l2ZW4gaXRlbVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcblxuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IHthc3BlY3RSYXRpbywgbWFpbnRhaW5Bc3BlY3RSYXRpb30sIHdpZHRoLCBoZWlnaHQsIF9hc3BlY3RSYXRpb30gPSB0aGlzO1xuICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgIC8vIElmIGFzcGVjdFJhdGlvIGlzIGRlZmluZWQgaW4gb3B0aW9ucywgdXNlIHRoYXQuXG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuXG4gICAgaWYgKG1haW50YWluQXNwZWN0UmF0aW8gJiYgX2FzcGVjdFJhdGlvKSB7XG4gICAgICAvLyBJZiBtYWludGFpbkFzcGVjdFJhdGlvIGlzIHRydXRobHkgYW5kIHdlIGhhZCBwcmV2aW91c2x5IGRldGVybWluZWQgX2FzcGVjdFJhdGlvLCB1c2UgdGhhdFxuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGVcbiAgICByZXR1cm4gaGVpZ2h0ID8gd2lkdGggLyBoZWlnaHQgOiBudWxsO1xuICB9XG5cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cblxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIGdldCByZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gcmVnaXN0cnk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9pbml0aWFsaXplKCkge1xuICAgIC8vIEJlZm9yZSBpbml0IHBsdWdpbiBub3RpZmljYXRpb25cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cblxuICAgIHRoaXMuYmluZEV2ZW50cygpO1xuXG4gICAgLy8gQWZ0ZXIgaW5pdCBwbHVnaW4gbm90aWZpY2F0aW9uXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgY2xlYXJDYW52YXModGhpcy5jYW52YXMsIHRoaXMuY3R4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXNpemUgdGhlIGNoYXJ0IHRvIGl0cyBjb250YWluZXIgb3IgdG8gZXhwbGljaXQgZGltZW5zaW9ucy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aF1cblx0ICogQHBhcmFtIHtudW1iZXJ9IFtoZWlnaHRdXG5cdCAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuXG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG5cbiAgICB0aGlzLndpZHRoID0gbmV3U2l6ZS53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG5ld1NpemUuaGVpZ2h0O1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICBpZiAoIXJldGluYVNjYWxlKHRoaXMsIG5ld1JhdGlvLCB0cnVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcblxuICAgIGNhbGxDYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICAvLyBUaGUgcmVzaXplIHVwZGF0ZSBpcyBkZWxheWVkLCBvbmx5IGRyYXcgd2l0aG91dCB1cGRhdGluZy5cbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuXG4gICAgZWFjaChzY2FsZXNPcHRpb25zLCAoYXhpc09wdGlvbnMsIGF4aXNJRCkgPT4ge1xuICAgICAgYXhpc09wdGlvbnMuaWQgPSBheGlzSUQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQnVpbGRzIGEgbWFwIG9mIHNjYWxlIElEIHRvIHNjYWxlIG9iamVjdCBmb3IgZnV0dXJlIGxvb2t1cC5cblx0ICovXG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuXG4gICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoXG4gICAgICAgIE9iamVjdC5rZXlzKHNjYWxlT3B0cykubWFwKChpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcHRpb25zOiBzY2FsZU9wdGlvbnMsXG4gICAgICAgICAgICBkcG9zaXRpb246IGlzUmFkaWFsID8gJ2NoYXJ0QXJlYScgOiBpc0hvcml6b250YWwgPyAnYm90dG9tJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG5cbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZWRbaWRdID0gdHJ1ZTtcbiAgICAgIGxldCBzY2FsZSA9IG51bGw7XG4gICAgICBpZiAoaWQgaW4gc2NhbGVzICYmIHNjYWxlc1tpZF0udHlwZSA9PT0gc2NhbGVUeXBlKSB7XG4gICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjYWxlQ2xhc3MgPSByZWdpc3RyeS5nZXRTY2FsZShzY2FsZVR5cGUpO1xuICAgICAgICBzY2FsZSA9IG5ldyBzY2FsZUNsYXNzKHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgY3R4OiB0aGlzLmN0eCxcbiAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgfVxuXG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgLy8gY2xlYXIgdXAgZGlzY2FyZGVkIHNjYWxlc1xuICAgIGVhY2godXBkYXRlZCwgKGhhc1VwZGF0ZWQsIGlkKSA9PiB7XG4gICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgZGVsZXRlIHNjYWxlc1tpZF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVNZXRhc2V0cygpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX21ldGFzZXRzO1xuICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bU1ldGEgPSBtZXRhc2V0cy5sZW5ndGg7XG5cbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpIHtcbiAgICBjb25zdCB7X21ldGFzZXRzOiBtZXRhc2V0cywgZGF0YToge2RhdGFzZXRzfX0gPSB0aGlzO1xuICAgIGlmIChtZXRhc2V0cy5sZW5ndGggPiBkYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdGFja3M7XG4gICAgfVxuICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0YXNldHMuZmlsdGVyKHggPT4geCA9PT0gbWV0YS5fZGF0YXNldCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcblxuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBkYXRhc2V0ID0gZGF0YXNldHNbaV07XG4gICAgICBsZXQgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCB0eXBlID0gZGF0YXNldC50eXBlIHx8IHRoaXMuY29uZmlnLnR5cGU7XG5cbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG5cbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcywge1xuICAgICAgICAgIGRhdGFFbGVtZW50VHlwZTogcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhRWxlbWVudFR5cGUpLFxuICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICB9KTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyID0gbmV3IENvbnRyb2xsZXJDbGFzcyh0aGlzLCBpKTtcbiAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJlc2V0IHRoZSBlbGVtZW50cyBvZiBhbGwgZGF0YXNldHNcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG5cbiAgLyoqXG5cdCogUmVzZXRzIHRoZSBjaGFydCBiYWNrIHRvIGl0cyBzdGF0ZSBiZWZvcmUgdGhlIGluaXRpYWwgYW5pbWF0aW9uXG5cdCovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cblxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuXG4gICAgY29uZmlnLnVwZGF0ZSgpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9vcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcblxuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcblxuICAgIC8vIHBsdWdpbnMgb3B0aW9ucyByZWZlcmVuY2VzIG1pZ2h0IGhhdmUgY2hhbmdlLCBsZXQncyBpbnZhbGlkYXRlIHRoZSBjYWNoZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy81MTExI2lzc3VlY29tbWVudC0zNTU5MzQxNjdcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIGRhdGFzZXQgY29udHJvbGxlcnMgYXJlIHVwZGF0ZWQgYW5kIG5ldyBjb250cm9sbGVycyBhcmUgcmVzZXRcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgYWxsIGRhdGFzZXQgY29udHJvbGxlcnMgaGF2ZSBjb3JyZWN0IG1ldGEgZGF0YSBjb3VudHNcbiAgICBsZXQgbWluUGFkZGluZyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB7Y29udHJvbGxlcn0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgIC8vIE5ldyBjb250cm9sbGVycyB3aWxsIGJlIHJlc2V0IGFmdGVyIHRoZSBsYXlvdXQgcGFzcywgc28gd2Ugb25seSB3YW50IHRvIG1vZGlmeVxuICAgICAgLy8gZWxlbWVudHMgYWRkZWQgdG8gbmV3IGRhdGFzZXRzXG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG5cbiAgICAvLyBPbmx5IHJlc2V0IHRoZSBjb250cm9sbGVycyBpZiB3ZSBoYXZlIGFuaW1hdGlvbnNcbiAgICBpZiAoIWFuaW1zRGlzYWJsZWQpIHtcbiAgICAgIC8vIENhbiBvbmx5IHJlc2V0IHRoZSBuZXcgY29udHJvbGxlcnMgYWZ0ZXIgdGhlIHNjYWxlcyBoYXZlIGJlZW4gdXBkYXRlZFxuICAgICAgLy8gUmVzZXQgaXMgZG9uZSB0byBnZXQgdGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgaW5pdGlhbCBhbmltYXRpb25cbiAgICAgIGVhY2gobmV3Q29udHJvbGxlcnMsIChjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgcmVuZGVyIHNvIHRoYXQgYW55IHBsdWdpbnMgdGhhdCBuZWVkIGZpbmFsIHNjYWxlIHVwZGF0ZXMgY2FuIHVzZSBpdFxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuXG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuXG4gICAgLy8gUmVwbGF5IGxhc3QgZXZlbnQgZnJvbSBiZWZvcmUgdXBkYXRlLCBvciBzZXQgaG92ZXIgc3R5bGVzIG9uIGFjdGl2ZSBlbGVtZW50c1xuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XG4gICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhfYWN0aXZlLCBfYWN0aXZlLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5lbnN1cmVTY2FsZXNIYXZlSURzKCk7XG4gICAgdGhpcy5idWlsZE9yVXBkYXRlU2NhbGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XG5cbiAgICBpZiAoIXNldHNFcXVhbChleGlzdGluZ0V2ZW50cywgbmV3RXZlbnRzKSB8fCAhIXRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgIT09IG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgLy8gVGhlIGNvbmZpZ3VyZWQgZXZlbnRzIGhhdmUgY2hhbmdlZC4gUmViaW5kLlxuICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgIHRoaXMuYmluZEV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XG4gICAgY29uc3Qge19oaWRkZW5JbmRpY2VzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxuICAgICAgX2RhdGFDaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjWzBdID09PSBpZHgpXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXG4gICAgKTtcblxuICAgIGNvbnN0IGNoYW5nZVNldCA9IG1ha2VTZXQoMCk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhc2V0Q291bnQ7IGkrKykge1xuICAgICAgaWYgKCFzZXRzRXF1YWwoY2hhbmdlU2V0LCBtYWtlU2V0KGkpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGNoYW5nZVNldClcbiAgICAgIC5tYXAoYyA9PiBjLnNwbGl0KCcsJykpXG4gICAgICAubWFwKGEgPT4gKHttZXRob2Q6IGFbMV0sIHN0YXJ0OiArYVsyXSwgY291bnQ6ICthWzNdfSkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNoYXJ0IGxheW91dCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlTGF5b3V0YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJMYXlvdXRgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG5cbiAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgY29uc3Qgbm9BcmVhID0gYXJlYS53aWR0aCA8PSAwIHx8IGFyZWEuaGVpZ2h0IDw9IDA7XG5cbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICAvLyBTa2lwIGRyYXdpbmcgYW5kIGNvbmZpZ3VyaW5nIGNoYXJ0QXJlYSBib3hlcyB3aGVuIGNoYXJ0QXJlYSBpcyB6ZXJvIG9yIG5lZ2F0aXZlXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uZmlndXJlIGlzIGNhbGxlZCB0d2ljZSwgb25jZSBpbiBjb3JlLnNjYWxlLnVwZGF0ZSBhbmQgb25jZSBoZXJlLlxuICAgICAgLy8gSGVyZSB0aGUgYm94ZXMgYXJlIGZ1bGx5IHVwZGF0ZWQgYW5kIGF0IHRoZWlyIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XG4gICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICBpdGVtLl9pZHggPSBpbmRleDtcbiAgICB9KTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBVcGRhdGVzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNVcGRhdGVgXG5cdCAqIGhvb2ssIGluIHdoaWNoIGNhc2UsIHBsdWdpbnMgd2lsbCBub3QgYmUgY2FsbGVkIG9uIGBhZnRlckRhdGFzZXRzVXBkYXRlYC5cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShpKS5jb250cm9sbGVyLmNvbmZpZ3VyZSgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7bW9kZX0pO1xuICB9XG5cbiAgLyoqXG5cdCAqIFVwZGF0ZXMgZGF0YXNldCBhdCBpbmRleCB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldFVwZGF0ZWBcblx0ICogaG9vaywgaW4gd2hpY2ggY2FzZSwgcGx1Z2lucyB3aWxsIG5vdCBiZSBjYWxsZWQgb24gYGFmdGVyRGF0YXNldFVwZGF0ZWAuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXRhLmNvbnRyb2xsZXIuX3VwZGF0ZShtb2RlKTtcblxuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYW5pbWF0b3IuaGFzKHRoaXMpKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICBhbmltYXRvci5zdGFydCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICBvbkFuaW1hdGlvbnNDb21wbGV0ZSh7Y2hhcnQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgLy8gVW5zZXQgcGVuZGluZyByZXNpemUgcmVxdWVzdCBub3cgdG8gYXZvaWQgcG9zc2libGUgcmVjdXJzaW9uIHdpdGhpbiBfcmVzaXplXG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQmVjYXVzZSBvZiBwbHVnaW4gaG9va3MgKGJlZm9yZS9hZnRlckRhdGFzZXRzRHJhdyksIGRhdGFzZXRzIGNhbid0XG4gICAgLy8gY3VycmVudGx5IGJlIHBhcnQgb2YgbGF5ZXJzLiBJbnN0ZWFkLCB3ZSBkcmF3XG4gICAgLy8gbGF5ZXJzIDw9IDAgYmVmb3JlKGRlZmF1bHQsIGJhY2t3YXJkIGNvbXBhdCksIGFuZCB0aGUgcmVzdCBhZnRlclxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aCAmJiBsYXllcnNbaV0ueiA8PSAwOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kcmF3RGF0YXNldHMoKTtcblxuICAgIC8vIFJlc3Qgb2YgbGF5ZXJzXG4gICAgZm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRHJhdycpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzZXRzW2ldO1xuICAgICAgaWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1ldGEudmlzaWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG5cdCAqIEdldHMgdGhlIHZpc2libGUgZGF0YXNldCBtZXRhcyBpbiBkcmF3aW5nIG9yZGVyXG5cdCAqIEByZXR1cm4ge29iamVjdFtdfVxuXHQgKi9cbiAgZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHRydWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdzIGFsbCBkYXRhc2V0cyB1bmxlc3MgYSBwbHVnaW4gcmV0dXJucyBgZmFsc2VgIHRvIHRoZSBgYmVmb3JlRGF0YXNldHNEcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0c0RyYXdgLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2RyYXdEYXRhc2V0cygpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c0RyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0aGlzLl9kcmF3RGF0YXNldChtZXRhc2V0c1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xuICB9XG5cbiAgLyoqXG5cdCAqIERyYXdzIGRhdGFzZXQgYXQgaW5kZXggdW5sZXNzIGEgcGx1Z2luIHJldHVybnMgYGZhbHNlYCB0byB0aGUgYGJlZm9yZURhdGFzZXREcmF3YFxuXHQgKiBob29rLCBpbiB3aGljaCBjYXNlLCBwbHVnaW5zIHdpbGwgbm90IGJlIGNhbGxlZCBvbiBgYWZ0ZXJEYXRhc2V0RHJhd2AuXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBtZXRhLFxuICAgICAgaW5kZXg6IG1ldGEuaW5kZXgsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgY2xpcCA9IGdldERhdGFzZXRDbGlwQXJlYSh0aGlzLCBtZXRhKTtcblxuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXREcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNsaXApIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgY2xpcCk7XG4gICAgfVxuXG4gICAgbWV0YS5jb250cm9sbGVyLmRyYXcoKTtcblxuICAgIGlmIChjbGlwKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuXG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXREcmF3JywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGlzIGluIHRoZSBjaGFydCBhcmVhLlxuICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIGluIHJlbGF0aXZlIGNvb3JkaW5hdGVzIChzZWUsIGUuZy4sIGdldFJlbGF0aXZlUG9zaXRpb24pXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNQb2ludEluQXJlYShwb2ludCkge1xuICAgIHJldHVybiBfaXNQb2ludEluQXJlYShwb2ludCwgdGhpcy5jaGFydEFyZWEsIHRoaXMuX21pblBhZGRpbmcpO1xuICB9XG5cbiAgZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBtb2RlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbWV0aG9kID0gSW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgbGV0IG1ldGEgPSBtZXRhc2V0cy5maWx0ZXIoeCA9PiB4ICYmIHguX2RhdGFzZXQgPT09IGRhdGFzZXQpLnBvcCgpO1xuXG4gICAgaWYgKCFtZXRhKSB7XG4gICAgICBtZXRhID0ge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgaGlkZGVuOiBudWxsLFx0XHRcdC8vIFNlZSBpc0RhdGFzZXRWaXNpYmxlKCkgY29tbWVudFxuICAgICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgICBvcmRlcjogZGF0YXNldCAmJiBkYXRhc2V0Lm9yZGVyIHx8IDAsXG4gICAgICAgIGluZGV4OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgIF9kYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICBfcGFyc2VkOiBbXSxcbiAgICAgICAgX3NvcnRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBtZXRhc2V0cy5wdXNoKG1ldGEpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhO1xuICB9XG5cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCwge2NoYXJ0OiB0aGlzLCB0eXBlOiAnY2hhcnQnfSkpO1xuICB9XG5cbiAgZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkubGVuZ3RoO1xuICB9XG5cbiAgaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKCFkYXRhc2V0KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuICAgIC8vIG1ldGEuaGlkZGVuIGlzIGEgcGVyIGNoYXJ0IGRhdGFzZXQgaGlkZGVuIGZsYWcgb3ZlcnJpZGUgd2l0aCAzIHN0YXRlczogaWYgdHJ1ZSBvciBmYWxzZSxcbiAgICAvLyB0aGUgZGF0YXNldC5oaWRkZW4gdmFsdWUgaXMgaWdub3JlZCwgZWxzZSBpZiBudWxsLCB0aGUgZGF0YXNldCBoaWRkZW4gc3RhdGUgaXMgcmV0dXJuZWQuXG4gICAgcmV0dXJuIHR5cGVvZiBtZXRhLmhpZGRlbiA9PT0gJ2Jvb2xlYW4nID8gIW1ldGEuaGlkZGVuIDogIWRhdGFzZXQuaGlkZGVuO1xuICB9XG5cbiAgc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICB9XG5cbiAgdG9nZ2xlRGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuXG4gIGdldERhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgcmV0dXJuICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtb2RlID0gdmlzaWJsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IGFuaW1zID0gbWV0YS5jb250cm9sbGVyLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpO1xuXG4gICAgaWYgKGRlZmluZWQoZGF0YUluZGV4KSkge1xuICAgICAgbWV0YS5kYXRhW2RhdGFJbmRleF0uaGlkZGVuID0gIXZpc2libGU7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSk7XG4gICAgICAvLyBBbmltYXRlIHZpc2libGUgc3RhdGUsIHNvIGhpZGUgYW5pbWF0aW9uIGNhbiBiZSBzZWVuLiBUaGlzIGNvdWxkIGJlIGhhbmRsZWQgYmV0dGVyIGlmIHVwZGF0ZSAvIHVwZGF0ZURhdGFzZXQgcmV0dXJuZWQgYSBQcm9taXNlLlxuICAgICAgYW5pbXMudXBkYXRlKG1ldGEsIHt2aXNpYmxlfSk7XG4gICAgICB0aGlzLnVwZGF0ZSgoY3R4KSA9PiBjdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cblxuICBoaWRlKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgZmFsc2UpO1xuICB9XG5cbiAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmIChtZXRhICYmIG1ldGEuY29udHJvbGxlcikge1xuICAgICAgbWV0YS5jb250cm9sbGVyLl9kZXN0cm95KCk7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9tZXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICB9XG5cbiAgX3N0b3AoKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgYW5pbWF0b3IucmVtb3ZlKHRoaXMpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGVzdHJveScpO1xuICAgIGNvbnN0IHtjYW52YXMsIGN0eH0gPSB0aGlzO1xuXG4gICAgdGhpcy5fc3RvcCgpO1xuICAgIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKTtcblxuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCk7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVsZXRlIGluc3RhbmNlc1t0aGlzLmlkXTtcblxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEZXN0cm95Jyk7XG4gIH1cblxuICB0b0Jhc2U2NEltYWdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBiaW5kVXNlckV2ZW50cygpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuXG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuXG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZSwgeCwgeSkgPT4ge1xuICAgICAgZS5vZmZzZXRYID0geDtcbiAgICAgIGUub2Zmc2V0WSA9IHk7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoZSk7XG4gICAgfTtcblxuICAgIGVhY2godGhpcy5vcHRpb25zLmV2ZW50cywgKHR5cGUpID0+IF9hZGQodHlwZSwgbGlzdGVuZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuXG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IF9yZW1vdmUgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgcGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbdHlwZV07XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGxpc3RlbmVyID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGRldGFjaGVkOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1jb25zdFxuICAgIGNvbnN0IGF0dGFjaGVkID0gKCkgPT4ge1xuICAgICAgX3JlbW92ZSgnYXR0YWNoJywgYXR0YWNoZWQpO1xuXG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAgIF9hZGQoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIF9hZGQoJ2RldGFjaCcsIGRldGFjaGVkKTtcbiAgICB9O1xuXG4gICAgZGV0YWNoZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG5cbiAgICAgIF9yZW1vdmUoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcblxuICAgICAgLy8gU3RvcCBhbmltYXRpbmcgYW5kIHJlbW92ZSBtZXRhc2V0cywgc28gd2hlbiByZS1hdHRhY2hlZCwgdGhlIGFuaW1hdGlvbnMgc3RhcnQgZnJvbSBiZWdpbm5pbmcuXG4gICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICB0aGlzLl9yZXNpemUoMCwgMCk7XG5cbiAgICAgIF9hZGQoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICB9O1xuXG4gICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpKSB7XG4gICAgICBhdHRhY2hlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgdW5iaW5kRXZlbnRzKCkge1xuICAgIGVhY2godGhpcy5fbGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpID0+IHtcbiAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfSk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cbiAgICBlYWNoKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlSG92ZXJTdHlsZShpdGVtcywgbW9kZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHByZWZpeCA9IGVuYWJsZWQgPyAnc2V0JyA6ICdyZW1vdmUnO1xuICAgIGxldCBtZXRhLCBpdGVtLCBpLCBpbGVuO1xuXG4gICAgaWYgKG1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbXNbMF0uZGF0YXNldEluZGV4KTtcbiAgICAgIG1ldGEuY29udHJvbGxlclsnXycgKyBwcmVmaXggKyAnRGF0YXNldEhvdmVyU3R5bGUnXSgpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBpdGVtICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oaXRlbS5lbGVtZW50LCBpdGVtLmRhdGFzZXRJbmRleCwgaXRlbS5pbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEdldCBhY3RpdmUgKGhvdmVyZWQpIGVsZW1lbnRzXG5cdCAqIEByZXR1cm5zIGFycmF5XG5cdCAqL1xuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBhY3RpdmUgKGhvdmVyZWQpIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGFjdGl2ZUVsZW1lbnRzIE5ldyBhY3RpdmUgZGF0YSBwb2ludHNcblx0ICovXG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGlmICghbWV0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGRhdGFzZXQgZm91bmQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcblxuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgdXNlIHRoZSBwcmV2aW91cyBtb3VzZSBldmVudCB0byBvdmVycmlkZSB0aGUgYWN0aXZlIGVsZW1lbnRzIGluIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBDYWxscyBlbmFibGVkIHBsdWdpbnMgb24gdGhlIHNwZWNpZmllZCBob29rIGFuZCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVseSByZXR1cm5zIGFzIHNvb24gYXMgYSBwbHVnaW4gZXhwbGljaXRseSByZXR1cm5zIGZhbHNlLiBUaGVcblx0ICogcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHVzZWQsIGZvciBpbnN0YW5jZSwgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IGFjdGlvbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGhvb2sgLSBUaGUgbmFtZSBvZiB0aGUgcGx1Z2luIG1ldGhvZCB0byBjYWxsIChlLmcuICdiZWZvcmVVcGRhdGUnKS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFthcmdzXSAtIEV4dHJhIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgaG9vayBjYWxsLlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi9jb3JlLnBsdWdpbnMuanMnKS5maWx0ZXJDYWxsYmFja30gW2ZpbHRlcl0gLSBGaWx0ZXJpbmcgZnVuY3Rpb24gZm9yIGxpbWl0aW5nIHdoaWNoIHBsdWdpbnMgYXJlIG5vdGlmaWVkXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBmYWxzZSBpZiBhbnkgb2YgdGhlIHBsdWdpbnMgcmV0dXJuIGZhbHNlLCBlbHNlIHJldHVybnMgdHJ1ZS5cblx0ICovXG4gIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIGhvb2ssIGFyZ3MsIGZpbHRlcik7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBwbHVnaW4gd2l0aCB0aGUgc3BlY2lmaWMgSUQgaXMgcmVnaXN0ZXJlZCBhbmQgZW5hYmxlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGx1Z2luSWQgLSBUaGUgSUQgb2YgdGhlIHBsdWdpbiBvZiB3aGljaCB0byBjaGVjayBpZiBpdCBpcyBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNQbHVnaW5FbmFibGVkKHBsdWdpbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMuX2NhY2hlLmZpbHRlcihwID0+IHAucGx1Z2luLmlkID09PSBwbHVnaW5JZCkubGVuZ3RoID09PSAxO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpIHtcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LmRhdGFzZXRJbmRleCA9PT0geS5kYXRhc2V0SW5kZXggJiYgeC5pbmRleCA9PT0geS5pbmRleCkpO1xuICAgIGNvbnN0IGRlYWN0aXZhdGVkID0gZGlmZihsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IGFjdGl2YXRlZCA9IHJlcGxheSA/IGFjdGl2ZSA6IGRpZmYoYWN0aXZlLCBsYXN0QWN0aXZlKTtcblxuICAgIGlmIChkZWFjdGl2YXRlZC5sZW5ndGgpIHtcbiAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShkZWFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoYWN0aXZhdGVkLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2V2ZW50SGFuZGxlcihlLCByZXBsYXkpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgZXZlbnQ6IGUsXG4gICAgICByZXBsYXksXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYShlKVxuICAgIH07XG4gICAgY29uc3QgZXZlbnRGaWx0ZXIgPSAocGx1Z2luKSA9PiAocGx1Z2luLm9wdGlvbnMuZXZlbnRzIHx8IHRoaXMub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKGUubmF0aXZlLnR5cGUpO1xuXG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgYXJncy5pbkNoYXJ0QXJlYSk7XG5cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcik7XG5cbiAgICBpZiAoY2hhbmdlZCB8fCBhcmdzLmNoYW5nZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSB0aGUgZXZlbnQgdG8gaGFuZGxlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSB0cnVlIGlmIHRoZSBldmVudCB3YXMgcmVwbGF5ZWQgYnkgYHVwZGF0ZWBcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gdHJ1ZSBpZiB0aGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBjaGFydCBuZWVkcyB0byByZS1yZW5kZXJcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9oYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qge19hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSwgb3B0aW9uc30gPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlIGV2ZW50IGlzIHJlcGxheWVkIGZyb20gYHVwZGF0ZWAsIHdlIHNob3VsZCBldmFsdWF0ZSB3aXRoIHRoZSBmaW5hbCBwb3NpdGlvbnMuXG4gICAgLy9cbiAgICAvLyBUaGUgYHJlcGxheWA6XG4gICAgLy8gSXQncyB0aGUgbGFzdCBldmVudCAoZXhjbHVkaW5nIGNsaWNrKSB0aGF0IGhhcyBvY2N1cnJlZCBiZWZvcmUgYHVwZGF0ZWAuXG4gICAgLy8gU28gbW91c2UgaGFzIG5vdCBtb3ZlZC4gSXQncyBhbHNvIG92ZXIgdGhlIGNoYXJ0LCBiZWNhdXNlIHRoZXJlIGlzIGEgYHJlcGxheWAuXG4gICAgLy9cbiAgICAvLyBUaGUgd2h5OlxuICAgIC8vIElmIGFuaW1hdGlvbnMgYXJlIGFjdGl2ZSwgdGhlIGVsZW1lbnRzIGhhdmVuJ3QgbW92ZWQgeWV0IGNvbXBhcmVkIHRvIHN0YXRlIGJlZm9yZSB1cGRhdGUuXG4gICAgLy8gQnV0IGlmIHRoZXkgd2lsbCwgd2UgYXJlIGFjdGl2YXRpbmcgdGhlIGVsZW1lbnRzIHRoYXQgd291bGQgYmUgYWN0aXZlLCBpZiB0aGlzIGNoZWNrXG4gICAgLy8gd2FzIGRvbmUgYWZ0ZXIgdGhlIGFuaW1hdGlvbnMgaGF2ZSBjb21wbGV0ZWQuID0+IFwiZmluYWwgcG9zaXRpb25zXCIuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYW5pbWF0aW9ucywgdGhlIFwiZmluYWxcIiBhbmQgXCJjdXJyZW50XCIgcG9zaXRpb25zIGFyZSBlcXVhbC5cbiAgICAvLyBUaGlzIGlzIGRvbmUgc28gd2UgZG8gbm90IGhhdmUgdG8gZXZhbHVhdGUgdGhlIGFjdGl2ZSBlbGVtZW50cyBlYWNoIGFuaW1hdGlvbiBmcmFtZVxuICAgIC8vIC0gaXQgd291bGQgYmUgZXhwZW5zaXZlLlxuICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSByZXBsYXk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IGlzQ2xpY2sgPSBfaXNDbGlja0V2ZW50KGUpO1xuICAgIGNvbnN0IGxhc3RFdmVudCA9IGRldGVybWluZUxhc3RFdmVudChlLCB0aGlzLl9sYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKTtcblxuICAgIGlmIChpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gU2V0IF9sYXN0RXZlbnQgdG8gbnVsbCB3aGlsZSB3ZSBhcmUgcHJvY2Vzc2luZyB0aGUgZXZlbnQgaGFuZGxlcnMuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHJlY3Vyc2lvbiBpZiB0aGUgaGFuZGxlciBjYWxscyBjaGFydC51cGRhdGUoKVxuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcblxuICAgICAgLy8gSW52b2tlIG9uSG92ZXIgaG9va1xuICAgICAgY2FsbENhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuXG4gICAgICBpZiAoaXNDbGljaykge1xuICAgICAgICBjYWxsQ2FsbGJhY2sob3B0aW9ucy5vbkNsaWNrLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkIHx8IHJlcGxheSkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RFdmVudCA9IGxhc3RFdmVudDtcblxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXguanMnKS5BY3RpdmVFbGVtZW50W119IGxhc3RBY3RpdmUgLSBQcmV2aW91c2x5IGFjdGl2ZSBlbGVtZW50c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluQ2hhcnRBcmVhIC0gSXMgdGhlIGV2ZW50IGluc2lkZSBjaGFydEFyZWFcbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VGaW5hbFBvc2l0aW9uIC0gU2hvdWxkIHRoZSBldmFsdWF0aW9uIGJlIGRvbmUgd2l0aCBjdXJyZW50IG9yIGZpbmFsIChhZnRlciBhbmltYXRpb24pIGVsZW1lbnQgcG9zaXRpb25zXG4gICAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQWN0aXZlRWxlbWVudFtdfSAtIFRoZSBhY3RpdmUgZWxlbWVudHNcbiAgICogQHByYXZhdGVcbiAgICovXG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBpZiAoIWluQ2hhcnRBcmVhKSB7XG4gICAgICAvLyBMZXQgdXNlciBjb250cm9sIHRoZSBhY3RpdmUgZWxlbWVudHMgb3V0c2lkZSBjaGFydEFyZWEuIEVnLiB1c2luZyBMZWdlbmQuXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZTtcbiAgICB9XG5cbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxufVxuXG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiBpbnZhbGlkYXRlUGx1Z2lucygpIHtcbiAgcmV0dXJuIGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IENoYXJ0O1xuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7X2FuZ2xlQmV0d2VlbiwgZ2V0QW5nbGVGcm9tUG9pbnQsIFRBVSwgSEFMRl9QSSwgdmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtQSSwgX2FuZ2xlRGlmZiwgX25vcm1hbGl6ZUFuZ2xlLCBfaXNCZXR3ZWVuLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtfcmVhZFZhbHVlVG9Qcm9wc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHR5cGUge0FyY09wdGlvbnMsIFBvaW50fSBmcm9tICcuLi90eXBlcy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGNsaXBTZWxmKGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBlbGVtZW50OiBBcmNFbGVtZW50LCBlbmRBbmdsZTogbnVtYmVyKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCB4LCB5LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIG9wdGlvbnN9ID0gZWxlbWVudDtcbiAgY29uc3Qge2JvcmRlcldpZHRoLCBib3JkZXJKb2luU3R5bGV9ID0gb3B0aW9ucztcbiAgY29uc3Qgb3V0ZXJBbmdsZUNsaXAgPSBNYXRoLm1pbihib3JkZXJXaWR0aCAvIG91dGVyUmFkaXVzLCBfbm9ybWFsaXplQW5nbGUoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSk7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cyAtIGJvcmRlcldpZHRoIC8gMiwgc3RhcnRBbmdsZSArIG91dGVyQW5nbGVDbGlwIC8gMiwgZW5kQW5nbGUgLSBvdXRlckFuZ2xlQ2xpcCAvIDIpO1xuXG4gIGlmIChpbm5lclJhZGl1cyA+IDApIHtcbiAgICBjb25zdCBpbm5lckFuZ2xlQ2xpcCA9IE1hdGgubWluKGJvcmRlcldpZHRoIC8gaW5uZXJSYWRpdXMsIF9ub3JtYWxpemVBbmdsZShzdGFydEFuZ2xlIC0gZW5kQW5nbGUpKTtcbiAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzICsgYm9yZGVyV2lkdGggLyAyLCBlbmRBbmdsZSAtIGlubmVyQW5nbGVDbGlwIC8gMiwgc3RhcnRBbmdsZSArIGlubmVyQW5nbGVDbGlwIC8gMiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY2xpcFdpZHRoID0gTWF0aC5taW4oYm9yZGVyV2lkdGggLyAyLCBvdXRlclJhZGl1cyAqIF9ub3JtYWxpemVBbmdsZShzdGFydEFuZ2xlIC0gZW5kQW5nbGUpKTtcblxuICAgIGlmIChib3JkZXJKb2luU3R5bGUgPT09ICdyb3VuZCcpIHtcbiAgICAgIGN0eC5hcmMoeCwgeSwgY2xpcFdpZHRoLCBlbmRBbmdsZSAtIFBJIC8gMiwgc3RhcnRBbmdsZSArIFBJIC8gMiwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChib3JkZXJKb2luU3R5bGUgPT09ICdiZXZlbCcpIHtcbiAgICAgIGNvbnN0IHIgPSAyICogY2xpcFdpZHRoICogY2xpcFdpZHRoO1xuICAgICAgY29uc3QgZW5kWCA9IC1yICogTWF0aC5jb3MoZW5kQW5nbGUgKyBQSSAvIDIpICsgeDtcbiAgICAgIGNvbnN0IGVuZFkgPSAtciAqIE1hdGguc2luKGVuZEFuZ2xlICsgUEkgLyAyKSArIHk7XG4gICAgICBjb25zdCBzdGFydFggPSByICogTWF0aC5jb3Moc3RhcnRBbmdsZSArIFBJIC8gMikgKyB4O1xuICAgICAgY29uc3Qgc3RhcnRZID0gciAqIE1hdGguc2luKHN0YXJ0QW5nbGUgKyBQSSAvIDIpICsgeTtcbiAgICAgIGN0eC5saW5lVG8oZW5kWCwgZW5kWSk7XG4gICAgICBjdHgubGluZVRvKHN0YXJ0WCwgc3RhcnRZKTtcbiAgICB9XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gIGN0eC5tb3ZlVG8oMCwgMCk7XG4gIGN0eC5yZWN0KDAsIDAsIGN0eC5jYW52YXMud2lkdGgsIGN0eC5jYW52YXMuaGVpZ2h0KTtcblxuICBjdHguY2xpcCgnZXZlbm9kZCcpO1xufVxuXG5cbmZ1bmN0aW9uIGNsaXBBcmMoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIGVsZW1lbnQ6IEFyY0VsZW1lbnQsIGVuZEFuZ2xlOiBudW1iZXIpIHtcbiAgY29uc3Qge3N0YXJ0QW5nbGUsIHBpeGVsTWFyZ2luLCB4LCB5LCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXN9ID0gZWxlbWVudDtcbiAgbGV0IGFuZ2xlTWFyZ2luID0gcGl4ZWxNYXJnaW4gLyBvdXRlclJhZGl1cztcblxuICAvLyBEcmF3IGFuIGlubmVyIGJvcmRlciBieSBjbGlwcGluZyB0aGUgYXJjIGFuZCBkcmF3aW5nIGEgZG91YmxlLXdpZHRoIGJvcmRlclxuICAvLyBFbmxhcmdlIHRoZSBjbGlwcGluZyBhcmMgYnkgMC4zMyBwaXhlbHMgdG8gZWxpbWluYXRlIGdsaXRjaGVzIGJldHdlZW4gYm9yZGVyc1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG4gIGlmIChpbm5lclJhZGl1cyA+IHBpeGVsTWFyZ2luKSB7XG4gICAgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGlubmVyUmFkaXVzO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmFyYyh4LCB5LCBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBIQUxGX1BJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuXG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ291dGVyU3RhcnQnLCAnb3V0ZXJFbmQnLCAnaW5uZXJTdGFydCcsICdpbm5lckVuZCddKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBib3JkZXIgcmFkaXVzIGZyb20gdGhlIHByb3ZpZGVkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYXJjOiBBcmNFbGVtZW50LCBpbm5lclJhZGl1czogbnVtYmVyLCBvdXRlclJhZGl1czogbnVtYmVyLCBhbmdsZURlbHRhOiBudW1iZXIpIHtcbiAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICBjb25zdCBoYWxmVGhpY2tuZXNzID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gMjtcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuXG4gIC8vIE91dGVyIGxpbWl0cyBhcmUgY29tcGxpY2F0ZWQuIFdlIHdhbnQgdG8gY29tcHV0ZSB0aGUgYXZhaWxhYmxlIGFuZ3VsYXIgZGlzdGFuY2UgYXRcbiAgLy8gYSByYWRpdXMgb2Ygb3V0ZXJSYWRpdXMgLSBib3JkZXJSYWRpdXMgYmVjYXVzZSBmb3Igc21hbGwgYW5ndWxhciBkaXN0YW5jZXMsIHRoaXMgdGVybSBsaW1pdHMuXG4gIC8vIFdlIGNvbXB1dGUgYXQgciA9IG91dGVyUmFkaXVzIC0gYm9yZGVyUmFkaXVzIGJlY2F1c2UgdGhpcyBjaXJjbGUgZGVmaW5lcyB0aGUgY2VudGVyIG9mIHRoZSBib3JkZXIgY29ybmVycy5cbiAgLy9cbiAgLy8gSWYgdGhlIGJvcmRlclJhZGl1cyBpcyBsYXJnZSwgdGhhdCB2YWx1ZSBjYW4gYmVjb21lIG5lZ2F0aXZlLlxuICAvLyBUaGlzIGNhdXNlcyB0aGUgb3V0ZXIgYm9yZGVycyB0byBsb3NlIHRoZWlyIHJhZGl1cyBlbnRpcmVseSwgd2hpY2ggaXMgcmF0aGVyIHVuZXhwZWN0ZWQuIFRvIHNvbHZlIHRoYXQsIGlmIGJvcmRlclJhZGl1cyA+IG91dGVyUmFkaXVzXG4gIC8vIHdlIGtub3cgdGhhdCB0aGUgdGhpY2tuZXNzIHRlcm0gd2lsbCBkb21pbmF0ZSBhbmQgY29tcHV0ZSB0aGUgbGltaXRzIGF0IHRoYXQgcG9pbnRcbiAgY29uc3QgY29tcHV0ZU91dGVyTGltaXQgPSAodmFsKSA9PiB7XG4gICAgY29uc3Qgb3V0ZXJBcmNMaW1pdCA9IChvdXRlclJhZGl1cyAtIE1hdGgubWluKGhhbGZUaGlja25lc3MsIHZhbCkpICogYW5nbGVEZWx0YSAvIDI7XG4gICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbCwgMCwgTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgb3V0ZXJBcmNMaW1pdCkpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogX2xpbWl0VmFsdWUoby5pbm5lclN0YXJ0LCAwLCBpbm5lckxpbWl0KSxcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydCAociwg8J2cgykgdG8gKHgsIHkpXG4gKi9cbmZ1bmN0aW9uIHJUaGV0YVRvWFkocjogbnVtYmVyLCB0aGV0YTogbnVtYmVyLCB4OiBudW1iZXIsIHk6IG51bWJlcikge1xuICByZXR1cm4ge1xuICAgIHg6IHggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHkgKyByICogTWF0aC5zaW4odGhldGEpLFxuICB9O1xufVxuXG5cbi8qKlxuICogUGF0aCB0aGUgYXJjLCByZXNwZWN0aW5nIGJvcmRlciByYWRpdXMgYnkgc2VwYXJhdGluZyBpbnRvIGxlZnQgYW5kIHJpZ2h0IGhhbHZlcy5cbiAqXG4gKiAgIFN0YXJ0ICAgICAgRW5kXG4gKlxuICogICAgMS0tLT5hLS0tPjIgICAgT3V0ZXJcbiAqICAgLyAgICAgICAgICAgXFxcbiAqICAgOCAgICAgICAgICAgM1xuICogICB8ICAgICAgICAgICB8XG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgNyAgICAgICAgICAgNFxuICogICBcXCAgICAgICAgICAgL1xuICogICAgNjwtLS1iPC0tLTUgICAgSW5uZXJcbiAqL1xuZnVuY3Rpb24gcGF0aEFyYyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGVuZDogbnVtYmVyLFxuICBjaXJjdWxhcjogYm9vbGVhbixcbikge1xuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZTogc3RhcnQsIHBpeGVsTWFyZ2luLCBpbm5lclJhZGl1czogaW5uZXJSfSA9IGVsZW1lbnQ7XG5cbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSICsgc3BhY2luZyArIG9mZnNldCArIHBpeGVsTWFyZ2luIDogMDtcblxuICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gIGNvbnN0IGFscGhhID0gZW5kIC0gc3RhcnQ7XG5cbiAgaWYgKHNwYWNpbmcpIHtcbiAgICAvLyBXaGVuIHNwYWNpbmcgaXMgcHJlc2VudCwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCBpdGVtc1xuICAgIC8vIFNvIHdlIGFkanVzdCB0aGUgc3RhcnQgYW5kIGVuZCBhbmdsZSBvZiB0aGUgYXJjIHN1Y2ggdGhhdFxuICAgIC8vIHRoZSBkaXN0YW5jZSBpcyB0aGUgc2FtZSBhcyBpdCB3b3VsZCBiZSB3aXRob3V0IHRoZSBzcGFjaW5nXG4gICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3Qgbm9TcGFjaW5nT3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyA+IDAgPyBvdXRlclJhZGl1cyAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IGF2Tm9nU3BhY2luZ1JhZGl1cyA9IChub1NwYWNpbmdJbm5lclJhZGl1cyArIG5vU3BhY2luZ091dGVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IChhbHBoYSAqIGF2Tm9nU3BhY2luZ1JhZGl1cykgLyAoYXZOb2dTcGFjaW5nUmFkaXVzICsgc3BhY2luZykgOiBhbHBoYTtcbiAgICBzcGFjaW5nT2Zmc2V0ID0gKGFscGhhIC0gYWRqdXN0ZWRBbmdsZSkgLyAyO1xuICB9XG5cbiAgY29uc3QgYmV0YSA9IE1hdGgubWF4KDAuMDAxLCBhbHBoYSAqIG91dGVyUmFkaXVzIC0gb2Zmc2V0IC8gUEkpIC8gb3V0ZXJSYWRpdXM7XG4gIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gKGFscGhhIC0gYmV0YSkgLyAyO1xuICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnQgKyBhbmdsZU9mZnNldCArIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IGVuZEFuZ2xlID0gZW5kIC0gYW5nbGVPZmZzZXQgLSBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCB7b3V0ZXJTdGFydCwgb3V0ZXJFbmQsIGlubmVyU3RhcnQsIGlubmVyRW5kfSA9IHBhcnNlQm9yZGVyUmFkaXVzKGVsZW1lbnQsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcblxuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyU3RhcnQ7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyRW5kO1xuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBvdXRlclN0YXJ0IC8gb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIG91dGVyRW5kIC8gb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cztcblxuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyU3RhcnQ7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyRW5kO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJFbmRBZGp1c3RlZFJhZGl1cztcblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgLy8gVGhlIGZpcnN0IGFyYyBzZWdtZW50cyBmcm9tIHBvaW50IDEgdG8gcG9pbnQgYSB0byBwb2ludCAyXG4gICAgY29uc3Qgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlID0gKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAvIDI7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIG91dGVyTWlkQWRqdXN0ZWRBbmdsZSk7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuXG4gICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgMiB0byBwb2ludCAzXG4gICAgaWYgKG91dGVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyRW5kLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIGVuZEFuZ2xlICsgSEFMRl9QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGxpbmUgZnJvbSBwb2ludCAzIHRvIHBvaW50IDRcbiAgICBjb25zdCBwNCA9IHJUaGV0YVRvWFkoaW5uZXJFbmRBZGp1c3RlZFJhZGl1cywgZW5kQW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDQueCwgcDQueSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA0IHRvIHBvaW50IDVcbiAgICBpZiAoaW5uZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJFbmQsIGVuZEFuZ2xlICsgSEFMRl9QSSwgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgLy8gVGhlIGlubmVyIGFyYyBmcm9tIHBvaW50IDUgdG8gcG9pbnQgYiB0byBwb2ludCA2XG4gICAgY29uc3QgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlID0gKChlbmRBbmdsZSAtIChpbm5lckVuZCAvIGlubmVyUmFkaXVzKSkgKyAoc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpKSkgLyAyO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpLCBpbm5lck1pZEFkanVzdGVkQW5nbGUsIHRydWUpO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgc3RhcnRBbmdsZSArIChpbm5lclN0YXJ0IC8gaW5uZXJSYWRpdXMpLCB0cnVlKTtcblxuICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDYgdG8gcG9pbnQgN1xuICAgIGlmIChpbm5lclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzLCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lclN0YXJ0LCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSArIE1hdGguUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbGluZSBmcm9tIHBvaW50IDcgdG8gcG9pbnQgOFxuICAgIGNvbnN0IHA4ID0gclRoZXRhVG9YWShvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIHN0YXJ0QW5nbGUsIHgsIHkpO1xuICAgIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XG5cbiAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCA4IHRvIHBvaW50IDFcbiAgICBpZiAob3V0ZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgIGNvbnN0IG91dGVyU3RhcnRYID0gTWF0aC5jb3Mob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyU3RhcnRZID0gTWF0aC5zaW4ob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJTdGFydFgsIG91dGVyU3RhcnRZKTtcblxuICAgIGNvbnN0IG91dGVyRW5kWCA9IE1hdGguY29zKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHg7XG4gICAgY29uc3Qgb3V0ZXJFbmRZID0gTWF0aC5zaW4ob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyRW5kWCwgb3V0ZXJFbmRZKTtcbiAgfVxuXG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cblxuZnVuY3Rpb24gZHJhd0FyYyhcbiAgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsXG4gIGVsZW1lbnQ6IEFyY0VsZW1lbnQsXG4gIG9mZnNldDogbnVtYmVyLFxuICBzcGFjaW5nOiBudW1iZXIsXG4gIGNpcmN1bGFyOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZX0gPSBlbGVtZW50O1xuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgJSBUQVUgfHwgVEFVKTtcbiAgICB9XG4gIH1cbiAgcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKTtcbiAgY3R4LmZpbGwoKTtcbiAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBkcmF3Qm9yZGVyKFxuICBjdHg6IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgZWxlbWVudDogQXJjRWxlbWVudCxcbiAgb2Zmc2V0OiBudW1iZXIsXG4gIHNwYWNpbmc6IG51bWJlcixcbiAgY2lyY3VsYXI6IGJvb2xlYW4sXG4pIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlLCBvcHRpb25zfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IHtib3JkZXJXaWR0aCwgYm9yZGVySm9pblN0eWxlLCBib3JkZXJEYXNoLCBib3JkZXJEYXNoT2Zmc2V0LCBib3JkZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3QgaW5uZXIgPSBvcHRpb25zLmJvcmRlckFsaWduID09PSAnaW5uZXInO1xuXG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2V0TGluZURhc2goYm9yZGVyRGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cblxuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5zZWxmSm9pbiAmJiBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPj0gUEkgJiYgYm9yZGVyUmFkaXVzID09PSAwICYmIGJvcmRlckpvaW5TdHlsZSAhPT0gJ21pdGVyJykge1xuICAgIGNsaXBTZWxmKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKCFmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXJjUHJvcHMgZXh0ZW5kcyBQb2ludCB7XG4gIHN0YXJ0QW5nbGU6IG51bWJlcjtcbiAgZW5kQW5nbGU6IG51bWJlcjtcbiAgaW5uZXJSYWRpdXM6IG51bWJlcjtcbiAgb3V0ZXJSYWRpdXM6IG51bWJlcjtcbiAgY2lyY3VtZmVyZW5jZTogbnVtYmVyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudDxBcmNQcm9wcywgQXJjT3B0aW9ucz4ge1xuXG4gIHN0YXRpYyBpZCA9ICdhcmMnO1xuXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJBbGlnbjogJ2NlbnRlcicsXG4gICAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogdW5kZWZpbmVkLFxuICAgIGJvcmRlclJhZGl1czogMCxcbiAgICBib3JkZXJXaWR0aDogMixcbiAgICBvZmZzZXQ6IDAsXG4gICAgc3BhY2luZzogMCxcbiAgICBhbmdsZTogdW5kZWZpbmVkLFxuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIHNlbGZKb2luOiBmYWxzZSxcbiAgfTtcblxuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXG4gIH07XG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCdcbiAgfTtcblxuICBjaXJjdW1mZXJlbmNlOiBudW1iZXI7XG4gIGVuZEFuZ2xlOiBudW1iZXI7XG4gIGZ1bGxDaXJjbGVzOiBudW1iZXI7XG4gIGlubmVyUmFkaXVzOiBudW1iZXI7XG4gIG91dGVyUmFkaXVzOiBudW1iZXI7XG4gIHBpeGVsTWFyZ2luOiBudW1iZXI7XG4gIHN0YXJ0QW5nbGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgaW5SYW5nZShjaGFydFg6IG51bWJlciwgY2hhcnRZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlLCBkaXN0YW5jZX0gPSBnZXRBbmdsZUZyb21Qb2ludChwb2ludCwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZSdcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCByQWRqdXN0ID0gKHRoaXMub3B0aW9ucy5zcGFjaW5nICsgdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoKSAvIDI7XG4gICAgY29uc3QgX2NpcmN1bWZlcmVuY2UgPSB2YWx1ZU9yRGVmYXVsdChjaXJjdW1mZXJlbmNlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IG5vblplcm9CZXR3ZWVuID0gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpICYmIHN0YXJ0QW5nbGUgIT09IGVuZEFuZ2xlO1xuICAgIGNvbnN0IGJldHdlZW5BbmdsZXMgPSBfY2lyY3VtZmVyZW5jZSA+PSBUQVUgfHwgbm9uWmVyb0JldHdlZW47XG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuXG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG4gIH1cblxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uOiBib29sZWFuKSB7XG4gICAgY29uc3Qge3gsIHksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXN9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAneCcsXG4gICAgICAneScsXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cydcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7b2Zmc2V0LCBzcGFjaW5nfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICB9O1xuICB9XG5cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb246IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGRyYXcoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDQ7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIGNvbnN0IGNpcmN1bGFyID0gb3B0aW9ucy5jaXJjdWxhcjtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gKG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IGNpcmN1bWZlcmVuY2UgPiBUQVUgPyBNYXRoLmZsb29yKGNpcmN1bWZlcmVuY2UgLyBUQVUpIDogMDtcblxuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgY3R4LnRyYW5zbGF0ZShNYXRoLmNvcyhoYWxmQW5nbGUpICogb2Zmc2V0LCBNYXRoLnNpbihoYWxmQW5nbGUpICogb2Zmc2V0KTtcbiAgICBjb25zdCBmaXggPSAxIC0gTWF0aC5zaW4oTWF0aC5taW4oUEksIGNpcmN1bWZlcmVuY2UgfHwgMCkpO1xuICAgIGNvbnN0IHJhZGl1c09mZnNldCA9IG9mZnNldCAqIGZpeDtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuXG4gICAgZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuICAgIGRyYXdCb3JkZXIoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge19iZXppZXJJbnRlcnBvbGF0aW9uLCBfcG9pbnRJbkxpbmUsIF9zdGVwcGVkSW50ZXJwb2xhdGlvbn0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmludGVycG9sYXRpb24uanMnO1xuaW1wb3J0IHtfY29tcHV0ZVNlZ21lbnRzLCBfYm91bmRTZWdtZW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLnNlZ21lbnQuanMnO1xuaW1wb3J0IHtfc3RlcHBlZExpbmVUbywgX2JlemllckN1cnZlVG99IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuaW1wb3J0IHtfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50c30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmN1cnZlLmpzJztcbmltcG9ydCB7dmFsdWVPckRlZmF1bHR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzdHlsZSA9IG9wdGlvbnMpIHtcbiAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoLCBvcHRpb25zLmJvcmRlckRhc2gpKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwgb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0KTtcbiAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gIGN0eC5saW5lV2lkdGggPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJXaWR0aCwgb3B0aW9ucy5ib3JkZXJXaWR0aCk7XG4gIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNvbG9yLCBvcHRpb25zLmJvcmRlckNvbG9yKTtcbn1cblxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5cbi8qKlxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZU1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRMaW5lVG87XG4gIH1cblxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVyQ3VydmVUbztcbiAgfVxuXG4gIHJldHVybiBsaW5lVG87XG59XG5cbmZ1bmN0aW9uIHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zID0ge30pIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCB7c3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCwgZW5kOiBwYXJhbXNFbmQgPSBjb3VudCAtIDF9ID0gcGFyYW1zO1xuICBjb25zdCB7c3RhcnQ6IHNlZ21lbnRTdGFydCwgZW5kOiBzZWdtZW50RW5kfSA9IHNlZ21lbnQ7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgocGFyYW1zU3RhcnQsIHNlZ21lbnRTdGFydCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHBhcmFtc0VuZCwgc2VnbWVudEVuZCk7XG4gIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBjb3VudCxcbiAgICBzdGFydCxcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgaWxlbjogZW5kIDwgc3RhcnQgJiYgIW91dHNpZGUgPyBjb3VudCArIGVuZCAtIHN0YXJ0IDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBpLCBwb2ludCwgcHJldjtcblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGkgOiBpKSkgJSBjb3VudF07XG5cbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBza2lwcGVkIHBvaW50IGluc2lkZSBhIHNlZ21lbnQsIHNwYW5HYXBzIG11c3QgYmUgdHJ1ZVxuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuXG4gICAgcHJldiA9IHBvaW50O1xuICB9XG5cbiAgaWYgKGxvb3ApIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICB9XG5cbiAgcmV0dXJuICEhbG9vcDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgcGF0aCBmcm9tIHBvaW50cywgZ3JvdXBpbmcgYnkgdHJ1bmNhdGVkIHgtY29vcmRpbmF0ZVxuICogUG9pbnRzIG5lZWQgdG8gYmUgaW4gb3JkZXIgYnkgeC1jb29yZGluYXRlIGZvciB0aGlzIHRvIHdvcmsgZWZmaWNpZW50bHlcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfFBhdGgyRH0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtvYmplY3R9IHNlZ21lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtc1xuICogQHBhcmFtIHtib29sZWFufSBwYXJhbXMubW92ZSAtIG1vdmUgdG8gc3RhcnRpbmcgcG9pbnQgKHZzIGxpbmUgdG8gaXQpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIGxpbWl0IHNlZ21lbnQgdG8gcG9pbnRzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5lbmQgLSBsaW1pdCBzZWdtZW50IHRvIHBvaW50cyBlbmRpbmcgYXQgYHN0YXJ0YCArIGBjb3VudGAgaW5kZXhcbiAqL1xuZnVuY3Rpb24gZmFzdFBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3Qge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGF2Z1ggPSAwO1xuICBsZXQgY291bnRYID0gMDtcbiAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG5cbiAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCkgPT4gKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaW5kZXggOiBpbmRleCkpICUgY291bnQ7XG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xuICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICAvLyBEcmF3IGxpbmUgdG8gbWF4WSBhbmQgbWluWSwgdXNpbmcgdGhlIGF2ZXJhZ2UgeC1jb29yZGluYXRlXG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgIC8vIExpbmUgdG8geS12YWx1ZSBvZiBsYXN0IHBvaW50IGluIGdyb3VwLiBTbyB0aGUgbGluZSBjb250aW51ZXNcbiAgICAgIC8vIGZyb20gY29ycmVjdCBwb3NpdGlvbi4gTm90IHVzaW5nIG1vdmUsIHRvIGhhdmUgc29saWQgcGF0aC5cbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgIH1cbiAgfTtcblxuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoaSldO1xuXG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgc2tpcHBlZCBwb2ludCBpbnNpZGUgYSBzZWdtZW50LCBzcGFuR2FwcyBtdXN0IGJlIHRydWVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwOyAvLyB0cnVuY2F0ZWQgeC1jb29yZGluYXRlXG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIC8vIEZvciBmaXJzdCBwb2ludCBpbiBncm91cCwgY291bnRYIGlzIGAwYCwgc28gYXZlcmFnZSB3aWxsIGJlIGB4YCAvIDEuXG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3WCgpO1xuICAgICAgLy8gRHJhdyBsaW5lIHRvIG5leHQgeC1wb3NpdGlvbiwgdXNpbmcgdGhlIGZpcnN0IChvciBvbmx5KVxuICAgICAgLy8geS12YWx1ZSBpbiB0aGF0IGdyb3VwXG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuXG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgeS12YWx1ZSBpbiBncm91cFxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnR9IGxpbmUgLSB0aGUgbGluZVxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cblxuICByZXR1cm4gX3BvaW50SW5MaW5lO1xufVxuXG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gIGN0eC5zdHJva2UocGF0aCk7XG59XG5cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHNlZ21lbnQuc3R5bGUpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtzdGFydCwgZW5kOiBzdGFydCArIGNvdW50IC0gMX0pKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnbGluZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgICBib3JkZXJEYXNoOiBbXSxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgICBib3JkZXJXaWR0aDogMyxcbiAgICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICAgIGZpbGw6IGZhbHNlLFxuICAgIHNwYW5HYXBzOiBmYWxzZSxcbiAgICBzdGVwcGVkOiBmYWxzZSxcbiAgICB0ZW5zaW9uOiAwLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xuICB9O1xuXG5cbiAgc3RhdGljIGRlc2NyaXB0b3JzID0ge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxuICB9O1xuXG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSAmJiAhb3B0aW9ucy5zdGVwcGVkICYmICF0aGlzLl9wb2ludHNVcGRhdGVkKSB7XG4gICAgICBjb25zdCBsb29wID0gb3B0aW9ucy5zcGFuR2FwcyA/IHRoaXMuX2xvb3AgOiB0aGlzLl9mdWxsTG9vcDtcbiAgICAgIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzKHRoaXMuX3BvaW50cywgb3B0aW9ucywgY2hhcnRBcmVhLCBsb29wLCBpbmRleEF4aXMpO1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuXG4gIGdldCBzZWdtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEZpcnN0IG5vbi1za2lwcGVkIHBvaW50IG9uIHRoaXMgbGluZVxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGZpcnN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICByZXR1cm4gc2VnbWVudHMubGVuZ3RoICYmIHBvaW50c1tzZWdtZW50c1swXS5zdGFydF07XG4gIH1cblxuICAvKipcblx0ICogTGFzdCBub24tc2tpcHBlZCBwb2ludCBvbiB0aGlzIGxpbmVcblx0ICogQHJldHVybnMge1BvaW50RWxlbWVudHx1bmRlZmluZWR9XG5cdCAqL1xuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBJbnRlcnBvbGF0ZSBhIHBvaW50IGluIHRoaXMgbGluZSBhdCB0aGUgc2FtZSB2YWx1ZSBvbiBgcHJvcGVydHlgIGFzXG5cdCAqIHRoZSByZWZlcmVuY2UgYHBvaW50YCBwcm92aWRlZFxuXHQgKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gcG9pbnQgLSB0aGUgcmVmZXJlbmNlIHBvaW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBwcm9wZXJ0eSB0byBtYXRjaCBvblxuXHQgKiBAcmV0dXJucyB7UG9pbnRFbGVtZW50fHVuZGVmaW5lZH1cblx0ICovXG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuXG4gICAgaWYgKCFzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRzW3N0YXJ0XTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2VuZF07XG4gICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGEgc2VnbWVudCBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWdtZW50XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZWdtZW50LnN0YXJ0IC0gc3RhcnQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudC5lbmQgLSBlbmQgaW5kZXggb2YgdGhlIHNlZ21lbnQsIHJlZmVycmluZyB0aGUgcG9pbnRzIGFycmF5XG4gXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNlZ21lbnQubG9vcCAtIGluZGljYXRlcyB0aGF0IHRoZSBzZWdtZW50IGlzIGEgbG9vcFxuXHQgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyYW1zLm1vdmUgLSBtb3ZlIHRvIHN0YXJ0aW5nIHBvaW50ICh2cyBsaW5lIHRvIGl0KVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5yZXZlcnNlIC0gcGF0aCB0aGUgc2VnbWVudCBmcm9tIGVuZCB0byBzdGFydFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnN0YXJ0IC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgc3RhcnRpbmcgZnJvbSBgc3RhcnRgIGluZGV4XG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwYXJhbXMuZW5kIC0gbGltaXQgc2VnbWVudCB0byBwb2ludHMgZW5kaW5nIGF0IGBzdGFydGAgKyBgY291bnRgIGluZGV4XG5cdCAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gLSB0cnVlIGlmIHRoZSBzZWdtZW50IGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cblxuICAvKipcblx0ICogQXBwZW5kIGFsbCBzZWdtZW50cyBvZiB0aGlzIGxpbmUgdG8gY3VycmVudCBwYXRoLlxuXHQgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxQYXRoMkR9IGN0eFxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKiBAcmV0dXJucyB7dW5kZWZpbmVkfGJvb2xlYW59IC0gdHJ1ZSBpZiBsaW5lIGlzIGEgZnVsbCBsb29wIChwYXRoIHNob3VsZCBiZSBjbG9zZWQpXG5cdCAqL1xuICBwYXRoKGN0eCwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICBsZXQgbG9vcCA9IHRoaXMuX2xvb3A7XG5cbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAodGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuXG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEcmF3XG5cdCAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcblx0ICogQHBhcmFtIHtvYmplY3R9IGNoYXJ0QXJlYVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuXHQgKiBAcGFyYW0ge251bWJlcn0gW2NvdW50XVxuXHQgKi9cbiAgZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGRyYXcoY3R4LCB0aGlzLCBzdGFydCwgY291bnQpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICAvLyBXaGVuIGxpbmUgaXMgYW5pbWF0ZWQsIHRoZSBjb250cm9sIHBvaW50cyBhbmQgcGF0aCBhcmUgbm90IGNhY2hlZC5cbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi4vY29yZS9jb3JlLmVsZW1lbnQuanMnO1xuaW1wb3J0IHtkcmF3UG9pbnQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB0eXBlIHtcbiAgQ2FydGVzaWFuUGFyc2VkRGF0YSxcbiAgQ2hhcnRBcmVhLFxuICBQb2ludCxcbiAgUG9pbnRIb3Zlck9wdGlvbnMsXG4gIFBvaW50T3B0aW9ucyxcbn0gZnJvbSAnLi4vdHlwZXMvaW5kZXguanMnO1xuXG5mdW5jdGlvbiBpblJhbmdlKGVsOiBQb2ludEVsZW1lbnQsIHBvczogbnVtYmVyLCBheGlzOiAneCcgfCAneScsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICBjb25zdCB7W2F4aXNdOiB2YWx1ZX0gPSBlbC5nZXRQcm9wcyhbYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pO1xuXG4gIHJldHVybiAoTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cyk7XG59XG5cbmV4cG9ydCB0eXBlIFBvaW50UHJvcHMgPSBQb2ludFxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PFBvaW50UHJvcHMsIFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPiB7XG5cbiAgc3RhdGljIGlkID0gJ3BvaW50JztcblxuICBwYXJzZWQ6IENhcnRlc2lhblBhcnNlZERhdGE7XG4gIHNraXA/OiBib29sZWFuO1xuICBzdG9wPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJXaWR0aDogMSxcbiAgICBoaXRSYWRpdXM6IDEsXG4gICAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgICBob3ZlclJhZGl1czogNCxcbiAgICBwb2ludFN0eWxlOiAnY2lyY2xlJyxcbiAgICByYWRpdXM6IDMsXG4gICAgcm90YXRpb246IDBcbiAgfTtcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2tpcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0b3AgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG5cbiAgaW5SYW5nZShtb3VzZVg6IG51bWJlciwgbW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiAoKE1hdGgucG93KG1vdXNlWCAtIHgsIDIpICsgTWF0aC5wb3cobW91c2VZIC0geSwgMikpIDwgTWF0aC5wb3cob3B0aW9ucy5oaXRSYWRpdXMgKyBvcHRpb25zLnJhZGl1cywgMikpO1xuICB9XG5cbiAgaW5YUmFuZ2UobW91c2VYOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCAneCcsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgaW5ZUmFuZ2UobW91c2VZOiBudW1iZXIsIHVzZUZpbmFsUG9zaXRpb24/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VZLCAneScsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbj86IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cblxuICBzaXplKG9wdGlvbnM/OiBQYXJ0aWFsPFBvaW50T3B0aW9ucyAmIFBvaW50SG92ZXJPcHRpb25zPikge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cblxuICBkcmF3KGN0eDogQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELCBhcmVhOiBDaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKHRoaXMuc2tpcCB8fCBvcHRpb25zLnJhZGl1cyA8IDAuMSB8fCAhX2lzUG9pbnRJbkFyZWEodGhpcywgYXJlYSwgdGhpcy5zaXplKG9wdGlvbnMpIC8gMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB0aGlzLngsIHRoaXMueSk7XG4gIH1cblxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgRmFsbGJhY2tzIHNob3VsZCBuZXZlciBiZSBoaXQgaW4gcHJhY3RpY2VcbiAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgfVxufVxuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCB7aXNPYmplY3QsIF9pc0JldHdlZW4sIF9saW1pdFZhbHVlfSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7YWRkUm91bmRlZFJlY3RQYXRofSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7dG9UUkJMLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKiBAdHlwZWRlZiB7eyB4OiBudW1iZXIsIHk6IG51bWJlciwgYmFzZTogbnVtYmVyLCBob3Jpem9udGFsOiBib29sZWFuLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSBCYXJQcm9wcyAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgYmFyIHJlZ2FyZGxlc3Mgb2YgdGhlIG9yaWVudGF0aW9uXG4gKiBAcGFyYW0ge0JhckVsZW1lbnR9IGJhciB0aGUgYmFyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VGaW5hbFBvc2l0aW9uXVxuICogQHJldHVybiB7b2JqZWN0fSBib3VuZHMgb2YgdGhlIGJhclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCB7eCwgeSwgYmFzZSwgd2lkdGgsIGhlaWdodH0gPSAvKiogQHR5cGUge0JhclByb3BzfSAqLyAoYmFyLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIHVzZUZpbmFsUG9zaXRpb24pKTtcblxuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xuXG4gIGlmIChiYXIuaG9yaXpvbnRhbCkge1xuICAgIGhhbGYgPSBoZWlnaHQgLyAyO1xuICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICByaWdodCA9IE1hdGgubWF4KHgsIGJhc2UpO1xuICAgIHRvcCA9IHkgLSBoYWxmO1xuICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICB9IGVsc2Uge1xuICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgbGVmdCA9IHggLSBoYWxmO1xuICAgIHJpZ2h0ID0geCArIGhhbGY7XG4gICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYmFzZSk7XG4gIH1cblxuICByZXR1cm4ge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX07XG59XG5cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gc2tpcCA/IDAgOiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlcldpZHRoKGJhciwgbWF4VywgbWF4SCkge1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlcldpZHRoO1xuICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IG8gPSB0b1RSQkwodmFsdWUpO1xuXG4gIHJldHVybiB7XG4gICAgdDogc2tpcE9yTGltaXQoc2tpcC50b3AsIG8udG9wLCAwLCBtYXhIKSxcbiAgICByOiBza2lwT3JMaW1pdChza2lwLnJpZ2h0LCBvLnJpZ2h0LCAwLCBtYXhXKSxcbiAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxuICAgIGw6IHNraXBPckxpbWl0KHNraXAubGVmdCwgby5sZWZ0LCAwLCBtYXhXKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3Qge2VuYWJsZUJvcmRlclJhZGl1c30gPSBiYXIuZ2V0UHJvcHMoWydlbmFibGVCb3JkZXJSYWRpdXMnXSk7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XG4gIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3QsIGFzc3VtZSB0aGUgdXNlciBrbm93cyB3aGF0IHRoZXkgYXJlIGRvaW5nXG4gIC8vIGFuZCBhcHBseSBhcyBkaXJlY3RlZC5cbiAgY29uc3QgZW5hYmxlQm9yZGVyID0gZW5hYmxlQm9yZGVyUmFkaXVzIHx8IGlzT2JqZWN0KHZhbHVlKTtcblxuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5sZWZ0LCBvLnRvcExlZnQsIDAsIG1heFIpLFxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgIGJvdHRvbVJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIG1heFIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMoYmFyKSB7XG4gIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICBjb25zdCB3aWR0aCA9IGJvdW5kcy5yaWdodCAtIGJvdW5kcy5sZWZ0O1xuICBjb25zdCBoZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gYm91bmRzLnRvcDtcbiAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIGNvbnN0IHJhZGl1cyA9IHBhcnNlQm9yZGVyUmFkaXVzKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuICByZXR1cm4ge1xuICAgIG91dGVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCxcbiAgICAgIHk6IGJvdW5kcy50b3AsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodCxcbiAgICAgIHJhZGl1c1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG4gICAgICB5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG4gICAgICB3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG4gICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHRvcExlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BMZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5sKSksXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcbiAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbUxlZnQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLmwpKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21SaWdodCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIucikpLFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XG4gIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG5cbiAgcmV0dXJuIGJvdW5kc1xuXHRcdCYmIChza2lwWCB8fCBfaXNCZXR3ZWVuKHgsIGJvdW5kcy5sZWZ0LCBib3VuZHMucmlnaHQpKVxuXHRcdCYmIChza2lwWSB8fCBfaXNCZXR3ZWVuKHksIGJvdW5kcy50b3AsIGJvdW5kcy5ib3R0b20pKTtcbn1cblxuZnVuY3Rpb24gaGFzUmFkaXVzKHJhZGl1cykge1xuICByZXR1cm4gcmFkaXVzLnRvcExlZnQgfHwgcmFkaXVzLnRvcFJpZ2h0IHx8IHJhZGl1cy5ib3R0b21MZWZ0IHx8IHJhZGl1cy5ib3R0b21SaWdodDtcbn1cblxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENvbnRleHRcbiAqIEBwYXJhbSB7Kn0gcmVjdCBCb3VuZGluZyByZWN0XG4gKi9cbmZ1bmN0aW9uIGFkZE5vcm1hbFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgY29uc3QgeSA9IHJlY3QueSAhPT0gcmVmUmVjdC55ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC54ICsgeCxcbiAgICB5OiByZWN0LnkgKyB5LFxuICAgIHc6IHJlY3QudyArIHcsXG4gICAgaDogcmVjdC5oICsgaCxcbiAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICBzdGF0aWMgaWQgPSAnYmFyJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICBib3JkZXJTa2lwcGVkOiAnc3RhcnQnLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGJvcmRlclJhZGl1czogMCxcbiAgICBpbmZsYXRlQW1vdW50OiAnYXV0bycsXG4gICAgcG9pbnRTdHlsZTogdW5kZWZpbmVkXG4gIH07XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gIH07XG5cbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbmZsYXRlQW1vdW50ID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuXG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qge2luZmxhdGVBbW91bnQsIG9wdGlvbnM6IHtib3JkZXJDb2xvciwgYmFja2dyb3VuZENvbG9yfX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpbm5lciwgb3V0ZXJ9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICBjb25zdCBhZGRSZWN0UGF0aCA9IGhhc1JhZGl1cyhvdXRlci5yYWRpdXMpID8gYWRkUm91bmRlZFJlY3RQYXRoIDogYWRkTm9ybWFsUmVjdFBhdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgfVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuXG4gIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbnVsbCwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cblxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBudWxsLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG5cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBiYXNlLCBob3Jpem9udGFsfSA9IC8qKiBAdHlwZSB7QmFyUHJvcHN9ICovICh0aGlzLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnaG9yaXpvbnRhbCddLCB1c2VGaW5hbFBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyAoeCArIGJhc2UpIC8gMiA6IHgsXG4gICAgICB5OiBob3Jpem9udGFsID8geSA6ICh5ICsgYmFzZSkgLyAyXG4gICAgfTtcbiAgfVxuXG4gIGdldFJhbmdlKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gIH1cbn1cbiIsICJpbXBvcnQge0RvdWdobnV0Q29udHJvbGxlciwgUG9sYXJBcmVhQ29udHJvbGxlciwgZGVmYXVsdHN9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCB0eXBlIHtDaGFydCwgQ2hhcnREYXRhc2V0fSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JzUGx1Z2luT3B0aW9ucyB7XG4gIGVuYWJsZWQ/OiBib29sZWFuO1xuICBmb3JjZU92ZXJyaWRlPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIENvbG9yc0Rlc2NyaXB0b3Ige1xuICBiYWNrZ3JvdW5kQ29sb3I/OiB1bmtub3duO1xuICBib3JkZXJDb2xvcj86IHVua25vd247XG59XG5cbmNvbnN0IEJPUkRFUl9DT0xPUlMgPSBbXG4gICdyZ2IoNTQsIDE2MiwgMjM1KScsIC8vIGJsdWVcbiAgJ3JnYigyNTUsIDk5LCAxMzIpJywgLy8gcmVkXG4gICdyZ2IoMjU1LCAxNTksIDY0KScsIC8vIG9yYW5nZVxuICAncmdiKDI1NSwgMjA1LCA4NiknLCAvLyB5ZWxsb3dcbiAgJ3JnYig3NSwgMTkyLCAxOTIpJywgLy8gZ3JlZW5cbiAgJ3JnYigxNTMsIDEwMiwgMjU1KScsIC8vIHB1cnBsZVxuICAncmdiKDIwMSwgMjAzLCAyMDcpJyAvLyBncmV5XG5dO1xuXG4vLyBCb3JkZXIgY29sb3JzIHdpdGggNTAlIHRyYW5zcGFyZW5jeVxuY29uc3QgQkFDS0dST1VORF9DT0xPUlMgPSAvKiAjX19QVVJFX18gKi8gQk9SREVSX0NPTE9SUy5tYXAoY29sb3IgPT4gY29sb3IucmVwbGFjZSgncmdiKCcsICdyZ2JhKCcpLnJlcGxhY2UoJyknLCAnLCAwLjUpJykpO1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJDb2xvcihpOiBudW1iZXIpIHtcbiAgcmV0dXJuIEJPUkRFUl9DT0xPUlNbaSAlIEJPUkRFUl9DT0xPUlMubGVuZ3RoXTtcbn1cblxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZENvbG9yKGk6IG51bWJlcikge1xuICByZXR1cm4gQkFDS0dST1VORF9DT0xPUlNbaSAlIEJBQ0tHUk9VTkRfQ09MT1JTLmxlbmd0aF07XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplRGVmYXVsdERhdGFzZXQoZGF0YXNldDogQ2hhcnREYXRhc2V0LCBpOiBudW1iZXIpIHtcbiAgZGF0YXNldC5ib3JkZXJDb2xvciA9IGdldEJvcmRlckNvbG9yKGkpO1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGdldEJhY2tncm91bmRDb2xvcihpKTtcblxuICByZXR1cm4gKytpO1xufVxuXG5mdW5jdGlvbiBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCkgPT4gZ2V0Qm9yZGVyQ29sb3IoaSsrKSk7XG5cbiAgcmV0dXJuIGk7XG59XG5cbmZ1bmN0aW9uIGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0OiBDaGFydERhdGFzZXQsIGk6IG51bWJlcikge1xuICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCkgPT4gZ2V0QmFja2dyb3VuZENvbG9yKGkrKykpO1xuXG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBnZXRDb2xvcml6ZXIoY2hhcnQ6IENoYXJ0KSB7XG4gIGxldCBpID0gMDtcblxuICByZXR1cm4gKGRhdGFzZXQ6IENoYXJ0RGF0YXNldCwgZGF0YXNldEluZGV4OiBudW1iZXIpID0+IHtcbiAgICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBEb3VnaG51dENvbnRyb2xsZXIpIHtcbiAgICAgIGkgPSBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBQb2xhckFyZWFDb250cm9sbGVyKSB7XG4gICAgICBpID0gY29sb3JpemVQb2xhckFyZWFEYXRhc2V0KGRhdGFzZXQsIGkpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlcikge1xuICAgICAgaSA9IGNvbG9yaXplRGVmYXVsdERhdGFzZXQoZGF0YXNldCwgaSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKFxuICBkZXNjcmlwdG9yczogQ29sb3JzRGVzY3JpcHRvcltdIHwgUmVjb3JkPHN0cmluZywgQ29sb3JzRGVzY3JpcHRvcj5cbikge1xuICBsZXQgazogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIGZvciAoayBpbiBkZXNjcmlwdG9ycykge1xuICAgIGlmIChkZXNjcmlwdG9yc1trXS5ib3JkZXJDb2xvciB8fCBkZXNjcmlwdG9yc1trXS5iYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKFxuICBkZXNjcmlwdG9yOiBDb2xvcnNEZXNjcmlwdG9yXG4pIHtcbiAgcmV0dXJuIGRlc2NyaXB0b3IgJiYgKGRlc2NyaXB0b3IuYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvci5iYWNrZ3JvdW5kQ29sb3IpO1xufVxuXG5mdW5jdGlvbiBjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucygpIHtcbiAgcmV0dXJuIGRlZmF1bHRzLmJvcmRlckNvbG9yICE9PSAncmdiYSgwLDAsMCwwLjEpJyB8fCBkZWZhdWx0cy5iYWNrZ3JvdW5kQ29sb3IgIT09ICdyZ2JhKDAsMCwwLDAuMSknO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnY29sb3JzJyxcblxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZm9yY2VPdmVycmlkZTogZmFsc2VcbiAgfSBhcyBDb2xvcnNQbHVnaW5PcHRpb25zLFxuXG4gIGJlZm9yZUxheW91dChjaGFydDogQ2hhcnQsIF9hcmdzLCBvcHRpb25zOiBDb2xvcnNQbHVnaW5PcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7ZGF0YXNldHN9LFxuICAgICAgb3B0aW9uczogY2hhcnRPcHRpb25zXG4gICAgfSA9IGNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCB7ZWxlbWVudHN9ID0gY2hhcnRPcHRpb25zO1xuXG4gICAgY29uc3QgY29udGFpbnNDb2xvckRlZmVuaXRpb24gPSAoXG4gICAgICBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGRhdGFzZXRzKSB8fFxuICAgICAgY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKGNoYXJ0T3B0aW9ucykgfHxcbiAgICAgIChlbGVtZW50cyAmJiBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGVsZW1lbnRzKSkgfHxcbiAgICAgIGNvbnRhaW5zRGVmYXVsdENvbG9yc0RlZmVuaXRpb25zKCkpO1xuXG4gICAgaWYgKCFvcHRpb25zLmZvcmNlT3ZlcnJpZGUgJiYgY29udGFpbnNDb2xvckRlZmVuaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb2xvcml6ZXIgPSBnZXRDb2xvcml6ZXIoY2hhcnQpO1xuXG4gICAgZGF0YXNldHMuZm9yRWFjaChjb2xvcml6ZXIpO1xuICB9XG59O1xuIiwgImltcG9ydCB7X2xpbWl0VmFsdWUsIF9sb29rdXBCeUtleSwgaXNOdWxsT3JVbmRlZiwgcmVzb2x2ZX0gZnJvbSAnLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBMYXJnZXN0IFRyaWFuZ2xlIFRocmVlIEJ1Y2tldHMgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBpbXBsZW1lbnRhdGlvbiBieSBTdmVpbm4gU3RlaW5hcnNzb25cbiAgICogaW4gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWlubi1zdGVpbmFyc3Nvbi9mbG90LWRvd25zYW1wbGUvYmxvYi9tYXN0ZXIvanF1ZXJ5LmZsb3QuZG93bnNhbXBsZS5qc1xuICAgKlxuICAgKiBUaGUgb3JpZ2luYWwgaW1wbGVtZW50YXRpb24gaXMgTUlUIGxpY2Vuc2VkLlxuICAgKi9cbiAgY29uc3Qgc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcyB8fCBhdmFpbGFibGVXaWR0aDtcbiAgLy8gVGhlcmUgYXJlIGxlc3MgcG9pbnRzIHRoYW4gdGhlIHRocmVzaG9sZCwgcmV0dXJuaW5nIHRoZSB3aG9sZSBhcnJheVxuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuXG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuXG4gIGNvbnN0IGJ1Y2tldFdpZHRoID0gKGNvdW50IC0gMikgLyAoc2FtcGxlcyAtIDIpO1xuICBsZXQgc2FtcGxlZEluZGV4ID0gMDtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgLy8gU3RhcnRpbmcgZnJvbSBvZmZzZXRcbiAgbGV0IGEgPSBzdGFydDtcbiAgbGV0IGksIG1heEFyZWFQb2ludCwgbWF4QXJlYSwgYXJlYSwgbmV4dEE7XG5cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG5cbiAgZm9yIChpID0gMDsgaSA8IHNhbXBsZXMgLSAyOyBpKyspIHtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGF2Z1kgPSAwO1xuICAgIGxldCBqO1xuXG4gICAgLy8gQWRkaW5nIG9mZnNldFxuICAgIGNvbnN0IGF2Z1JhbmdlU3RhcnQgPSBNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUxlbmd0aCA9IGF2Z1JhbmdlRW5kIC0gYXZnUmFuZ2VTdGFydDtcblxuICAgIGZvciAoaiA9IGF2Z1JhbmdlU3RhcnQ7IGogPCBhdmdSYW5nZUVuZDsgaisrKSB7XG4gICAgICBhdmdYICs9IGRhdGFbal0ueDtcbiAgICAgIGF2Z1kgKz0gZGF0YVtqXS55O1xuICAgIH1cblxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcblxuICAgIC8vIEFkZGluZyBvZmZzZXRcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBjaGFuZ2VkIGZyb20gdGhlIG9yaWdpbmFsIGFsZ29yaXRobSB3aGljaCBpbml0aWFsaXplcyB0aGVzZVxuICAgIC8vIHZhbHVlcyB0byAxLiBUaGUgcmVhc29uIGZvciB0aGlzIGNoYW5nZSBpcyB0aGF0IGlmIHRoZSBhcmVhIGlzIHNtYWxsLCBuZXh0QVxuICAgIC8vIHdvdWxkIG5ldmVyIGJlIHNldCBhbmQgdGh1cyBhIGNyYXNoIHdvdWxkIG9jY3VyIGluIHRoZSBuZXh0IGxvb3AgYXMgYGFgIHdvdWxkIGJlY29tZVxuICAgIC8vIGB1bmRlZmluZWRgLiBTaW5jZSB0aGUgYXJlYSBpcyBhbHdheXMgcG9zaXRpdmUsIGJ1dCBjb3VsZCBiZSAwIGluIHRoZSBjYXNlIG9mIGEgZmxhdCB0cmFjZSxcbiAgICAvLyBpbml0aWFsaXppbmcgd2l0aCBhIG5lZ2F0aXZlIG51bWJlciBpcyB0aGUgY29ycmVjdCBzb2x1dGlvbi5cbiAgICBtYXhBcmVhID0gYXJlYSA9IC0xO1xuXG4gICAgZm9yIChqID0gcmFuZ2VPZmZzOyBqIDwgcmFuZ2VUbzsgaisrKSB7XG4gICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoXG4gICAgICAgIChwb2ludEF4IC0gYXZnWCkgKiAoZGF0YVtqXS55IC0gcG9pbnRBeSkgLVxuICAgICAgICAocG9pbnRBeCAtIGRhdGFbal0ueCkgKiAoYXZnWSAtIHBvaW50QXkpXG4gICAgICApO1xuXG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgIGEgPSBuZXh0QTtcbiAgfVxuXG4gIC8vIEluY2x1ZGUgdGhlIGxhc3QgcG9pbnRcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuXG4gIHJldHVybiBkZWNpbWF0ZWQ7XG59XG5cbmZ1bmN0aW9uIG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCkge1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHgsIHksIHByZXZYLCBtaW5JbmRleCwgbWF4SW5kZXgsIHN0YXJ0SW5kZXgsIG1pblksIG1heFk7XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuXG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcblxuICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICB4ID0gKHBvaW50LnggLSB4TWluKSAvIGR4ICogYXZhaWxhYmxlV2lkdGg7XG4gICAgeSA9IHBvaW50Lnk7XG4gICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG5cbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgLy8gRGV0ZXJtaW5lIGBtaW5ZYCAvIGBtYXhZYCBhbmQgYGF2Z1hgIHdoaWxlIHdlIHN0YXkgd2l0aGluIHNhbWUgeC1wb3NpdGlvblxuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICAvLyBGb3IgZmlyc3QgcG9pbnQgaW4gZ3JvdXAsIGNvdW50WCBpcyBgMGAsIHNvIGF2ZXJhZ2Ugd2lsbCBiZSBgeGAgLyAxLlxuICAgICAgLy8gVXNlIHBvaW50LnggaGVyZSBiZWNhdXNlIHdlJ3JlIGNvbXB1dGluZyB0aGUgYXZlcmFnZSBkYXRhIGB4YCB2YWx1ZVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHVzaCB1cCB0byA0IHBvaW50cywgMyBmb3IgdGhlIGxhc3QgaW50ZXJ2YWwgYW5kIHRoZSBmaXJzdCBwb2ludCBmb3IgdGhpcyBpbnRlcnZhbFxuICAgICAgY29uc3QgbGFzdEluZGV4ID0gaSAtIDE7XG5cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihtaW5JbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYobWF4SW5kZXgpKSB7XG4gICAgICAgIC8vIFRoZSBpbnRlcnZhbCBpcyBkZWZpbmVkIGJ5IDQgcG9pbnRzOiBzdGFydCwgbWluLCBtYXgsIGVuZC5cbiAgICAgICAgLy8gVGhlIHN0YXJ0aW5nIHBvaW50IGlzIGFscmVhZHkgY29uc2lkZXJlZCBhdCB0aGlzIHBvaW50LCBzbyB3ZSBuZWVkIHRvIGRldGVybWluZSB3aGljaFxuICAgICAgICAvLyBvZiB0aGUgb3RoZXIgcG9pbnRzIHRvIGFkZC4gV2UgbmVlZCB0byBzb3J0IHRoZXNlIHBvaW50cyB0byBlbnN1cmUgdGhlIGRlY2ltYXRlZCBkYXRhXG4gICAgICAgIC8vIGlzIHN0aWxsIHNvcnRlZCBhbmQgdGhlbiBlbnN1cmUgdGhlcmUgYXJlIG5vIGR1cGxpY2F0ZXMuXG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MSA9IE1hdGgubWluKG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MiA9IE1hdGgubWF4KG1pbkluZGV4LCBtYXhJbmRleCk7XG5cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBsYXN0SW5kZXggPT09IHN0YXJ0SW5kZXggd2lsbCBvY2N1ciB3aGVuIGEgcmFuZ2UgaGFzIG9ubHkgMSBwb2ludCB3aGljaCBjb3VsZFxuICAgICAgLy8gaGFwcGVuIHdpdGggdmVyeSB1bmV2ZW4gZGF0YVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICAvLyBMYXN0IHBvaW50IGluIHRoZSBwcmV2aW91cyBpbnRlcnZhbFxuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTdGFydCBvZiB0aGUgbmV3IGludGVydmFsXG4gICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGRhdGEsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KSB7XG4gIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCkgPT4ge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIHBvaW50cykge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG5cbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcblxuICBpZiAobWluRGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1pbikubG8sIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCkge1xuICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2RlY2ltYXRpb24nLFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxnb3JpdGhtOiAnbWluLW1heCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gIH0sXG5cbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAvLyBUaGUgZGVjaW1hdGlvbiBwbHVnaW4gbWF5IGhhdmUgYmVlbiBwcmV2aW91c2x5IGVuYWJsZWQuIE5lZWQgdG8gcmVtb3ZlIG9sZCBgZGF0YXNldC5fZGF0YWAgaGFuZGxlcnNcbiAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXNzdW1lIHRoZSBlbnRpcmUgY2hhcnQgaXMgYXZhaWxhYmxlIHRvIHNob3cgYSBmZXcgbW9yZSBwb2ludHMgdGhhbiBuZWVkZWRcbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuXG4gICAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtfZGF0YSwgaW5kZXhBeGlzfSA9IGRhdGFzZXQ7XG4gICAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBfZGF0YSB8fCBkYXRhc2V0LmRhdGE7XG5cbiAgICAgIGlmIChyZXNvbHZlKFtpbmRleEF4aXMsIGNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09ICd5Jykge1xuICAgICAgICAvLyBEZWNpbWF0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBsaW5lcyB0aGF0IGhhdmUgYW4gWCBpbmRleEF4aXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcbiAgICAgICAgLy8gT25seSBsaW5lIGRhdGFzZXRzIGFyZSBzdXBwb3J0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICAvLyBPbmx5IGxpbmVhciBpbnRlcnBvbGF0aW9uIGlzIHN1cHBvcnRlZFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFydC5vcHRpb25zLnBhcnNpbmcpIHtcbiAgICAgICAgLy8gUGx1Z2luIG9ubHkgc3VwcG9ydHMgZGF0YSB0aGF0IGRvZXMgbm90IG5lZWQgcGFyc2luZ1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICAvLyBObyBkZWNpbWF0aW9uIGlzIHJlcXVpcmVkIHVudGlsIHdlIGFyZSBhYm92ZSB0aGlzIHRocmVzaG9sZFxuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgd2UgYXJlIHNlZWluZyB0aGlzIGRhdGFzZXRcbiAgICAgICAgLy8gV2Ugb3ZlcnJpZGUgdGhlICdkYXRhJyBwcm9wZXJ0eSB3aXRoIGEgc2V0dGVyIHRoYXQgc3RvcmVzIHRoZVxuICAgICAgICAvLyByYXcgZGF0YSBpbiBfZGF0YSwgYnV0IHJlYWRzIHRoZSBkZWNpbWF0ZWQgZGF0YSBmcm9tIF9kZWNpbWF0ZWRcbiAgICAgICAgZGF0YXNldC5fZGF0YSA9IGRhdGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY2ltYXRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gUG9pbnQgdGhlIGNoYXJ0IHRvIHRoZSBkZWNpbWF0ZWQgZGF0YVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cblxuICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgIH0pO1xuICB9LFxuXG4gIGRlc3Ryb3koY2hhcnQpIHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICB9XG59O1xuIiwgImltcG9ydCB7X2JvdW5kU2VnbWVudCwgX2JvdW5kU2VnbWVudHMsIF9ub3JtYWxpemVBbmdsZX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB0cG9pbnRzID0gdGFyZ2V0LnBvaW50cztcbiAgY29uc3QgcGFydHMgPSBbXTtcblxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKTtcblxuICAgIGNvbnN0IGJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHBvaW50c1tzdGFydF0sIHBvaW50c1tlbmRdLCBzZWdtZW50Lmxvb3ApO1xuXG4gICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYm91bmRhcnkgbm90IHN1cHBvcnRpbmcgYHNlZ21lbnRzYCAoc2ltcGxlQXJjKVxuICAgICAgLy8gQm91bmRzIGFyZSBwcm92aWRlZCBhcyBgdGFyZ2V0YCBmb3IgcGFydGlhbCBjaXJjbGUsIG9yIHVuZGVmaW5lZCBmb3IgZnVsbCBjaXJjbGVcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgIHRhcmdldDogYm91bmRzLFxuICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYWxsIHNlZ21lbnRzIGZyb20gYHRhcmdldGAgdGhhdCBpbnRlcnNlY3QgdGhlIGJvdW5kcyBvZiBjdXJyZW50IHNlZ21lbnQgb2YgYGxpbmVgXG4gICAgY29uc3QgdGFyZ2V0U2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0YXJnZXQsIGJvdW5kcyk7XG5cbiAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cykge1xuICAgICAgY29uc3Qgc3ViQm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuXG4gICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpIHtcbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlOiBmaWxsU291cmNlLFxuICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ3N0YXJ0JywgTWF0aC5tYXgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldEJvdW5kcyhwcm9wZXJ0eSwgZmlyc3QsIGxhc3QsIGxvb3ApIHtcbiAgaWYgKGxvb3ApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICBsZXQgZW5kID0gbGFzdFtwcm9wZXJ0eV07XG5cbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgc3RhcnQgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICAgIGVuZCA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICB9XG4gIHJldHVybiB7cHJvcGVydHksIHN0YXJ0LCBlbmR9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICBjb25zdCB7eCA9IG51bGwsIHkgPSBudWxsfSA9IGJvdW5kYXJ5IHx8IHt9O1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBsaW5lLnNlZ21lbnRzLmZvckVhY2goKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBsaW5lUG9pbnRzKTtcbiAgICBjb25zdCBmaXJzdCA9IGxpbmVQb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3QgPSBsaW5lUG9pbnRzW2VuZF07XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBmaXJzdC54LCB5fSk7XG4gICAgICBwb2ludHMucHVzaCh7eDogbGFzdC54LCB5fSk7XG4gICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogZmlyc3QueX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGxhc3QueX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuXG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICBpZiAoYSAmJiBiKSB7XG4gICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICB9XG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cbiIsICIvKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuaW1wb3J0IHtMaW5lRWxlbWVudH0gZnJvbSAnLi4vLi4vZWxlbWVudHMvaW5kZXguanMnO1xuaW1wb3J0IHtpc0FycmF5fSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3BvaW50c0Zyb21TZWdtZW50c30gZnJvbSAnLi9maWxsZXIuc2VnbWVudC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXSB8IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IH19IGJvdW5kYXJ5XG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudD99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGxldCBwb2ludHMgPSBbXTtcbiAgbGV0IF9sb29wID0gZmFsc2U7XG5cbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgfSBlbHNlIHtcbiAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuZmlsbCAhPT0gZmFsc2U7XG59XG4iLCAiaW1wb3J0IHtpc09iamVjdCwgaXNGaW5pdGUsIHZhbHVlT3JEZWZhdWx0fSBmcm9tICcuLi8uLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcycpLmRlZmF1bHQgfSBMaW5lRWxlbWVudFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL3R5cGVzL2luZGV4LmpzJykuRmlsbFRhcmdldCB9IEZpbGxUYXJnZXRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi90eXBlcy9pbmRleC5qcycpLkNvbXBsZXhGaWxsVGFyZ2V0IH0gQ29tcGxleEZpbGxUYXJnZXRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG5cbiAgaWYgKCFwcm9wYWdhdGUpIHtcbiAgICByZXR1cm4gZmlsbDtcbiAgfVxuXG4gIHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShmaWxsKSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0YXJnZXQudmlzaWJsZSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuXG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xpbmVFbGVtZW50fSBsaW5lXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RlY29kZUZpbGwobGluZSwgaW5kZXgsIGNvdW50KSB7XG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwge3ZhbHVlOiBudW1iZXJ9fSAqL1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuXG4gIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHJldHVybiBpc05hTihmaWxsLnZhbHVlKSA/IGZhbHNlIDogZmlsbDtcbiAgfVxuXG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuXG4gIGlmIChpc0Zpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGRlY29kZVRhcmdldEluZGV4KGZpbGxbMF0sIGluZGV4LCB0YXJnZXQsIGNvdW50KTtcbiAgfVxuXG4gIHJldHVybiBbJ29yaWdpbicsICdzdGFydCcsICdlbmQnLCAnc3RhY2snLCAnc2hhcGUnXS5pbmRleE9mKGZpbGwpID49IDAgJiYgZmlsbDtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVGFyZ2V0SW5kZXgoZmlyc3RDaCwgaW5kZXgsIHRhcmdldCwgY291bnQpIHtcbiAgaWYgKGZpcnN0Q2ggPT09ICctJyB8fCBmaXJzdENoID09PSAnKycpIHtcbiAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgfVxuXG4gIGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ZpbGxUYXJnZXQgfCBDb21wbGV4RmlsbFRhcmdldH0gZmlsbFxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBudWxsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKSB7XG4gIGxldCBwaXhlbCA9IG51bGw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5ib3R0b207XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwaXhlbCA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUoZmlsbC52YWx1ZSk7XG4gIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgfVxuICByZXR1cm4gcGl4ZWw7XG59XG5cbi8qKlxuICogQHBhcmFtIHtGaWxsVGFyZ2V0IHwgQ29tcGxleEZpbGxUYXJnZXR9IGZpbGxcbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRWYWx1ZVxuICogQHJldHVybnMge251bWJlciB8IHVuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnRWYWx1ZSkge1xuICBsZXQgdmFsdWU7XG5cbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0VmFsdWU7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLm9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICovXG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuXG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBmaWxsID0gISFvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgfVxuXG4gIGlmIChmaWxsID09PSBmYWxzZSB8fCBmaWxsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG4iLCAiLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vLi4vY29yZS9jb3JlLmNvbnRyb2xsZXIuanMnKS5kZWZhdWx0IH0gQ2hhcnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuc2NhbGUuanMnKS5kZWZhdWx0IH0gU2NhbGVcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9lbGVtZW50cy9lbGVtZW50LnBvaW50LmpzJykuZGVmYXVsdCB9IFBvaW50RWxlbWVudFxuICovXG5cbmltcG9ydCB7TGluZUVsZW1lbnR9IGZyb20gJy4uLy4uL2VsZW1lbnRzL2luZGV4LmpzJztcbmltcG9ydCB7X2lzQmV0d2Vlbn0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19jcmVhdGVCb3VuZGFyeUxpbmV9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHt7IGNoYXJ0OiBDaGFydDsgc2NhbGU6IFNjYWxlOyBpbmRleDogbnVtYmVyOyBsaW5lOiBMaW5lRWxlbWVudDsgfX0gc291cmNlXG4gKiBAcmV0dXJuIHtMaW5lRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9idWlsZFN0YWNrTGluZShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBpbmRleCwgbGluZX0gPSBzb3VyY2U7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHNvdXJjZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBsaW5lc0JlbG93ID0gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpO1xuICBsaW5lc0JlbG93LnB1c2goX2NyZWF0ZUJvdW5kYXJ5TGluZSh7eDogbnVsbCwgeTogc2NhbGUuYm90dG9tfSwgbGluZSkpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKykge1xuICAgICAgYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludHNbal0sIGxpbmVzQmVsb3cpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExpbmVFbGVtZW50KHtwb2ludHMsIG9wdGlvbnM6IHt9fSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7TGluZUVsZW1lbnRbXX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgaWYgKG1ldGEuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFtZXRhLmhpZGRlbikge1xuICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmVsb3c7XG59XG5cbi8qKlxuICogQHBhcmFtIHtQb2ludEVsZW1lbnRbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge1BvaW50RWxlbWVudH0gc291cmNlUG9pbnRcbiAqIEBwYXJhbSB7TGluZUVsZW1lbnRbXX0gbGluZXNCZWxvd1xuICovXG5mdW5jdGlvbiBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50LCBsaW5lc0JlbG93KSB7XG4gIGNvbnN0IHBvc3Rwb25lZCA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzQmVsb3cubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNCZWxvd1tqXTtcbiAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHBvaW50fSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcblxuICAgIGlmICghcG9pbnQgfHwgKGZpcnN0ICYmIGxhc3QpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICAvLyBGaXJzdCBwb2ludCBvZiBhIHNlZ21lbnQgLT4gbmVlZCB0byBhZGQgYW5vdGhlciBwb2ludCBiZWZvcmUgdGhpcyxcbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIC8vIEluIHRoZSBtaWRkbGUgb2YgYSBzZWdtZW50LCBubyBuZWVkIHRvIGFkZCBtb3JlIHBvaW50cy5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtMaW5lRWxlbWVudH0gbGluZVxuICogQHBhcmFtIHtQb2ludEVsZW1lbnR9IHNvdXJjZVBvaW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHt7cG9pbnQ/OiBQb2ludEVsZW1lbnQsIGZpcnN0PzogYm9vbGVhbiwgbGFzdD86IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICBpZiAoIXBvaW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgY29uc3QgcG9pbnRWYWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGxldCBmaXJzdCA9IGZhbHNlO1xuICBsZXQgbGFzdCA9IGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGNvbnN0IGZpcnN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuc3RhcnRdW3Byb3BlcnR5XTtcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgaWYgKF9pc0JldHdlZW4ocG9pbnRWYWx1ZSwgZmlyc3RWYWx1ZSwgbGFzdFZhbHVlKSkge1xuICAgICAgZmlyc3QgPSBwb2ludFZhbHVlID09PSBmaXJzdFZhbHVlO1xuICAgICAgbGFzdCA9IHBvaW50VmFsdWUgPT09IGxhc3RWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge2ZpcnN0LCBsYXN0LCBwb2ludH07XG59XG4iLCAiaW1wb3J0IHtUQVV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vLyBUT0RPOiB1c2UgZWxlbWVudHMuQXJjRWxlbWVudCBpbnN0ZWFkXG5leHBvcnQgY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuXG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG5cbiAgaW50ZXJwb2xhdGUocG9pbnQpIHtcbiAgICBjb25zdCB7eCwgeSwgcmFkaXVzfSA9IHRoaXM7XG4gICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeCArIE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXMsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzRmluaXRlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X2NyZWF0ZUJvdW5kYXJ5TGluZX0gZnJvbSAnLi9maWxsZXIuaGVscGVyLmpzJztcbmltcG9ydCB7X2dldFRhcmdldFBpeGVsLCBfZ2V0VGFyZ2V0VmFsdWV9IGZyb20gJy4vZmlsbGVyLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtfYnVpbGRTdGFja0xpbmV9IGZyb20gJy4vZmlsbGVyLnRhcmdldC5zdGFjay5qcyc7XG5pbXBvcnQge3NpbXBsZUFyY30gZnJvbSAnLi9zaW1wbGVBcmMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi8uLi9jb3JlL2NvcmUuY29udHJvbGxlci5qcycpLmRlZmF1bHQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2NvcmUvY29yZS5zY2FsZS5qcycpLmRlZmF1bHQgfSBTY2FsZVxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQucG9pbnQuanMnKS5kZWZhdWx0IH0gUG9pbnRFbGVtZW50XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG5cbiAgaWYgKGlzRmluaXRlKGZpbGwpKSB7XG4gICAgcmV0dXJuIGdldExpbmVCeUluZGV4KGNoYXJ0LCBmaWxsKTtcbiAgfVxuXG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG5cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGJvdW5kYXJ5ID0gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSk7XG5cbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG5cbiAgcmV0dXJuIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhcnR9IGNoYXJ0XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qgc2NhbGUgPSBzb3VyY2Uuc2NhbGUgfHwge307XG5cbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSA9IHt9LCBmaWxsfSA9IHNvdXJjZTtcbiAgY29uc3QgcGl4ZWwgPSBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpO1xuXG4gIGlmIChpc0Zpbml0ZShwaXhlbCkpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcbiAgICAgIHk6IGhvcml6b250YWwgPyBudWxsIDogcGl4ZWxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG5cbiAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBzdGFydCk7XG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueSxcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdGFyZ2V0LnB1c2goc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGksIHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuIiwgImltcG9ydCB7Y2xpcEFyZWEsIHVuY2xpcEFyZWEsIGdldERhdGFzZXRDbGlwQXJlYX0gZnJvbSAnLi4vLi4vaGVscGVycy9pbmRleC5qcyc7XG5pbXBvcnQge19maW5kU2VnbWVudEVuZCwgX2dldEJvdW5kcywgX3NlZ21lbnRzfSBmcm9tICcuL2ZpbGxlci5zZWdtZW50LmpzJztcbmltcG9ydCB7X2dldFRhcmdldH0gZnJvbSAnLi9maWxsZXIudGFyZ2V0LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIF9kcmF3ZmlsbChjdHgsIHNvdXJjZSwgYXJlYSkge1xuICBjb25zdCB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IHtjaGFydCwgaW5kZXgsIGxpbmUsIHNjYWxlLCBheGlzfSA9IHNvdXJjZTtcbiAgY29uc3QgbGluZU9wdHMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBsaW5lT3B0cy5maWxsO1xuICBjb25zdCBjb2xvciA9IGxpbmVPcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgY29uc3Qge2Fib3ZlID0gY29sb3IsIGJlbG93ID0gY29sb3J9ID0gZmlsbE9wdGlvbiB8fCB7fTtcbiAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgY29uc3QgY2xpcCA9IGdldERhdGFzZXRDbGlwQXJlYShjaGFydCwgbWV0YSk7XG4gIGlmICh0YXJnZXQgJiYgbGluZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICBkb0ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlLCBheGlzLCBjbGlwfSk7XG4gICAgdW5jbGlwQXJlYShjdHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRvRmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlLCBjbGlwfSA9IGNmZztcbiAgY29uc3QgcHJvcGVydHkgPSBsaW5lLl9sb29wID8gJ2FuZ2xlJyA6IGNmZy5heGlzO1xuXG4gIGN0eC5zYXZlKCk7XG5cbiAgbGV0IGZpbGxDb2xvciA9IGJlbG93O1xuICBpZiAoYmVsb3cgIT09IGFib3ZlKSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAneCcpIHtcbiAgICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgICAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBhYm92ZSwgc2NhbGUsIHByb3BlcnR5LCBjbGlwfSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS5ib3R0b20pO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICd5Jykge1xuICAgICAgY2xpcEhvcml6b250YWwoY3R4LCB0YXJnZXQsIGFyZWEubGVmdCk7XG4gICAgICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHksIGNsaXB9KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY2xpcEhvcml6b250YWwoY3R4LCB0YXJnZXQsIGFyZWEucmlnaHQpO1xuICAgICAgZmlsbENvbG9yID0gYWJvdmU7XG4gICAgfVxuICB9XG4gIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogZmlsbENvbG9yLCBzY2FsZSwgcHJvcGVydHksIGNsaXB9KTtcblxuICBjdHgucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gY2xpcEhvcml6b250YWwoY3R4LCB0YXJnZXQsIGNsaXBYKSB7XG4gIGNvbnN0IHtzZWdtZW50cywgcG9pbnRzfSA9IHRhcmdldDtcbiAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgbGV0IGxpbmVMb29wID0gZmFsc2U7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oY2xpcFgsIGZpcnN0UG9pbnQueSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGNsaXBYLCBsYXN0UG9pbnQueSk7XG4gICAgfVxuICB9XG5cbiAgY3R4LmxpbmVUbyhjbGlwWCwgdGFyZ2V0LmZpcnN0KCkueSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cblxuZnVuY3Rpb24gZmlsbChjdHgsIGNmZykge1xuICBjb25zdCB7bGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSwgY29sb3IsIHNjYWxlLCBjbGlwfSA9IGNmZztcbiAgY29uc3Qgc2VnbWVudHMgPSBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSk7XG5cbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcblxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcblxuICAgIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgY2xpcCwgbm90U2hhcGUgJiYgX2dldEJvdW5kcyhwcm9wZXJ0eSwgc3RhcnQsIGVuZCkpO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuXG4gICAgbGV0IGxvb3A7XG4gICAgaWYgKG5vdFNoYXBlKSB7XG4gICAgICBpZiAobGluZUxvb3ApIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgY2xpcCwgYm91bmRzKSB7XG4gIGNvbnN0IGNoYXJ0QXJlYSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydCwgZW5kfSA9IGJvdW5kcyB8fCB7fTtcblxuICBpZiAocHJvcGVydHkgPT09ICd4JyB8fCBwcm9wZXJ0eSA9PT0gJ3knKSB7XG4gICAgbGV0IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbTtcblxuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgICBsZWZ0ID0gc3RhcnQ7XG4gICAgICB0b3AgPSBjaGFydEFyZWEudG9wO1xuICAgICAgcmlnaHQgPSBlbmQ7XG4gICAgICBib3R0b20gPSBjaGFydEFyZWEuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB0b3AgPSBzdGFydDtcbiAgICAgIHJpZ2h0ID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgICAgYm90dG9tID0gZW5kO1xuICAgIH1cblxuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChjbGlwKSB7XG4gICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgY2xpcC5sZWZ0KTtcbiAgICAgIHJpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIGNsaXAucmlnaHQpO1xuICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBjbGlwLnRvcCk7XG4gICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIGNsaXAuYm90dG9tKTtcbiAgICB9XG5cbiAgICBjdHgucmVjdChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgICBjdHguY2xpcCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGludGVycG9sYXRlZFBvaW50ID0gdGFyZ2V0LmludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XG4gIH1cbn1cblxuIiwgIi8qKlxuICogUGx1Z2luIGJhc2VkIG9uIGRpc2N1c3Npb24gZnJvbSB0aGUgZm9sbG93aW5nIENoYXJ0LmpzIGlzc3VlczpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzIzODAjaXNzdWVjb21tZW50LTI3OTk2MTU2OVxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvMjQ0MCNpc3N1ZWNvbW1lbnQtMjU2NDYxODk3XG4gKi9cblxuaW1wb3J0IExpbmVFbGVtZW50IGZyb20gJy4uLy4uL2VsZW1lbnRzL2VsZW1lbnQubGluZS5qcyc7XG5pbXBvcnQge19kcmF3ZmlsbH0gZnJvbSAnLi9maWxsZXIuZHJhd2luZy5qcyc7XG5pbXBvcnQge19zaG91bGRBcHBseUZpbGx9IGZyb20gJy4vZmlsbGVyLmhlbHBlci5qcyc7XG5pbXBvcnQge19kZWNvZGVGaWxsLCBfcmVzb2x2ZVRhcmdldH0gZnJvbSAnLi9maWxsZXIub3B0aW9ucy5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICdmaWxsZXInLFxuXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuXG4gICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGZpbGw6IF9kZWNvZGVGaWxsKGxpbmUsIGksIGNvdW50KSxcbiAgICAgICAgICBjaGFydCxcbiAgICAgICAgICBheGlzOiBtZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5pbmRleEF4aXMsXG4gICAgICAgICAgc2NhbGU6IG1ldGEudlNjYWxlLFxuICAgICAgICAgIGxpbmUsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGF0YXNldHNEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldHNEcmF3Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcblxuICAgICAgaWYgKF9zaG91bGRBcHBseUZpbGwoc291cmNlKSkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURhdGFzZXREcmF3KGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlID0gYXJncy5tZXRhLiRmaWxsZXI7XG5cbiAgICBpZiAoIV9zaG91bGRBcHBseUZpbGwoc291cmNlKSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuXG4gIGRlZmF1bHRzOiB7XG4gICAgcHJvcGFnYXRlOiB0cnVlLFxuICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldERyYXcnXG4gIH1cbn07XG4iLCAiaW1wb3J0IGRlZmF1bHRzIGZyb20gJy4uL2NvcmUvY29yZS5kZWZhdWx0cy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQgbGF5b3V0cyBmcm9tICcuLi9jb3JlL2NvcmUubGF5b3V0cy5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aCwgZHJhd1BvaW50TGVnZW5kLCByZW5kZXJUZXh0fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7XG4gIF9pc0JldHdlZW4sXG4gIGNhbGxiYWNrIGFzIGNhbGwsXG4gIGNsaXBBcmVhLFxuICBnZXRSdGxBZGFwdGVyLFxuICBvdmVycmlkZVRleHREaXJlY3Rpb24sXG4gIHJlc3RvcmVUZXh0RGlyZWN0aW9uLFxuICB0b0ZvbnQsXG4gIHRvUGFkZGluZyxcbiAgdW5jbGlwQXJlYSxcbiAgdmFsdWVPckRlZmF1bHQsXG59IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuaW1wb3J0IHtfYWxpZ25TdGFydEVuZCwgX3RleHRYLCBfdG9MZWZ0UmlnaHRDZW50ZXJ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5leHRyYXMuanMnO1xuaW1wb3J0IHt0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqL1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpID0+IHtcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XG5cbiAgaWYgKGxhYmVsT3B0cy51c2VQb2ludFN0eWxlKSB7XG4gICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgYm94V2lkdGggPSBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoIHx8IE1hdGgubWluKGJveFdpZHRoLCBmb250U2l6ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJveFdpZHRoLFxuICAgIGJveEhlaWdodCxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICB9O1xufTtcblxuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5cbmV4cG9ydCBjbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcblx0ICogQHBhcmFtIHt7IGN0eDogYW55OyBvcHRpb25zOiBhbnk7IGNoYXJ0OiBhbnk7IH19IGNvbmZpZ1xuXHQgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2FkZGVkID0gZmFsc2U7XG5cbiAgICAvLyBDb250YWlucyBoaXQgYm94ZXMgZm9yIGVhY2ggZGF0YXNldCAoaW4gZGF0YXNldCBvcmRlcilcbiAgICB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG5cbiAgICAvKipcbiBcdFx0ICogQHByaXZhdGVcbiBcdFx0ICovXG4gICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuXG4gICAgLy8gQXJlIHdlIGluIGRvdWdobnV0IG1vZGUgd2hpY2ggaGFzIGEgZGlmZmVyZW50IGRhdGEgdHlwZVxuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG5cbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBtYXJnaW5zKSB7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zO1xuXG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5idWlsZExhYmVscygpO1xuICAgIHRoaXMuZml0KCk7XG4gIH1cblxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgYnVpbGRMYWJlbHMoKSB7XG4gICAgY29uc3QgbGFiZWxPcHRzID0gdGhpcy5vcHRpb25zLmxhYmVscyB8fCB7fTtcbiAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW3RoaXMuY2hhcnRdLCB0aGlzKSB8fCBbXTtcblxuICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG5cbiAgICBpZiAobGFiZWxPcHRzLnNvcnQpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXMuc29ydCgoYSwgYikgPT4gbGFiZWxPcHRzLnNvcnQoYSwgYiwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG5cbiAgZml0KCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjdHh9ID0gdGhpcztcblxuICAgIC8vIFRoZSBsZWdlbmQgbWF5IG5vdCBiZSBkaXNwbGF5ZWQgZm9yIGEgdmFyaWV0eSBvZiByZWFzb25zIGluY2x1ZGluZ1xuICAgIC8vIHRoZSBmYWN0IHRoYXQgdGhlIGRlZmF1bHRzIGdvdCBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyBXaGVuIHRoZSBsZWdlbmQgaXMgbm90IGRpc3BsYXllZCwgdGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgdGhhdCB0aGUgb3B0aW9uc1xuICAgIC8vIGFyZSBjb3JyZWN0bHkgZm9ybWF0dGVkIHNvIHdlIG5lZWQgdG8gYmFpbCBvdXQgYXMgZWFybHkgYXMgcG9zc2libGUuXG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2JveFdpZHRoLCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcblxuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB3aWR0aCA9IHRoaXMubWF4V2lkdGg7IC8vIGZpbGwgYWxsIHRoZSB3aWR0aFxuICAgICAgaGVpZ2h0ID0gdGhpcy5fZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDsgLy8gZmlsbCBhbGwgdGhlIGhlaWdodFxuICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBsYWJlbEZvbnQsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cblxuICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgb3B0aW9ucy5tYXhIZWlnaHQgfHwgdGhpcy5tYXhIZWlnaHQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICAvLyBXaWR0aCBvZiBlYWNoIGxpbmUgb2YgbGVnZW5kIGJveGVzLiBMYWJlbHMgd3JhcCBvbnRvIG11bHRpcGxlIGxpbmVzIHdoZW4gdGhlcmUgYXJlIHRvbyBtYW55IHRvIGZpdCBvbiBvbmVcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcblxuICAgIGN0eC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgbGV0IHJvdyA9IC0xO1xuICAgIGxldCB0b3AgPSAtbGluZUhlaWdodDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcblxuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cblxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdDogMCwgdG9wLCByb3csIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG5cbiAgX2ZpdENvbHModGl0bGVIZWlnaHQsIGxhYmVsRm9udCwgYm94V2lkdGgsIF9pdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4SGVpZ2h0LCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XG4gICAgY29uc3QgaGVpZ2h0TGltaXQgPSBtYXhIZWlnaHQgLSB0aXRsZUhlaWdodDtcblxuICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICBsZXQgY3VycmVudENvbFdpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG5cbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IGNvbCA9IDA7XG5cbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IHtpdGVtV2lkdGgsIGl0ZW1IZWlnaHR9ID0gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCk7XG5cbiAgICAgIC8vIElmIHRvbyB0YWxsLCBnbyB0byBuZXcgY29sdW1uXG4gICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7IC8vIHByZXZpb3VzIGNvbHVtbiBzaXplXG4gICAgICAgIGxlZnQgKz0gY3VycmVudENvbFdpZHRoICsgcGFkZGluZztcbiAgICAgICAgY29sKys7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBTdG9yZSB0aGUgaGl0Ym94IHdpZHRoIGFuZCBoZWlnaHQgaGVyZS4gRmluYWwgcG9zaXRpb24gd2lsbCBiZSB1cGRhdGVkIGluIGBkcmF3YFxuICAgICAgaGl0Ym94ZXNbaV0gPSB7bGVmdCwgdG9wOiBjdXJyZW50Q29sSGVpZ2h0LCBjb2wsIHdpZHRoOiBpdGVtV2lkdGgsIGhlaWdodDogaXRlbUhlaWdodH07XG5cbiAgICAgIC8vIEdldCBtYXggd2lkdGhcbiAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcbiAgICAgIGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgfSk7XG5cbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTsgLy8gcHJldmlvdXMgY29sdW1uIHNpemVcblxuICAgIHJldHVybiB0b3RhbFdpZHRoO1xuICB9XG5cbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtsZWdlbmRIaXRCb3hlczogaGl0Ym94ZXMsIG9wdGlvbnM6IHthbGlnbiwgbGFiZWxzOiB7cGFkZGluZ30sIHJ0bH19ID0gdGhpcztcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICBsZXQgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKHJvdyAhPT0gaGl0Ym94LnJvdykge1xuICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XG4gICAgICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngobGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgIGhpdGJveC5sZWZ0ICs9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH1cblxuICBkcmF3KCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuXG4gICAgICB0aGlzLl9kcmF3KCk7XG5cbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiBvcHRzLCBjb2x1bW5TaXplcywgbGluZVdpZHRocywgY3R4fSA9IHRoaXM7XG4gICAgY29uc3Qge2FsaWduLCBsYWJlbHM6IGxhYmVsT3B0c30gPSBvcHRzO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmNvbG9yO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCB7cGFkZGluZ30gPSBsYWJlbE9wdHM7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgbGV0IGN1cnNvcjtcblxuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbignbGVmdCcpO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHgubGluZVdpZHRoID0gMC41O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcblxuICAgIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0LCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG5cbiAgICAvLyBjdXJyZW50IHBvc2l0aW9uXG4gICAgY29uc3QgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCB8fCBpc05hTihib3hIZWlnaHQpIHx8IGJveEhlaWdodCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIGN0eCBmb3IgdGhlIGJveFxuICAgICAgY3R4LnNhdmUoKTtcblxuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG5cbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoLCBbXSkpO1xuXG4gICAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgeCBhbmQgeSBmb3IgZHJhd1BvaW50KCkgYmVjYXVzZSBpdHMgZXhwZWN0aW5nXG4gICAgICAgIC8vIHggYW5kIHkgdG8gYmUgY2VudGVyIG9mIGZpZ3VyZSAoaW5zdGVhZCBvZiB0b3AgbGVmdClcbiAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgICAgcmFkaXVzOiBib3hIZWlnaHQgKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuXG4gICAgICAgIC8vIERyYXcgcG9pbnRTdHlsZSBhcyBsZWdlbmQgc3ltYm9sXG4gICAgICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZLCBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoICYmIGJveFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERyYXcgYm94IGFzIGxlZ2VuZCBzeW1ib2xcbiAgICAgICAgLy8gQWRqdXN0IHBvc2l0aW9uIHdoZW4gYm94SGVpZ2h0IDwgZm9udFNpemUgKHdhbnQgaXQgY2VudGVyZWQpXG4gICAgICAgIGNvbnN0IHlCb3hUb3AgPSB5ICsgTWF0aC5tYXgoKGZvbnRTaXplIC0gYm94SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICBjb25zdCB4Qm94TGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHgsIGJveFdpZHRoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAobGluZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEhvcml6b250YWxcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBvdmVycmlkZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG5cbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKSA9PiB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvcjsgLy8gZm9yIHN0cmlrZXRocm91Z2ggZWZmZWN0XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3I7IC8vIHJlbmRlciBpbiBjb3JyZWN0IGNvbG91clxuXG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuXG4gICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XG5cbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIHggKyB3aWR0aCArIHBhZGRpbmcgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgICB4ID0gY3Vyc29yLnggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbY3Vyc29yLmxpbmVdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiB5ICsgbGluZUhlaWdodCA+IHRoaXMuYm90dG9tKSB7XG4gICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICB5ID0gY3Vyc29yLnkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLmhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG5cbiAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICB4ID0gX3RleHRYKHRleHRBbGlnbiwgeCArIGJveFdpZHRoICsgaGFsZkZvbnRTaXplLCBpc0hvcml6b250YWwgPyB4ICsgd2lkdGggOiB0aGlzLnJpZ2h0LCBvcHRzLnJ0bCk7XG5cbiAgICAgIC8vIEZpbGwgdGhlIGFjdHVhbCBsYWJlbFxuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgZm9udExpbmVIZWlnaHQgPSBsYWJlbEZvbnQubGluZUhlaWdodDtcbiAgICAgICAgY3Vyc29yLnkgKz0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkgKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuXG4gICAgaWYgKCF0aXRsZU9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcblxuICAgIC8vIFRoZXNlIGRlZmF1bHRzIGFyZSB1c2VkIHdoZW4gdGhlIGxlZ2VuZCBpcyB2ZXJ0aWNhbC5cbiAgICAvLyBXaGVuIGhvcml6b250YWwsIHRoZXkgYXJlIGNvbXB1dGVkIGJlbG93LlxuICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgLy8gTW92ZSBsZWZ0IC8gcmlnaHQgc28gdGhhdCB0aGUgdGl0bGUgaXMgYWJvdmUgdGhlIGxlZ2VuZCBsaW5lc1xuICAgICAgbWF4V2lkdGggPSBNYXRoLm1heCguLi50aGlzLmxpbmVXaWR0aHMpO1xuICAgICAgeSA9IHRoaXMudG9wICsgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemU7XG4gICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQob3B0cy5hbGlnbiwgbGVmdCwgdGhpcy5yaWdodCAtIG1heFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBkb3duIHNvIHRoYXQgdGhlIHRpdGxlIGlzIGFib3ZlIHRoZSBsZWdlbmQgc3RhY2sgaW4gZXZlcnkgYWxpZ25tZW50XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlIGtub3cgdGhlIGxlZnQgZWRnZSBvZiB0aGUgaW5uZXIgbGVnZW5kIGJveCwgY29tcHV0ZSB0aGUgY29ycmVjdFxuICAgIC8vIFggY29vcmRpbmF0ZSBmcm9tIHRoZSB0aXRsZSBhbGlnbm1lbnRcbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG5cbiAgICAvLyBDYW52YXMgc2V0dXBcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuXG4gICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG5cbiAgICBpZiAoX2lzQmV0d2Vlbih4LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpXG4gICAgICAmJiBfaXNCZXR3ZWVuKHksIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgIC8vIFNlZSBpZiB3ZSBhcmUgdG91Y2hpbmcgb25lIG9mIHRoZSBkYXRhc2V0IGJveGVzXG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG5cbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKVxuICAgICAgICAgICYmIF9pc0JldHdlZW4oeSwgaGl0Qm94LnRvcCwgaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpKSB7XG4gICAgICAgICAgLy8gVG91Y2hpbmcgYW4gZWxlbWVudFxuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcblx0ICogSGFuZGxlIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICovXG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hhcnQgZXZlbnQgYWxyZWFkeSBoYXMgcmVsYXRpdmUgcG9zaXRpb24gaW4gaXRcbiAgICBjb25zdCBob3ZlcmVkSXRlbSA9IHRoaXMuX2dldExlZ2VuZEl0ZW1BdChlLngsIGUueSk7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbChvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuXG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGwob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsKG9wdHMub25DbGljaywgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1TaXplKGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCwgbGVnZW5kSXRlbSwgX2l0ZW1IZWlnaHQpIHtcbiAgY29uc3QgaXRlbVdpZHRoID0gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCk7XG4gIGNvbnN0IGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBsYWJlbEZvbnQubGluZUhlaWdodCk7XG4gIHJldHVybiB7aXRlbVdpZHRoLCBpdGVtSGVpZ2h0fTtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVdpZHRoKGxlZ2VuZEl0ZW0sIGJveFdpZHRoLCBsYWJlbEZvbnQsIGN0eCkge1xuICBsZXQgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtLnRleHQ7XG4gIGlmIChsZWdlbmRJdGVtVGV4dCAmJiB0eXBlb2YgbGVnZW5kSXRlbVRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtVGV4dC5yZWR1Y2UoKGEsIGIpID0+IGEubGVuZ3RoID4gYi5sZW5ndGggPyBhIDogYik7XG4gIH1cbiAgcmV0dXJuIGJveFdpZHRoICsgKGxhYmVsRm9udC5zaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbVRleHQpLndpZHRoO1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICBsZXQgaXRlbUhlaWdodCA9IF9pdGVtSGVpZ2h0O1xuICBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBpdGVtSGVpZ2h0ID0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1IZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpIHtcbiAgY29uc3QgbGFiZWxIZWlnaHQgPSBsZWdlbmRJdGVtLnRleHQgPyBsZWdlbmRJdGVtLnRleHQubGVuZ3RoIDogMDtcbiAgcmV0dXJuIGZvbnRMaW5lSGVpZ2h0ICogbGFiZWxIZWlnaHQ7XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xuICBpZiAoKHR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHR5cGUgPT09ICdtb3VzZW91dCcpICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpZDogJ2xlZ2VuZCcsXG5cbiAgLyoqXG5cdCAqIEZvciB0ZXN0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VsZW1lbnQ6IExlZ2VuZCxcblxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQgPSBuZXcgTGVnZW5kKHtjdHg6IGNoYXJ0LmN0eCwgb3B0aW9ucywgY2hhcnR9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XG4gICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgfSxcblxuICAvLyBEdXJpbmcgdGhlIGJlZm9yZVVwZGF0ZSBzdGVwLCB0aGUgbGF5b3V0IGNvbmZpZ3VyYXRpb24gbmVlZHMgdG8gcnVuXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0IGlmIHRoZSBsZWdlbmQgcG9zaXRpb24gY2hhbmdlcyAodmlhIGFuIG9wdGlvbiB1cGRhdGUpXG4gIC8vIHRoZSBsYXlvdXQgc3lzdGVtIHJlc3BlY3RzIHRoZSBjaGFuZ2UuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNzUyN1xuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICAvLyBUaGUgbGFiZWxzIG5lZWQgdG8gYmUgYnVpbHQgYWZ0ZXIgZGF0YXNldHMgYXJlIHVwZGF0ZWQgdG8gZW5zdXJlIHRoYXQgY29sb3JzXG4gIC8vIGFuZCBvdGhlciBzdHlsaW5nIGFyZSBjb3JyZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzY5NjhcbiAgYWZ0ZXJVcGRhdGUoY2hhcnQpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgbGVnZW5kLmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG5cblxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICB3ZWlnaHQ6IDEwMDAsXG5cbiAgICAvLyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBoYW5kbGVcbiAgICBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgIGNpLmhpZGUoaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIC8vIEdlbmVyYXRlcyBsYWJlbHMgc2hvd24gaW4gdGhlIGxlZ2VuZFxuICAgICAgLy8gVmFsaWQgcHJvcGVydGllcyB0byByZXR1cm46XG4gICAgICAvLyB0ZXh0IDogdGV4dCB0byBkaXNwbGF5XG4gICAgICAvLyBmaWxsU3R5bGUgOiBmaWxsIG9mIGNvbG91cmVkIGJveFxuICAgICAgLy8gc3Ryb2tlU3R5bGU6IHN0cm9rZSBvZiBjb2xvdXJlZCBib3hcbiAgICAgIC8vIGhpZGRlbiA6IGlmIHRoaXMgbGVnZW5kIGl0ZW0gcmVmZXJzIHRvIGEgaGlkZGVuIGl0ZW1cbiAgICAgIC8vIGxpbmVDYXAgOiBjYXAgc3R5bGUgZm9yIGxpbmVcbiAgICAgIC8vIGxpbmVEYXNoXG4gICAgICAvLyBsaW5lRGFzaE9mZnNldCA6XG4gICAgICAvLyBsaW5lSm9pbiA6XG4gICAgICAvLyBsaW5lV2lkdGggOlxuICAgICAgZ2VuZXJhdGVMYWJlbHMoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBjb25zdCB7bGFiZWxzOiB7dXNlUG9pbnRTdHlsZSwgcG9pbnRTdHlsZSwgdGV4dEFsaWduLCBjb2xvciwgdXNlQm9yZGVyUmFkaXVzLCBib3JkZXJSYWRpdXN9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuXG4gICAgICAgIHJldHVybiBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKCkubWFwKChtZXRhKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gdG9QYWRkaW5nKHN0eWxlLmJvcmRlcldpZHRoKTtcblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGhpZGRlbjogIW1ldGEudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiB1c2VCb3JkZXJSYWRpdXMgJiYgKGJvcmRlclJhZGl1cyB8fCBzdHlsZS5ib3JkZXJSYWRpdXMpLFxuXG4gICAgICAgICAgICAvLyBCZWxvdyBpcyBleHRyYSBkYXRhIHVzZWQgZm9yIHRvZ2dsaW5nIHRoZSBkYXRhc2V0c1xuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgIHRleHQ6ICcnLFxuICAgIH1cbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICBsYWJlbHM6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gIVsnZ2VuZXJhdGVMYWJlbHMnLCAnZmlsdGVyJywgJ3NvcnQnXS5pbmNsdWRlcyhuYW1lKSxcbiAgICB9XG4gIH0sXG59O1xuIiwgImltcG9ydCBFbGVtZW50IGZyb20gJy4uL2NvcmUvY29yZS5lbGVtZW50LmpzJztcbmltcG9ydCBsYXlvdXRzIGZyb20gJy4uL2NvcmUvY29yZS5sYXlvdXRzLmpzJztcbmltcG9ydCB7UEksIGlzQXJyYXksIHRvUGFkZGluZywgdG9Gb250fSBmcm9tICcuLi9oZWxwZXJzL2luZGV4LmpzJztcbmltcG9ydCB7X3RvTGVmdFJpZ2h0Q2VudGVyLCBfYWxpZ25TdGFydEVuZH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmV4dHJhcy5qcyc7XG5pbXBvcnQge3JlbmRlclRleHR9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jYW52YXMuanMnO1xuXG5leHBvcnQgY2xhc3MgVGl0bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgLyoqXG5cdCAqIEBwYXJhbSB7eyBjdHg6IGFueTsgb3B0aW9uczogYW55OyBjaGFydDogYW55OyB9fSBjb25maWdcblx0ICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLl9wYWRkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGhpcy5sZWZ0ID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG5cbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndpZHRoID0gdGhpcy5yaWdodCA9IG1heFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG5cbiAgICBjb25zdCBsaW5lQ291bnQgPSBpc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMucGFkZGluZyk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBsaW5lQ291bnQgKiB0b0ZvbnQob3B0cy5mb250KS5saW5lSGVpZ2h0ICsgdGhpcy5fcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplO1xuICAgIH1cbiAgfVxuXG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb247XG4gICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgfVxuXG4gIF9kcmF3QXJncyhvZmZzZXQpIHtcbiAgICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcblxuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIDAuNTtcbiAgICAgIH1cbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xuICB9XG5cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGhpcy5fZHJhd0FyZ3Mob2Zmc2V0KTtcblxuICAgIHJlbmRlclRleHQoY3R4LCBvcHRzLnRleHQsIDAsIDAsIGZvbnRPcHRzLCB7XG4gICAgICBjb2xvcjogb3B0cy5jb2xvcixcbiAgICAgIG1heFdpZHRoLFxuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0QWxpZ246IF90b0xlZnRSaWdodENlbnRlcihvcHRzLmFsaWduKSxcbiAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICB0cmFuc2xhdGlvbjogW3RpdGxlWCwgdGl0bGVZXSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUaXRsZShjaGFydCwgdGl0bGVPcHRzKSB7XG4gIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICBvcHRpb25zOiB0aXRsZU9wdHMsXG4gICAgY2hhcnRcbiAgfSk7XG5cbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICd0aXRsZScsXG5cbiAgLyoqXG5cdCAqIEZvciB0ZXN0c1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2VsZW1lbnQ6IFRpdGxlLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNyZWF0ZVRpdGxlKGNoYXJ0LCBvcHRpb25zKTtcbiAgfSxcblxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuICAgIGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDEwLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICB0ZXh0OiAnJyxcbiAgICB3ZWlnaHQ6IDIwMDAgICAgICAgICAvLyBieSBkZWZhdWx0IGdyZWF0ZXIgdGhhbiBsZWdlbmQgKDEwMDApIHRvIGJlIGFib3ZlXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGNvbG9yOiAnY29sb3InXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG4iLCAiaW1wb3J0IHtUaXRsZX0gZnJvbSAnLi9wbHVnaW4udGl0bGUuanMnO1xuaW1wb3J0IGxheW91dHMgZnJvbSAnLi4vY29yZS9jb3JlLmxheW91dHMuanMnO1xuXG5jb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGlkOiAnc3VidGl0bGUnLFxuXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICAgIGN0eDogY2hhcnQuY3R4LFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGNoYXJ0XG4gICAgfSk7XG5cbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgbWFwLnNldChjaGFydCwgdGl0bGUpO1xuICB9LFxuXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG1hcC5nZXQoY2hhcnQpO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG5cbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMTUwMCAgICAgICAgIC8vIGJ5IGRlZmF1bHQgZ3JlYXRlciB0aGFuIGxlZ2VuZCAoMTAwMCkgYW5kIHNtYWxsZXIgdGhhbiB0aXRsZSAoMjAwMClcbiAgfSxcblxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcblxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcbiIsICJpbXBvcnQgQW5pbWF0aW9ucyBmcm9tICcuLi9jb3JlL2NvcmUuYW5pbWF0aW9ucy5qcyc7XG5pbXBvcnQgRWxlbWVudCBmcm9tICcuLi9jb3JlL2NvcmUuZWxlbWVudC5qcyc7XG5pbXBvcnQge2FkZFJvdW5kZWRSZWN0UGF0aH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNhbnZhcy5qcyc7XG5pbXBvcnQge2VhY2gsIG5vb3AsIGlzTnVsbE9yVW5kZWYsIGlzQXJyYXksIF9lbGVtZW50c0VxdWFsLCBpc09iamVjdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b0ZvbnQsIHRvUGFkZGluZywgdG9UUkJMQ29ybmVyc30gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm9wdGlvbnMuanMnO1xuaW1wb3J0IHtnZXRSdGxBZGFwdGVyLCBvdmVycmlkZVRleHREaXJlY3Rpb24sIHJlc3RvcmVUZXh0RGlyZWN0aW9ufSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMucnRsLmpzJztcbmltcG9ydCB7ZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IHtjcmVhdGVDb250ZXh0LCBkcmF3UG9pbnR9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi9wbGF0Zm9ybS9wbGF0Zm9ybS5iYXNlLmpzJykuQ2hhcnQgfSBDaGFydFxuICogQHR5cGVkZWYgeyBpbXBvcnQoJy4uL3R5cGVzL2luZGV4LmpzJykuQ2hhcnRFdmVudCB9IENoYXJ0RXZlbnRcbiAqIEB0eXBlZGVmIHsgaW1wb3J0KCcuLi90eXBlcy9pbmRleC5qcycpLkFjdGl2ZUVsZW1lbnQgfSBBY3RpdmVFbGVtZW50XG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmludGVyYWN0aW9uLmpzJykuSW50ZXJhY3Rpb25JdGVtIH0gSW50ZXJhY3Rpb25JdGVtXG4gKi9cblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIC8qKlxuXHQgKiBBdmVyYWdlIG1vZGUgcGxhY2VzIHRoZSB0b29sdGlwIGF0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50cyBzaG93blxuXHQgKi9cbiAgYXZlcmFnZShpdGVtcykge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGksIGxlbjtcbiAgICBsZXQgeFNldCA9IG5ldyBTZXQoKTtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBwb3MgPSBlbC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgICAgeFNldC5hZGQocG9zLngpO1xuICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vIHZpc2libGUgaXRlbXMgd2hlcmUgZm91bmQsIHJldHVybiBmYWxzZSBzbyB3ZSBkb24ndCBoYXZlIHRvIGRpdmlkZSBieSAwIHdoaWNoIHJlZHVjZXMgaW4gTmFOXG4gICAgaWYgKGNvdW50ID09PSAwIHx8IHhTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHhBdmVyYWdlID0gWy4uLnhTZXRdLnJlZHVjZSgoYSwgYikgPT4gYSArIGIpIC8geFNldC5zaXplO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhBdmVyYWdlLFxuICAgICAgeTogeSAvIGNvdW50XG4gICAgfTtcbiAgfSxcblxuICAvKipcblx0ICogR2V0cyB0aGUgdG9vbHRpcCBwb3NpdGlvbiBuZWFyZXN0IG9mIHRoZSBpdGVtIG5lYXJlc3QgdG8gdGhlIGV2ZW50IHBvc2l0aW9uXG5cdCAqL1xuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsZXQgeCA9IGV2ZW50UG9zaXRpb24ueDtcbiAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGksIGxlbiwgbmVhcmVzdEVsZW1lbnQ7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuXG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWFyZXN0RWxlbWVudCkge1xuICAgICAgY29uc3QgdHAgPSBuZWFyZXN0RWxlbWVudC50b29sdGlwUG9zaXRpb24oKTtcbiAgICAgIHggPSB0cC54O1xuICAgICAgeSA9IHRwLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufTtcblxuLy8gSGVscGVyIHRvIHB1c2ggb3IgY29uY2F0IGJhc2VkIG9uIGlmIHRoZSAybmQgcGFyYW1ldGVyIGlzIGFuIGFycmF5IG9yIG5vdFxuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgLy8gYmFzZSA9IGJhc2UuY29uY2F0KHRvUHVzaCk7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlLnB1c2godG9QdXNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFycmF5IG9mIHN0cmluZ3Mgc3BsaXQgYnkgbmV3bGluZVxuICogQHBhcmFtIHsqfSBzdHIgLSBUaGUgdmFsdWUgdG8gc3BsaXQgYnkgbmV3bGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3RyaW5nW119IHZhbHVlIGlmIG5ld2xpbmUgcHJlc2VudCAtIFJldHVybmVkIGZyb20gU3RyaW5nIHNwbGl0KCkgbWV0aG9kXG4gKiBAZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuXG4vKipcbiAqIFByaXZhdGUgaGVscGVyIHRvIGNyZWF0ZSBhIHRvb2x0aXAgaXRlbSBtb2RlbFxuICogQHBhcmFtIHtDaGFydH0gY2hhcnRcbiAqIEBwYXJhbSB7QWN0aXZlRWxlbWVudH0gaXRlbSAtIHtlbGVtZW50LCBpbmRleCwgZGF0YXNldEluZGV4fSB0byBjcmVhdGUgdGhlIHRvb2x0aXAgaXRlbSBmb3JcbiAqIEByZXR1cm4gbmV3IHRvb2x0aXAgaXRlbVxuICovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShjaGFydCwgaXRlbSkge1xuICBjb25zdCB7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0gPSBpdGVtO1xuICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICBjb25zdCB7bGFiZWwsIHZhbHVlfSA9IGNvbnRyb2xsZXIuZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCk7XG5cbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdG9vbHRpcFxuICovXG5mdW5jdGlvbiBnZXRUb29sdGlwU2l6ZSh0b29sdGlwLCBvcHRpb25zKSB7XG4gIGNvbnN0IGN0eCA9IHRvb2x0aXAuY2hhcnQuY3R4O1xuICBjb25zdCB7Ym9keSwgZm9vdGVyLCB0aXRsZX0gPSB0b29sdGlwO1xuICBjb25zdCB7Ym94V2lkdGgsIGJveEhlaWdodH0gPSBvcHRpb25zO1xuICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgY29uc3QgZm9vdGVyRm9udCA9IHRvRm9udChvcHRpb25zLmZvb3RlckZvbnQpO1xuICBjb25zdCB0aXRsZUxpbmVDb3VudCA9IHRpdGxlLmxlbmd0aDtcbiAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgY29uc3QgYm9keUxpbmVJdGVtQ291bnQgPSBib2R5Lmxlbmd0aDtcblxuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGxldCBoZWlnaHQgPSBwYWRkaW5nLmhlaWdodDtcbiAgbGV0IHdpZHRoID0gMDtcblxuICAvLyBDb3VudCBvZiBhbGwgbGluZXMgaW4gdGhlIGJvZHlcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuXG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIGhlaWdodCBkZXBlbmRpbmcgb24gYm94SGVpZ2h0XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuXG4gIC8vIFRpdGxlIHdpZHRoXG4gIGxldCB3aWR0aFBhZGRpbmcgPSAwO1xuICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoICsgd2lkdGhQYWRkaW5nKTtcbiAgfTtcblxuICBjdHguc2F2ZSgpO1xuXG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuXG4gIC8vIEJvZHkgd2lkdGhcbiAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG5cbiAgLy8gQm9keSBsaW5lcyBtYXkgaW5jbHVkZSBzb21lIGV4dHJhIHdpZHRoIGR1ZSB0byB0aGUgY29sb3IgYm94XG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcpIDogMDtcbiAgZWFjaChib2R5LCAoYm9keUl0ZW0pID0+IHtcbiAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IGJhY2sgdG8gMFxuICB3aWR0aFBhZGRpbmcgPSAwO1xuXG4gIC8vIEZvb3RlciB3aWR0aFxuICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuXG4gIGN0eC5yZXN0b3JlKCk7XG5cbiAgLy8gQWRkIHBhZGRpbmdcbiAgd2lkdGggKz0gcGFkZGluZy53aWR0aDtcblxuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuXG4gIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgIHJldHVybiAndG9wJztcbiAgfSBlbHNlIGlmICh5ID4gKGNoYXJ0LmhlaWdodCAtIGhlaWdodCAvIDIpKSB7XG4gICAgcmV0dXJuICdib3R0b20nO1xuICB9XG4gIHJldHVybiAnY2VudGVyJztcbn1cblxuZnVuY3Rpb24gZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCB7d2lkdGg6IGNoYXJ0V2lkdGgsIGNoYXJ0QXJlYToge2xlZnQsIHJpZ2h0fX0gPSBjaGFydDtcbiAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuXG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeEFsaWduID0geCA8PSAobGVmdCArIHJpZ2h0KSAvIDIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdyaWdodCc7XG4gIH1cblxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG5cbiAgcmV0dXJuIHhBbGlnbjtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSBhbGlnbm1lbnQgb2YgYSB0b29sdGlwIGdpdmVuIHRoZSBzaXplXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuXG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBzaXplLnhBbGlnbiB8fCBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXG4gICAgeUFsaWduXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24gYWxpZ25ZKHNpemUsIHlBbGlnbiwgcGFkZGluZ0FuZFNpemUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICBsZXQge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSB7XG4gICAgeSAtPSAoaGVpZ2h0IC8gMik7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIGdldCB0aGUgbG9jYXRpb24gYSB0b29sdGlwIG5lZWRzIHRvIGJlIHBsYWNlZCBhdCBnaXZlbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiAodmlhIHRoZSB2bSkgYW5kIHRoZSBzaXplIGFuZCBhbGlnbm1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHNpemUsIGFsaWdubWVudCwgY2hhcnQpIHtcbiAgY29uc3Qge2NhcmV0U2l6ZSwgY2FyZXRQYWRkaW5nLCBjb3JuZXJSYWRpdXN9ID0gb3B0aW9ucztcbiAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IGFsaWdubWVudDtcbiAgY29uc3QgcGFkZGluZ0FuZFNpemUgPSBjYXJldFNpemUgKyBjYXJldFBhZGRpbmc7XG4gIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuXG4gIGxldCB4ID0gYWxpZ25YKHNpemUsIHhBbGlnbik7XG4gIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XG5cbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgeTogX2xpbWl0VmFsdWUoeSwgMCwgY2hhcnQuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHRvb2x0aXAsIGFsaWduLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcblxuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuXG4vKipcbiAqIEhlbHBlciB0byBidWlsZCBiZWZvcmUgYW5kIGFmdGVyIGJvZHkgbGluZXNcbiAqL1xuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwQ29udGV4dChwYXJlbnQsIHRvb2x0aXAsIHRvb2x0aXBJdGVtcykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0b29sdGlwLFxuICAgIHRvb2x0aXBJdGVtcyxcbiAgICB0eXBlOiAndG9vbHRpcCdcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIG92ZXJyaWRlID8gY2FsbGJhY2tzLm92ZXJyaWRlKG92ZXJyaWRlKSA6IGNhbGxiYWNrcztcbn1cblxuY29uc3QgZGVmYXVsdENhbGxiYWNrcyA9IHtcbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZVRpdGxlOiBub29wLFxuICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0b29sdGlwSXRlbXNbMF07XG4gICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuXG4gICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmxhYmVsKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsc1tpdGVtLmRhdGFJbmRleF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9LFxuICBhZnRlclRpdGxlOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBiZWZvcmVCb2R5OiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW0sIGRhdGEpXG4gIGJlZm9yZUxhYmVsOiBub29wLFxuICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgfVxuXG4gICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgbGFiZWwgKz0gJzogJztcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGxhYmVsO1xuICB9LFxuICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICB9O1xuICB9LFxuICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgfSxcbiAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBwb2ludFN0eWxlOiBvcHRpb25zLnBvaW50U3R5bGUsXG4gICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICB9O1xuICB9LFxuICBhZnRlckxhYmVsOiBub29wLFxuXG4gIC8vIEFyZ3MgYXJlOiAodG9vbHRpcEl0ZW1zLCBkYXRhKVxuICBhZnRlckJvZHk6IG5vb3AsXG5cbiAgLy8gQXJncyBhcmU6ICh0b29sdGlwSXRlbXMsIGRhdGEpXG4gIGJlZm9yZUZvb3Rlcjogbm9vcCxcbiAgZm9vdGVyOiBub29wLFxuICBhZnRlckZvb3Rlcjogbm9vcFxufTtcblxuLyoqXG4gKiBJbnZva2UgY2FsbGJhY2sgZnJvbSBvYmplY3Qgd2l0aCBjb250ZXh0IGFuZCBhcmd1bWVudHMuXG4gKiBJZiBjYWxsYmFjayByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGVuIHdpbGwgYmUgaW52b2tlZCBkZWZhdWx0IGNhbGxiYWNrLlxuICogQHBhcmFtIHtSZWNvcmQ8a2V5b2YgdHlwZW9mIGRlZmF1bHRDYWxsYmFja3MsIEZ1bmN0aW9uPn0gY2FsbGJhY2tzXG4gKiBAcGFyYW0ge2tleW9mIHR5cGVvZiBkZWZhdWx0Q2FsbGJhY2tzfSBuYW1lXG4gKiBAcGFyYW0geyp9IGN0eFxuICogQHBhcmFtIHsqfSBhcmdcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgbmFtZSwgY3R4LCBhcmcpIHtcbiAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuXG4gIGlmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBkZWZhdWx0Q2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBDaGFydC5Ub29sdGlwLnBvc2l0aW9uZXJzXG4gICAqL1xuICBzdGF0aWMgcG9zaXRpb25lcnMgPSBwb3NpdGlvbmVycztcblxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5vcGFjaXR5ID0gMDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NpemUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmRhdGFQb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJlZm9yZUJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9vdGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueEFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICAvLyBUT0RPOiBWNCwgbWFrZSB0aGlzIHByaXZhdGUsIHJlbmFtZSB0byBgX2xhYmVsU3R5bGVzYCwgYW5kIGNvbWJpbmUgd2l0aCBgbGFiZWxQb2ludFN0eWxlc2BcbiAgICAvLyBhbmQgYGxhYmVsVGV4dENvbG9yc2AgdG8gY3JlYXRlIGEgc2luZ2xlIHZhcmlhYmxlXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpbml0aWFsaXplKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cblxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmNoYXJ0LCBvcHRzKTtcbiAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgfVxuXG4gIGdldFRpdGxlKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2JlZm9yZVRpdGxlJywgdGhpcywgY29udGV4dCk7XG4gICAgY29uc3QgdGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICd0aXRsZScsIHRoaXMsIGNvbnRleHQpO1xuICAgIGNvbnN0IGFmdGVyVGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdhZnRlclRpdGxlJywgdGhpcywgY29udGV4dCk7XG5cbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG5cbiAgZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoXG4gICAgICBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhvcHRpb25zLmNhbGxiYWNrcywgJ2JlZm9yZUJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpXG4gICAgKTtcbiAgfVxuXG4gIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlJdGVtcyA9IFtdO1xuXG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdiZWZvcmVMYWJlbCcsIHRoaXMsIGNvbnRleHQpKSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0ubGluZXMsIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2FmdGVyTGFiZWwnLCB0aGlzLCBjb250ZXh0KSkpO1xuXG4gICAgICBib2R5SXRlbXMucHVzaChib2R5SXRlbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYm9keUl0ZW1zO1xuICB9XG5cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhcbiAgICAgIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYWZ0ZXJCb2R5JywgdGhpcywgdG9vbHRpcEl0ZW1zKVxuICAgICk7XG4gIH1cblxuICAvLyBHZXQgdGhlIGZvb3RlciBhbmQgYmVmb3JlRm9vdGVyIGFuZCBhZnRlckZvb3RlciBsaW5lc1xuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYmVmb3JlRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlRm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICBjb25zdCBmb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdmb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYWZ0ZXJGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuXG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcblxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZXMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFRleHRDb2xvcnMgPSBbXTtcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgbGV0IGksIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBmaWx0ZXIgZnVuY3Rpb24sIHVzZSBpdCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgaXRlbXNcbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHVzZXIgcHJvdmlkZWQgYSBzb3J0aW5nIGZ1bmN0aW9uLCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSB0b29sdGlwIGl0ZW1zXG4gICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlcm1pbmUgY29sb3JzIGZvciBib3hlc1xuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsUG9pbnRTdHlsZScsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsVGV4dENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsVGV4dENvbG9yJywgdGhpcywgY29udGV4dCkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cblxuICB1cGRhdGUoY2hhbmdlZCwgcmVwbGF5KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgbGV0IHByb3BlcnRpZXM7XG4gICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuXG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcblxuICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCBzaXplKTtcbiAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudCh0aGlzLmNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgYmFja2dyb3VuZFBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCB0aGlzLmNoYXJ0KTtcblxuICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuXG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl90b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXM7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cblxuICBkcmF3Q2FyZXQodG9vbHRpcFBvaW50LCBjdHgsIHNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG5cbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuXG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuXG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHkyID0gcHRZICsgKGhlaWdodCAvIDIpO1xuXG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gTGVmdCBkcmF3cyBib3R0b20gLT4gdG9wLCB0aGlzIHkxIGlzIG9uIHRoZSBib3R0b21cbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG5cbiAgICAgICAgLy8gUmlnaHQgZHJhd3MgdG9wIC0+IGJvdHRvbSwgdGh1cyB5MSBpcyBvbiB0aGUgdG9wXG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG5cbiAgICAgIHgzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MiA9IHB0WCArIE1hdGgubWF4KHRvcExlZnQsIGJvdHRvbUxlZnQpICsgKGNhcmV0U2l6ZSk7XG4gICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4MiA9IHB0WCArIHdpZHRoIC0gTWF0aC5tYXgodG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyID0gdGhpcy5jYXJldFg7XG4gICAgICB9XG5cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuXG4gICAgICAgIC8vIFRvcCBkcmF3cyBsZWZ0IC0+IHJpZ2h0LCB0aHVzIHgxIGlzIG9uIHRoZSBsZWZ0XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcblxuICAgICAgICAvLyBCb3R0b20gZHJhd3MgcmlnaHQgLT4gbGVmdCwgdGh1cyB4MSBpcyBvbiB0aGUgcmlnaHRcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cblxuICBkcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy50aXRsZTtcbiAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgbGV0IHRpdGxlRm9udCwgdGl0bGVTcGFjaW5nLCBpO1xuXG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMudGl0bGVBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcblxuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0aXRsZVtpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyB0aXRsZUZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVTcGFjaW5nOyAvLyBMaW5lIEhlaWdodCBhbmQgc3BhY2luZ1xuXG4gICAgICAgIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nOyAvLyBJZiBMYXN0LCBhZGQgbWFyZ2luLCByZW1vdmUgc3BhY2luZ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsQ29sb3IgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tpXTtcbiAgICBjb25zdCB7Ym94SGVpZ2h0LCBib3hXaWR0aH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuXG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLCAvLyBmaXQgdGhlIGNpcmNsZSBpbiB0aGUgYm94XG4gICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICByb3RhdGlvbjogbGFiZWxQb2ludFN0eWxlLnJvdGF0aW9uLFxuICAgICAgICBib3JkZXJXaWR0aDogMVxuICAgICAgfTtcbiAgICAgIC8vIFJlY2FsY3VsYXRlIHggYW5kIHkgZm9yIGRyYXdQb2ludCgpIGJlY2F1c2UgaXRzIGV4cGVjdGluZ1xuICAgICAgLy8geCBhbmQgeSB0byBiZSBjZW50ZXIgb2YgZmlndXJlIChpbnN0ZWFkIG9mIHRvcCBsZWZ0KVxuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG5cbiAgICAgIC8vIEZpbGwgdGhlIHBvaW50IHdpdGggd2hpdGUgc28gdGhhdCBjb2xvdXJzIG1lcmdlIG5pY2VseSBpZiB0aGUgb3BhY2l0eSBpcyA8IDFcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuXG4gICAgICAvLyBEcmF3IHRoZSBwb2ludFxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQm9yZGVyXG4gICAgICBjdHgubGluZVdpZHRoID0gaXNPYmplY3QobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkgPyBNYXRoLm1heCguLi5PYmplY3QudmFsdWVzKGxhYmVsQ29sb3IuYm9yZGVyV2lkdGgpKSA6IChsYWJlbENvbG9yLmJvcmRlcldpZHRoIHx8IDEpOyAvLyBUT0RPLCB2NCByZW1vdmUgZmFsbGJhY2tcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3IuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvci5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxhYmVsQ29sb3IuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuXG4gICAgICAvLyBGaWxsIGEgd2hpdGUgcmVjdCBzbyB0aGF0IGNvbG91cnMgbWVyZ2UgbmljZWx5IGlmIHRoZSBvcGFjaXR5IGlzIDwgMVxuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSAyKTtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGFiZWxDb2xvci5ib3JkZXJSYWRpdXMpO1xuXG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIC8vIElubmVyIHNxdWFyZVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IGlubmVyWCxcbiAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgIHc6IGJveFdpZHRoIC0gMixcbiAgICAgICAgICBoOiBib3hIZWlnaHQgLSAyLFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vcm1hbCByZWN0XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICAvLyBJbm5lciBzcXVhcmVcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3IuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgZmlsbFN0eWxlXG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG5cbiAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtib2R5fSA9IHRoaXM7XG4gICAgY29uc3Qge2JvZHlTcGFjaW5nLCBib2R5QWxpZ24sIGRpc3BsYXlDb2xvcnMsIGJveEhlaWdodCwgYm94V2lkdGgsIGJveFBhZGRpbmd9ID0gb3B0aW9ucztcbiAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGxldCB4TGluZVBhZGRpbmcgPSAwO1xuXG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcblxuICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICB9O1xuXG4gICAgY29uc3QgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gPSBydGxIZWxwZXIudGV4dEFsaWduKGJvZHlBbGlnbik7XG4gICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuXG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG5cbiAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuXG4gICAgLy8gQmVmb3JlIGJvZHkgbGluZXNcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgZWFjaCh0aGlzLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcblxuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxuICAgICAgOiAwO1xuXG4gICAgLy8gRHJhdyBib2R5IGxpbmVzIG5vd1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuXG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgLy8gRHJhdyBMZWdlbmQtbGlrZSBib3hlcyBpZiBuZWVkZWRcbiAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBNYXRoLm1heChib2R5Rm9udC5saW5lSGVpZ2h0LCBib3hIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgLy8gUmVzZXQgZm9yIGFueSBsaW5lcyB0aGF0IGRvbid0IGluY2x1ZGUgY29sb3Jib3hcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgYmFjayB0byAwIGZvciBhZnRlciBib2R5XG4gICAgeExpbmVQYWRkaW5nID0gMDtcbiAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG5cbiAgICAvLyBBZnRlciBib2R5IGxpbmVzXG4gICAgZWFjaCh0aGlzLmFmdGVyQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHB0LnkgLT0gYm9keVNwYWNpbmc7IC8vIFJlbW92ZSBsYXN0IGJvZHkgc3BhY2luZ1xuICB9XG5cbiAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZm9vdGVyID0gdGhpcy5mb290ZXI7XG4gICAgY29uc3QgbGVuZ3RoID0gZm9vdGVyLmxlbmd0aDtcbiAgICBsZXQgZm9vdGVyRm9udCwgaTtcblxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG5cbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG5cbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKG9wdGlvbnMuZm9vdGVyQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuXG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG5cbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChmb290ZXJbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgZm9vdGVyRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKG9wdGlvbnMuY29ybmVyUmFkaXVzKTtcblxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHRvcExlZnQsIHkpO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gdG9wUmlnaHQsIHkpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyBib3R0b21MZWZ0LCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYm90dG9tTGVmdCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgdG9wTGVmdCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIGN0eC5maWxsKCk7XG5cbiAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogVXBkYXRlIHgveSBhbmltYXRpb24gdGFyZ2V0cyB3aGVuIF9hY3RpdmUgZWxlbWVudHMgYXJlIGFuaW1hdGluZyB0b29cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgIGNvbnN0IGFuaW1ZID0gYW5pbXMgJiYgYW5pbXMueTtcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgcG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIGNoYXJ0KTtcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XG4gICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSB0b29sdGlwIHdpbGwgZHJhdyBhbnl0aGluZ1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdG9vbHRpcCB3aWxsIHJlbmRlclxuICAgKi9cbiAgX3dpbGxSZW5kZXIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICB9XG5cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpO1xuXG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcblxuICAgIC8vIElFMTEvRWRnZSBkb2VzIG5vdCBsaWtlIHZlcnkgc21hbGwgb3BhY2l0aWVzLCBzbyBzbmFwIHRvIDBcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG5cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG5cbiAgICAvLyBUcnV0aHkvZmFsc2V5IHZhbHVlIGZvciBlbXB0eSB0b29sdGlwXG4gICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcblxuICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXG4gICAgICAvLyBEcmF3IEJhY2tncm91bmRcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuXG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuXG4gICAgICAvLyBUaXRsZXNcbiAgICAgIHRoaXMuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBCb2R5XG4gICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBGb290ZXJcbiAgICAgIHRoaXMuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcblxuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBHZXQgYWN0aXZlIGVsZW1lbnRzIGluIHRoZSB0b29sdGlwXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBhcmUgYWN0aXZlIGluIHRoZSB0b29sdGlwXG5cdCAqL1xuICBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICB9XG5cbiAgLyoqXG5cdCAqIFNldCBhY3RpdmUgZWxlbWVudHMgaW4gdGhlIHRvb2x0aXBcblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlRWxlbWVudHMgQXJyYXkgb2YgYWN0aXZlIGRhdGFzZXRJbmRleC9pbmRleCBwYWlycy5cblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UG9zaXRpb24gU3ludGhldGljIGV2ZW50IHBvc2l0aW9uIHVzZWQgaW4gcG9zaXRpb25pbmdcblx0ICovXG4gIHNldEFjdGl2ZUVsZW1lbnRzKGFjdGl2ZUVsZW1lbnRzLCBldmVudFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHtkYXRhc2V0SW5kZXgsIGluZGV4fSkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcblxuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG5cbiAgICBpZiAoY2hhbmdlZCB8fCBwb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSBldmVudFBvc2l0aW9uO1xuICAgICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMudXBkYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBIYW5kbGUgYW4gZXZlbnRcblx0ICogQHBhcmFtIHtDaGFydEV2ZW50fSBlIC0gVGhlIGV2ZW50IHRvIGhhbmRsZVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXBsYXldIC0gVGhpcyBpcyBhIHJlcGxheWVkIGV2ZW50IChmcm9tIHVwZGF0ZSlcblx0ICogQHBhcmFtIHtib29sZWFufSBbaW5DaGFydEFyZWFdIC0gVGhlIGV2ZW50IGlzIGluc2lkZSBjaGFydEFyZWFcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHRvb2x0aXAgY2hhbmdlZFxuXHQgKi9cbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICBpZiAocmVwbGF5ICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGl0ZW1zIHNob3duLCBidXQgdGhlIHRvb2x0aXAgcG9zaXRpb24gaXMgbmVhcmVzdCBtb2RlXG4gICAgLy8gYW4gdXBkYXRlIG1heSBuZWVkIHRvIGJlIG1hZGUgYmVjYXVzZSBvdXIgcG9zaXRpb24gbWF5IGhhdmUgY2hhbmdlZCBldmVuIHRob3VnaFxuICAgIC8vIHRoZSBpdGVtcyBhcmUgdGhlIHNhbWUgYXMgYmVmb3JlLlxuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuXG4gICAgLy8gUmVtZW1iZXIgTGFzdCBBY3RpdmVzXG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG5cbiAgICAvLyBPbmx5IGhhbmRsZSB0YXJnZXQgZXZlbnQgb24gdG9vbHRpcCBjaGFuZ2VcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuXG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBIZWxwZXIgZm9yIGRldGVybWluaW5nIHRoZSBhY3RpdmUgZWxlbWVudHMgZm9yIGV2ZW50XG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIFRoZSBldmVudCB0byBoYW5kbGVcblx0ICogQHBhcmFtIHtJbnRlcmFjdGlvbkl0ZW1bXX0gbGFzdEFjdGl2ZSAtIFByZXZpb3VzbHkgYWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcGxheV0gLSBUaGlzIGlzIGEgcmVwbGF5ZWQgZXZlbnQgKGZyb20gdXBkYXRlKVxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbkNoYXJ0QXJlYV0gLSBUaGUgZXZlbnQgaXMgaW5zaWRlIGNoYXJ0QXJlYVxuXHQgKiBAcmV0dXJucyB7SW50ZXJhY3Rpb25JdGVtW119IC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgLy8gTGV0IHVzZXIgY29udHJvbCB0aGUgYWN0aXZlIGVsZW1lbnRzIG91dHNpZGUgY2hhcnRBcmVhLiBFZy4gdXNpbmcgTGVnZW5kLlxuICAgICAgLy8gQnV0IG1ha2Ugc3VyZSB0aGF0IGFjdGl2ZSBlbGVtZW50cyBhcmUgc3RpbGwgdmFsaWQuXG4gICAgICByZXR1cm4gbGFzdEFjdGl2ZS5maWx0ZXIoaSA9PlxuICAgICAgICB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbaS5kYXRhc2V0SW5kZXhdICYmXG4gICAgICAgIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIuZ2V0UGFyc2VkKGkuaW5kZXgpICE9PSB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBBY3RpdmUgRWxlbWVudHMgZm9yIHRvb2x0aXBzXG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5jaGFydC5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIG9wdGlvbnMubW9kZSwgb3B0aW9ucywgcmVwbGF5KTtcblxuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBEZXRlcm1pbmUgaWYgdGhlIGFjdGl2ZSBlbGVtZW50cyArIGV2ZW50IGNvbWJpbmF0aW9uIGNoYW5nZXMgdGhlXG5cdCAqIHRvb2x0aXAgcG9zaXRpb25cblx0ICogQHBhcmFtIHthcnJheX0gYWN0aXZlIC0gQWN0aXZlIGVsZW1lbnRzXG5cdCAqIEBwYXJhbSB7Q2hhcnRFdmVudH0gZSAtIEV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBwb3NpdGlvbiBjaGFuZ2Vcblx0ICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBvc2l0aW9uIGhhcyBjaGFuZ2VkXG5cdCAqL1xuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaWQ6ICd0b29sdGlwJyxcbiAgX2VsZW1lbnQ6IFRvb2x0aXAsXG4gIHBvc2l0aW9uZXJzLFxuXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtjaGFydCwgb3B0aW9uc30pO1xuICAgIH1cbiAgfSxcblxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgcmVzZXQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG5cbiAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLl93aWxsUmVuZGVyKCkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIHRvb2x0aXBcbiAgICAgIH07XG5cbiAgICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIHsuLi5hcmdzLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG5cbiAgICAgIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyVG9vbHRpcERyYXcnLCBhcmdzKTtcbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICAvLyBJZiB0aGUgZXZlbnQgaXMgcmVwbGF5ZWQgZnJvbSBgdXBkYXRlYCwgd2Ugc2hvdWxkIGV2YWx1YXRlIHdpdGggdGhlIGZpbmFsIHBvc2l0aW9ucy5cbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XG4gICAgICAgIC8vIG5vdGlmeSBjaGFydCBhYm91dCB0aGUgY2hhbmdlLCBzbyBpdCB3aWxsIHJlbmRlclxuICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiBkZWZhdWx0Q2FsbGJhY2tzXG4gIH0sXG5cbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG5cbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdmaWx0ZXInICYmIG5hbWUgIT09ICdpdGVtU29ydCcgJiYgbmFtZSAhPT0gJ2V4dGVybmFsJyxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICBjYWxsYmFja3M6IHtcbiAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBfZmFsbGJhY2s6IGZhbHNlXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgfVxuICB9LFxuXG4gIC8vIFJlc29sdmUgYWRkaXRpb25hbGx5IGZyb20gYGludGVyYWN0aW9uYCBvcHRpb25zIGFuZCBkZWZhdWx0cy5cbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuIiwgImltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IHtpc051bGxPclVuZGVmLCB2YWx1ZU9yRGVmYXVsdCwgX2xpbWl0VmFsdWV9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSA9PiB7XG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIGluZGV4ID0gbGFiZWxzLnB1c2gocmF3KSAtIDE7XG4gICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7aW5kZXgsIGxhYmVsOiByYXd9KTtcbiAgfSBlbHNlIGlmIChpc05hTihyYXcpKSB7XG4gICAgaW5kZXggPSBudWxsO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5cbmZ1bmN0aW9uIGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpIHtcbiAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICBpZiAoZmlyc3QgPT09IC0xKSB7XG4gICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpO1xuICB9XG4gIGNvbnN0IGxhc3QgPSBsYWJlbHMubGFzdEluZGV4T2YocmF3KTtcbiAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cblxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcblxuZnVuY3Rpb24gX2dldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcblxuICBpZiAodmFsdWUgPj0gMCAmJiB2YWx1ZSA8IGxhYmVscy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhdGVnb3J5U2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG5cbiAgc3RhdGljIGlkID0gJ2NhdGVnb3J5JztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICB0aWNrczoge1xuICAgICAgY2FsbGJhY2s6IF9nZXRMYWJlbEZvclZhbHVlXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gIH1cblxuICBpbml0KHNjYWxlT3B0aW9ucykge1xuICAgIGNvbnN0IGFkZGVkID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgaWYgKGFkZGVkLmxlbmd0aCkge1xuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgIGZvciAoY29uc3Qge2luZGV4LCBsYWJlbH0gb2YgYWRkZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc1tpbmRleF0gPT09IGxhYmVsKSB7XG4gICAgICAgICAgbGFiZWxzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIHN1cGVyLmluaXQoc2NhbGVPcHRpb25zKTtcbiAgfVxuXG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpbmRleCA9IGlzRmluaXRlKGluZGV4KSAmJiBsYWJlbHNbaW5kZXhdID09PSByYXcgPyBpbmRleFxuICAgICAgOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcbiAgICByZXR1cm4gdmFsaWRJbmRleChpbmRleCwgbGFiZWxzLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgIG1heCA9IHRoaXMuZ2V0TGFiZWxzKCkubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuXG4gICAgLy8gSWYgd2UgYXJlIHZpZXdpbmcgc29tZSBzdWJzZXQgb2YgbGFiZWxzLCBzbGljZSB0aGUgb3JpZ2luYWwgYXJyYXlcbiAgICBsYWJlbHMgPSAobWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1pbiwgbWF4ICsgMSk7XG5cbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChvZmZzZXQgPyAwLjUgOiAwKTtcblxuICAgIGZvciAobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gX2dldExhYmVsRm9yVmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgY29uZmlndXJlKCkge1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAvLyBGb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdmVydGljYWwgY2F0ZWdvcnkgc2NhbGUgcmV2ZXJzZSBpcyBpbnZlcnRlZC5cbiAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhdGhpcy5fcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gIH1cblxuICAvLyBVc2VkIHRvIGdldCBkYXRhIHZhbHVlIGxvY2F0aW9ucy4gVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBpbmRleCBvciBhIG51bWVyaWNhbCB2YWx1ZVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIC8vIE11c3Qgb3ZlcnJpZGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIGl0IGNhbGxzIGdldFBpeGVsRm9yVmFsdWVcbiAgLy8gYW5kIGNhdGVnb3J5IHNjYWxlIGNhbiBoYXZlIGR1cGxpY2F0ZSB2YWx1ZXNcbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gIH1cbn1cbiIsICJpbXBvcnQge2lzTnVsbE9yVW5kZWZ9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7YWxtb3N0RXF1YWxzLCBhbG1vc3RXaG9sZSwgbmljZU51bSwgX2RlY2ltYWxQbGFjZXMsIF9zZXRNaW5BbmRNYXhCeUtleSwgc2lnbiwgdG9SYWRpYW5zfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMubWF0aC5qcyc7XG5pbXBvcnQgU2NhbGUgZnJvbSAnLi4vY29yZS9jb3JlLnNjYWxlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzZXQgb2YgbGluZWFyIHRpY2tzIGZvciBhbiBheGlzXG4gKiAxLiBJZiBnZW5lcmF0aW9uT3B0aW9ucy5taW4sIGdlbmVyYXRpb25PcHRpb25zLm1heCwgYW5kIGdlbmVyYXRpb25PcHRpb25zLnN0ZXAgYXJlIGRlZmluZWQ6XG4gKiAgICBpZiAobWF4IC0gbWluKSAvIHN0ZXAgaXMgYW4gaW50ZWdlciwgdGlja3MgYXJlIGdlbmVyYXRlZCBhcyBbbWluLCBtaW4gKyBzdGVwLCAuLi4sIG1heF1cbiAqICAgIE5vdGUgdGhhdCB0aGUgZ2VuZXJhdGlvbk9wdGlvbnMubWF4Q291bnQgc2V0dGluZyBpcyByZXNwZWN0ZWQgaW4gdGhpcyBzY2VuYXJpb1xuICpcbiAqIDIuIElmIGdlbmVyYXRpb25PcHRpb25zLm1pbiwgZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCBhbmQgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gY291bnRcbiAqICAgIFRpY2tzIGFyZSBnZW5lcmF0ZWQgYXMgW21pbiwgbWluICsgc3BhY2luZywgLi4uLCBtYXhdXG4gKlxuICogMy4gSWYgZ2VuZXJhdGlvbk9wdGlvbnMuY291bnQgaXMgZGVmaW5lZFxuICogICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBjb3VudFxuICpcbiAqIDQuIENvbXB1dGUgb3B0aW1hbCBzcGFjaW5nIG9mIHRpY2tzIHVzaW5nIG5pY2VOdW0gYWxnb3JpdGhtXG4gKlxuICogQHBhcmFtIGdlbmVyYXRpb25PcHRpb25zIHRoZSBvcHRpb25zIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpY2tzXG4gKiBAcGFyYW0gZGF0YVJhbmdlIHRoZSByYW5nZSBvZiB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdFtdfSBhcnJheSBvZiB0aWNrIG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8vIFRvIGdldCBhIFwibmljZVwiIHZhbHVlIGZvciB0aGUgdGljayBzcGFjaW5nLCB3ZSB3aWxsIHVzZSB0aGUgYXBwcm9wcmlhdGVseSBuYW1lZFxuICAvLyBcIm5pY2UgbnVtYmVyXCIgYWxnb3JpdGhtLiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNjg4MS9uaWNlLWxhYmVsLWFsZ29yaXRobS1mb3ItY2hhcnRzLXdpdGgtbWluaW11bS10aWNrc1xuICAvLyBmb3IgZGV0YWlscy5cblxuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG5cbiAgLy8gQmV5b25kIE1JTl9TUEFDSU5HIGZsb2F0aW5nIHBvaW50IG51bWJlcnMgYmVpbmcgdG8gbG9zZSBwcmVjaXNpb25cbiAgLy8gc3VjaCB0aGF0IHdlIGNhbid0IGRvIHRoZSBtYXRoIG5lY2Vzc2FyeSB0byBnZW5lcmF0ZSB0aWNrc1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuXG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIC8vIElmIHRoZSBjYWxjdWxhdGVkIG51bSBvZiBzcGFjZXMgZXhjZWVkcyBtYXhOdW1TcGFjZXMsIHJlY2FsY3VsYXRlIGl0XG4gICAgc3BhY2luZyA9IG5pY2VOdW0obnVtU3BhY2VzICogc3BhY2luZyAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgfVxuXG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgLy8gSWYgdGhlIHVzZXIgc3BlY2lmaWVkIGEgcHJlY2lzaW9uLCByb3VuZCB0byB0aGF0IG51bWJlciBvZiBkZWNpbWFsIHBsYWNlc1xuICAgIGZhY3RvciA9IE1hdGgucG93KDEwLCBwcmVjaXNpb24pO1xuICAgIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIH1cblxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cblxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAvLyBDYXNlIDE6IElmIG1pbiwgbWF4IGFuZCBzdGVwU2l6ZSBhcmUgc2V0IGFuZCB0aGV5IG1ha2UgYW4gZXZlbmx5IHNwYWNlZCBzY2FsZSB1c2UgaXQuXG4gICAgLy8gc3BhY2luZyA9IHN0ZXA7XG4gICAgLy8gbnVtU3BhY2VzID0gKG1heCAtIG1pbikgLyBzcGFjaW5nO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSByb3VuZCBoZXJlIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhbG1vc3RXaG9sZSB0cmFuc2xhdGVkIGFuIEZQIGVycm9yXG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICAvLyBDYXNlcyAyICYgMywgd2UgaGF2ZSBhIGNvdW50IHNwZWNpZmllZC4gSGFuZGxlIG9wdGlvbmFsIHVzZXIgZGVmaW5lZCBlZGdlcyB0byB0aGUgcmFuZ2UuXG4gICAgLy8gU29tZXRpbWVzIHRoZXNlIGFyZSBuby1vcHMsIGJ1dCBpdCBtYWtlcyB0aGUgY29kZSBhIGxvdCBjbGVhcmVyXG4gICAgLy8gYW5kIHdoZW4gYSB1c2VyIGRlZmluZWQgcmFuZ2UgaXMgc3BlY2lmaWVkLCB3ZSB3YW50IHRoZSBjb3JyZWN0IHRpY2tzXG4gICAgbmljZU1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiBuaWNlTWluO1xuICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICBudW1TcGFjZXMgPSBjb3VudCAtIDE7XG4gICAgc3BhY2luZyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBudW1TcGFjZXM7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2FzZSA0XG4gICAgbnVtU3BhY2VzID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIHNwYWNpbmc7XG5cbiAgICAvLyBJZiB2ZXJ5IGNsb3NlIHRvIG91ciByb3VuZGVkIHZhbHVlLCB1c2UgaXQuXG4gICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGguY2VpbChudW1TcGFjZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRoZSBzcGFjaW5nIHdpbGwgaGF2ZSBjaGFuZ2VkIGluIGNhc2VzIDEsIDIsIGFuZCAzIHNvIHRoZSBmYWN0b3IgY2Fubm90IGJlIGNvbXB1dGVkXG4gIC8vIHVudGlsIHRoaXMgcG9pbnRcbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuXG4gIGxldCBqID0gMDtcbiAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICBpZiAoaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWluICE9PSBtaW4pIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtaW59KTtcblxuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrOyAvLyBTa2lwIG5pY2VNaW5cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZSBuZXh0IG5pY2UgdGljayBpcyBjbG9zZSB0byBtaW4sIHNraXAgaXRcbiAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgIGorKztcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgY29uc3QgdGlja1ZhbHVlID0gTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgaWYgKG1heERlZmluZWQgJiYgdGlja1ZhbHVlID4gbWF4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWx1ZX0pO1xuICB9XG5cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgdGljayBpcyB0b28gY2xvc2UgdG8gbWF4LCByZXBsYWNlIGl0IHdpdGggbWF4LCBlbHNlIGFkZCBtYXhcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cblxuICByZXR1cm4gdGlja3M7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7aG9yaXpvbnRhbCwgbWluUm90YXRpb259KSB7XG4gIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihyYWQpIDogTWF0aC5jb3MocmFkKSkgfHwgMC4wMDE7XG4gIGNvbnN0IGxlbmd0aCA9IDAuNzUgKiBtaW5TcGFjaW5nICogKCcnICsgdmFsdWUpLmxlbmd0aDtcbiAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fZW5kVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cblxuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuICtyYXc7XG4gIH1cblxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuXG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcblxuICAgIGlmIChiZWdpbkF0WmVybykge1xuICAgICAgY29uc3QgbWluU2lnbiA9IHNpZ24obWluKTtcbiAgICAgIGNvbnN0IG1heFNpZ24gPSBzaWduKG1heCk7XG5cbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSBtYXggPT09IDAgPyAxIDogTWF0aC5hYnMobWF4ICogMC4wNSk7XG5cbiAgICAgIHNldE1heChtYXggKyBvZmZzZXQpO1xuXG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuXG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG5cbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG5cbiAgICBpZiAobWF4VGlja3NMaW1pdCkge1xuICAgICAgbWF4VGlja3MgPSBNYXRoLm1pbihtYXhUaWNrc0xpbWl0LCBtYXhUaWNrcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG5cbiAgICAvLyBGaWd1cmUgb3V0IHdoYXQgdGhlIG1heCBudW1iZXIgb2YgdGlja3Mgd2UgY2FuIHN1cHBvcnQgaXQgaXMgYmFzZWQgb24gdGhlIHNpemUgb2ZcbiAgICAvLyB0aGUgYXhpcyBhcmVhLiBGb3Igbm93LCB3ZSBzYXkgdGhhdCB0aGUgbWluaW11bSB0aWNrIHNwYWNpbmcgaW4gcGl4ZWxzIG11c3QgYmUgNDBcbiAgICAvLyBXZSBhbHNvIGxpbWl0IHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyB0byAxMSB3aGljaCBnaXZlcyBhIG5pY2UgMTAgc3F1YXJlcyBvblxuICAgIC8vIHRoZSBncmFwaC4gTWFrZSBzdXJlIHdlIGFsd2F5cyBoYXZlIGF0IGxlYXN0IDIgdGlja3NcbiAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgIG1heFRpY2tzID0gTWF0aC5tYXgoMiwgbWF4VGlja3MpO1xuXG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKG51bWVyaWNHZW5lcmF0b3JPcHRpb25zLCBkYXRhUmFuZ2UpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCB0byB1cGRhdGUgb3VyIG1heCBhbmQgbWluIGdpdmVuIHRoZSB0aWNrIHZhbHVlcyxcbiAgICAvLyBzaW5jZSB3ZSBwcm9iYWJseSBoYXZlIGV4cGFuZGVkIHRoZSByYW5nZSBvZiB0aGUgc2NhbGVcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cblxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuIiwgImltcG9ydCB7aXNGaW5pdGV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCBMaW5lYXJTY2FsZUJhc2UgZnJvbSAnLi9zY2FsZS5saW5lYXJiYXNlLmpzJztcbmltcG9ydCBUaWNrcyBmcm9tICcuLi9jb3JlL2NvcmUudGlja3MuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnN9IGZyb20gJy4uL2hlbHBlcnMvaW5kZXguanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG5cbiAgc3RhdGljIGlkID0gJ2xpbmVhcic7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgdGlja3M6IHtcbiAgICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgICB9XG4gIH07XG5cblxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpID8gbWF4IDogMTtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcbiBcdCAqL1xuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gIH1cblxuICAvLyBVdGlsc1xuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbiIsICJpbXBvcnQge2Zpbml0ZU9yRGVmYXVsdCwgaXNGaW5pdGV9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb3JlLmpzJztcbmltcG9ydCB7Zm9ybWF0TnVtYmVyfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuaW50bC5qcyc7XG5pbXBvcnQge19zZXRNaW5BbmRNYXhCeUtleSwgbG9nMTB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5tYXRoLmpzJztcbmltcG9ydCBTY2FsZSBmcm9tICcuLi9jb3JlL2NvcmUuc2NhbGUuanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5cbmNvbnN0IGxvZzEwRmxvb3IgPSB2ID0+IE1hdGguZmxvb3IobG9nMTAodikpO1xuY29uc3QgY2hhbmdlRXhwb25lbnQgPSAodiwgbSkgPT4gTWF0aC5wb3coMTAsIGxvZzEwRmxvb3IodikgKyBtKTtcblxuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XG4gIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWwgLyAoTWF0aC5wb3coMTAsIGxvZzEwRmxvb3IodGlja1ZhbCkpKTtcbiAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cblxuZnVuY3Rpb24gc3RlcHMobWluLCBtYXgsIHJhbmdlRXhwKSB7XG4gIGNvbnN0IHJhbmdlU3RlcCA9IE1hdGgucG93KDEwLCByYW5nZUV4cCk7XG4gIGNvbnN0IHN0YXJ0ID0gTWF0aC5mbG9vcihtaW4gLyByYW5nZVN0ZXApO1xuICBjb25zdCBlbmQgPSBNYXRoLmNlaWwobWF4IC8gcmFuZ2VTdGVwKTtcbiAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xufVxuXG5mdW5jdGlvbiBzdGFydEV4cChtaW4sIG1heCkge1xuICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcbiAgbGV0IHJhbmdlRXhwID0gbG9nMTBGbG9vcihyYW5nZSk7XG4gIHdoaWxlIChzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApID4gMTApIHtcbiAgICByYW5nZUV4cCsrO1xuICB9XG4gIHdoaWxlIChzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIDwgMTApIHtcbiAgICByYW5nZUV4cC0tO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihyYW5nZUV4cCwgbG9nMTBGbG9vcihtaW4pKTtcbn1cblxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc2V0IG9mIGxvZ2FyaXRobWljIHRpY2tzXG4gKiBAcGFyYW0gZ2VuZXJhdGlvbk9wdGlvbnMgdGhlIG9wdGlvbnMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgdGlja3NcbiAqIEBwYXJhbSBkYXRhUmFuZ2UgdGhlIHJhbmdlIG9mIHRoZSBkYXRhXG4gKiBAcmV0dXJucyB7b2JqZWN0W119IGFycmF5IG9mIHRpY2sgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB7bWluLCBtYXh9KSB7XG4gIG1pbiA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIG1pbik7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IG1pbkV4cCA9IGxvZzEwRmxvb3IobWluKTtcbiAgbGV0IGV4cCA9IHN0YXJ0RXhwKG1pbiwgbWF4KTtcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICBjb25zdCBzdGVwU2l6ZSA9IE1hdGgucG93KDEwLCBleHApO1xuICBjb25zdCBiYXNlID0gbWluRXhwID4gZXhwID8gTWF0aC5wb3coMTAsIG1pbkV4cCkgOiAwO1xuICBjb25zdCBzdGFydCA9IE1hdGgucm91bmQoKG1pbiAtIGJhc2UpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcigobWluIC0gYmFzZSkgLyBzdGVwU2l6ZSAvIDEwKSAqIHN0ZXBTaXplICogMTA7XG4gIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IoKHN0YXJ0IC0gb2Zmc2V0KSAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgbGV0IHZhbHVlID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG4gIHdoaWxlICh2YWx1ZSA8IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlLCBtYWpvcjogaXNNYWpvcih2YWx1ZSksIHNpZ25pZmljYW5kfSk7XG4gICAgaWYgKHNpZ25pZmljYW5kID49IDEwKSB7XG4gICAgICBzaWduaWZpY2FuZCA9IHNpZ25pZmljYW5kIDwgMTUgPyAxNSA6IDIwO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaWduaWZpY2FuZCsrO1xuICAgIH1cbiAgICBpZiAoc2lnbmlmaWNhbmQgPj0gMjApIHtcbiAgICAgIGV4cCsrO1xuICAgICAgc2lnbmlmaWNhbmQgPSAyO1xuICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuICAgIH1cbiAgICB2YWx1ZSA9IE1hdGgucm91bmQoKGJhc2UgKyBvZmZzZXQgKyBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH1cbiAgY29uc3QgbGFzdFRpY2sgPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWF4LCB2YWx1ZSk7XG4gIHRpY2tzLnB1c2goe3ZhbHVlOiBsYXN0VGljaywgbWFqb3I6IGlzTWFqb3IobGFzdFRpY2spLCBzaWduaWZpY2FuZH0pO1xuXG4gIHJldHVybiB0aWNrcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nYXJpdGhtaWNTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAnbG9nYXJpdGhtaWMnO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIHRpY2tzOiB7XG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG5cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGNvbnN0IHZhbHVlID0gTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbcmF3LCBpbmRleF0pO1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpICYmIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuXG4gICAgdGhpcy5taW4gPSBpc0Zpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpID8gTWF0aC5tYXgoMCwgbWF4KSA6IG51bGw7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBkYXRhIGhhcyBgMGAgaW4gaXQgb3IgYGJlZ2luQXRaZXJvYCBpcyB0cnVlLCBtaW4gKG5vbiB6ZXJvKSB2YWx1ZSBpcyBhdCBib3R0b21cbiAgICAvLyBvZiBzY2FsZSwgYW5kIGl0IGRvZXMgbm90IGVxdWFsIHN1Z2dlc3RlZE1pbiwgbG93ZXIgdGhlIG1pbiBib3VuZCBieSBvbmUgZXhwLlxuICAgIGlmICh0aGlzLl96ZXJvICYmIHRoaXMubWluICE9PSB0aGlzLl9zdWdnZXN0ZWRNaW4gJiYgIWlzRmluaXRlKHRoaXMuX3VzZXJNaW4pKSB7XG4gICAgICB0aGlzLm1pbiA9IG1pbiA9PT0gY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApID8gY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIC0xKSA6IGNoYW5nZUV4cG9uZW50KHRoaXMubWluLCAwKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IG1pbiA9IHRoaXMubWluO1xuICAgIGxldCBtYXggPSB0aGlzLm1heDtcblxuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG5cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGlmIChtaW4gPD0gMCkgeyAvLyBpbmNsdWRlcyBudWxsXG4gICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgc2V0TWF4KDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1pbihjaGFuZ2VFeHBvbmVudChtaW4sIC0xKSk7XG4gICAgICAgIHNldE1heChjaGFuZ2VFeHBvbmVudChtYXgsICsxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgc2V0TWluKGNoYW5nZUV4cG9uZW50KG1heCwgLTEpKTtcbiAgICB9XG4gICAgaWYgKG1heCA8PSAwKSB7XG5cbiAgICAgIHNldE1heChjaGFuZ2VFeHBvbmVudChtaW4sICsxKSk7XG4gICAgfVxuXG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cblxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICBjb25zdCBnZW5lcmF0aW9uT3B0aW9ucyA9IHtcbiAgICAgIG1pbjogdGhpcy5fdXNlck1pbixcbiAgICAgIG1heDogdGhpcy5fdXNlck1heFxuICAgIH07XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCB0aGlzKTtcblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIG5lZWQgdG8gdXBkYXRlIG91ciBtYXggYW5kIG1pbiBnaXZlbiB0aGUgdGljayB2YWx1ZXMsXG4gICAgLy8gc2luY2Ugd2UgcHJvYmFibHkgaGF2ZSBleHBhbmRlZCB0aGUgcmFuZ2Ugb2YgdGhlIHNjYWxlXG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcblxuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnMCdcbiAgICAgIDogZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1pbjtcblxuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuXG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IGxvZzEwKHN0YXJ0KTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gbG9nMTAodGhpcy5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICB9XG5cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodmFsdWUgPT09IHRoaXMubWluXG4gICAgICA/IDBcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cblxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKTtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbn1cbiIsICJpbXBvcnQgZGVmYXVsdHMgZnJvbSAnLi4vY29yZS9jb3JlLmRlZmF1bHRzLmpzJztcbmltcG9ydCB7X2xvbmdlc3RUZXh0LCBhZGRSb3VuZGVkUmVjdFBhdGgsIHJlbmRlclRleHQsIF9pc1BvaW50SW5BcmVhfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY2FudmFzLmpzJztcbmltcG9ydCB7SEFMRl9QSSwgVEFVLCB0b0RlZ3JlZXMsIHRvUmFkaWFucywgX25vcm1hbGl6ZUFuZ2xlLCBQSX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IExpbmVhclNjYWxlQmFzZSBmcm9tICcuL3NjYWxlLmxpbmVhcmJhc2UuanMnO1xuaW1wb3J0IFRpY2tzIGZyb20gJy4uL2NvcmUvY29yZS50aWNrcy5qcyc7XG5pbXBvcnQge3ZhbHVlT3JEZWZhdWx0LCBpc0FycmF5LCBpc0Zpbml0ZSwgY2FsbGJhY2sgYXMgY2FsbENhbGxiYWNrLCBpc051bGxPclVuZGVmfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29yZS5qcyc7XG5pbXBvcnQge2NyZWF0ZUNvbnRleHQsIHRvRm9udCwgdG9QYWRkaW5nLCB0b1RSQkxDb3JuZXJzfSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMub3B0aW9ucy5qcyc7XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVMYWJlbFNpemUoY3R4LCBmb250LCBsYWJlbCkge1xuICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbbGFiZWxdO1xuICByZXR1cm4ge1xuICAgIHc6IF9sb25nZXN0VGV4dChjdHgsIGZvbnQuc3RyaW5nLCBsYWJlbCksXG4gICAgaDogbGFiZWwubGVuZ3RoICogZm9udC5saW5lSGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZml0IGEgcmFkaWFsIGxpbmVhciBzY2FsZSB3aXRoIHBvaW50IGxhYmVsc1xuICovXG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcblxuICAvLyBSaWdodCwgdGhpcyBpcyByZWFsbHkgY29uZnVzaW5nIGFuZCB0aGVyZSBpcyBhIGxvdCBvZiBtYXRocyBnb2luZyBvbiBoZXJlXG4gIC8vIFRoZSBnaXN0IG9mIHRoZSBwcm9ibGVtIGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL25ubmljay82OTZjYzljNTVmNGIwYmViOGZlOVxuICAvL1xuICAvLyBSZWFjdGlvbjogaHR0cHM6Ly9kbC5kcm9wYm94dXNlcmNvbnRlbnQuY29tL3UvMzQ2MDEzNjMvdG9vbXVjaHNjaWVuY2UuZ2lmXG4gIC8vXG4gIC8vIFNvbHV0aW9uOlxuICAvL1xuICAvLyBXZSBhc3N1bWUgdGhlIHJhZGl1cyBvZiB0aGUgcG9seWdvbiBpcyBoYWxmIHRoZSBzaXplIG9mIHRoZSBjYW52YXMgYXQgZmlyc3RcbiAgLy8gYXQgZWFjaCBpbmRleCB3ZSBjaGVjayBpZiB0aGUgdGV4dCBvdmVybGFwcy5cbiAgLy9cbiAgLy8gV2hlcmUgaXQgZG9lcywgd2Ugc3RvcmUgdGhhdCBhbmdsZSBhbmQgdGhhdCBpbmRleC5cbiAgLy9cbiAgLy8gQWZ0ZXIgZmluZGluZyB0aGUgbGFyZ2VzdCBpbmRleCBhbmQgYW5nbGUgd2UgY2FsY3VsYXRlIGhvdyBtdWNoIHdlIG5lZWQgdG8gcmVtb3ZlXG4gIC8vIGZyb20gdGhlIHNoYXBlIHJhZGl1cyB0byBtb3ZlIHRoZSBwb2ludCBpbndhcmRzIGJ5IHRoYXQgeC5cbiAgLy9cbiAgLy8gV2UgYXZlcmFnZSB0aGUgbGVmdCBhbmQgcmlnaHQgZGlzdGFuY2VzIHRvIGdldCB0aGUgbWF4aW11bSBzaGFwZSByYWRpdXMgdGhhdCBjYW4gZml0IGluIHRoZSBib3hcbiAgLy8gYWxvbmcgd2l0aCBsYWJlbHMuXG4gIC8vXG4gIC8vIE9uY2Ugd2UgaGF2ZSB0aGF0LCB3ZSBjYW4gZmluZCB0aGUgY2VudHJlIHBvaW50IGZvciB0aGUgY2hhcnQsIGJ5IHRha2luZyB0aGUgeCB0ZXh0IHByb3RydXNpb25cbiAgLy8gb24gZWFjaCBzaWRlLCByZW1vdmluZyB0aGF0IGZyb20gdGhlIHNpemUsIGhhbHZpbmcgaXQgYW5kIGFkZGluZyB0aGUgbGVmdCB4IHByb3RydXNpb24gd2lkdGguXG4gIC8vXG4gIC8vIFRoaXMgd2lsbCBtZWFuIHdlIGhhdmUgYSBzaGFwZSBmaXR0ZWQgdG8gdGhlIGNhbnZhcywgYXMgbGFyZ2UgYXMgaXQgY2FuIGJlIHdpdGggdGhlIGxhYmVsc1xuICAvLyBhbmQgcG9zaXRpb24gaXQgaW4gdGhlIG1vc3Qgc3BhY2UgZWZmaWNpZW50IG1hbm5lclxuICAvL1xuICAvLyBodHRwczovL2RsLmRyb3Bib3h1c2VyY29udGVudC5jb20vdS8zNDYwMTM2My95ZWFoc2NpZW5jZS5naWZcblxuICAvLyBHZXQgbWF4aW11bSByYWRpdXMgb2YgdGhlIHBvbHlnb24uIEVpdGhlciBoYWxmIHRoZSBoZWlnaHQgKG1pbnVzIHRoZSB0ZXh0IHdpZHRoKSBvciBoYWxmIHRoZSB3aWR0aC5cbiAgLy8gVXNlIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgKyBjaGFuZ2UuIC0gTWFrZSBzdXJlIEwvUiBwcm90cnVzaW9uIGlzIGF0IGxlYXN0IDAgdG8gc3RvcCBpc3N1ZXMgd2l0aCBjZW50cmUgcG9pbnRzXG4gIGNvbnN0IG9yaWcgPSB7XG4gICAgbDogc2NhbGUubGVmdCArIHNjYWxlLl9wYWRkaW5nLmxlZnQsXG4gICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICB0OiBzY2FsZS50b3AgKyBzY2FsZS5fcGFkZGluZy50b3AsXG4gICAgYjogc2NhbGUuYm90dG9tIC0gc2NhbGUuX3BhZGRpbmcuYm90dG9tXG4gIH07XG4gIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICBjb25zdCBsYWJlbFNpemVzID0gW107XG4gIGNvbnN0IHBhZGRpbmcgPSBbXTtcbiAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gIGNvbnN0IHBvaW50TGFiZWxPcHRzID0gc2NhbGUub3B0aW9ucy5wb2ludExhYmVscztcbiAgY29uc3QgYWRkaXRpb25hbEFuZ2xlID0gcG9pbnRMYWJlbE9wdHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG5cbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcbiAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xuICB9XG5cbiAgc2NhbGUuc2V0Q2VudGVyUG9pbnQoXG4gICAgb3JpZy5sIC0gbGltaXRzLmwsXG4gICAgbGltaXRzLnIgLSBvcmlnLnIsXG4gICAgb3JpZy50IC0gbGltaXRzLnQsXG4gICAgbGltaXRzLmIgLSBvcmlnLmJcbiAgKTtcblxuICAvLyBOb3cgdGhhdCB0ZXh0IHNpemUgaXMgZGV0ZXJtaW5lZCwgY29tcHV0ZSB0aGUgZnVsbCBwb3NpdGlvbnNcbiAgc2NhbGUuX3BvaW50TGFiZWxJdGVtcyA9IGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxJdGVtKHNjYWxlLCBpbmRleCwgaXRlbU9wdHMpIHtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCB7ZXh0cmEsIGFkZGl0aW9uYWxBbmdsZSwgcGFkZGluZywgc2l6ZX0gPSBpdGVtT3B0cztcbiAgY29uc3QgcG9pbnRMYWJlbFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZywgYWRkaXRpb25hbEFuZ2xlKTtcbiAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgcmV0dXJuIHtcbiAgICAvLyBpZiB0byBkcmF3IG9yIG92ZXJsYXBwZWRcbiAgICB2aXNpYmxlOiB0cnVlLFxuXG4gICAgLy8gVGV4dCBwb3NpdGlvblxuICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgIHksXG5cbiAgICAvLyBUZXh0IHJlbmRlcmluZyBkYXRhXG4gICAgdGV4dEFsaWduLFxuXG4gICAgLy8gQm91bmRpbmcgYm94XG4gICAgbGVmdCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IGxlZnQgKyBzaXplLncsXG4gICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKSB7XG4gIGlmICghYXJlYSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gaXRlbTtcbiAgY29uc3QgYXBleGVzSW5BcmVhID0gX2lzUG9pbnRJbkFyZWEoe3g6IGxlZnQsIHk6IHRvcH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHt4OiBsZWZ0LCB5OiBib3R0b219LCBhcmVhKSB8fFxuICAgIF9pc1BvaW50SW5BcmVhKHt4OiByaWdodCwgeTogdG9wfSwgYXJlYSkgfHwgX2lzUG9pbnRJbkFyZWEoe3g6IHJpZ2h0LCB5OiBib3R0b219LCBhcmVhKTtcbiAgcmV0dXJuICFhcGV4ZXNJbkFyZWE7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3Qge2NlbnRlclBvaW50TGFiZWxzLCBkaXNwbGF5fSA9IG9wdHMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGl0ZW1PcHRzID0ge1xuICAgIGV4dHJhOiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykgLyAyLFxuICAgIGFkZGl0aW9uYWxBbmdsZTogY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwXG4gIH07XG4gIGxldCBhcmVhO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgaXRlbU9wdHMucGFkZGluZyA9IHBhZGRpbmdbaV07XG4gICAgaXRlbU9wdHMuc2l6ZSA9IGxhYmVsU2l6ZXNbaV07XG5cbiAgICBjb25zdCBpdGVtID0gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGksIGl0ZW1PcHRzKTtcbiAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgIGlmIChkaXNwbGF5ID09PSAnYXV0bycpIHtcbiAgICAgIGl0ZW0udmlzaWJsZSA9IGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKTtcbiAgICAgIGlmIChpdGVtLnZpc2libGUpIHtcbiAgICAgICAgYXJlYSA9IGl0ZW07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpdGVtcztcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICByZXR1cm4gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9XG5cbiAgcmV0dXJuICdyaWdodCc7XG59XG5cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cblxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgIHkgLT0gKGggLyAyKTtcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgeSAtPSBoO1xuICB9XG4gIHJldHVybiB5O1xufVxuXG5mdW5jdGlvbiBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHMsIGl0ZW0pIHtcbiAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSBpdGVtO1xuICBjb25zdCB7YmFja2Ryb3BDb2xvcn0gPSBvcHRzO1xuXG4gIGlmICghaXNOdWxsT3JVbmRlZihiYWNrZHJvcENvbG9yKSkge1xuICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0cy5ib3JkZXJSYWRpdXMpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xuXG4gICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xuICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG5cbiAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICB4OiBiYWNrZHJvcExlZnQsXG4gICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICBoOiBiYWNrZHJvcEhlaWdodCxcbiAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICB9KTtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5maWxsUmVjdChiYWNrZHJvcExlZnQsIGJhY2tkcm9wVG9wLCBiYWNrZHJvcFdpZHRoLCBiYWNrZHJvcEhlaWdodCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuXG4gIGZvciAobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBpdGVtID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICBpZiAoIWl0ZW0udmlzaWJsZSkge1xuICAgICAgLy8gb3ZlcmxhcHBpbmdcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIGRyYXdQb2ludExhYmVsQm94KGN0eCwgb3B0c0F0SW5kZXgsIGl0ZW0pO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICBjb25zdCB7eCwgeSwgdGV4dEFsaWdufSA9IGl0ZW07XG5cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgY29uc3Qge2N0eH0gPSBzY2FsZTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgLy8gRHJhdyBjaXJjdWxhciBhcmNzIGJldHdlZW4gdGhlIHBvaW50c1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIC8vIERyYXcgc3RyYWlnaHQgbGluZXMgY29ubmVjdGluZyBlYWNoIGluZGV4XG4gICAgbGV0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKDAsIHJhZGl1cyk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQsIGJvcmRlck9wdHMpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcblxuICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBncmlkTGluZU9wdHM7XG5cbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGJvcmRlck9wdHMuZGFzaCB8fCBbXSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlck9wdHMuZGFzaE9mZnNldDtcblxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuXG4gIHN0YXRpYyBpZCA9ICdyYWRpYWxMaW5lYXInO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAvLyBCb29sZWFuIC0gV2hldGhlciB0byBhbmltYXRlIHNjYWxpbmcgdGhlIGNoYXJ0IGZyb20gdGhlIGNlbnRyZVxuICAgIGFuaW1hdGU6IHRydWUsXG4gICAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuXG4gICAgYW5nbGVMaW5lczoge1xuICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIGJvcmRlckRhc2g6IFtdLFxuICAgICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gICAgfSxcblxuICAgIGdyaWQ6IHtcbiAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgIH0sXG5cbiAgICBzdGFydEFuZ2xlOiAwLFxuXG4gICAgLy8gbGFiZWwgc2V0dGluZ3NcbiAgICB0aWNrczoge1xuICAgICAgLy8gQm9vbGVhbiAtIFNob3cgYSBiYWNrZHJvcCB0byB0aGUgc2NhbGUgbGFiZWxcbiAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuXG4gICAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gICAgfSxcblxuICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICBiYWNrZHJvcENvbG9yOiB1bmRlZmluZWQsXG5cbiAgICAgIC8vIE51bWJlciAtIFRoZSBiYWNrZHJvcCBwYWRkaW5nIGFib3ZlICYgYmVsb3cgdGhlIGxhYmVsIGluIHBpeGVsc1xuICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuXG4gICAgICAvLyBCb29sZWFuIC0gaWYgdHJ1ZSwgc2hvdyBwb2ludCBsYWJlbHNcbiAgICAgIGRpc3BsYXk6IHRydWUsXG5cbiAgICAgIC8vIE51bWJlciAtIFBvaW50IGxhYmVsIGZvbnQgc2l6ZSBpbiBwaXhlbHNcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgc2l6ZTogMTBcbiAgICAgIH0sXG5cbiAgICAgIC8vIEZ1bmN0aW9uIC0gVXNlZCB0byBjb252ZXJ0IHBvaW50IGxhYmVsc1xuICAgICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgfSxcblxuICAgICAgLy8gTnVtYmVyIC0gQWRkaXRpb25sIHBhZGRpbmcgYmV0d2VlbiBzY2FsZSBhbmQgcG9pbnRMYWJlbFxuICAgICAgcGFkZGluZzogNSxcblxuICAgICAgLy8gQm9vbGVhbiAtIGlmIHRydWUsIGNlbnRlciBwb2ludCBsYWJlbHMgdG8gc2xpY2VzIGluIHBvbGFyIGNoYXJ0XG4gICAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgJ2FuZ2xlTGluZXMuY29sb3InOiAnYm9yZGVyQ29sb3InLFxuICAgICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xuICB9O1xuXG4gIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICBhbmdsZUxpbmVzOiB7XG4gICAgICBfZmFsbGJhY2s6ICdncmlkJ1xuICAgIH1cbiAgfTtcblxuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgLy8gU2V0IHRoZSB1bmNvbnN0cmFpbmVkIGRpbWVuc2lvbiBiZWZvcmUgbGFiZWwgcm90YXRpb25cbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuXG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcblxuICAgIHRoaXMubWluID0gaXNGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogMDtcblxuICAgIC8vIENvbW1vbiBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGhhbmRsZSBtaW4sIG1heCwgYmVnaW5BdFplcm9cbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG51bWJlciBvZiB0aWNrcyBiYXNlZCBvbiB0aGUgc2NhbGUgZGltZW5zaW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG5cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG5cbiAgICAvLyBQb2ludCBsYWJlbHNcbiAgICB0aGlzLl9wb2ludExhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKClcbiAgICAgIC5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGNhbGxDYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuXG4gIGZpdCgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuXG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cblxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cblxuICBnZXRJbmRleEFuZ2xlKGluZGV4KSB7XG4gICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gdGhpcy5vcHRpb25zLnN0YXJ0QW5nbGUgfHwgMDtcblxuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG5cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaGFsZiBmb250IHNpemUgKyB0aGUgeVBhZGRpbmcgb2YgdGhlIHRvcCB2YWx1ZVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG5cbiAgZ2V0VmFsdWVGb3JEaXN0YW5jZUZyb21DZW50ZXIoZGlzdGFuY2UpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihkaXN0YW5jZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcblxuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgcG9pbnRMYWJlbHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwb2ludExhYmVsID0gcG9pbnRMYWJlbHNbaW5kZXhdO1xuICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgcG9pbnRMYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuXG4gIGdldEJhc2VQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCB8fCAwLCB0aGlzLmdldEJhc2VWYWx1ZSgpKTtcbiAgfVxuXG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkLCBib3JkZXJ9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuXG4gICAgbGV0IGksIG9mZnNldCwgcG9zaXRpb247XG5cbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuXG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDAgfHwgKGluZGV4ID09PSAwICYmIHRoaXMubWluIDwgMCkpIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmdldENvbnRleHQoaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG5cbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50LCBvcHRzQXRJbmRleEJvcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGZvciAoaSA9IGxhYmVsQ291bnQgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGFuZ2xlTGluZXMuc2V0Q29udGV4dCh0aGlzLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICAgICAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gb3B0c0F0SW5kZXg7XG5cbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcblxuICAgICAgICBjdHguc2V0TGluZURhc2gob3B0c0F0SW5kZXguYm9yZGVyRGFzaCk7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG5cbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBkcmF3Qm9yZGVyKCkge31cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcblxuICAgIGlmICghdGlja09wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgIGlmICgoaW5kZXggPT09IDAgJiYgdGhpcy5taW4gPj0gMCkgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gdGlja09wdHMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLnRpY2tzW2luZGV4XS52YWx1ZSk7XG5cbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJUZXh0KGN0eCwgdGljay5sYWJlbCwgMCwgLW9mZnNldCwgdGlja0ZvbnQsIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICBzdHJva2VDb2xvcjogb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogb3B0c0F0SW5kZXgudGV4dFN0cm9rZVdpZHRoLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGRyYXdUaXRsZSgpIHt9XG59XG4iLCAiaW1wb3J0IGFkYXB0ZXJzIGZyb20gJy4uL2NvcmUvY29yZS5hZGFwdGVycy5qcyc7XG5pbXBvcnQge2NhbGxiYWNrIGFzIGNhbGwsIGlzRmluaXRlLCBpc051bGxPclVuZGVmLCBtZXJnZUlmLCB2YWx1ZU9yRGVmYXVsdH0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLmNvcmUuanMnO1xuaW1wb3J0IHt0b1JhZGlhbnMsIGlzTnVtYmVyLCBfbGltaXRWYWx1ZX0gZnJvbSAnLi4vaGVscGVycy9oZWxwZXJzLm1hdGguanMnO1xuaW1wb3J0IFNjYWxlIGZyb20gJy4uL2NvcmUvY29yZS5zY2FsZS5qcyc7XG5pbXBvcnQge19hcnJheVVuaXF1ZSwgX2ZpbHRlckJldHdlZW4sIF9sb29rdXB9IGZyb20gJy4uL2hlbHBlcnMvaGVscGVycy5jb2xsZWN0aW9uLmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuVGltZVVuaXQgfSBVbml0XG4gKiBAdHlwZWRlZiB7e2NvbW1vbjogYm9vbGVhbiwgc2l6ZTogbnVtYmVyLCBzdGVwcz86IG51bWJlcn19IEludGVydmFsXG4gKiBAdHlwZWRlZiB7IGltcG9ydCgnLi4vY29yZS9jb3JlLmFkYXB0ZXJzLmpzJykuRGF0ZUFkYXB0ZXIgfSBEYXRlQWRhcHRlclxuICovXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxVbml0LCBJbnRlcnZhbD59XG4gKi9cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5cbi8qKlxuICogQHR5cGUge1VuaXRbXX1cbiAqL1xuY29uc3QgVU5JVFMgPSAvKiogQHR5cGUgVW5pdFtdICovIC8qICNfX1BVUkVfXyAqLyAoT2JqZWN0LmtleXMoSU5URVJWQUxTKSk7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKi9cbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RpbWVTY2FsZX0gc2NhbGVcbiAqIEBwYXJhbSB7Kn0gaW5wdXRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCB7cGFyc2VyLCByb3VuZCwgaXNvV2Vla2RheX0gPSBzY2FsZS5fcGFyc2VPcHRzO1xuICBsZXQgdmFsdWUgPSBpbnB1dDtcblxuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE9ubHkgcGFyc2UgaWYgaXQncyBub3QgYSB0aW1lc3RhbXAgYWxyZWFkeVxuICBpZiAoIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgcGFyc2VyKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJvdW5kKSB7XG4gICAgdmFsdWUgPSByb3VuZCA9PT0gJ3dlZWsnICYmIChpc051bWJlcihpc29XZWVrZGF5KSB8fCBpc29XZWVrZGF5ID09PSB0cnVlKVxuICAgICAgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSlcbiAgICAgIDogYWRhcHRlci5zdGFydE9mKHZhbHVlLCByb3VuZCk7XG4gIH1cblxuICByZXR1cm4gK3ZhbHVlO1xufVxuXG4vKipcbiAqIEZpZ3VyZXMgb3V0IHdoYXQgdW5pdCByZXN1bHRzIGluIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhdXRvLWdlbmVyYXRlZCB0aWNrc1xuICogQHBhcmFtIHtVbml0fSBtaW5Vbml0XG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKiBAcGFyYW0ge251bWJlcn0gY2FwYWNpdHlcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcblxuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuXG4gICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGF0IHVuaXQgdG8gZm9ybWF0IGEgc2V0IG9mIHRpY2tzIHdpdGhcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bVRpY2tzXG4gKiBAcGFyYW0ge1VuaXR9IG1pblVuaXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtaW5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm4ge1VuaXR9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5cbi8qKlxuICogQHBhcmFtIHtVbml0fSB1bml0XG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZU1ham9yVW5pdCh1bml0KSB7XG4gIGZvciAobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSB0aWNrc1xuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyW119IFt0aW1lc3RhbXBzXSAtIGlmIGRlZmluZWQsIHNuYXAgdG8gdGhlc2UgdGltZXN0YW1wc1xuICovXG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtvYmplY3RbXX0gdGlja3NcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBcbiAqIEBwYXJhbSB7VW5pdH0gbWFqb3JVbml0XG4gKiBAcmV0dXJuIHtvYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG5cbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VGltZVNjYWxlfSBzY2FsZVxuICogQHBhcmFtIHtudW1iZXJbXX0gdmFsdWVzXG4gKiBAcGFyYW0ge1VuaXR8dW5kZWZpbmVkfSBbbWFqb3JVbml0XVxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIC8qKiBAdHlwZSB7T2JqZWN0PG51bWJlcixvYmplY3Q+fSAqL1xuICBjb25zdCBtYXAgPSB7fTtcbiAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCBpLCB2YWx1ZTtcblxuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG5cbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICAvLyBXZSBzZXQgdGhlIG1ham9yIHRpY2tzIHNlcGFyYXRlbHkgZnJvbSB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIGNhbGxpbmcgc3RhcnRPZiBmb3IgZXZlcnkgdGlja1xuICAvLyBpcyBleHBlbnNpdmUgd2hlbiB0aGVyZSBpcyBhIGxhcmdlIG51bWJlciBvZiB0aWNrc1xuICByZXR1cm4gKGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCkgPyB0aWNrcyA6IHNldE1ham9yVGlja3Moc2NhbGUsIHRpY2tzLCBtYXAsIG1ham9yVW5pdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcblxuICBzdGF0aWMgaWQgPSAndGltZSc7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogU2NhbGUgYm91bmRhcnkgc3RyYXRlZ3kgKGJ5cGFzc2VkIGJ5IG1pbi9tYXggdGltZSBvcHRpb25zKVxuICAgICAqIC0gYGRhdGFgOiBtYWtlIHN1cmUgZGF0YSBhcmUgZnVsbHkgdmlzaWJsZSwgdGlja3Mgb3V0c2lkZSBhcmUgcmVtb3ZlZFxuICAgICAqIC0gYHRpY2tzYDogbWFrZSBzdXJlIHRpY2tzIGFyZSBmdWxseSB2aXNpYmxlLCBkYXRhIG91dHNpZGUgYXJlIHRydW5jYXRlZFxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvcHVsbC80NTU2XG4gICAgICogQHNpbmNlIDIuNy4wXG4gICAgICovXG4gICAgYm91bmRzOiAnZGF0YScsXG5cbiAgICBhZGFwdGVyczoge30sXG4gICAgdGltZToge1xuICAgICAgcGFyc2VyOiBmYWxzZSwgLy8gZmFsc2UgPT0gYSBwYXR0ZXJuIHN0cmluZyBmcm9tIG9yIGEgY3VzdG9tIGNhbGxiYWNrIHRoYXQgY29udmVydHMgaXRzIGFyZ3VtZW50IHRvIGEgdGltZXN0YW1wXG4gICAgICB1bml0OiBmYWxzZSwgLy8gZmFsc2UgPT0gYXV0b21hdGljIG9yIG92ZXJyaWRlIHdpdGggd2VlaywgbW9udGgsIHllYXIsIGV0Yy5cbiAgICAgIHJvdW5kOiBmYWxzZSwgLy8gbm9uZSwgb3Igb3ZlcnJpZGUgd2l0aCB3ZWVrLCBtb250aCwgeWVhciwgZXRjLlxuICAgICAgaXNvV2Vla2RheTogZmFsc2UsIC8vIG92ZXJyaWRlIHdlZWsgc3RhcnQgZGF5XG4gICAgICBtaW5Vbml0OiAnbWlsbGlzZWNvbmQnLFxuICAgICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gICAgfSxcbiAgICB0aWNrczoge1xuICAgICAgLyoqXG4gICAgICAgKiBUaWNrcyBnZW5lcmF0aW9uIGlucHV0IHZhbHVlczpcbiAgICAgICAqIC0gJ2F1dG8nOiBnZW5lcmF0ZXMgXCJvcHRpbWFsXCIgdGlja3MgYmFzZWQgb24gc2NhbGUgc2l6ZSBhbmQgdGltZSBvcHRpb25zLlxuICAgICAgICogLSAnZGF0YSc6IGdlbmVyYXRlcyB0aWNrcyBmcm9tIGRhdGEgKGluY2x1ZGluZyBsYWJlbHMgZnJvbSBkYXRhIHt0fHh8eX0gb2JqZWN0cykuXG4gICAgICAgKiAtICdsYWJlbHMnOiBnZW5lcmF0ZXMgdGlja3MgZnJvbSB1c2VyIGdpdmVuIGBkYXRhLmxhYmVsc2AgdmFsdWVzIE9OTFkuXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL3B1bGwvNDUwN1xuICAgICAgICogQHNpbmNlIDIuNy4wXG4gICAgICAgKi9cbiAgICAgIHNvdXJjZTogJ2F1dG8nLFxuXG4gICAgICBjYWxsYmFjazogZmFsc2UsXG5cbiAgICAgIG1ham9yOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcblx0ICovXG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLyoqIEB0eXBlIHt7ZGF0YTogbnVtYmVyW10sIGxhYmVsczogbnVtYmVyW10sIGFsbDogbnVtYmVyW119fSAqL1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG5cbiAgICAvKiogQHR5cGUge1VuaXR9ICovXG4gICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgIC8qKiBAdHlwZSB7VW5pdD19ICovXG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgLyoqIEB0eXBlIHtEYXRlQWRhcHRlcn0gKi9cbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG5cbiAgICBhZGFwdGVyLmluaXQob3B0cyk7XG5cbiAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5OiBiZWZvcmUgaW50cm9kdWNpbmcgYWRhcHRlciwgYGRpc3BsYXlGb3JtYXRzYCB3YXNcbiAgICAvLyBzdXBwb3NlZCB0byBjb250YWluICphbGwqIHVuaXQvc3RyaW5nIHBhaXJzIGJ1dCB0aGlzIGNhbid0IGJlIHJlc29sdmVkXG4gICAgLy8gd2hlbiBsb2FkaW5nIHRoZSBzY2FsZSAoYWRhcHRlcnMgYXJlIGxvYWRlZCBhZnRlcndhcmQpLCBzbyBsZXQncyBwb3B1bGF0ZVxuICAgIC8vIG1pc3NpbmcgZm9ybWF0cyBvbiB1cGRhdGVcbiAgICBtZXJnZUlmKHRpbWUuZGlzcGxheUZvcm1hdHMsIGFkYXB0ZXIuZm9ybWF0cygpKTtcblxuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgIH07XG5cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG5cbiAgICB0aGlzLl9ub3JtYWxpemVkID0gb3B0cy5ub3JtYWxpemVkO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7Kn0gcmF3XG5cdCAqIEBwYXJhbSB7bnVtYmVyP30gW2luZGV4XVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBwYXJzZShyYXcsIGluZGV4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICBpZiAocmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgfVxuXG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG5cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcblxuICAgIC8qKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZHNcblx0XHQgKi9cbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSB1c2VyIHByb3ZpZGVkIGBtaW5gIGFuZCBgbWF4YCBsYWJlbHMgLyBkYXRhIGJvdW5kcyBjYW4gYmUgaWdub3JlZFxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgLy8gTGFiZWxzIGFyZSBhbHdheXMgY29uc2lkZXJlZCwgd2hlbiB1c2VyIGRpZCBub3QgZm9yY2UgYm91bmRzXG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG5cbiAgICAgIC8vIElmIGBib3VuZHNgIGlzIGAndGlja3MnYCBhbmQgYHRpY2tzLnNvdXJjZWAgaXMgYCdsYWJlbHMnYCxcbiAgICAgIC8vIGRhdGEgYm91bmRzIGFyZSBpZ25vcmVkIChhbmQgZG9uJ3QgbmVlZCB0byBiZSBkZXRlcm1pbmVkKVxuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtaW4gPSBpc0Zpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc0Zpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgbWF4IGlzIHN0cmljdGx5IGhpZ2hlciB0aGFuIG1pbiAocmVxdWlyZWQgYnkgdGhlIHRpbWVzZXJpZXMgbG9va3VwIHRhYmxlKVxuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cblxuICAvKipcblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcblxuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcmV0dXJuIHtvYmplY3RbXX1cblx0ICovXG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2xhYmVscycgPyB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpIDogdGhpcy5fZ2VuZXJhdGUoKTtcblxuICAgIGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cblxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuXG4gICAgY29uc3QgdGlja3MgPSBfZmlsdGVyQmV0d2Vlbih0aW1lc3RhbXBzLCBtaW4sIG1heCk7XG5cbiAgICAvLyBQUklWQVRFXG4gICAgLy8gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcgcmVsaWVzIG9uIHRoZSBudW1iZXIgb2YgdGlja3Mgc28gd2UgZG9uJ3QgdXNlIGl0IHdoZW5cbiAgICAvLyBhdXRvU2tpcCBpcyBlbmFibGVkIGJlY2F1c2Ugd2UgZG9uJ3QgeWV0IGtub3cgd2hhdCB0aGUgZmluYWwgbnVtYmVyIG9mIHRpY2tzIHdpbGwgYmVcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcodGhpcywgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcbiAgICAgIDogZGV0ZXJtaW5lTWFqb3JVbml0KHRoaXMuX3VuaXQpO1xuICAgIHRoaXMuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG5cbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgdGlja3MsIHRoaXMuX21ham9yVW5pdCk7XG4gIH1cblxuICBhZnRlckF1dG9Ta2lwKCkge1xuICAgIC8vIE9mZnNldHMgZm9yIGJhciBjaGFydHMgbmVlZCB0byBiZSBoYW5kbGVkIHdpdGggdGhlIGF1dG8gc2tpcHBlZFxuICAgIC8vIHRpY2tzLiBPbmNlIHRpY2tzIGhhdmUgYmVlbiBza2lwcGVkLCB3ZSByZS1jb21wdXRlIHRoZSBvZmZzZXRzLlxuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xuICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCh0aWNrID0+ICt0aWNrLnZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBmcm9tIGVkZ2VzIGluIHRoZSBmb3JtIG9mIHtzdGFydCwgZW5kfVxuXHQgKiB3aGVyZSBlYWNoIHZhbHVlIGlzIGEgcmVsYXRpdmUgd2lkdGggdG8gdGhlIHNjYWxlIGFuZCByYW5nZXMgYmV0d2VlbiAwIGFuZCAxLlxuXHQgKiBUaGV5IGFkZCBleHRyYSBtYXJnaW5zIG9uIHRoZSBib3RoIHNpZGVzIGJ5IHNjYWxpbmcgZG93biB0aGUgb3JpZ2luYWwgc2NhbGUuXG5cdCAqIE9mZnNldHMgYXJlIGFkZGVkIHdoZW4gdGhlIGBvZmZzZXRgIG9wdGlvbiBpcyB0cnVlLlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB0aW1lc3RhbXBzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMgPSBbXSkge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIGZpcnN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1swXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RhcnQgPSAxIC0gZmlyc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICB9XG4gICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBlbmQgPSBsYXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kID0gKGxhc3QgLSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMl0pKSAvIDI7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBsaW1pdCk7XG4gICAgZW5kID0gX2xpbWl0VmFsdWUoZW5kLCAwLCBsaW1pdCk7XG5cbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBtYXhpbXVtIG9mIGBjYXBhY2l0eWAgdGltZXN0YW1wcyBiZXR3ZWVuIG1pbiBhbmQgbWF4LCByb3VuZGVkIHRvIHRoZVxuXHQgKiBgbWlub3JgIHVuaXQgdXNpbmcgdGhlIGdpdmVuIHNjYWxlIHRpbWUgYG9wdGlvbnNgLlxuXHQgKiBJbXBvcnRhbnQ6IHRoaXMgbWV0aG9kIGNhbiByZXR1cm4gdGlja3Mgb3V0c2lkZSB0aGUgbWluIGFuZCBtYXggcmFuZ2UsIGl0J3MgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgX2dlbmVyYXRlKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5zdGVwU2l6ZSwgMSk7XG4gICAgY29uc3Qgd2Vla2RheSA9IG1pbm9yID09PSAnd2VlaycgPyB0aW1lT3B0cy5pc29XZWVrZGF5IDogZmFsc2U7XG4gICAgY29uc3QgaGFzV2Vla2RheSA9IGlzTnVtYmVyKHdlZWtkYXkpIHx8IHdlZWtkYXkgPT09IHRydWU7XG4gICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICBsZXQgZmlyc3QgPSBtaW47XG4gICAgbGV0IHRpbWUsIGNvdW50O1xuXG4gICAgLy8gRm9yICd3ZWVrJyB1bml0LCBoYW5kbGUgdGhlIGZpcnN0IGRheSBvZiB3ZWVrIG9wdGlvblxuICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgfVxuXG4gICAgLy8gQWxpZ24gZmlyc3QgdGlja3Mgb24gdW5pdFxuICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgaGFzV2Vla2RheSA/ICdkYXknIDogbWlub3IpO1xuXG4gICAgLy8gUHJldmVudCBicm93c2VyIGZyb20gZnJlZXppbmcgaW4gY2FzZSB1c2VyIG9wdGlvbnMgcmVxdWVzdCBtaWxsaW9ucyBvZiBtaWxsaXNlY29uZHNcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSBvcHRpb25zLnRpY2tzLnNvdXJjZSA9PT0gJ2RhdGEnICYmIHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBmb3IgKHRpbWUgPSBmaXJzdCwgY291bnQgPSAwOyB0aW1lIDwgbWF4OyB0aW1lID0gK2FkYXB0ZXIuYWRkKHRpbWUsIHN0ZXBTaXplLCBtaW5vciksIGNvdW50KyspIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoc29ydGVyKS5tYXAoeCA9PiAreCk7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICovXG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuXG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGZvcm1hdFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9XG5cdCAqL1xuICBmb3JtYXQodmFsdWUsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBmbXQgPSBmb3JtYXQgfHwgZm9ybWF0c1t1bml0XTtcbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodmFsdWUsIGZtdCk7XG4gIH1cblxuICAvKipcblx0ICogRnVuY3Rpb24gdG8gZm9ybWF0IGFuIGluZGl2aWR1YWwgdGljayBtYXJrXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IFtmb3JtYXRdXG5cdCAqIEByZXR1cm4ge3N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHRlciA9IG9wdGlvbnMudGlja3MuY2FsbGJhY2s7XG5cbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gY2FsbChmb3JtYXR0ZXIsIFt0aW1lLCBpbmRleCwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgIGNvbnN0IHVuaXQgPSB0aGlzLl91bml0O1xuICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICBjb25zdCBtaW5vckZvcm1hdCA9IHVuaXQgJiYgZm9ybWF0c1t1bml0XTtcbiAgICBjb25zdCBtYWpvckZvcm1hdCA9IG1ham9yVW5pdCAmJiBmb3JtYXRzW21ham9yVW5pdF07XG4gICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICBjb25zdCBtYWpvciA9IG1ham9yVW5pdCAmJiBtYWpvckZvcm1hdCAmJiB0aWNrICYmIHRpY2subWFqb3I7XG5cbiAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdFtdfSB0aWNrc1xuXHQgKi9cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gTWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqL1xuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG5cdCAqIEByZXR1cm4ge3t3Om51bWJlciwgaDpudW1iZXJ9fVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdzogKHRpY2tMYWJlbFdpZHRoICogY29zUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uKSxcbiAgICAgIGg6ICh0aWNrTGFiZWxXaWR0aCAqIHNpblJvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBjb3NSb3RhdGlvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBleGFtcGxlVGltZVxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcblxuICAgIC8vIHBpY2sgdGhlIGxvbmdlc3QgZm9ybWF0IChtaWxsaXNlY29uZHMpIGZvciBndWVzc3RpbWF0aW9uXG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIC8vIHN1YnRyYWN0IDEgLSBpZiBvZmZzZXQgdGhlbiB0aGVyZSdzIG9uZSBsZXNzIGxhYmVsIHRoYW4gdGlja1xuICAgIC8vIGlmIG5vdCBvZmZzZXQgdGhlbiBvbmUgaGFsZiBsYWJlbCBwYWRkaW5nIGlzIGFkZGVkIHRvIGVhY2ggZW5kIGxlYXZpbmcgcm9vbSBmb3Igb25lIGxlc3MgbGFiZWxcbiAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgIHJldHVybiBjYXBhY2l0eSA+IDAgPyBjYXBhY2l0eSA6IDE7XG4gIH1cblxuICAvKipcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgZ2V0RGF0YVRpbWVzdGFtcHMoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcblxuICAgIGlmICh0aGlzLl9ub3JtYWxpemVkICYmIG1ldGFzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gbWV0YXNbMF0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG5cbiAgLyoqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuXG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG5cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZXNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIC8vIEl0IHNlZW1zIHRvIGJlIHNvbWV3aGF0IGZhc3RlciB0byBkbyBzb3J0aW5nIGZpcnN0XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuIiwgImltcG9ydCBUaW1lU2NhbGUgZnJvbSAnLi9zY2FsZS50aW1lLmpzJztcbmltcG9ydCB7X2xvb2t1cEJ5S2V5fSBmcm9tICcuLi9oZWxwZXJzL2hlbHBlcnMuY29sbGVjdGlvbi5qcyc7XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIHRoZSBnaXZlbiBzb3VyY2UgYHZhbGAgdXNpbmcgdGhlIHRhYmxlLiBJZiB2YWx1ZSBpcyBvdXQgb2YgYm91bmRzLCB2YWx1ZXNcbiAqIGF0IGVkZ2VzIGFyZSB1c2VkIGZvciB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbFxuICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gbG9va3VwIHRpbWUgYmFzZWQgb24gcG9zaXRpb24gaW5zdGVhZCBvZiB2aWNlIHZlcnNhXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuXG4gIGNvbnN0IHNwYW4gPSBuZXh0U291cmNlIC0gcHJldlNvdXJjZTtcbiAgcmV0dXJuIHNwYW4gPyBwcmV2VGFyZ2V0ICsgKG5leHRUYXJnZXQgLSBwcmV2VGFyZ2V0KSAqICh2YWwgLSBwcmV2U291cmNlKSAvIHNwYW4gOiBwcmV2VGFyZ2V0O1xufVxuXG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuXG4gIHN0YXRpYyBpZCA9ICd0aW1lc2VyaWVzJztcblxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIHN0YXRpYyBkZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxuICAvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG5cdCAqL1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIC8qKiBAdHlwZSB7b2JqZWN0W119ICovXG4gICAgdGhpcy5fdGFibGUgPSBbXTtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuICBpbml0T2Zmc2V0cygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fZ2V0VGltZXN0YW1wc0ZvclRhYmxlKCk7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLl90YWJsZSA9IHRoaXMuYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKTtcbiAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5tYXgpIC0gdGhpcy5fbWluUG9zO1xuICAgIHN1cGVyLmluaXRPZmZzZXRzKHRpbWVzdGFtcHMpO1xuICB9XG5cbiAgLyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2Yge3RpbWUsIHBvc30gb2JqZWN0cyB1c2VkIHRvIGludGVycG9sYXRlIGEgc3BlY2lmaWMgYHRpbWVgIG9yIHBvc2l0aW9uXG5cdCAqIChgcG9zYCkgb24gdGhlIHNjYWxlLCBieSBzZWFyY2hpbmcgZW50cmllcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSByZXF1ZXN0ZWQgdmFsdWUuIGBwb3NgIGlzXG5cdCAqIGEgZGVjaW1hbCBiZXR3ZWVuIDAgYW5kIDE6IDAgYmVpbmcgdGhlIHN0YXJ0IG9mIHRoZSBzY2FsZSAobGVmdCBvciB0b3ApIGFuZCAxIHRoZSBvdGhlclxuXHQgKiBleHRyZW1pdHkgKGxlZnQgKyB3aWR0aCBvciB0b3AgKyBoZWlnaHQpLiBOb3RlIHRoYXQgaXQgd291bGQgYmUgbW9yZSBvcHRpbWl6ZWQgdG8gZGlyZWN0bHlcblx0ICogc3RvcmUgcHJlLWNvbXB1dGVkIHBpeGVscywgYnV0IHRoZSBzY2FsZSBkaW1lbnNpb25zIGFyZSBub3QgZ3VhcmFudGVlZCBhdCB0aGUgdGltZSB3ZSBuZWVkXG5cdCAqIHRvIGNyZWF0ZSB0aGUgbG9va3VwIHRhYmxlLiBUaGUgdGFibGUgQUxXQVlTIGNvbnRhaW5zIGF0IGxlYXN0IHR3byBpdGVtczogbWluIGFuZCBtYXguXG5cdCAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWVzdGFtcHNcblx0ICogQHJldHVybiB7b2JqZWN0W119XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG4gIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgdGFibGUgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgcHJldiwgY3VyciwgbmV4dDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgLy8gSW4gY2FzZSB0aGVyZSBpcyBsZXNzIHRoYXQgMiB0aW1lc3RhbXBzIGJldHdlZW4gbWluIGFuZCBtYXgsIHRoZSBzY2FsZSBpcyBkZWZpbmVkIGJ5IG1pbiBhbmQgbWF4XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7dGltZTogbWluLCBwb3M6IDB9LFxuICAgICAgICB7dGltZTogbWF4LCBwb3M6IDF9XG4gICAgICBdO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuXG4gICAgICAvLyBvbmx5IGFkZCBwb2ludHMgdGhhdCBicmVha3MgdGhlIHNjYWxlIGxpbmVhcml0eVxuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG5cbiAgLyoqXG4gICAgKiBHZW5lcmF0ZXMgYWxsIHRpbWVzdGFtcHMgZGVmaW5lZCBpbiB0aGUgZGF0YS5cbiAgICAqIEltcG9ydGFudDogdGhpcyBtZXRob2QgY2FuIHJldHVybiB0aWNrcyBvdXRzaWRlIHRoZSBtaW4gYW5kIG1heCByYW5nZSwgaXQncyB0aGVcbiAgICAqIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsaW5nIGNvZGUgdG8gY2xhbXAgdmFsdWVzIGlmIG5lZWRlZC5cbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqL1xuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSBzdXBlci5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtaW4pIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcy5zcGxpY2UoMCwgMCwgbWluKTtcbiAgICB9XG4gICAgaWYgKCF0aW1lc3RhbXBzLmluY2x1ZGVzKG1heCkgfHwgdGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIH1cblxuICAvKipcblx0ICogUmV0dXJucyBhbGwgdGltZXN0YW1wc1xuXHQgKiBAcmV0dXJuIHtudW1iZXJbXX1cblx0ICogQHByaXZhdGVcblx0ICovXG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG5cbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAmJiBsYWJlbC5sZW5ndGgpIHtcbiAgICAgIC8vIElmIGNvbWJpbmluZyBsYWJlbHMgYW5kIGRhdGEgKGRhdGEgbWlnaHQgbm90IGNvbnRhaW4gYWxsIGxhYmVscyksXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJlY2hlY2sgdW5pcXVlbmVzcyBhbmQgc29ydFxuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG5cbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuXG4gIC8qKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBNaWxsaXNlY29uZHMgc2luY2UgZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQylcblx0ICogQHJldHVybiB7bnVtYmVyfVxuXHQgKi9cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cblxuICAvKipcblx0ICogQHBhcmFtIHtudW1iZXJ9IHBpeGVsXG5cdCAqIEByZXR1cm4ge251bWJlcn1cblx0ICovXG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUodGhpcy5fdGFibGUsIGRlY2ltYWwgKiB0aGlzLl90YWJsZVJhbmdlICsgdGhpcy5fbWluUG9zLCB0cnVlKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBUaW1lU2VyaWVzU2NhbGU7XG4iLCAiZXhwb3J0ICogZnJvbSAnLi9jb250cm9sbGVycy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvcmUvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BsYXRmb3JtL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3NjYWxlcy9pbmRleC5qcyc7XG5cbmltcG9ydCAqIGFzIGNvbnRyb2xsZXJzIGZyb20gJy4vY29udHJvbGxlcnMvaW5kZXguanMnO1xuaW1wb3J0ICogYXMgZWxlbWVudHMgZnJvbSAnLi9lbGVtZW50cy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBwbHVnaW5zIGZyb20gJy4vcGx1Z2lucy9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBzY2FsZXMgZnJvbSAnLi9zY2FsZXMvaW5kZXguanMnO1xuXG5leHBvcnQge1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG4iLCAiaW1wb3J0IHsgTm90aWNlLCBURmlsZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBBSU1DUFBsdWdpbiBmcm9tICcuLi9tYWluJztcblxuLy8gTm90ZTogVXNpbmcgZmV0Y2ggQVBJIGZvciBlbWFpbCBzZW5kaW5nIGluc3RlYWQgb2Ygbm9kZW1haWxlciBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1haWxDb25maWcge1xuICBzbXRwSG9zdDogc3RyaW5nO1xuICBzbXRwUG9ydDogbnVtYmVyO1xuICBzZWN1cmU6IGJvb2xlYW47XG4gIHVzZXJuYW1lOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIGZyb21FbWFpbDogc3RyaW5nO1xuICBmcm9tTmFtZTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVtYWlsVGVtcGxhdGUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHN1YmplY3Q6IHN0cmluZztcbiAgaHRtbFRlbXBsYXRlOiBzdHJpbmc7XG4gIHRleHRUZW1wbGF0ZTogc3RyaW5nO1xuICB2YXJpYWJsZXM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGlmaWNhdGlvblJ1bGUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVuYWJsZWQ6IGJvb2xlYW47XG4gIHRyaWdnZXI6ICdmaWxlX2NyZWF0ZWQnIHwgJ2ZpbGVfbW9kaWZpZWQnIHwgJ3RhZ19hZGRlZCcgfCAnZGFpbHlfc3VtbWFyeScgfCAnd2Vla2x5X3JlcG9ydCcgfCAnYWlfaW5zaWdodCc7XG4gIGNvbmRpdGlvbnM6IHtcbiAgICBmaWxlUGF0dGVybj86IHN0cmluZztcbiAgICB0YWdQYXR0ZXJuPzogc3RyaW5nO1xuICAgIHRpbWVTY2hlZHVsZT86IHN0cmluZzsgLy8gY3JvbiBmb3JtYXRcbiAgICB0aHJlc2hvbGQ/OiBudW1iZXI7XG4gIH07XG4gIHJlY2lwaWVudHM6IHN0cmluZ1tdO1xuICB0ZW1wbGF0ZUlkOiBzdHJpbmc7XG4gIGxhc3RUcmlnZ2VyZWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW1haWxBdHRhY2htZW50IHtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgY29udGVudDogQnVmZmVyIHwgc3RyaW5nO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBlbmNvZGluZz86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIEVtYWlsU2VydmljZSB7XG4gIHByaXZhdGUgY29uZmlnOiBFbWFpbENvbmZpZyB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzQ29uZmlndXJlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGx1Z2luOiBBSU1DUFBsdWdpbikge31cblxuICBhc3luYyBjb25maWd1cmUoY29uZmlnOiBFbWFpbENvbmZpZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgIFxuICAgICAgLy8gVGVzdCB0aGUgY29ubmVjdGlvbiBieSBhdHRlbXB0aW5nIHRvIHNlbmQgYSB0ZXN0IGVtYWlsXG4gICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gYXdhaXQgdGhpcy50ZXN0Q29ubmVjdGlvbigpO1xuICAgICAgXG4gICAgICBpZiAodGVzdFJlc3VsdCkge1xuICAgICAgICB0aGlzLmlzQ29uZmlndXJlZCA9IHRydWU7XG4gICAgICAgIG5ldyBOb3RpY2UoJ0VtYWlsIHNlcnZpY2UgY29uZmlndXJlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gdGVzdCBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRW1haWwgY29uZmlndXJhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgbmV3IE5vdGljZShgRW1haWwgY29uZmlndXJhdGlvbiBmYWlsZWQ6ICR7KGVycm9yIGFzIEVycm9yKS5tZXNzYWdlfWApO1xuICAgICAgdGhpcy5pc0NvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzZW5kRW1haWwoXG4gICAgdG86IHN0cmluZyB8IHN0cmluZ1tdLFxuICAgIHN1YmplY3Q6IHN0cmluZyxcbiAgICBodG1sQ29udGVudDogc3RyaW5nLFxuICAgIHRleHRDb250ZW50Pzogc3RyaW5nLFxuICAgIGF0dGFjaG1lbnRzPzogRW1haWxBdHRhY2htZW50W11cbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgaWYgKCF0aGlzLmlzQ29uZmlndXJlZCB8fCAhdGhpcy5jb25maWcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW1haWwgc2VydmljZSBub3QgY29uZmlndXJlZCcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZWNpcGllbnRzID0gQXJyYXkuaXNBcnJheSh0bykgPyB0byA6IFt0b107XG4gICAgICBcbiAgICAgIC8vIFVzZSBhIHdlYi1iYXNlZCBlbWFpbCBzZXJ2aWNlIEFQSSAobGlrZSBFbWFpbEpTLCBTZW5kR3JpZCwgZXRjLilcbiAgICAgIC8vIEZvciBkZW1vIHB1cnBvc2VzLCB3ZSdsbCBzaW11bGF0ZSBlbWFpbCBzZW5kaW5nXG4gICAgICBjb25zb2xlLmxvZygnU2ltdWxhdGluZyBlbWFpbCBzZW5kOicsIHtcbiAgICAgICAgZnJvbTogYFwiJHt0aGlzLmNvbmZpZy5mcm9tTmFtZX1cIiA8JHt0aGlzLmNvbmZpZy5mcm9tRW1haWx9PmAsXG4gICAgICAgIHRvOiByZWNpcGllbnRzLmpvaW4oJywgJyksXG4gICAgICAgIHN1YmplY3QsXG4gICAgICAgIGh0bWw6IGh0bWxDb250ZW50LFxuICAgICAgICB0ZXh0OiB0ZXh0Q29udGVudCB8fCB0aGlzLmh0bWxUb1RleHQoaHRtbENvbnRlbnQpLFxuICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHM/Lmxlbmd0aCB8fCAwXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB5b3Ugd291bGQgdXNlIGEgc2VydmljZSBsaWtlOlxuICAgICAgLy8gLSBFbWFpbEpTIGZvciBjbGllbnQtc2lkZSBlbWFpbCBzZW5kaW5nXG4gICAgICAvLyAtIFNlbmRHcmlkIEFQSVxuICAgICAgLy8gLSBNYWlsZ3VuIEFQSVxuICAgICAgLy8gLSBZb3VyIG93biBlbWFpbCBzZXJ2aWNlIGVuZHBvaW50XG4gICAgICBcbiAgICAgIG5ldyBOb3RpY2UoYEVtYWlsIHNlbnQgdG8gJHtyZWNpcGllbnRzLmpvaW4oJywgJyl9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlbmQgZW1haWw6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2VuZFRlbXBsYXRlZEVtYWlsKFxuICAgIHRvOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgICB0ZW1wbGF0ZUlkOiBzdHJpbmcsXG4gICAgdmFyaWFibGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIGF0dGFjaG1lbnRzPzogRW1haWxBdHRhY2htZW50W11cbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLmdldFRlbXBsYXRlKHRlbXBsYXRlSWQpO1xuICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGVtcGxhdGUgJHt0ZW1wbGF0ZUlkfSBub3QgZm91bmRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5wcm9jZXNzVGVtcGxhdGUodGVtcGxhdGUuc3ViamVjdCwgdmFyaWFibGVzKTtcbiAgICBjb25zdCBodG1sQ29udGVudCA9IHRoaXMucHJvY2Vzc1RlbXBsYXRlKHRlbXBsYXRlLmh0bWxUZW1wbGF0ZSwgdmFyaWFibGVzKTtcbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IHRoaXMucHJvY2Vzc1RlbXBsYXRlKHRlbXBsYXRlLnRleHRUZW1wbGF0ZSwgdmFyaWFibGVzKTtcblxuICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmRFbWFpbCh0bywgc3ViamVjdCwgaHRtbENvbnRlbnQsIHRleHRDb250ZW50LCBhdHRhY2htZW50cyk7XG4gIH1cblxuICBwcml2YXRlIHByb2Nlc3NUZW1wbGF0ZSh0ZW1wbGF0ZTogc3RyaW5nLCB2YXJpYWJsZXM6IFJlY29yZDxzdHJpbmcsIGFueT4pOiBzdHJpbmcge1xuICAgIGxldCBwcm9jZXNzZWQgPSB0ZW1wbGF0ZTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh2YXJpYWJsZXMpKSB7XG4gICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYHt7XFxcXHMqJHtrZXl9XFxcXHMqfX1gLCAnZycpO1xuICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkLnJlcGxhY2UocmVnZXgsIFN0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gIH1cblxuICBwcml2YXRlIGh0bWxUb1RleHQoaHRtbDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBTaW1wbGUgSFRNTCB0byB0ZXh0IGNvbnZlcnNpb25cbiAgICByZXR1cm4gaHRtbFxuICAgICAgLnJlcGxhY2UoLzxiclxccypcXC8/Pi9naSwgJ1xcbicpXG4gICAgICAucmVwbGFjZSgvPFxcL3A+L2dpLCAnXFxuXFxuJylcbiAgICAgIC5yZXBsYWNlKC88W14+XSo+L2csICcnKVxuICAgICAgLnJlcGxhY2UoLyZuYnNwOy9nLCAnICcpXG4gICAgICAucmVwbGFjZSgvJmFtcDsvZywgJyYnKVxuICAgICAgLnJlcGxhY2UoLyZsdDsvZywgJzwnKVxuICAgICAgLnJlcGxhY2UoLyZndDsvZywgJz4nKVxuICAgICAgLnRyaW0oKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VGVtcGxhdGUodGVtcGxhdGVJZDogc3RyaW5nKTogRW1haWxUZW1wbGF0ZSB8IG51bGwge1xuICAgIGNvbnN0IHRlbXBsYXRlcyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLmVtYWlsVGVtcGxhdGVzIHx8IFtdO1xuICAgIHJldHVybiB0ZW1wbGF0ZXMuZmluZCh0ID0+IHQuaWQgPT09IHRlbXBsYXRlSWQpIHx8IG51bGw7XG4gIH1cblxuICBpc1JlYWR5KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmlzQ29uZmlndXJlZDtcbiAgfVxuXG4gIGFzeW5jIHRlc3RDb25uZWN0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICghdGhpcy5jb25maWcpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU2ltdWxhdGUgY29ubmVjdGlvbiB0ZXN0XG4gICAgICBjb25zb2xlLmxvZygnVGVzdGluZyBlbWFpbCBjb25maWd1cmF0aW9uOicsIHtcbiAgICAgICAgaG9zdDogdGhpcy5jb25maWcuc210cEhvc3QsXG4gICAgICAgIHBvcnQ6IHRoaXMuY29uZmlnLnNtdHBQb3J0LFxuICAgICAgICB1c2VybmFtZTogdGhpcy5jb25maWcudXNlcm5hbWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSB3b3VsZCB0ZXN0IHRoZSBhY3R1YWwgY29ubmVjdGlvblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0VtYWlsIGNvbm5lY3Rpb24gdGVzdCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRmlsZVNoYXJlU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGx1Z2luOiBBSU1DUFBsdWdpbiwgcHJpdmF0ZSBlbWFpbFNlcnZpY2U6IEVtYWlsU2VydmljZSkge31cblxuICBhc3luYyBzaGFyZUZpbGVWaWFFbWFpbChcbiAgICBmaWxlOiBURmlsZSxcbiAgICByZWNpcGllbnRzOiBzdHJpbmdbXSxcbiAgICBtZXNzYWdlPzogc3RyaW5nLFxuICAgIGluY2x1ZGVNZXRhZGF0YSA9IHRydWVcbiAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRzOiBFbWFpbEF0dGFjaG1lbnRbXSA9IFtdO1xuXG4gICAgICAvLyBBZGQgdGhlIG1haW4gZmlsZVxuICAgICAgYXR0YWNobWVudHMucHVzaCh7XG4gICAgICAgIGZpbGVuYW1lOiBgJHtmaWxlLmJhc2VuYW1lfS5tZGAsXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgIGNvbnRlbnRUeXBlOiAndGV4dC9tYXJrZG93bidcbiAgICAgIH0pO1xuXG4gICAgICAvLyBBZGQgbWV0YWRhdGEgaWYgcmVxdWVzdGVkXG4gICAgICBpZiAoaW5jbHVkZU1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5leHRyYWN0RmlsZU1ldGFkYXRhKGZpbGUpO1xuICAgICAgICBhdHRhY2htZW50cy5wdXNoKHtcbiAgICAgICAgICBmaWxlbmFtZTogYCR7ZmlsZS5iYXNlbmFtZX1fbWV0YWRhdGEuanNvbmAsXG4gICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEsIG51bGwsIDIpLFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEdlbmVyYXRlIGVtYWlsIGNvbnRlbnRcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgICAgICAgZmlsZU5hbWU6IGZpbGUuYmFzZW5hbWUsXG4gICAgICAgIGZpbGVQYXRoOiBmaWxlLnBhdGgsXG4gICAgICAgIGZpbGVTaXplOiB0aGlzLmZvcm1hdEZpbGVTaXplKGNvbnRlbnQubGVuZ3RoKSxcbiAgICAgICAgc2hhcmVEYXRlOiBuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpLFxuICAgICAgICBzaGFyZVRpbWU6IG5ldyBEYXRlKCkudG9Mb2NhbGVUaW1lU3RyaW5nKCksXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgJ1NoYXJlZCBmcm9tIE9ic2lkaWFuIEFJIE1DUCBQbHVnaW4nLFxuICAgICAgICB2YXVsdE5hbWU6IHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXROYW1lKClcbiAgICAgIH07XG5cbiAgICAgIGF3YWl0IHRoaXMuZW1haWxTZXJ2aWNlLnNlbmRUZW1wbGF0ZWRFbWFpbChcbiAgICAgICAgcmVjaXBpZW50cyxcbiAgICAgICAgJ2ZpbGVfc2hhcmUnLFxuICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgIGF0dGFjaG1lbnRzXG4gICAgICApO1xuXG4gICAgICBuZXcgTm90aWNlKGBGaWxlIFwiJHtmaWxlLmJhc2VuYW1lfVwiIHNoYXJlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGaWxlIHNoYXJpbmcgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBzaGFyZSBmaWxlOiAkeyhlcnJvciBhcyBFcnJvcikubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzaGFyZU11bHRpcGxlRmlsZXMoXG4gICAgZmlsZXM6IFRGaWxlW10sXG4gICAgcmVjaXBpZW50czogc3RyaW5nW10sXG4gICAgbWVzc2FnZT86IHN0cmluZyxcbiAgICBmb3JtYXQ6ICdpbmRpdmlkdWFsJyB8ICd6aXAnID0gJ2luZGl2aWR1YWwnXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnaW5kaXZpZHVhbCcpIHtcbiAgICAgICAgLy8gU2VuZCBlYWNoIGZpbGUgc2VwYXJhdGVseVxuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNoYXJlRmlsZVZpYUVtYWlsKGZpbGUsIHJlY2lwaWVudHMsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgYSB6aXAtbGlrZSBzdHJ1Y3R1cmUgKHNpbXBsaWZpZWQpXG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnRzOiBFbWFpbEF0dGFjaG1lbnRbXSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuICAgICAgICAgIGF0dGFjaG1lbnRzLnB1c2goe1xuICAgICAgICAgICAgZmlsZW5hbWU6IGAke2ZpbGUucGF0aC5yZXBsYWNlKC9cXC8vZywgJ18nKX0ubWRgLFxuICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAndGV4dC9tYXJrZG93bidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgICAgICAgICBmaWxlQ291bnQ6IGZpbGVzLmxlbmd0aCxcbiAgICAgICAgICBmaWxlTmFtZXM6IGZpbGVzLm1hcChmID0+IGYuYmFzZW5hbWUpLmpvaW4oJywgJyksXG4gICAgICAgICAgc2hhcmVEYXRlOiBuZXcgRGF0ZSgpLnRvTG9jYWxlRGF0ZVN0cmluZygpLFxuICAgICAgICAgIHNoYXJlVGltZTogbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKSxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8ICdNdWx0aXBsZSBmaWxlcyBzaGFyZWQgZnJvbSBPYnNpZGlhbicsXG4gICAgICAgICAgdmF1bHROYW1lOiB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0TmFtZSgpXG4gICAgICAgIH07XG5cbiAgICAgICAgYXdhaXQgdGhpcy5lbWFpbFNlcnZpY2Uuc2VuZFRlbXBsYXRlZEVtYWlsKFxuICAgICAgICAgIHJlY2lwaWVudHMsXG4gICAgICAgICAgJ211bHRpcGxlX2ZpbGVzX3NoYXJlJyxcbiAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgYXR0YWNobWVudHNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbmV3IE5vdGljZShgJHtmaWxlcy5sZW5ndGh9IGZpbGVzIHNoYXJlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdNdWx0aXBsZSBmaWxlIHNoYXJpbmcgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIG5ldyBOb3RpY2UoYEZhaWxlZCB0byBzaGFyZSBmaWxlczogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc2hhcmVWYXVsdFN1bW1hcnkoXG4gICAgcmVjaXBpZW50czogc3RyaW5nW10sXG4gICAgaW5jbHVkZVN0YXRzID0gdHJ1ZSxcbiAgICBpbmNsdWRlUmVjZW50RmlsZXMgPSB0cnVlXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgdGhpcy5nZW5lcmF0ZVZhdWx0U3VtbWFyeShpbmNsdWRlU3RhdHMsIGluY2x1ZGVSZWNlbnRGaWxlcyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgICAgICAgdmF1bHROYW1lOiB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0TmFtZSgpLFxuICAgICAgICBzdW1tYXJ5RGF0ZTogbmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKSxcbiAgICAgICAgLi4uc3VtbWFyeVxuICAgICAgfTtcblxuICAgICAgYXdhaXQgdGhpcy5lbWFpbFNlcnZpY2Uuc2VuZFRlbXBsYXRlZEVtYWlsKFxuICAgICAgICByZWNpcGllbnRzLFxuICAgICAgICAndmF1bHRfc3VtbWFyeScsXG4gICAgICAgIHZhcmlhYmxlc1xuICAgICAgKTtcblxuICAgICAgbmV3IE5vdGljZSgnVmF1bHQgc3VtbWFyeSBzaGFyZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignVmF1bHQgc3VtbWFyeSBzaGFyaW5nIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICBuZXcgTm90aWNlKGBGYWlsZWQgdG8gc2hhcmUgdmF1bHQgc3VtbWFyeTogJHsoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBleHRyYWN0RmlsZU1ldGFkYXRhKGZpbGU6IFRGaWxlKTogYW55IHtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogZmlsZS5iYXNlbmFtZSxcbiAgICAgIHBhdGg6IGZpbGUucGF0aCxcbiAgICAgIHNpemU6IGZpbGUuc3RhdC5zaXplLFxuICAgICAgY3JlYXRlZDogbmV3IERhdGUoZmlsZS5zdGF0LmN0aW1lKS50b0lTT1N0cmluZygpLFxuICAgICAgbW9kaWZpZWQ6IG5ldyBEYXRlKGZpbGUuc3RhdC5tdGltZSkudG9JU09TdHJpbmcoKSxcbiAgICAgIHRhZ3M6IGNhY2hlPy50YWdzPy5tYXAodCA9PiB0LnRhZykgfHwgW10sXG4gICAgICBsaW5rczogY2FjaGU/LmxpbmtzPy5tYXAobCA9PiBsLmxpbmspIHx8IFtdLFxuICAgICAgaGVhZGluZ3M6IGNhY2hlPy5oZWFkaW5ncz8ubWFwKGggPT4gKHtcbiAgICAgICAgbGV2ZWw6IGgubGV2ZWwsXG4gICAgICAgIGhlYWRpbmc6IGguaGVhZGluZ1xuICAgICAgfSkpIHx8IFtdLFxuICAgICAgZnJvbnRtYXR0ZXI6IGNhY2hlPy5mcm9udG1hdHRlciB8fCB7fVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGZvcm1hdEZpbGVTaXplKGJ5dGVzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIGNvbnN0IHNpemVzID0gWydCeXRlcycsICdLQicsICdNQicsICdHQiddO1xuICAgIGlmIChieXRlcyA9PT0gMCkgcmV0dXJuICcwIEJ5dGVzJztcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZygxMDI0KSk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYnl0ZXMgLyBNYXRoLnBvdygxMDI0LCBpKSAqIDEwMCkgLyAxMDAgKyAnICcgKyBzaXplc1tpXTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVWYXVsdFN1bW1hcnkoaW5jbHVkZVN0YXRzOiBib29sZWFuLCBpbmNsdWRlUmVjZW50RmlsZXM6IGJvb2xlYW4pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IGZpbGVzID0gdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgICBjb25zdCBzdW1tYXJ5OiBhbnkgPSB7fTtcblxuICAgIGlmIChpbmNsdWRlU3RhdHMpIHtcbiAgICAgIGxldCB0b3RhbFdvcmRzID0gMDtcbiAgICAgIGNvbnN0IHRhZ3MgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMucGx1Z2luLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuICAgICAgICAgIHRvdGFsV29yZHMgKz0gY29udGVudC5zcGxpdCgvXFxzKy8pLmxlbmd0aDtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMucGx1Z2luLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgICBpZiAoY2FjaGU/LnRhZ3MpIHtcbiAgICAgICAgICAgIGNhY2hlLnRhZ3MuZm9yRWFjaCh0YWcgPT4gdGFncy5hZGQodGFnLnRhZykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFNraXAgZmlsZXMgdGhhdCBjYW4ndCBiZSByZWFkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3VtbWFyeS5zdGF0cyA9IHtcbiAgICAgICAgdG90YWxGaWxlczogZmlsZXMubGVuZ3RoLFxuICAgICAgICB0b3RhbFdvcmRzLFxuICAgICAgICB0b3RhbFRhZ3M6IHRhZ3Muc2l6ZSxcbiAgICAgICAgYXZlcmFnZVdvcmRzUGVyRmlsZTogTWF0aC5yb3VuZCh0b3RhbFdvcmRzIC8gZmlsZXMubGVuZ3RoKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZVJlY2VudEZpbGVzKSB7XG4gICAgICBjb25zdCByZWNlbnRGaWxlcyA9IGZpbGVzXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLnN0YXQubXRpbWUgLSBhLnN0YXQubXRpbWUpXG4gICAgICAgIC5zbGljZSgwLCAxMClcbiAgICAgICAgLm1hcChmaWxlID0+ICh7XG4gICAgICAgICAgbmFtZTogZmlsZS5iYXNlbmFtZSxcbiAgICAgICAgICBwYXRoOiBmaWxlLnBhdGgsXG4gICAgICAgICAgbW9kaWZpZWQ6IG5ldyBEYXRlKGZpbGUuc3RhdC5tdGltZSkudG9Mb2NhbGVEYXRlU3RyaW5nKClcbiAgICAgICAgfSkpO1xuXG4gICAgICBzdW1tYXJ5LnJlY2VudEZpbGVzID0gcmVjZW50RmlsZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bW1hcnk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvbk1hbmFnZXIge1xuICBwcml2YXRlIHJ1bGVzOiBNYXA8c3RyaW5nLCBOb3RpZmljYXRpb25SdWxlPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBzY2hlZHVsZWRKb2JzOiBNYXA8c3RyaW5nLCBOb2RlSlMuVGltZW91dD4gPSBuZXcgTWFwKCk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBwbHVnaW46IEFJTUNQUGx1Z2luLFxuICAgIHByaXZhdGUgZW1haWxTZXJ2aWNlOiBFbWFpbFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBmaWxlU2hhcmVTZXJ2aWNlOiBGaWxlU2hhcmVTZXJ2aWNlXG4gICkge1xuICAgIHRoaXMubG9hZFJ1bGVzKCk7XG4gICAgdGhpcy5zZXR1cEZpbGVXYXRjaGVycygpO1xuICB9XG5cbiAgYWRkUnVsZShydWxlOiBOb3RpZmljYXRpb25SdWxlKTogdm9pZCB7XG4gICAgdGhpcy5ydWxlcy5zZXQocnVsZS5pZCwgcnVsZSk7XG4gICAgdGhpcy5zYXZlUnVsZXMoKTtcbiAgICBcbiAgICBpZiAocnVsZS5lbmFibGVkICYmIHJ1bGUuY29uZGl0aW9ucy50aW1lU2NoZWR1bGUpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVSdWxlKHJ1bGUpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVJ1bGUocnVsZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLnJ1bGVzLmRlbGV0ZShydWxlSWQpO1xuICAgIHRoaXMudW5zY2hlZHVsZVJ1bGUocnVsZUlkKTtcbiAgICB0aGlzLnNhdmVSdWxlcygpO1xuICB9XG5cbiAgZW5hYmxlUnVsZShydWxlSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLnJ1bGVzLmdldChydWxlSWQpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICBydWxlLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5zYXZlUnVsZXMoKTtcbiAgICAgIFxuICAgICAgaWYgKHJ1bGUuY29uZGl0aW9ucy50aW1lU2NoZWR1bGUpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJ1bGUocnVsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZVJ1bGUocnVsZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBydWxlID0gdGhpcy5ydWxlcy5nZXQocnVsZUlkKTtcbiAgICBpZiAocnVsZSkge1xuICAgICAgcnVsZS5lbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnVuc2NoZWR1bGVSdWxlKHJ1bGVJZCk7XG4gICAgICB0aGlzLnNhdmVSdWxlcygpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHRyaWdnZXJSdWxlKHJ1bGVJZDogc3RyaW5nLCBjb250ZXh0PzogYW55KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcnVsZSA9IHRoaXMucnVsZXMuZ2V0KHJ1bGVJZCk7XG4gICAgaWYgKCFydWxlIHx8ICFydWxlLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSBhd2FpdCB0aGlzLnByZXBhcmVWYXJpYWJsZXMocnVsZSwgY29udGV4dCk7XG4gICAgICBcbiAgICAgIGF3YWl0IHRoaXMuZW1haWxTZXJ2aWNlLnNlbmRUZW1wbGF0ZWRFbWFpbChcbiAgICAgICAgcnVsZS5yZWNpcGllbnRzLFxuICAgICAgICBydWxlLnRlbXBsYXRlSWQsXG4gICAgICAgIHZhcmlhYmxlc1xuICAgICAgKTtcblxuICAgICAgcnVsZS5sYXN0VHJpZ2dlcmVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgdGhpcy5zYXZlUnVsZXMoKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYE5vdGlmaWNhdGlvbiBydWxlIFwiJHtydWxlLm5hbWV9XCIgdHJpZ2dlcmVkIHN1Y2Nlc3NmdWxseWApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gdHJpZ2dlciBydWxlIFwiJHtydWxlLm5hbWV9XCI6YCwgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbG9hZFJ1bGVzKCk6IHZvaWQge1xuICAgIGNvbnN0IHNhdmVkUnVsZXMgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3RpZmljYXRpb25SdWxlcyB8fCBbXTtcbiAgICBzYXZlZFJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICB0aGlzLnJ1bGVzLnNldChydWxlLmlkLCBydWxlKTtcbiAgICAgIGlmIChydWxlLmVuYWJsZWQgJiYgcnVsZS5jb25kaXRpb25zLnRpbWVTY2hlZHVsZSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlUnVsZShydWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc2F2ZVJ1bGVzKCk6IHZvaWQge1xuICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLm5vdGlmaWNhdGlvblJ1bGVzID0gQXJyYXkuZnJvbSh0aGlzLnJ1bGVzLnZhbHVlcygpKTtcbiAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBGaWxlV2F0Y2hlcnMoKTogdm9pZCB7XG4gICAgLy8gV2F0Y2ggZm9yIGZpbGUgY3JlYXRpb25cbiAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm9uKCdjcmVhdGUnLCAoZmlsZSkgPT4ge1xuICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVGaWxlRXZlbnQoJ2ZpbGVfY3JlYXRlZCcsIGZpbGUpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG5cbiAgICAvLyBXYXRjaCBmb3IgZmlsZSBtb2RpZmljYXRpb25cbiAgICB0aGlzLnBsdWdpbi5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm9uKCdtb2RpZnknLCAoZmlsZSkgPT4ge1xuICAgICAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICAgICAgdGhpcy5oYW5kbGVGaWxlRXZlbnQoJ2ZpbGVfbW9kaWZpZWQnLCBmaWxlKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVGaWxlRXZlbnQodHJpZ2dlcjogJ2ZpbGVfY3JlYXRlZCcgfCAnZmlsZV9tb2RpZmllZCcsIGZpbGU6IFRGaWxlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHRoaXMucnVsZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChydWxlLmVuYWJsZWQgJiYgcnVsZS50cmlnZ2VyID09PSB0cmlnZ2VyKSB7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoZXNGaWxlUGF0dGVybihmaWxlLCBydWxlLmNvbmRpdGlvbnMuZmlsZVBhdHRlcm4pKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy50cmlnZ2VyUnVsZShydWxlLmlkLCB7IGZpbGUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG1hdGNoZXNGaWxlUGF0dGVybihmaWxlOiBURmlsZSwgcGF0dGVybj86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGlmICghcGF0dGVybikgcmV0dXJuIHRydWU7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChwYXR0ZXJuLCAnaScpO1xuICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoZmlsZS5wYXRoKSB8fCByZWdleC50ZXN0KGZpbGUuYmFzZW5hbWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHBhdHRlcm4gaXMgaW52YWxpZCByZWdleCwgZG8gc2ltcGxlIHN0cmluZyBtYXRjaGluZ1xuICAgICAgcmV0dXJuIGZpbGUucGF0aC5pbmNsdWRlcyhwYXR0ZXJuKSB8fCBmaWxlLmJhc2VuYW1lLmluY2x1ZGVzKHBhdHRlcm4pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2NoZWR1bGVSdWxlKHJ1bGU6IE5vdGlmaWNhdGlvblJ1bGUpOiB2b2lkIHtcbiAgICBpZiAoIXJ1bGUuY29uZGl0aW9ucy50aW1lU2NoZWR1bGUpIHJldHVybjtcblxuICAgIC8vIFNpbXBsaWZpZWQgY3Jvbi1saWtlIHNjaGVkdWxpbmcgKGZvciBkZW1vIHB1cnBvc2VzKVxuICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91J2QgdXNlIGEgcHJvcGVyIGNyb24gbGlicmFyeVxuICAgIGNvbnN0IHNjaGVkdWxlID0gcnVsZS5jb25kaXRpb25zLnRpbWVTY2hlZHVsZTtcbiAgICBsZXQgaW50ZXJ2YWw6IG51bWJlcjtcblxuICAgIGlmIChzY2hlZHVsZSA9PT0gJ2RhaWx5Jykge1xuICAgICAgaW50ZXJ2YWwgPSAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyAyNCBob3Vyc1xuICAgIH0gZWxzZSBpZiAoc2NoZWR1bGUgPT09ICd3ZWVrbHknKSB7XG4gICAgICBpbnRlcnZhbCA9IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwOyAvLyA3IGRheXNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuOyAvLyBVbnN1cHBvcnRlZCBzY2hlZHVsZSBmb3JtYXRcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lb3V0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy50cmlnZ2VyUnVsZShydWxlLmlkKTtcbiAgICB9LCBpbnRlcnZhbCk7XG5cbiAgICB0aGlzLnNjaGVkdWxlZEpvYnMuc2V0KHJ1bGUuaWQsIHRpbWVvdXQpO1xuICB9XG5cbiAgcHJpdmF0ZSB1bnNjaGVkdWxlUnVsZShydWxlSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLnNjaGVkdWxlZEpvYnMuZ2V0KHJ1bGVJZCk7XG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGltZW91dCk7XG4gICAgICB0aGlzLnNjaGVkdWxlZEpvYnMuZGVsZXRlKHJ1bGVJZCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBwcmVwYXJlVmFyaWFibGVzKHJ1bGU6IE5vdGlmaWNhdGlvblJ1bGUsIGNvbnRleHQ/OiBhbnkpOiBQcm9taXNlPFJlY29yZDxzdHJpbmcsIGFueT4+IHtcbiAgICBjb25zdCB2YXJpYWJsZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7XG4gICAgICBydWxlTmFtZTogcnVsZS5uYW1lLFxuICAgICAgdHJpZ2dlclRpbWU6IG5ldyBEYXRlKCkudG9Mb2NhbGVTdHJpbmcoKSxcbiAgICAgIHZhdWx0TmFtZTogdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmdldE5hbWUoKVxuICAgIH07XG5cbiAgICBpZiAoY29udGV4dD8uZmlsZSkge1xuICAgICAgY29uc3QgZmlsZSA9IGNvbnRleHQuZmlsZSBhcyBURmlsZTtcbiAgICAgIHZhcmlhYmxlcy5maWxlTmFtZSA9IGZpbGUuYmFzZW5hbWU7XG4gICAgICB2YXJpYWJsZXMuZmlsZVBhdGggPSBmaWxlLnBhdGg7XG4gICAgICB2YXJpYWJsZXMuZmlsZVNpemUgPSB0aGlzLmZpbGVTaGFyZVNlcnZpY2VbJ2Zvcm1hdEZpbGVTaXplJ10oZmlsZS5zdGF0LnNpemUpO1xuICAgIH1cblxuICAgIC8vIEFkZCB2YXVsdCBzdGF0aXN0aWNzIGZvciBzdW1tYXJ5IGVtYWlsc1xuICAgIGlmIChydWxlLnRyaWdnZXIgPT09ICdkYWlseV9zdW1tYXJ5JyB8fCBydWxlLnRyaWdnZXIgPT09ICd3ZWVrbHlfcmVwb3J0Jykge1xuICAgICAgY29uc3Qgc3VtbWFyeSA9IGF3YWl0IHRoaXMuZmlsZVNoYXJlU2VydmljZVsnZ2VuZXJhdGVWYXVsdFN1bW1hcnknXSh0cnVlLCB0cnVlKTtcbiAgICAgIE9iamVjdC5hc3NpZ24odmFyaWFibGVzLCBzdW1tYXJ5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFyaWFibGVzO1xuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAvLyBDbGVhciBhbGwgc2NoZWR1bGVkIGpvYnNcbiAgICBmb3IgKGNvbnN0IHRpbWVvdXQgb2YgdGhpcy5zY2hlZHVsZWRKb2JzLnZhbHVlcygpKSB7XG4gICAgICBjbGVhckludGVydmFsKHRpbWVvdXQpO1xuICAgIH1cbiAgICB0aGlzLnNjaGVkdWxlZEpvYnMuY2xlYXIoKTtcbiAgfVxufVxuXG4vLyBEZWZhdWx0IGVtYWlsIHRlbXBsYXRlc1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfRU1BSUxfVEVNUExBVEVTOiBFbWFpbFRlbXBsYXRlW10gPSBbXG4gIHtcbiAgICBpZDogJ2ZpbGVfc2hhcmUnLFxuICAgIG5hbWU6ICdGaWxlIFNoYXJlJyxcbiAgICBzdWJqZWN0OiAnU2hhcmVkIGZpbGU6IHt7ZmlsZU5hbWV9fScsXG4gICAgaHRtbFRlbXBsYXRlOiBgXG4gICAgICA8aDI+RmlsZSBTaGFyZWQgZnJvbSB7e3ZhdWx0TmFtZX19PC9oMj5cbiAgICAgIDxwPjxzdHJvbmc+RmlsZTo8L3N0cm9uZz4ge3tmaWxlTmFtZX19PC9wPlxuICAgICAgPHA+PHN0cm9uZz5TaXplOjwvc3Ryb25nPiB7e2ZpbGVTaXplfX08L3A+XG4gICAgICA8cD48c3Ryb25nPlNoYXJlZCBvbjo8L3N0cm9uZz4ge3tzaGFyZURhdGV9fSBhdCB7e3NoYXJlVGltZX19PC9wPlxuICAgICAgPHA+PHN0cm9uZz5NZXNzYWdlOjwvc3Ryb25nPjwvcD5cbiAgICAgIDxibG9ja3F1b3RlPnt7bWVzc2FnZX19PC9ibG9ja3F1b3RlPlxuICAgICAgPHA+VGhlIGZpbGUgaXMgYXR0YWNoZWQgdG8gdGhpcyBlbWFpbC48L3A+XG4gICAgYCxcbiAgICB0ZXh0VGVtcGxhdGU6IGBcbkZpbGUgU2hhcmVkIGZyb20ge3t2YXVsdE5hbWV9fVxuXG5GaWxlOiB7e2ZpbGVOYW1lfX1cblNpemU6IHt7ZmlsZVNpemV9fVxuU2hhcmVkIG9uOiB7e3NoYXJlRGF0ZX19IGF0IHt7c2hhcmVUaW1lfX1cblxuTWVzc2FnZTpcbnt7bWVzc2FnZX19XG5cblRoZSBmaWxlIGlzIGF0dGFjaGVkIHRvIHRoaXMgZW1haWwuXG4gICAgYCxcbiAgICB2YXJpYWJsZXM6IFsnZmlsZU5hbWUnLCAnZmlsZVNpemUnLCAnc2hhcmVEYXRlJywgJ3NoYXJlVGltZScsICdtZXNzYWdlJywgJ3ZhdWx0TmFtZSddXG4gIH0sXG4gIHtcbiAgICBpZDogJ211bHRpcGxlX2ZpbGVzX3NoYXJlJyxcbiAgICBuYW1lOiAnTXVsdGlwbGUgRmlsZXMgU2hhcmUnLFxuICAgIHN1YmplY3Q6ICdTaGFyZWQge3tmaWxlQ291bnR9fSBmaWxlcyBmcm9tIHt7dmF1bHROYW1lfX0nLFxuICAgIGh0bWxUZW1wbGF0ZTogYFxuICAgICAgPGgyPk11bHRpcGxlIEZpbGVzIFNoYXJlZDwvaDI+XG4gICAgICA8cD48c3Ryb25nPkZpbGVzICh7e2ZpbGVDb3VudH19KTo8L3N0cm9uZz4ge3tmaWxlTmFtZXN9fTwvcD5cbiAgICAgIDxwPjxzdHJvbmc+U2hhcmVkIG9uOjwvc3Ryb25nPiB7e3NoYXJlRGF0ZX19IGF0IHt7c2hhcmVUaW1lfX08L3A+XG4gICAgICA8cD48c3Ryb25nPk1lc3NhZ2U6PC9zdHJvbmc+PC9wPlxuICAgICAgPGJsb2NrcXVvdGU+e3ttZXNzYWdlfX08L2Jsb2NrcXVvdGU+XG4gICAgICA8cD5BbGwgZmlsZXMgYXJlIGF0dGFjaGVkIHRvIHRoaXMgZW1haWwuPC9wPlxuICAgIGAsXG4gICAgdGV4dFRlbXBsYXRlOiBgXG5NdWx0aXBsZSBGaWxlcyBTaGFyZWRcblxuRmlsZXMgKHt7ZmlsZUNvdW50fX0pOiB7e2ZpbGVOYW1lc319XG5TaGFyZWQgb246IHt7c2hhcmVEYXRlfX0gYXQge3tzaGFyZVRpbWV9fVxuXG5NZXNzYWdlOlxue3ttZXNzYWdlfX1cblxuQWxsIGZpbGVzIGFyZSBhdHRhY2hlZCB0byB0aGlzIGVtYWlsLlxuICAgIGAsXG4gICAgdmFyaWFibGVzOiBbJ2ZpbGVDb3VudCcsICdmaWxlTmFtZXMnLCAnc2hhcmVEYXRlJywgJ3NoYXJlVGltZScsICdtZXNzYWdlJywgJ3ZhdWx0TmFtZSddXG4gIH0sXG4gIHtcbiAgICBpZDogJ3ZhdWx0X3N1bW1hcnknLFxuICAgIG5hbWU6ICdWYXVsdCBTdW1tYXJ5JyxcbiAgICBzdWJqZWN0OiAnRGFpbHkgU3VtbWFyeToge3t2YXVsdE5hbWV9fScsXG4gICAgaHRtbFRlbXBsYXRlOiBgXG4gICAgICA8aDI+VmF1bHQgU3VtbWFyeSBmb3Ige3t2YXVsdE5hbWV9fTwvaDI+XG4gICAgICA8cD48c3Ryb25nPkRhdGU6PC9zdHJvbmc+IHt7c3VtbWFyeURhdGV9fTwvcD5cbiAgICAgIFxuICAgICAgPGgzPlN0YXRpc3RpY3M8L2gzPlxuICAgICAgPHVsPlxuICAgICAgICA8bGk+VG90YWwgRmlsZXM6IHt7c3RhdHMudG90YWxGaWxlc319PC9saT5cbiAgICAgICAgPGxpPlRvdGFsIFdvcmRzOiB7e3N0YXRzLnRvdGFsV29yZHN9fTwvbGk+XG4gICAgICAgIDxsaT5Ub3RhbCBUYWdzOiB7e3N0YXRzLnRvdGFsVGFnc319PC9saT5cbiAgICAgICAgPGxpPkF2ZXJhZ2UgV29yZHMgcGVyIEZpbGU6IHt7c3RhdHMuYXZlcmFnZVdvcmRzUGVyRmlsZX19PC9saT5cbiAgICAgIDwvdWw+XG4gICAgICBcbiAgICAgIDxoMz5SZWNlbnQgRmlsZXM8L2gzPlxuICAgICAgPHVsPlxuICAgICAgICB7eyNlYWNoIHJlY2VudEZpbGVzfX1cbiAgICAgICAgPGxpPnt7bmFtZX19ICh7e21vZGlmaWVkfX0pPC9saT5cbiAgICAgICAge3svZWFjaH19XG4gICAgICA8L3VsPlxuICAgIGAsXG4gICAgdGV4dFRlbXBsYXRlOiBgXG5WYXVsdCBTdW1tYXJ5IGZvciB7e3ZhdWx0TmFtZX19XG5EYXRlOiB7e3N1bW1hcnlEYXRlfX1cblxuU3RhdGlzdGljczpcbi0gVG90YWwgRmlsZXM6IHt7c3RhdHMudG90YWxGaWxlc319XG4tIFRvdGFsIFdvcmRzOiB7e3N0YXRzLnRvdGFsV29yZHN9fVxuLSBUb3RhbCBUYWdzOiB7e3N0YXRzLnRvdGFsVGFnc319XG4tIEF2ZXJhZ2UgV29yZHMgcGVyIEZpbGU6IHt7c3RhdHMuYXZlcmFnZVdvcmRzUGVyRmlsZX19XG5cblJlY2VudCBGaWxlczpcbnt7I2VhY2ggcmVjZW50RmlsZXN9fVxuLSB7e25hbWV9fSAoe3ttb2RpZmllZH19KVxue3svZWFjaH19XG4gICAgYCxcbiAgICB2YXJpYWJsZXM6IFsndmF1bHROYW1lJywgJ3N1bW1hcnlEYXRlJywgJ3N0YXRzJywgJ3JlY2VudEZpbGVzJ11cbiAgfVxuXTtcbiIsICJpbXBvcnQgeyBURmlsZSwgTm90aWNlLCBNb2RhbCwgU2V0dGluZyB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBBSU1DUFBsdWdpbiBmcm9tICcuLi9tYWluJztcbmltcG9ydCB7IFZveWFnZUFJSW50ZWdyYXRpb24gfSBmcm9tICcuL3ZveWFnZS1haSc7XG5pbXBvcnQgeyBWZXJjZWxBSUludGVncmF0aW9uIH0gZnJvbSAnLi92ZXJjZWwtYWknO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaFJlc3VsdCB7XG4gIGlkOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgZmlsZT86IFRGaWxlO1xuICBzY29yZTogbnVtYmVyO1xuICByZXJhbmtTY29yZT86IG51bWJlcjtcbiAgZmluYWxTY29yZT86IG51bWJlcjtcbiAgbWV0YWRhdGE6IHtcbiAgICB0eXBlOiAnZmlsZScgfCAnbm9kZScgfCAnZXh0ZXJuYWwnO1xuICAgIHNvdXJjZTogc3RyaW5nO1xuICAgIHBhdGg/OiBzdHJpbmc7XG4gICAgdGFncz86IHN0cmluZ1tdO1xuICAgIGNyZWF0ZWQ/OiBzdHJpbmc7XG4gICAgbW9kaWZpZWQ/OiBzdHJpbmc7XG4gICAgd29yZENvdW50PzogbnVtYmVyO1xuICAgIGhpZ2hsaWdodHM/OiBzdHJpbmdbXTtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hPcHRpb25zIHtcbiAgcXVlcnk6IHN0cmluZztcbiAgc2VhcmNoVHlwZTogJ3NlbWFudGljJyB8ICdrZXl3b3JkJyB8ICdoeWJyaWQnIHwgJ2FpX2VuaGFuY2VkJztcbiAgbWF4UmVzdWx0czogbnVtYmVyO1xuICB1c2VSZXJhbms6IGJvb2xlYW47XG4gIHJlcmFua1RocmVzaG9sZDogbnVtYmVyO1xuICBpbmNsdWRlQ29udGVudDogYm9vbGVhbjtcbiAgZmlsZVR5cGVzOiBzdHJpbmdbXTtcbiAgZGF0ZVJhbmdlPzoge1xuICAgIGZyb206IERhdGU7XG4gICAgdG86IERhdGU7XG4gIH07XG4gIHRhZ3M/OiBzdHJpbmdbXTtcbiAgZm9sZGVycz86IHN0cmluZ1tdO1xuICBzb3J0Qnk6ICdyZWxldmFuY2UnIHwgJ2RhdGUnIHwgJ3RpdGxlJyB8ICdzaXplJztcbiAgc29ydE9yZGVyOiAnYXNjJyB8ICdkZXNjJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hGaWx0ZXIge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6ICd0YWcnIHwgJ2ZvbGRlcicgfCAnZGF0ZScgfCAnc2l6ZScgfCAndHlwZSc7XG4gIHZhbHVlOiBhbnk7XG4gIG9wZXJhdG9yOiAnZXF1YWxzJyB8ICdjb250YWlucycgfCAnZ3JlYXRlcicgfCAnbGVzcycgfCAnYmV0d2Vlbic7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2F2ZWRTZWFyY2gge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHF1ZXJ5OiBzdHJpbmc7XG4gIG9wdGlvbnM6IFNlYXJjaE9wdGlvbnM7XG4gIGZpbHRlcnM6IFNlYXJjaEZpbHRlcltdO1xuICBjcmVhdGVkOiBzdHJpbmc7XG4gIGxhc3RVc2VkOiBzdHJpbmc7XG4gIHVzZUNvdW50OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBFbmhhbmNlZFNlYXJjaEVuZ2luZSB7XG4gIHByaXZhdGUgc2VhcmNoSGlzdG9yeTogQXJyYXk8e3F1ZXJ5OiBzdHJpbmc7IHRpbWVzdGFtcDogc3RyaW5nOyByZXN1bHRDb3VudDogbnVtYmVyfT4gPSBbXTtcbiAgcHJpdmF0ZSBzYXZlZFNlYXJjaGVzOiBNYXA8c3RyaW5nLCBTYXZlZFNlYXJjaD4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgc2VhcmNoQ2FjaGU6IE1hcDxzdHJpbmcsIHtyZXN1bHRzOiBTZWFyY2hSZXN1bHRbXTsgdGltZXN0YW1wOiBudW1iZXJ9PiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBjYWNoZVRpbWVvdXQgPSA1ICogNjAgKiAxMDAwOyAvLyA1IG1pbnV0ZXNcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHBsdWdpbjogQUlNQ1BQbHVnaW4sXG4gICAgcHJpdmF0ZSB2b3lhZ2VBSTogVm95YWdlQUlJbnRlZ3JhdGlvbixcbiAgICBwcml2YXRlIHZlcmNlbEFJOiBWZXJjZWxBSUludGVncmF0aW9uXG4gICkge1xuICAgIHRoaXMubG9hZFNhdmVkU2VhcmNoZXMoKTtcbiAgfVxuXG4gIGFzeW5jIHNlYXJjaChvcHRpb25zOiBTZWFyY2hPcHRpb25zKTogUHJvbWlzZTxTZWFyY2hSZXN1bHRbXT4ge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gdGhpcy5nZW5lcmF0ZUNhY2hlS2V5KG9wdGlvbnMpO1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuc2VhcmNoQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBcbiAgICBpZiAoY2FjaGVkICYmIERhdGUubm93KCkgLSBjYWNoZWQudGltZXN0YW1wIDwgdGhpcy5jYWNoZVRpbWVvdXQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQucmVzdWx0cztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgbGV0IHJlc3VsdHM6IFNlYXJjaFJlc3VsdFtdID0gW107XG5cbiAgICAgIHN3aXRjaCAob3B0aW9ucy5zZWFyY2hUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3NlbWFudGljJzpcbiAgICAgICAgICByZXN1bHRzID0gYXdhaXQgdGhpcy5zZW1hbnRpY1NlYXJjaChvcHRpb25zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAna2V5d29yZCc6XG4gICAgICAgICAgcmVzdWx0cyA9IGF3YWl0IHRoaXMua2V5d29yZFNlYXJjaChvcHRpb25zKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaHlicmlkJzpcbiAgICAgICAgICByZXN1bHRzID0gYXdhaXQgdGhpcy5oeWJyaWRTZWFyY2gob3B0aW9ucyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FpX2VuaGFuY2VkJzpcbiAgICAgICAgICByZXN1bHRzID0gYXdhaXQgdGhpcy5haUVuaGFuY2VkU2VhcmNoKG9wdGlvbnMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlc3VsdHMgPSBhd2FpdCB0aGlzLmh5YnJpZFNlYXJjaChvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgcmVyYW5raW5nIGlmIGVuYWJsZWRcbiAgICAgIGlmIChvcHRpb25zLnVzZVJlcmFuayAmJiB0aGlzLnZveWFnZUFJLmlzUmVhZHkoKSkge1xuICAgICAgICByZXN1bHRzID0gYXdhaXQgdGhpcy5yZXJhbmtSZXN1bHRzKG9wdGlvbnMucXVlcnksIHJlc3VsdHMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBmaWx0ZXJzIGFuZCBzb3J0aW5nXG4gICAgICByZXN1bHRzID0gdGhpcy5hcHBseUZpbHRlcnMocmVzdWx0cywgb3B0aW9ucyk7XG4gICAgICByZXN1bHRzID0gdGhpcy5zb3J0UmVzdWx0cyhyZXN1bHRzLCBvcHRpb25zKTtcblxuICAgICAgLy8gTGltaXQgcmVzdWx0c1xuICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgb3B0aW9ucy5tYXhSZXN1bHRzKTtcblxuICAgICAgLy8gQ2FjaGUgcmVzdWx0c1xuICAgICAgdGhpcy5zZWFyY2hDYWNoZS5zZXQoY2FjaGVLZXksIHtcbiAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpXG4gICAgICB9KTtcblxuICAgICAgLy8gVXBkYXRlIHNlYXJjaCBoaXN0b3J5XG4gICAgICB0aGlzLmFkZFRvSGlzdG9yeShvcHRpb25zLnF1ZXJ5LCByZXN1bHRzLmxlbmd0aCk7XG5cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFbmhhbmNlZCBzZWFyY2ggZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2VtYW50aWNTZWFyY2gob3B0aW9uczogU2VhcmNoT3B0aW9ucyk6IFByb21pc2U8U2VhcmNoUmVzdWx0W10+IHtcbiAgICBpZiAoIXRoaXMucGx1Z2luLmVtYmVkZGluZ3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW1iZWRkaW5ncyBub3QgYXZhaWxhYmxlIGZvciBzZW1hbnRpYyBzZWFyY2gnKTtcbiAgICB9XG5cbiAgICBjb25zdCBxdWVyeUVtYmVkZGluZyA9IGF3YWl0IHRoaXMucGx1Z2luLmVtYmVkZGluZ3MuZW1iZWRRdWVyeShvcHRpb25zLnF1ZXJ5KTtcbiAgICBjb25zdCByYWdSZXN1bHRzID0gYXdhaXQgdGhpcy5wbHVnaW4ucmFnSW50ZWdyYXRvci5zZWFyY2hTaW1pbGFyKHF1ZXJ5RW1iZWRkaW5nLCBvcHRpb25zLm1heFJlc3VsdHMgKiAyKTtcblxuICAgIHJldHVybiByYWdSZXN1bHRzLm1hcCgocmVzdWx0LCBpbmRleCkgPT4gKHtcbiAgICAgIGlkOiBgc2VtYW50aWNfJHtpbmRleH1gLFxuICAgICAgdGl0bGU6IHRoaXMuZXh0cmFjdFRpdGxlKHJlc3VsdC50ZXh0KSxcbiAgICAgIGNvbnRlbnQ6IHJlc3VsdC50ZXh0LFxuICAgICAgc2NvcmU6IHJlc3VsdC5zY29yZSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHR5cGU6ICdub2RlJyBhcyBjb25zdCxcbiAgICAgICAgc291cmNlOiAncmFnJyxcbiAgICAgICAgaGlnaGxpZ2h0czogdGhpcy5leHRyYWN0SGlnaGxpZ2h0cyhyZXN1bHQudGV4dCwgb3B0aW9ucy5xdWVyeSlcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGtleXdvcmRTZWFyY2gob3B0aW9uczogU2VhcmNoT3B0aW9ucyk6IFByb21pc2U8U2VhcmNoUmVzdWx0W10+IHtcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgY29uc3QgcmVzdWx0czogU2VhcmNoUmVzdWx0W10gPSBbXTtcbiAgICBjb25zdCBxdWVyeVdvcmRzID0gb3B0aW9ucy5xdWVyeS50b0xvd2VyQ2FzZSgpLnNwbGl0KC9cXHMrLyk7XG5cbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgICAgY29uc3QgY29udGVudExvd2VyID0gY29udGVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBcbiAgICAgICAgbGV0IHNjb3JlID0gMDtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0czogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUga2V5d29yZCBtYXRjaCBzY29yZVxuICAgICAgICBmb3IgKGNvbnN0IHdvcmQgb2YgcXVlcnlXb3Jkcykge1xuICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoY29udGVudExvd2VyLm1hdGNoKG5ldyBSZWdFeHAod29yZCwgJ2cnKSkgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgICBzY29yZSArPSBtYXRjaGVzO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChtYXRjaGVzID4gMCkge1xuICAgICAgICAgICAgaGlnaGxpZ2h0cy5wdXNoKC4uLnRoaXMuZmluZFdvcmRDb250ZXh0KGNvbnRlbnQsIHdvcmQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NvcmUgPiAwKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBga2V5d29yZF8ke2ZpbGUucGF0aH1gLFxuICAgICAgICAgICAgdGl0bGU6IGZpbGUuYmFzZW5hbWUsXG4gICAgICAgICAgICBjb250ZW50OiBvcHRpb25zLmluY2x1ZGVDb250ZW50ID8gY29udGVudCA6IHRoaXMuZXh0cmFjdFN1bW1hcnkoY29udGVudCksXG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgc2NvcmU6IHNjb3JlIC8gcXVlcnlXb3Jkcy5sZW5ndGgsXG4gICAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgICAgICAgIHNvdXJjZTogJ3ZhdWx0JyxcbiAgICAgICAgICAgICAgcGF0aDogZmlsZS5wYXRoLFxuICAgICAgICAgICAgICBjcmVhdGVkOiBuZXcgRGF0ZShmaWxlLnN0YXQuY3RpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgIG1vZGlmaWVkOiBuZXcgRGF0ZShmaWxlLnN0YXQubXRpbWUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgIHdvcmRDb3VudDogY29udGVudC5zcGxpdCgvXFxzKy8pLmxlbmd0aCxcbiAgICAgICAgICAgICAgaGlnaGxpZ2h0czogaGlnaGxpZ2h0cy5zbGljZSgwLCAzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gc2VhcmNoIGZpbGUgJHtmaWxlLnBhdGh9OmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGh5YnJpZFNlYXJjaChvcHRpb25zOiBTZWFyY2hPcHRpb25zKTogUHJvbWlzZTxTZWFyY2hSZXN1bHRbXT4ge1xuICAgIGNvbnN0IFtzZW1hbnRpY1Jlc3VsdHMsIGtleXdvcmRSZXN1bHRzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuc2VtYW50aWNTZWFyY2gob3B0aW9ucykuY2F0Y2goKCkgPT4gW10gYXMgU2VhcmNoUmVzdWx0W10pLFxuICAgICAgdGhpcy5rZXl3b3JkU2VhcmNoKG9wdGlvbnMpXG4gICAgXSk7XG5cbiAgICAvLyBDb21iaW5lIGFuZCBkZWR1cGxpY2F0ZSByZXN1bHRzXG4gICAgY29uc3QgY29tYmluZWRSZXN1bHRzID0gbmV3IE1hcDxzdHJpbmcsIFNlYXJjaFJlc3VsdD4oKTtcblxuICAgIC8vIEFkZCBzZW1hbnRpYyByZXN1bHRzXG4gICAgc2VtYW50aWNSZXN1bHRzLmZvckVhY2goKHJlc3VsdDogU2VhcmNoUmVzdWx0KSA9PiB7XG4gICAgICBjb21iaW5lZFJlc3VsdHMuc2V0KHJlc3VsdC5pZCwge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIGZpbmFsU2NvcmU6IHJlc3VsdC5zY29yZSAqIDAuNyAvLyBXZWlnaHQgc2VtYW50aWMgcmVzdWx0c1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQga2V5d29yZCByZXN1bHRzLCBjb21iaW5pbmcgc2NvcmVzIGlmIGR1cGxpY2F0ZVxuICAgIGtleXdvcmRSZXN1bHRzLmZvckVhY2goKHJlc3VsdDogU2VhcmNoUmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IGNvbWJpbmVkUmVzdWx0cy5nZXQocmVzdWx0LmlkKTtcbiAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICBleGlzdGluZy5maW5hbFNjb3JlID0gKGV4aXN0aW5nLmZpbmFsU2NvcmUgfHwgZXhpc3Rpbmcuc2NvcmUpICsgKHJlc3VsdC5zY29yZSAqIDAuMyk7XG4gICAgICAgIGV4aXN0aW5nLm1ldGFkYXRhLmhpZ2hsaWdodHMgPSBbXG4gICAgICAgICAgLi4uKGV4aXN0aW5nLm1ldGFkYXRhLmhpZ2hsaWdodHMgfHwgW10pLFxuICAgICAgICAgIC4uLihyZXN1bHQubWV0YWRhdGEuaGlnaGxpZ2h0cyB8fCBbXSlcbiAgICAgICAgXS5zbGljZSgwLCA1KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbWJpbmVkUmVzdWx0cy5zZXQocmVzdWx0LmlkLCB7XG4gICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgIGZpbmFsU2NvcmU6IHJlc3VsdC5zY29yZSAqIDAuMyAvLyBXZWlnaHQga2V5d29yZCByZXN1bHRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEFycmF5LmZyb20oY29tYmluZWRSZXN1bHRzLnZhbHVlcygpKVxuICAgICAgLnNvcnQoKGEsIGIpID0+IChiLmZpbmFsU2NvcmUgfHwgYi5zY29yZSkgLSAoYS5maW5hbFNjb3JlIHx8IGEuc2NvcmUpKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgYWlFbmhhbmNlZFNlYXJjaChvcHRpb25zOiBTZWFyY2hPcHRpb25zKTogUHJvbWlzZTxTZWFyY2hSZXN1bHRbXT4ge1xuICAgIGlmICghdGhpcy52ZXJjZWxBSS5pc1JlYWR5KCkpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmh5YnJpZFNlYXJjaChvcHRpb25zKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gVXNlIEFJIHRvIGV4cGFuZCBhbmQgaW1wcm92ZSB0aGUgcXVlcnlcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy52ZXJjZWxBSS5nZXRQcm92aWRlcigpO1xuICAgICAgY29uc3QgZXhwYW5kZWRRdWVyaWVzID0gYXdhaXQgcHJvdmlkZXIuZ2VuZXJhdGVRdWVzdGlvbnMoXG4gICAgICAgIGBTZWFyY2ggcXVlcnk6ICR7b3B0aW9ucy5xdWVyeX1gLFxuICAgICAgICAzXG4gICAgICApO1xuXG4gICAgICAvLyBQZXJmb3JtIHNlYXJjaGVzIHdpdGggZXhwYW5kZWQgcXVlcmllc1xuICAgICAgY29uc3QgYWxsUmVzdWx0czogU2VhcmNoUmVzdWx0W10gPSBbXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBxdWVyeSBvZiBbb3B0aW9ucy5xdWVyeSwgLi4uZXhwYW5kZWRRdWVyaWVzXSkge1xuICAgICAgICBjb25zdCBxdWVyeU9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHF1ZXJ5IH07XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmh5YnJpZFNlYXJjaChxdWVyeU9wdGlvbnMpO1xuICAgICAgICBhbGxSZXN1bHRzLnB1c2goLi4ucmVzdWx0cyk7XG4gICAgICB9XG5cbiAgICAgIC8vIERlZHVwbGljYXRlIGFuZCBzY29yZVxuICAgICAgY29uc3QgdW5pcXVlUmVzdWx0cyA9IHRoaXMuZGVkdXBsaWNhdGVSZXN1bHRzKGFsbFJlc3VsdHMpO1xuICAgICAgXG4gICAgICAvLyBVc2UgQUkgdG8gYW5hbHl6ZSBhbmQgc2NvcmUgcmVzdWx0c1xuICAgICAgY29uc3QgYW5hbHl6ZWRSZXN1bHRzID0gYXdhaXQgdGhpcy5hbmFseXplUmVzdWx0c1dpdGhBSShvcHRpb25zLnF1ZXJ5LCB1bmlxdWVSZXN1bHRzKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGFuYWx5emVkUmVzdWx0cztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQUkgZW5oYW5jZWQgc2VhcmNoIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIGh5YnJpZDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5oeWJyaWRTZWFyY2gob3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZXJhbmtSZXN1bHRzKFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgcmVzdWx0czogU2VhcmNoUmVzdWx0W10sXG4gICAgb3B0aW9uczogU2VhcmNoT3B0aW9uc1xuICApOiBQcm9taXNlPFNlYXJjaFJlc3VsdFtdPiB7XG4gICAgaWYgKCF0aGlzLnZveWFnZUFJLmlzUmVhZHkoKSB8fCByZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRvY3VtZW50cyA9IHJlc3VsdHMubWFwKHIgPT4gci5jb250ZW50KTtcbiAgICAgIGNvbnN0IHJlcmFua1Jlc3BvbnNlID0gYXdhaXQgdGhpcy52b3lhZ2VBSS5yZXJhbmtPbmx5KHF1ZXJ5LCBkb2N1bWVudHMsIG9wdGlvbnMubWF4UmVzdWx0cyk7XG4gICAgICBcbiAgICAgIGlmICghcmVyYW5rUmVzcG9uc2UpIHJldHVybiByZXN1bHRzO1xuXG4gICAgICBjb25zdCByZXJhbmtlZFJlc3VsdHMgPSByZXJhbmtSZXNwb25zZS5kYXRhXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnJlbGV2YW5jZV9zY29yZSA+PSBvcHRpb25zLnJlcmFua1RocmVzaG9sZClcbiAgICAgICAgLm1hcChpdGVtID0+IHtcbiAgICAgICAgICBjb25zdCBvcmlnaW5hbFJlc3VsdCA9IHJlc3VsdHNbaXRlbS5pbmRleF07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLm9yaWdpbmFsUmVzdWx0LFxuICAgICAgICAgICAgcmVyYW5rU2NvcmU6IGl0ZW0ucmVsZXZhbmNlX3Njb3JlLFxuICAgICAgICAgICAgZmluYWxTY29yZTogKG9yaWdpbmFsUmVzdWx0LnNjb3JlICogMC4zKSArIChpdGVtLnJlbGV2YW5jZV9zY29yZSAqIDAuNylcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJlcmFua2VkUmVzdWx0cy5zb3J0KChhLCBiKSA9PiAoYi5maW5hbFNjb3JlIHx8IGIuc2NvcmUpIC0gKGEuZmluYWxTY29yZSB8fCBhLnNjb3JlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1JlcmFua2luZyBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBhbmFseXplUmVzdWx0c1dpdGhBSShxdWVyeTogc3RyaW5nLCByZXN1bHRzOiBTZWFyY2hSZXN1bHRbXSk6IFByb21pc2U8U2VhcmNoUmVzdWx0W10+IHtcbiAgICBpZiAoIXRoaXMudmVyY2VsQUkuaXNSZWFkeSgpIHx8IHJlc3VsdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnZlcmNlbEFJLmdldFByb3ZpZGVyKCk7XG4gICAgICBcbiAgICAgIC8vIEFuYWx5emUgZWFjaCByZXN1bHQgZm9yIHJlbGV2YW5jZVxuICAgICAgY29uc3QgYW5hbHl6ZWRSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHJlc3VsdHMubWFwKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBhd2FpdCBwcm92aWRlci5nZW5lcmF0ZVRleHQoW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcm9sZTogJ3N5c3RlbScsXG4gICAgICAgICAgICAgICAgY29udGVudDogJ1lvdSBhcmUgYSBzZWFyY2ggcmVsZXZhbmNlIGFuYWx5emVyLiBSYXRlIHRoZSByZWxldmFuY2Ugb2YgdGhlIGdpdmVuIGNvbnRlbnQgdG8gdGhlIHNlYXJjaCBxdWVyeSBvbiBhIHNjYWxlIG9mIDAtMS4nXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgICAgICAgY29udGVudDogYFF1ZXJ5OiBcIiR7cXVlcnl9XCJcXG5cXG5Db250ZW50OiBcIiR7cmVzdWx0LmNvbnRlbnQuc3Vic3RyaW5nKDAsIDUwMCl9XCJcXG5cXG5SZWxldmFuY2Ugc2NvcmUgKDAtMSk6YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLCB7IG1heFRva2VuczogMTAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFpU2NvcmUgPSBwYXJzZUZsb2F0KGFuYWx5c2lzLnRyaW0oKSkgfHwgcmVzdWx0LnNjb3JlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgIGZpbmFsU2NvcmU6IChyZXN1bHQuc2NvcmUgKiAwLjUpICsgKGFpU2NvcmUgKiAwLjUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBSSBhbmFseXNpcyBmYWlsZWQgZm9yIHJlc3VsdDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBhbmFseXplZFJlc3VsdHMuc29ydCgoYSwgYikgPT4gKGIuZmluYWxTY29yZSB8fCBiLnNjb3JlKSAtIChhLmZpbmFsU2NvcmUgfHwgYS5zY29yZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBSSByZXN1bHQgYW5hbHlzaXMgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlGaWx0ZXJzKHJlc3VsdHM6IFNlYXJjaFJlc3VsdFtdLCBvcHRpb25zOiBTZWFyY2hPcHRpb25zKTogU2VhcmNoUmVzdWx0W10ge1xuICAgIGxldCBmaWx0ZXJlZCA9IHJlc3VsdHM7XG5cbiAgICAvLyBGaWxlIHR5cGUgZmlsdGVyXG4gICAgaWYgKG9wdGlvbnMuZmlsZVR5cGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmICghcmVzdWx0LmZpbGUpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5maWxlVHlwZXMuaW5jbHVkZXMocmVzdWx0LmZpbGUuZXh0ZW5zaW9uKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERhdGUgcmFuZ2UgZmlsdGVyXG4gICAgaWYgKG9wdGlvbnMuZGF0ZVJhbmdlKSB7XG4gICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLmZpbHRlcihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAoIXJlc3VsdC5tZXRhZGF0YS5tb2RpZmllZCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkRGF0ZSA9IG5ldyBEYXRlKHJlc3VsdC5tZXRhZGF0YS5tb2RpZmllZCk7XG4gICAgICAgIHJldHVybiBtb2RpZmllZERhdGUgPj0gb3B0aW9ucy5kYXRlUmFuZ2UhLmZyb20gJiYgbW9kaWZpZWREYXRlIDw9IG9wdGlvbnMuZGF0ZVJhbmdlIS50bztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRhZ3MgZmlsdGVyXG4gICAgaWYgKG9wdGlvbnMudGFncyAmJiBvcHRpb25zLnRhZ3MubGVuZ3RoID4gMCkge1xuICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIocmVzdWx0ID0+IHtcbiAgICAgICAgaWYgKCFyZXN1bHQubWV0YWRhdGEudGFncykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy50YWdzIS5zb21lKHRhZyA9PiByZXN1bHQubWV0YWRhdGEudGFncyEuaW5jbHVkZXModGFnKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGb2xkZXJzIGZpbHRlclxuICAgIGlmIChvcHRpb25zLmZvbGRlcnMgJiYgb3B0aW9ucy5mb2xkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmICghcmVzdWx0Lm1ldGFkYXRhLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZm9sZGVycyEuc29tZShmb2xkZXIgPT4gcmVzdWx0Lm1ldGFkYXRhLnBhdGghLnN0YXJ0c1dpdGgoZm9sZGVyKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmlsdGVyZWQ7XG4gIH1cblxuICBwcml2YXRlIHNvcnRSZXN1bHRzKHJlc3VsdHM6IFNlYXJjaFJlc3VsdFtdLCBvcHRpb25zOiBTZWFyY2hPcHRpb25zKTogU2VhcmNoUmVzdWx0W10ge1xuICAgIGNvbnN0IHNvcnRlZCA9IFsuLi5yZXN1bHRzXTtcblxuICAgIHNvcnRlZC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBsZXQgY29tcGFyaXNvbiA9IDA7XG5cbiAgICAgIHN3aXRjaCAob3B0aW9ucy5zb3J0QnkpIHtcbiAgICAgICAgY2FzZSAncmVsZXZhbmNlJzpcbiAgICAgICAgICBjb21wYXJpc29uID0gKGIuZmluYWxTY29yZSB8fCBiLnNjb3JlKSAtIChhLmZpbmFsU2NvcmUgfHwgYS5zY29yZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgIGNvbnN0IGFEYXRlID0gbmV3IERhdGUoYS5tZXRhZGF0YS5tb2RpZmllZCB8fCAwKS5nZXRUaW1lKCk7XG4gICAgICAgICAgY29uc3QgYkRhdGUgPSBuZXcgRGF0ZShiLm1ldGFkYXRhLm1vZGlmaWVkIHx8IDApLmdldFRpbWUoKTtcbiAgICAgICAgICBjb21wYXJpc29uID0gYkRhdGUgLSBhRGF0ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgIGNvbXBhcmlzb24gPSBhLnRpdGxlLmxvY2FsZUNvbXBhcmUoYi50aXRsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NpemUnOlxuICAgICAgICAgIGNvbXBhcmlzb24gPSAoYi5tZXRhZGF0YS53b3JkQ291bnQgfHwgMCkgLSAoYS5tZXRhZGF0YS53b3JkQ291bnQgfHwgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcHRpb25zLnNvcnRPcmRlciA9PT0gJ2Rlc2MnID8gY29tcGFyaXNvbiA6IC1jb21wYXJpc29uO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNvcnRlZDtcbiAgfVxuXG4gIHByaXZhdGUgZGVkdXBsaWNhdGVSZXN1bHRzKHJlc3VsdHM6IFNlYXJjaFJlc3VsdFtdKTogU2VhcmNoUmVzdWx0W10ge1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgTWFwPHN0cmluZywgU2VhcmNoUmVzdWx0PigpO1xuXG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgY29uc3Qga2V5ID0gcmVzdWx0LmZpbGU/LnBhdGggfHwgcmVzdWx0LnRpdGxlO1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBzZWVuLmdldChrZXkpO1xuXG4gICAgICBpZiAoIWV4aXN0aW5nIHx8IChyZXN1bHQuZmluYWxTY29yZSB8fCByZXN1bHQuc2NvcmUpID4gKGV4aXN0aW5nLmZpbmFsU2NvcmUgfHwgZXhpc3Rpbmcuc2NvcmUpKSB7XG4gICAgICAgIHNlZW4uc2V0KGtleSwgcmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbShzZWVuLnZhbHVlcygpKTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgbWV0aG9kc1xuICBwcml2YXRlIGV4dHJhY3RUaXRsZShjb250ZW50OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgZmlyc3RIZWFkaW5nID0gbGluZXMuZmluZChsaW5lID0+IGxpbmUuc3RhcnRzV2l0aCgnIycpKTtcbiAgICBpZiAoZmlyc3RIZWFkaW5nKSB7XG4gICAgICByZXR1cm4gZmlyc3RIZWFkaW5nLnJlcGxhY2UoL14jK1xccyovLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50LnN1YnN0cmluZygwLCA1MCkudHJpbSgpICsgJy4uLic7XG4gIH1cblxuICBwcml2YXRlIGV4dHJhY3RTdW1tYXJ5KGNvbnRlbnQ6IHN0cmluZywgbWF4TGVuZ3RoID0gMjAwKTogc3RyaW5nIHtcbiAgICBjb25zdCBjbGVhbmVkID0gY29udGVudC5yZXBsYWNlKC8jK1xccyovZywgJycpLnJlcGxhY2UoL1xcbisvZywgJyAnKS50cmltKCk7XG4gICAgcmV0dXJuIGNsZWFuZWQubGVuZ3RoID4gbWF4TGVuZ3RoID8gY2xlYW5lZC5zdWJzdHJpbmcoMCwgbWF4TGVuZ3RoKSArICcuLi4nIDogY2xlYW5lZDtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdEhpZ2hsaWdodHMoY29udGVudDogc3RyaW5nLCBxdWVyeTogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHdvcmRzID0gcXVlcnkudG9Mb3dlckNhc2UoKS5zcGxpdCgvXFxzKy8pO1xuICAgIGNvbnN0IGhpZ2hsaWdodHM6IHN0cmluZ1tdID0gW107XG4gICAgXG4gICAgZm9yIChjb25zdCB3b3JkIG9mIHdvcmRzKSB7XG4gICAgICBjb25zdCBjb250ZXh0cyA9IHRoaXMuZmluZFdvcmRDb250ZXh0KGNvbnRlbnQsIHdvcmQpO1xuICAgICAgaGlnaGxpZ2h0cy5wdXNoKC4uLmNvbnRleHRzKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhpZ2hsaWdodHMuc2xpY2UoMCwgMyk7XG4gIH1cblxuICBwcml2YXRlIGZpbmRXb3JkQ29udGV4dChjb250ZW50OiBzdHJpbmcsIHdvcmQ6IHN0cmluZywgY29udGV4dExlbmd0aCA9IDUwKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXGIke3dvcmR9XFxcXGJgLCAnZ2knKTtcbiAgICBjb25zdCBtYXRjaGVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCBtYXRjaDtcblxuICAgIHdoaWxlICgobWF0Y2ggPSByZWdleC5leGVjKGNvbnRlbnQpKSAhPT0gbnVsbCAmJiBtYXRjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgbWF0Y2guaW5kZXggLSBjb250ZXh0TGVuZ3RoKTtcbiAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGNvbnRlbnQubGVuZ3RoLCBtYXRjaC5pbmRleCArIHdvcmQubGVuZ3RoICsgY29udGV4dExlbmd0aCk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICBtYXRjaGVzLnB1c2goY29udGV4dC50cmltKCkpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZUNhY2hlS2V5KG9wdGlvbnM6IFNlYXJjaE9wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBxdWVyeTogb3B0aW9ucy5xdWVyeSxcbiAgICAgIHNlYXJjaFR5cGU6IG9wdGlvbnMuc2VhcmNoVHlwZSxcbiAgICAgIHVzZVJlcmFuazogb3B0aW9ucy51c2VSZXJhbmssXG4gICAgICBmaWxlVHlwZXM6IG9wdGlvbnMuZmlsZVR5cGVzLFxuICAgICAgdGFnczogb3B0aW9ucy50YWdzLFxuICAgICAgZm9sZGVyczogb3B0aW9ucy5mb2xkZXJzXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFkZFRvSGlzdG9yeShxdWVyeTogc3RyaW5nLCByZXN1bHRDb3VudDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5zZWFyY2hIaXN0b3J5LnVuc2hpZnQoe1xuICAgICAgcXVlcnksXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHJlc3VsdENvdW50XG4gICAgfSk7XG5cbiAgICAvLyBLZWVwIG9ubHkgbGFzdCAxMDAgc2VhcmNoZXNcbiAgICB0aGlzLnNlYXJjaEhpc3RvcnkgPSB0aGlzLnNlYXJjaEhpc3Rvcnkuc2xpY2UoMCwgMTAwKTtcbiAgICB0aGlzLnNhdmVTZWFyY2hIaXN0b3J5KCk7XG4gIH1cblxuICAvLyBTYXZlZCBzZWFyY2hlcyBtYW5hZ2VtZW50XG4gIHNhdmVTZWFyY2gobmFtZTogc3RyaW5nLCBxdWVyeTogc3RyaW5nLCBvcHRpb25zOiBTZWFyY2hPcHRpb25zLCBmaWx0ZXJzOiBTZWFyY2hGaWx0ZXJbXSA9IFtdKTogdm9pZCB7XG4gICAgY29uc3Qgc2F2ZWRTZWFyY2g6IFNhdmVkU2VhcmNoID0ge1xuICAgICAgaWQ6IGBzZWFyY2hfJHtEYXRlLm5vdygpfWAsXG4gICAgICBuYW1lLFxuICAgICAgcXVlcnksXG4gICAgICBvcHRpb25zLFxuICAgICAgZmlsdGVycyxcbiAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGxhc3RVc2VkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICB1c2VDb3VudDogMFxuICAgIH07XG5cbiAgICB0aGlzLnNhdmVkU2VhcmNoZXMuc2V0KHNhdmVkU2VhcmNoLmlkLCBzYXZlZFNlYXJjaCk7XG4gICAgdGhpcy5zYXZlU2F2ZWRTZWFyY2hlcygpO1xuICB9XG5cbiAgZ2V0U2F2ZWRTZWFyY2hlcygpOiBTYXZlZFNlYXJjaFtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnNhdmVkU2VhcmNoZXMudmFsdWVzKCkpXG4gICAgICAuc29ydCgoYSwgYikgPT4gbmV3IERhdGUoYi5sYXN0VXNlZCkuZ2V0VGltZSgpIC0gbmV3IERhdGUoYS5sYXN0VXNlZCkuZ2V0VGltZSgpKTtcbiAgfVxuXG4gIGFzeW5jIGV4ZWN1dGVTYXZlZFNlYXJjaChzZWFyY2hJZDogc3RyaW5nKTogUHJvbWlzZTxTZWFyY2hSZXN1bHRbXT4ge1xuICAgIGNvbnN0IHNhdmVkU2VhcmNoID0gdGhpcy5zYXZlZFNlYXJjaGVzLmdldChzZWFyY2hJZCk7XG4gICAgaWYgKCFzYXZlZFNlYXJjaCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYXZlZCBzZWFyY2ggbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgc2F2ZWRTZWFyY2gubGFzdFVzZWQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgc2F2ZWRTZWFyY2gudXNlQ291bnQrKztcbiAgICB0aGlzLnNhdmVTYXZlZFNlYXJjaGVzKCk7XG5cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZWFyY2goc2F2ZWRTZWFyY2gub3B0aW9ucyk7XG4gIH1cblxuICBkZWxldGVTYXZlZFNlYXJjaChzZWFyY2hJZDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zYXZlZFNlYXJjaGVzLmRlbGV0ZShzZWFyY2hJZCk7XG4gICAgdGhpcy5zYXZlU2F2ZWRTZWFyY2hlcygpO1xuICB9XG5cbiAgZ2V0U2VhcmNoSGlzdG9yeSgpOiBBcnJheTx7cXVlcnk6IHN0cmluZzsgdGltZXN0YW1wOiBzdHJpbmc7IHJlc3VsdENvdW50OiBudW1iZXJ9PiB7XG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoSGlzdG9yeTtcbiAgfVxuXG4gIGNsZWFyU2VhcmNoSGlzdG9yeSgpOiB2b2lkIHtcbiAgICB0aGlzLnNlYXJjaEhpc3RvcnkgPSBbXTtcbiAgICB0aGlzLnNhdmVTZWFyY2hIaXN0b3J5KCk7XG4gIH1cblxuICAvLyBQZXJzaXN0ZW5jZSBtZXRob2RzXG4gIHByaXZhdGUgbG9hZFNhdmVkU2VhcmNoZXMoKTogdm9pZCB7XG4gICAgY29uc3Qgc2F2ZWQgPSB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zYXZlZFNlYXJjaGVzIHx8IFtdO1xuICAgIHNhdmVkLmZvckVhY2goKHNlYXJjaDogU2F2ZWRTZWFyY2gpID0+IHtcbiAgICAgIHRoaXMuc2F2ZWRTZWFyY2hlcy5zZXQoc2VhcmNoLmlkLCBzZWFyY2gpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzYXZlU2F2ZWRTZWFyY2hlcygpOiB2b2lkIHtcbiAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zYXZlZFNlYXJjaGVzID0gQXJyYXkuZnJvbSh0aGlzLnNhdmVkU2VhcmNoZXMudmFsdWVzKCkpO1xuICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICB9XG5cbiAgcHJpdmF0ZSBzYXZlU2VhcmNoSGlzdG9yeSgpOiB2b2lkIHtcbiAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5zZWFyY2hIaXN0b3J5ID0gdGhpcy5zZWFyY2hIaXN0b3J5O1xuICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICB9XG5cbiAgLy8gQW5hbHl0aWNzXG4gIGdldFNlYXJjaEFuYWx5dGljcygpOiB7XG4gICAgdG90YWxTZWFyY2hlczogbnVtYmVyO1xuICAgIHRvcFF1ZXJpZXM6IEFycmF5PHtxdWVyeTogc3RyaW5nOyBjb3VudDogbnVtYmVyfT47XG4gICAgYXZlcmFnZVJlc3VsdHM6IG51bWJlcjtcbiAgICBzZWFyY2hUeXBlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgfSB7XG4gICAgY29uc3QgcXVlcnlDb3VudCA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG4gICAgbGV0IHRvdGFsUmVzdWx0cyA9IDA7XG5cbiAgICB0aGlzLnNlYXJjaEhpc3RvcnkuZm9yRWFjaChzZWFyY2ggPT4ge1xuICAgICAgcXVlcnlDb3VudC5zZXQoc2VhcmNoLnF1ZXJ5LCAocXVlcnlDb3VudC5nZXQoc2VhcmNoLnF1ZXJ5KSB8fCAwKSArIDEpO1xuICAgICAgdG90YWxSZXN1bHRzICs9IHNlYXJjaC5yZXN1bHRDb3VudDtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRvcFF1ZXJpZXMgPSBBcnJheS5mcm9tKHF1ZXJ5Q291bnQuZW50cmllcygpKVxuICAgICAgLm1hcCgoW3F1ZXJ5LCBjb3VudF0pID0+ICh7IHF1ZXJ5LCBjb3VudCB9KSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmNvdW50IC0gYS5jb3VudClcbiAgICAgIC5zbGljZSgwLCAxMCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxTZWFyY2hlczogdGhpcy5zZWFyY2hIaXN0b3J5Lmxlbmd0aCxcbiAgICAgIHRvcFF1ZXJpZXMsXG4gICAgICBhdmVyYWdlUmVzdWx0czogdGhpcy5zZWFyY2hIaXN0b3J5Lmxlbmd0aCA+IDAgPyB0b3RhbFJlc3VsdHMgLyB0aGlzLnNlYXJjaEhpc3RvcnkubGVuZ3RoIDogMCxcbiAgICAgIHNlYXJjaFR5cGVzOiB7XG4gICAgICAgIHNlbWFudGljOiAwLFxuICAgICAgICBrZXl3b3JkOiAwLFxuICAgICAgICBoeWJyaWQ6IDAsXG4gICAgICAgIGFpX2VuaGFuY2VkOiAwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNsZWFyQ2FjaGUoKTogdm9pZCB7XG4gICAgdGhpcy5zZWFyY2hDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IE1vZGFsLCBBcHAsIFNldHRpbmcgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBTZWFyY2hSZXN1bHQgfSBmcm9tICcuL2VuaGFuY2VkLXNlYXJjaCc7XG5cbmV4cG9ydCBjbGFzcyBTZWFyY2hSZXN1bHRzTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwcml2YXRlIHJlc3VsdHM6IFNlYXJjaFJlc3VsdFtdKSB7XG4gICAgc3VwZXIoYXBwKTtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJoMlwiLCB7IHRleHQ6IGBTZWFyY2ggUmVzdWx0cyAoJHt0aGlzLnJlc3VsdHMubGVuZ3RofSlgIH0pO1xuXG4gICAgaWYgKHRoaXMucmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRlbnRFbC5jcmVhdGVFbChcInBcIiwgeyB0ZXh0OiBcIk5vIHJlc3VsdHMgZm91bmQuXCIgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0c0NvbnRhaW5lciA9IGNvbnRlbnRFbC5jcmVhdGVFbChcImRpdlwiLCB7IGNsczogXCJzZWFyY2gtcmVzdWx0cy1jb250YWluZXJcIiB9KTtcblxuICAgIHRoaXMucmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRFbCA9IHJlc3VsdHNDb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwic2VhcmNoLXJlc3VsdC1pdGVtXCIgfSk7XG4gICAgICBcbiAgICAgIC8vIFRpdGxlIGFuZCBzY29yZVxuICAgICAgY29uc3QgaGVhZGVyID0gcmVzdWx0RWwuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwicmVzdWx0LWhlYWRlclwiIH0pO1xuICAgICAgY29uc3QgdGl0bGUgPSBoZWFkZXIuY3JlYXRlRWwoXCJoM1wiLCB7IHRleHQ6IHJlc3VsdC50aXRsZSwgY2xzOiBcInJlc3VsdC10aXRsZVwiIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzdWx0LmZpbGUpIHtcbiAgICAgICAgdGl0bGUub25jbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoJ3RhYicpO1xuICAgICAgICAgIGF3YWl0IGxlYWYub3BlbkZpbGUocmVzdWx0LmZpbGUhKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRpdGxlLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgdGl0bGUuc3R5bGUuY29sb3IgPSAndmFyKC0tdGV4dC1hY2NlbnQpJztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc2NvcmVFbCA9IGhlYWRlci5jcmVhdGVFbChcInNwYW5cIiwgeyBjbHM6IFwicmVzdWx0LXNjb3JlXCIgfSk7XG4gICAgICBpZiAocmVzdWx0LnJlcmFua1Njb3JlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2NvcmVFbC5zZXRUZXh0KGBTY29yZTogJHtyZXN1bHQuc2NvcmUudG9GaXhlZCgzKX0gfCBSZXJhbms6ICR7cmVzdWx0LnJlcmFua1Njb3JlLnRvRml4ZWQoMyl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY29yZUVsLnNldFRleHQoYFNjb3JlOiAke3Jlc3VsdC5zY29yZS50b0ZpeGVkKDMpfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDb250ZW50IHByZXZpZXdcbiAgICAgIGNvbnN0IGNvbnRlbnRFbCA9IHJlc3VsdEVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcInJlc3VsdC1jb250ZW50XCIgfSk7XG4gICAgICBjb25zdCBwcmV2aWV3ID0gcmVzdWx0LmNvbnRlbnQubGVuZ3RoID4gMjAwIFxuICAgICAgICA/IHJlc3VsdC5jb250ZW50LnN1YnN0cmluZygwLCAyMDApICsgJy4uLidcbiAgICAgICAgOiByZXN1bHQuY29udGVudDtcbiAgICAgIGNvbnRlbnRFbC5zZXRUZXh0KHByZXZpZXcpO1xuICAgICAgXG4gICAgICAvLyBNZXRhZGF0YVxuICAgICAgaWYgKHJlc3VsdC5tZXRhZGF0YS5oaWdobGlnaHRzICYmIHJlc3VsdC5tZXRhZGF0YS5oaWdobGlnaHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgaGlnaGxpZ2h0c0VsID0gcmVzdWx0RWwuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwicmVzdWx0LWhpZ2hsaWdodHNcIiB9KTtcbiAgICAgICAgaGlnaGxpZ2h0c0VsLmNyZWF0ZUVsKFwic3Ryb25nXCIsIHsgdGV4dDogXCJIaWdobGlnaHRzOiBcIiB9KTtcbiAgICAgICAgcmVzdWx0Lm1ldGFkYXRhLmhpZ2hsaWdodHMuZm9yRWFjaChoaWdobGlnaHQgPT4ge1xuICAgICAgICAgIGhpZ2hsaWdodHNFbC5jcmVhdGVFbChcInNwYW5cIiwgeyBcbiAgICAgICAgICAgIHRleHQ6IGBcIiR7aGlnaGxpZ2h0fVwiIGAsXG4gICAgICAgICAgICBjbHM6IFwiaGlnaGxpZ2h0LXNuaXBwZXRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRmlsZSBpbmZvXG4gICAgICBpZiAocmVzdWx0Lm1ldGFkYXRhLnBhdGgpIHtcbiAgICAgICAgY29uc3QgcGF0aEVsID0gcmVzdWx0RWwuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwicmVzdWx0LXBhdGhcIiB9KTtcbiAgICAgICAgcGF0aEVsLnNldFRleHQoYFBhdGg6ICR7cmVzdWx0Lm1ldGFkYXRhLnBhdGh9YCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDbG9zZSBidXR0b25cbiAgICBjb25zdCBidXR0b25Db250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwibW9kYWwtYnV0dG9uLWNvbnRhaW5lclwiIH0pO1xuICAgIGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiLCB7IHRleHQ6IFwiQ2xvc2VcIiB9KS5vbmNsaWNrID0gKCkgPT4gdGhpcy5jbG9zZSgpO1xuICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUFBLG1CQWNPO0FBQ1Asa0JBQTZCO0FBQzdCLHVCQUFvQztBQUNwQyw0QkFBNkI7OztBQ0F0QixJQUFNLHVCQUFOLE1BQTJCO0FBQUE7QUFBQSxFQVFoQyxZQUFvQixRQUFxQjtBQUFyQjtBQVBwQixTQUFRLFFBQVEsb0JBQUksSUFBd0I7QUFDNUMsU0FBUSxhQUF5QixDQUFDO0FBQ2xDLFNBQVEsZUFBZTtBQUN2QixTQUFpQixZQUFZLElBQUksS0FBSztBQUN0QztBQUFBLFNBQWlCLGFBQWE7QUFDOUIsU0FBaUIsY0FBYztBQWtML0I7QUFBQSxTQUFRLHlCQUF5QixvQkFBSSxJQUE0QjtBQXNIakU7QUFBQSxTQUFRLHFCQUFxQjtBQUFBLE1BQzNCLG1CQUFtQjtBQUFBLE1BQ25CLFdBQVc7QUFBQSxNQUNYLGFBQWE7QUFBQSxNQUNiLG9CQUFvQjtBQUFBLE1BQ3BCLHFCQUFxQjtBQUFBLElBQ3ZCO0FBM1NFLFNBQUssb0JBQW9CO0FBQ3pCLFNBQUssa0JBQWtCO0FBQUEsRUFDekI7QUFBQTtBQUFBLEVBR0EsU0FBUyxLQUFhLE1BQVcsTUFBYyxLQUFLLFdBQWlCO0FBQ25FLFNBQUssTUFBTSxJQUFJLEtBQUs7QUFBQSxNQUNsQjtBQUFBLE1BQ0EsV0FBVyxLQUFLLElBQUk7QUFBQSxNQUNwQjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVBLFNBQVMsS0FBeUI7QUFDaEMsVUFBTSxRQUFRLEtBQUssTUFBTSxJQUFJLEdBQUc7QUFDaEMsUUFBSSxDQUFDO0FBQU8sYUFBTztBQUVuQixRQUFJLEtBQUssSUFBSSxJQUFJLE1BQU0sWUFBWSxNQUFNLEtBQUs7QUFDNUMsV0FBSyxNQUFNLE9BQU8sR0FBRztBQUNyQixhQUFPO0FBQUEsSUFDVDtBQUVBLFdBQU8sTUFBTTtBQUFBLEVBQ2Y7QUFBQSxFQUVBLGFBQW1CO0FBQ2pCLFNBQUssTUFBTSxNQUFNO0FBQUEsRUFDbkI7QUFBQTtBQUFBLEVBR0EsTUFBTSxhQUFhLE1BQXFDO0FBQ3RELFVBQU0sV0FBVyxRQUFRLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxLQUFLO0FBQ3JELFVBQU0sU0FBUyxLQUFLLFNBQVMsUUFBUTtBQUNyQyxRQUFJO0FBQVEsYUFBTztBQUduQixRQUFJLEtBQUssS0FBSyxPQUFPLEtBQUssT0FBTyxvQkFBb0IsV0FBVyxhQUFhLGtCQUFrQixlQUFlO0FBQzVHLGNBQVEsS0FBSyxRQUFRLEtBQUssSUFBSSxzQkFBc0I7QUFDcEQsYUFBTztBQUFBLElBQ1Q7QUFFQSxRQUFJO0FBQ0YsWUFBTSxVQUFVLE1BQU0sS0FBSyxPQUFPLElBQUksTUFBTSxLQUFLLElBQUk7QUFDckQsV0FBSyxTQUFTLFVBQVUsT0FBTztBQUMvQixhQUFPO0FBQUEsSUFDVCxTQUFTLEdBQUc7QUFDVixjQUFRLE1BQU0sdUJBQXVCLEtBQUssSUFBSSxLQUFLLENBQUM7QUFDcEQsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQUE7QUFBQSxFQUdBLFdBQVcsS0FBaUQ7QUFDMUQsVUFBTSxLQUFLLEdBQUcsSUFBSSxJQUFJLElBQUksS0FBSyxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sRUFBRSxTQUFTLEVBQUUsRUFBRSxPQUFPLEdBQUcsQ0FBQyxDQUFDO0FBQy9FLFVBQU0sV0FBcUI7QUFBQSxNQUN6QixHQUFHO0FBQUEsTUFDSDtBQUFBLE1BQ0EsV0FBVyxLQUFLLElBQUk7QUFBQSxJQUN0QjtBQUVBLFNBQUssV0FBVyxLQUFLLFFBQVE7QUFDN0IsU0FBSyxXQUFXLEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxXQUFXLEVBQUUsUUFBUTtBQUV0RCxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRVEsc0JBQTRCO0FBQ2xDLGdCQUFZLFlBQVk7QUFDdEIsVUFBSSxLQUFLLGdCQUFnQixLQUFLLFdBQVcsV0FBVztBQUFHO0FBRXZELFdBQUssZUFBZTtBQUNwQixZQUFNLFFBQVEsS0FBSyxXQUFXLE9BQU8sR0FBRyxLQUFLLFVBQVU7QUFFdkQsVUFBSTtBQUNGLGNBQU0sS0FBSyxhQUFhLEtBQUs7QUFBQSxNQUMvQixTQUFTLEdBQUc7QUFDVixnQkFBUSxNQUFNLDRCQUE0QixDQUFDO0FBQUEsTUFDN0MsVUFBRTtBQUNBLGFBQUssZUFBZTtBQUFBLE1BQ3RCO0FBQUEsSUFDRixHQUFHLEtBQUssV0FBVztBQUFBLEVBQ3JCO0FBQUEsRUFFQSxNQUFjLGFBQWEsTUFBaUM7QUFDMUQsVUFBTSxnQkFBZ0IsS0FBSyxPQUFPLFNBQU8sSUFBSSxTQUFTLFdBQVc7QUFDakUsVUFBTSxlQUFlLEtBQUssT0FBTyxTQUFPLElBQUksU0FBUyxVQUFVO0FBQy9ELFVBQU0sV0FBVyxLQUFLLE9BQU8sU0FBTyxJQUFJLFNBQVMsTUFBTTtBQUd2RCxRQUFJLGNBQWMsU0FBUyxHQUFHO0FBQzVCLFlBQU0sS0FBSyxzQkFBc0IsYUFBYTtBQUFBLElBQ2hEO0FBR0EsUUFBSSxhQUFhLFNBQVMsR0FBRztBQUMzQixZQUFNLEtBQUsscUJBQXFCLFlBQVk7QUFBQSxJQUM5QztBQUdBLFFBQUksU0FBUyxTQUFTLEdBQUc7QUFDdkIsWUFBTSxLQUFLLGlCQUFpQixRQUFRO0FBQUEsSUFDdEM7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLHNCQUFzQixNQUFpQztBQUNuRSxVQUFNLGdCQUFnQixLQUFLLE9BQU8sb0JBQW9CLGFBQWEsMkJBQTJCO0FBQzlGLFVBQU0sU0FBUyxLQUFLLFdBQVcsTUFBTSxhQUFhO0FBRWxELGVBQVcsU0FBUyxRQUFRO0FBQzFCLFlBQU0sV0FBVyxNQUFNLElBQUksT0FBTyxRQUFRO0FBQ3hDLFlBQUk7QUFDRixnQkFBTSxZQUFZLE1BQU0sS0FBSyxPQUFPLFdBQVcsV0FBVyxJQUFJLEtBQUssSUFBSTtBQUd2RSxnQkFBTSxXQUFXLGFBQWEsS0FBSyxXQUFXLElBQUksS0FBSyxJQUFJLENBQUM7QUFDNUQsZUFBSyxTQUFTLFVBQVUsV0FBVyxLQUFLLEtBQUssS0FBSyxHQUFJO0FBR3RELGdCQUFNLEtBQUssT0FBTyxZQUFZLFFBQVE7QUFBQSxZQUNwQyxNQUFNLElBQUksS0FBSyxRQUFRO0FBQUEsWUFDdkIsU0FBUyxJQUFJLEtBQUs7QUFBQSxZQUNsQixTQUFTLElBQUksS0FBSyxXQUFXLENBQUM7QUFBQSxVQUNoQyxHQUFHLFNBQVM7QUFHWixnQkFBTSxLQUFLLE9BQU8sY0FBYztBQUFBLFlBQzlCLElBQUk7QUFBQSxZQUNKO0FBQUEsWUFDQSxJQUFJLEtBQUs7QUFBQSxVQUNYO0FBQUEsUUFFRixTQUFTLEdBQUc7QUFDVixrQkFBUSxNQUFNLG1DQUFtQyxJQUFJLEVBQUUsS0FBSyxDQUFDO0FBQUEsUUFDL0Q7QUFBQSxNQUNGLENBQUM7QUFFRCxZQUFNLFFBQVEsV0FBVyxRQUFRO0FBQUEsSUFDbkM7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLHFCQUFxQixNQUFpQztBQUNsRSxlQUFXLE9BQU8sTUFBTTtBQUN0QixVQUFJO0FBRUYsY0FBTSxLQUFLLGFBQWEsSUFBSSxJQUFJO0FBQUEsTUFDbEMsU0FBUyxHQUFHO0FBQ1YsZ0JBQVEsTUFBTSxrQ0FBa0MsSUFBSSxFQUFFLEtBQUssQ0FBQztBQUFBLE1BQzlEO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQWMsaUJBQWlCLE1BQWlDO0FBQzlELGVBQVcsT0FBTyxNQUFNO0FBQ3RCLFVBQUk7QUFFRixjQUFNLEtBQUssU0FBUyxJQUFJLElBQUk7QUFBQSxNQUM5QixTQUFTLEdBQUc7QUFDVixnQkFBUSxNQUFNLDhCQUE4QixJQUFJLEVBQUUsS0FBSyxDQUFDO0FBQUEsTUFDMUQ7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYyxhQUFhLE1BQTBCO0FBRW5ELFlBQVEsSUFBSSxxQkFBcUIsSUFBSTtBQUFBLEVBQ3ZDO0FBQUEsRUFFQSxNQUFjLFNBQVMsTUFBMEI7QUFFL0MsUUFBSSxLQUFLLE9BQU8sU0FBUyx1QkFBdUI7QUFDOUMsWUFBTSxLQUFLLE9BQU8sb0JBQW9CLEtBQUssSUFBSTtBQUFBLElBQ2pEO0FBQUEsRUFDRjtBQUFBLEVBS0EsdUJBQXVCLE1BQWEsUUFBZ0IsS0FBWTtBQUM5RCxVQUFNLFdBQVcsS0FBSyx1QkFBdUIsSUFBSSxLQUFLLElBQUk7QUFDMUQsUUFBSSxVQUFVO0FBQ1osbUJBQWEsUUFBUTtBQUFBLElBQ3ZCO0FBRUEsVUFBTSxVQUFVLFdBQVcsWUFBWTtBQUNyQyxZQUFNLEtBQUssa0JBQWtCLElBQUk7QUFDakMsV0FBSyx1QkFBdUIsT0FBTyxLQUFLLElBQUk7QUFBQSxJQUM5QyxHQUFHLEtBQUs7QUFFUixTQUFLLHVCQUF1QixJQUFJLEtBQUssTUFBTSxPQUFPO0FBQUEsRUFDcEQ7QUFBQSxFQUVBLE1BQWMsa0JBQWtCLE1BQTRCO0FBQzFELFVBQU0sVUFBVSxNQUFNLEtBQUssYUFBYSxJQUFJO0FBQzVDLFFBQUksQ0FBQztBQUFTO0FBR2QsVUFBTSxjQUFjLEtBQUssV0FBVyxPQUFPO0FBQzNDLFVBQU0sV0FBVyxLQUFLLE9BQU8sV0FBVyxJQUFJLEtBQUssSUFBSTtBQUVyRCxRQUFJLGFBQWE7QUFBYTtBQUc5QixTQUFLLFdBQVc7QUFBQSxNQUNkLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxRQUNKLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxRQUNOLFNBQVMsQ0FBQztBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sSUFBSSxLQUFLO0FBQUEsVUFDVCxhQUFhLEtBQUs7QUFBQSxRQUNwQixDQUFDO0FBQUEsTUFDSDtBQUFBLE1BQ0EsVUFBVTtBQUFBLElBQ1osQ0FBQztBQUVELFNBQUssT0FBTyxXQUFXLElBQUksS0FBSyxNQUFNLFdBQVc7QUFBQSxFQUNuRDtBQUFBO0FBQUEsRUFHQSxNQUFNLHNCQUFxQztBQUV6QyxTQUFLLGFBQWE7QUFHbEIsVUFBTSxLQUFLLGlCQUFpQjtBQUc1QixTQUFLLGtCQUFrQjtBQUd2QixRQUFJLFdBQU8sSUFBSTtBQUNiLGlCQUFPLEdBQUc7QUFBQSxJQUNaO0FBQUEsRUFDRjtBQUFBLEVBRVEsZUFBcUI7QUFDM0IsVUFBTSxNQUFNLEtBQUssSUFBSTtBQUNyQixlQUFXLENBQUMsS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLFFBQVEsR0FBRztBQUMvQyxVQUFJLE1BQU0sTUFBTSxZQUFZLE1BQU0sS0FBSztBQUNyQyxhQUFLLE1BQU0sT0FBTyxHQUFHO0FBQUEsTUFDdkI7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYyxtQkFBa0M7QUFDOUMsVUFBTSxRQUFRLE1BQU0sS0FBSyxPQUFPLFlBQVksS0FBSztBQUNqRCxVQUFNLFlBQVksS0FBSyxPQUFPLG9CQUFvQixXQUFXLGFBQWE7QUFHMUUsVUFBTSxRQUFRLE1BQU0sTUFBTSxPQUFPLFVBQVEsS0FBSyxjQUFjLFNBQVM7QUFHckUsVUFBTSxVQUFVLElBQUksSUFBSSxNQUFNLE1BQU0sSUFBSSxPQUFLLEVBQUUsRUFBRSxDQUFDO0FBQ2xELFVBQU0sUUFBUSxNQUFNLE1BQU07QUFBQSxNQUFPLFVBQy9CLFFBQVEsSUFBSSxLQUFLLElBQUksS0FBSyxRQUFRLElBQUksS0FBSyxFQUFFO0FBQUEsSUFDL0M7QUFFQSxVQUFNLEtBQUssT0FBTyxZQUFZLEtBQUssS0FBSztBQUFBLEVBQzFDO0FBQUEsRUFFUSxvQkFBMEI7QUFDaEMsVUFBTSxTQUFTLEtBQUssSUFBSSxJQUFLLEtBQUssS0FBSztBQUN2QyxTQUFLLGFBQWEsS0FBSyxXQUFXLE9BQU8sU0FBTyxJQUFJLFlBQVksTUFBTTtBQUFBLEVBQ3hFO0FBQUEsRUFFUSxvQkFBMEI7QUFFaEMsZ0JBQVksTUFBTTtBQUNoQixXQUFLLGFBQWE7QUFBQSxJQUNwQixHQUFHLEtBQUssS0FBSyxHQUFJO0FBQUEsRUFDbkI7QUFBQTtBQUFBLEVBR1EsV0FBYyxPQUFZLE1BQXFCO0FBQ3JELFVBQU0sU0FBZ0IsQ0FBQztBQUN2QixhQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLLE1BQU07QUFDM0MsYUFBTyxLQUFLLE1BQU0sTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDO0FBQUEsSUFDdEM7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRVEsV0FBVyxLQUFxQjtBQUN0QyxRQUFJLE9BQU87QUFDWCxhQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxLQUFLO0FBQ25DLFlBQU0sT0FBTyxJQUFJLFdBQVcsQ0FBQztBQUM3QixjQUFTLFFBQVEsS0FBSyxPQUFRO0FBQzlCLGFBQU8sT0FBTztBQUFBLElBQ2hCO0FBQ0EsV0FBTyxLQUFLLFNBQVM7QUFBQSxFQUN2QjtBQUFBLEVBV0EseUJBQStCO0FBQzdCLFNBQUssbUJBQW1CO0FBQUEsRUFDMUI7QUFBQSxFQUVBLGlCQUF1QjtBQUNyQixTQUFLLG1CQUFtQjtBQUFBLEVBQzFCO0FBQUEsRUFFQSxrQkFBd0I7QUFDdEIsU0FBSyxtQkFBbUI7QUFBQSxFQUMxQjtBQUFBLEVBRUEsMEJBQWdDO0FBQzlCLFNBQUssbUJBQW1CO0FBQUEsRUFDMUI7QUFBQSxFQUVBLHdCQUF3RDtBQUN0RCxXQUFPLEVBQUUsR0FBRyxLQUFLLG1CQUFtQjtBQUFBLEVBQ3RDO0FBQUEsRUFFQSxnQkFBbUQ7QUFDakQsVUFBTSxRQUFRLEtBQUssbUJBQW1CLFlBQVksS0FBSyxtQkFBbUI7QUFDMUUsVUFBTSxVQUFVLFFBQVEsSUFBSSxLQUFLLG1CQUFtQixZQUFZLFFBQVE7QUFFeEUsV0FBTztBQUFBLE1BQ0wsTUFBTSxLQUFLLE1BQU07QUFBQSxNQUNqQixTQUFTLEtBQUssTUFBTSxVQUFVLEdBQUcsSUFBSTtBQUFBLElBQ3ZDO0FBQUEsRUFDRjtBQUFBO0FBQUEsRUFHQSxVQUFnQjtBQUVkLGVBQVcsV0FBVyxLQUFLLHVCQUF1QixPQUFPLEdBQUc7QUFDMUQsbUJBQWEsT0FBTztBQUFBLElBQ3RCO0FBQ0EsU0FBSyx1QkFBdUIsTUFBTTtBQUdsQyxTQUFLLFdBQVc7QUFHaEIsU0FBSyxhQUFhLENBQUM7QUFBQSxFQUNyQjtBQUNGOzs7QUNuWEEsc0JBQThDO0FBc0J2QyxJQUFNLG1CQUFOLE1BQXVCO0FBQUEsRUFDNUIsWUFBb0IsUUFBcUI7QUFBckI7QUFBQSxFQUFzQjtBQUFBO0FBQUEsRUFHMUMsTUFBTSx5QkFBeUIsU0FBOEM7QUFDM0UsVUFBTSxjQUFpQyxDQUFDO0FBQ3hDLFVBQU0sUUFBUSxNQUFNLEtBQUssT0FBTyxZQUFZLEtBQUs7QUFDakQsVUFBTSxhQUFhLEtBQUssT0FBTyxJQUFJLFVBQVUsY0FBYztBQUczRCxVQUFNLGtCQUFrQixNQUFNLEtBQUssd0JBQXdCLE9BQU8sVUFBVTtBQUM1RSxnQkFBWSxLQUFLLEdBQUcsZUFBZTtBQUduQyxVQUFNLHdCQUF3QixNQUFNLEtBQUssOEJBQThCLE9BQU8sVUFBVTtBQUN4RixnQkFBWSxLQUFLLEdBQUcscUJBQXFCO0FBR3pDLFVBQU0sc0JBQXNCLE1BQU0sS0FBSyw0QkFBNEIsT0FBTztBQUMxRSxnQkFBWSxLQUFLLEdBQUcsbUJBQW1CO0FBRXZDLFdBQU8sWUFBWSxLQUFLLENBQUMsR0FBRyxNQUFNLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxNQUFNLEdBQUcsRUFBRTtBQUFBLEVBQzVFO0FBQUEsRUFFQSxNQUFjLHdCQUF3QixPQUFZLFlBQXNEO0FBQ3RHLFVBQU0sY0FBaUMsQ0FBQztBQUN4QyxVQUFNLFlBQVksTUFBTSxNQUFNLE9BQU8sQ0FBQyxNQUFXLEVBQUUsU0FBUyxNQUFNO0FBR2xFLFVBQU0sZUFBZSxVQUFVLE9BQU8sQ0FBQyxTQUFjO0FBQ25ELFlBQU0sVUFBVSxLQUFLLFlBQVk7QUFDakMsYUFBTyxXQUFXLElBQUksS0FBSyxPQUFPLElBQUksb0JBQUksS0FBSztBQUFBLElBQ2pELENBQUM7QUFFRCxlQUFXLFFBQVEsYUFBYSxNQUFNLEdBQUcsQ0FBQyxHQUFHO0FBQzNDLGtCQUFZLEtBQUs7QUFBQSxRQUNmLElBQUksV0FBVyxLQUFLLEVBQUU7QUFBQSxRQUN0QixNQUFNO0FBQUEsUUFDTixPQUFPLDBCQUEwQixLQUFLLE9BQU87QUFBQSxRQUM3QyxhQUFhLHdCQUF3QixLQUFLLFdBQVcsUUFBUTtBQUFBLFFBQzdELFlBQVk7QUFBQSxRQUNaLFFBQVEsWUFBWTtBQUNsQixnQkFBTSxLQUFLLGVBQWUsSUFBSTtBQUFBLFFBQ2hDO0FBQUEsUUFDQSxVQUFVLEVBQUUsUUFBUSxLQUFLLElBQUksTUFBTSxVQUFVO0FBQUEsTUFDL0MsQ0FBQztBQUFBLElBQ0g7QUFHQSxVQUFNLFlBQVksS0FBSyxxQkFBcUIsT0FBTyxTQUFTO0FBQzVELGVBQVcsUUFBUSxVQUFVLE1BQU0sR0FBRyxDQUFDLEdBQUc7QUFDeEMsa0JBQVksS0FBSztBQUFBLFFBQ2YsSUFBSSxRQUFRLEtBQUssRUFBRTtBQUFBLFFBQ25CLE1BQU07QUFBQSxRQUNOLE9BQU8sbUJBQW1CLEtBQUssT0FBTztBQUFBLFFBQ3RDLGFBQWE7QUFBQSxRQUNiLFlBQVk7QUFBQSxRQUNaLFFBQVEsWUFBWTtBQUNsQixnQkFBTSxLQUFLLGVBQWUsSUFBSTtBQUFBLFFBQ2hDO0FBQUEsUUFDQSxVQUFVLEVBQUUsUUFBUSxLQUFLLElBQUksTUFBTSxRQUFRO0FBQUEsTUFDN0MsQ0FBQztBQUFBLElBQ0g7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsTUFBYyw4QkFBOEIsT0FBWSxZQUFzRDtBQUM1RyxVQUFNLGNBQWlDLENBQUM7QUFFeEMsUUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLE9BQU87QUFBWSxhQUFPO0FBRW5ELFFBQUk7QUFDRixZQUFNLFVBQVUsTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLEtBQUssVUFBVTtBQUMzRCxZQUFNLFlBQVksTUFBTSxLQUFLLE9BQU8sV0FBVyxXQUFXLFFBQVEsVUFBVSxHQUFHLEdBQUcsQ0FBQztBQUNuRixZQUFNLGVBQWUsTUFBTSxLQUFLLGlCQUFpQixPQUFPLFNBQVM7QUFFakUsaUJBQVcsUUFBUSxhQUFhLE1BQU0sR0FBRyxDQUFDLEdBQUc7QUFDM0MsWUFBSSxLQUFLLFVBQVUsQ0FBQyxHQUFHLE9BQU8sV0FBVyxNQUFNO0FBQzdDLHNCQUFZLEtBQUs7QUFBQSxZQUNmLElBQUksV0FBVyxLQUFLLEVBQUU7QUFBQSxZQUN0QixNQUFNO0FBQUEsWUFDTixPQUFPLGVBQWUsS0FBSyxPQUFPO0FBQUEsWUFDbEMsYUFBYSwyQkFBMkIsS0FBSyxhQUFhLEtBQUssUUFBUSxDQUFDLENBQUM7QUFBQSxZQUN6RSxZQUFZLEtBQUs7QUFBQSxZQUNqQixRQUFRLFlBQVk7QUFDbEIsb0JBQU0sS0FBSyxpQkFBaUIsWUFBWSxJQUFJO0FBQUEsWUFDOUM7QUFBQSxZQUNBLFVBQVUsRUFBRSxRQUFRLEtBQUssSUFBSSxZQUFZLEtBQUssV0FBVztBQUFBLFVBQzNELENBQUM7QUFBQSxRQUNIO0FBQUEsTUFDRjtBQUFBLElBQ0YsU0FBUyxHQUFHO0FBQ1YsY0FBUSxNQUFNLDhDQUE4QyxDQUFDO0FBQUEsSUFDL0Q7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsTUFBYyw0QkFBNEIsU0FBOEM7QUFDdEYsVUFBTSxjQUFpQyxDQUFDO0FBQ3hDLFVBQU0sUUFBUSxNQUFNLEtBQUssT0FBTyxZQUFZLEtBQUs7QUFHakQsVUFBTSxPQUFPLEtBQUssc0JBQXNCLEtBQUs7QUFDN0MsZUFBVyxPQUFPLEtBQUssTUFBTSxHQUFHLENBQUMsR0FBRztBQUNsQyxrQkFBWSxLQUFLO0FBQUEsUUFDZixJQUFJLFlBQVksSUFBSSxLQUFLO0FBQUEsUUFDekIsTUFBTTtBQUFBLFFBQ04sT0FBTyxhQUFhLElBQUksS0FBSztBQUFBLFFBQzdCLGFBQWEsU0FBUyxJQUFJLFFBQVE7QUFBQSxRQUNsQyxZQUFZO0FBQUEsUUFDWixRQUFRLFlBQVk7QUFDbEIsZ0JBQU0sS0FBSyxtQkFBbUIsSUFBSSxLQUFLO0FBQUEsUUFDekM7QUFBQSxRQUNBLFVBQVUsRUFBRSxPQUFPLElBQUksT0FBTyxVQUFVLElBQUksU0FBUztBQUFBLE1BQ3ZELENBQUM7QUFBQSxJQUNIO0FBRUEsV0FBTztBQUFBLEVBQ1Q7QUFBQTtBQUFBLEVBR0EsTUFBTSwyQkFBMkIsWUFBa0Q7QUFDakYsVUFBTSxXQUFnQyxDQUFDO0FBQ3ZDLFVBQU0sUUFBUSxNQUFNLEtBQUssT0FBTyxZQUFZLEtBQUs7QUFHakQsVUFBTSxXQUFXLEtBQUssZUFBZSxLQUFLO0FBQzFDLGFBQVMsS0FBSyxHQUFHLFFBQVE7QUFHekIsVUFBTSxPQUFPLEtBQUssc0JBQXNCLEtBQUs7QUFDN0MsYUFBUyxLQUFLLEdBQUcsS0FBSyxJQUFJLFVBQVE7QUFBQSxNQUNoQyxNQUFNO0FBQUEsTUFDTixPQUFPLGtCQUFrQixJQUFJLEtBQUs7QUFBQSxNQUNsQyxhQUFhLG1CQUFtQixJQUFJLFFBQVE7QUFBQSxNQUM1QyxXQUFXLElBQUksV0FBVztBQUFBLE1BQzFCLFNBQVMsSUFBSTtBQUFBLE1BQ2IsYUFBYTtBQUFBLFFBQ1gsWUFBWSxJQUFJLEtBQUs7QUFBQSxRQUNyQixxQ0FBcUMsSUFBSSxLQUFLO0FBQUEsUUFDOUMsZ0NBQWdDLElBQUksS0FBSztBQUFBLE1BQzNDO0FBQUEsSUFDRixFQUFFLENBQUM7QUFHSCxVQUFNLFNBQVMsS0FBSyxlQUFlLEtBQUs7QUFDeEMsYUFBUyxLQUFLLEdBQUcsTUFBTTtBQUV2QixXQUFPLFNBQVMsS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLFlBQVksRUFBRSxTQUFTO0FBQUEsRUFDMUQ7QUFBQSxFQUVRLGVBQWUsT0FBaUM7QUFDdEQsVUFBTSxXQUFnQyxDQUFDO0FBR3ZDLFVBQU0sU0FBUyxLQUFLLGNBQWMsS0FBSztBQUN2QyxlQUFXLFNBQVMsT0FBTyxNQUFNLEdBQUcsQ0FBQyxHQUFHO0FBQ3RDLGVBQVMsS0FBSztBQUFBLFFBQ1osTUFBTTtBQUFBLFFBQ04sT0FBTyxvQkFBb0IsTUFBTSxJQUFJO0FBQUEsUUFDckMsYUFBYSxjQUFjLE1BQU0sU0FBUztBQUFBLFFBQzFDLFdBQVcsTUFBTSxZQUFZLE1BQU0sTUFBTTtBQUFBLFFBQ3pDLFNBQVMsTUFBTTtBQUFBLFFBQ2YsYUFBYTtBQUFBLFVBQ1gsNEJBQTRCLE1BQU0sSUFBSTtBQUFBLFVBQ3RDLDZCQUE2QixNQUFNLEtBQUssWUFBWSxDQUFDO0FBQUEsVUFDckQsK0JBQStCLE1BQU0sSUFBSTtBQUFBLFFBQzNDO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQUVBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFUSxlQUFlLE9BQWlDO0FBQ3RELFVBQU0sU0FBOEIsQ0FBQztBQUNyQyxVQUFNLGNBQWMsTUFBTSxNQUFNLE9BQU8sQ0FBQyxNQUFXO0FBQ2pELFlBQU0sVUFBVSxJQUFJLEtBQUssRUFBRSxVQUFVLFVBQVU7QUFDL0MsWUFBTSxVQUFVLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssS0FBSyxLQUFLLEdBQUk7QUFDN0QsYUFBTyxVQUFVO0FBQUEsSUFDbkIsQ0FBQztBQUVELFFBQUksWUFBWSxTQUFTLEdBQUc7QUFDMUIsWUFBTSxjQUFjLEtBQUssWUFBWSxXQUFXO0FBQ2hELFlBQU0saUJBQWlCLE9BQU8sUUFBUSxXQUFXLEVBQzlDLEtBQUssQ0FBQyxDQUFDLEVBQUMsQ0FBQyxHQUFHLENBQUMsRUFBQyxDQUFDLE1BQU8sSUFBZ0IsQ0FBWSxFQUNsRCxNQUFNLEdBQUcsQ0FBQztBQUViLGlCQUFXLENBQUMsT0FBTyxLQUFLLEtBQUssZ0JBQWdCO0FBQzNDLGVBQU8sS0FBSztBQUFBLFVBQ1YsTUFBTTtBQUFBLFVBQ04sT0FBTyxhQUFhLEtBQUs7QUFBQSxVQUN6QixhQUFhLEdBQUcsS0FBSztBQUFBLFVBQ3JCLFdBQVksUUFBbUIsWUFBWTtBQUFBLFVBQzNDLFNBQVMsWUFDTixPQUFPLENBQUMsTUFBVyxFQUFFLFFBQVEsWUFBWSxFQUFFLFNBQVMsTUFBTSxZQUFZLENBQUMsQ0FBQyxFQUN4RSxJQUFJLENBQUMsTUFBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLE1BQU0sU0FBUyxFQUMvQyxNQUFNLEdBQUcsQ0FBQztBQUFBLFVBQ2IsYUFBYTtBQUFBLFlBQ1gsOEJBQThCLEtBQUs7QUFBQSxZQUNuQyx1QkFBdUIsS0FBSztBQUFBLFlBQzVCLHNCQUFzQixLQUFLO0FBQUEsVUFDN0I7QUFBQSxRQUNGLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRjtBQUVBLFdBQU87QUFBQSxFQUNUO0FBQUE7QUFBQSxFQUdBLE1BQU0sZUFBZSxNQUFhLFNBQW9DO0FBQ3BFLFFBQUksQ0FBQyxLQUFLLE9BQU87QUFBWSxhQUFPLENBQUM7QUFFckMsUUFBSTtBQUNGLFlBQU0sWUFBWSxNQUFNLEtBQUssT0FBTyxXQUFXLFdBQVcsT0FBTztBQUNqRSxZQUFNLFFBQVEsTUFBTSxLQUFLLE9BQU8sWUFBWSxLQUFLO0FBQ2pELFlBQU0sZUFBZSxNQUFNLEtBQUssaUJBQWlCLE9BQU8sU0FBUztBQUVqRSxZQUFNLE9BQU8sb0JBQUksSUFBWTtBQUc3QixpQkFBVyxRQUFRLGFBQWEsTUFBTSxHQUFHLENBQUMsR0FBRztBQUMzQyxZQUFJLEtBQUssYUFBYSxLQUFLO0FBQ3pCLGdCQUFNLFdBQVcsS0FBSyx1QkFBdUIsS0FBSyxPQUFPO0FBQ3pELG1CQUFTLFFBQVEsU0FBTyxLQUFLLElBQUksR0FBRyxDQUFDO0FBQUEsUUFDdkM7QUFBQSxNQUNGO0FBR0EsWUFBTSxlQUFlLE1BQU0sS0FBSyxxQkFBcUIsT0FBTztBQUM1RCxtQkFBYSxRQUFRLFNBQU8sS0FBSyxJQUFJLEdBQUcsQ0FBQztBQUV6QyxhQUFPLE1BQU0sS0FBSyxJQUFJLEVBQUUsTUFBTSxHQUFHLEVBQUU7QUFBQSxJQUNyQyxTQUFTLEdBQUc7QUFDVixjQUFRLE1BQU0sd0JBQXdCLENBQUM7QUFDdkMsYUFBTyxDQUFDO0FBQUEsSUFDVjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQWMscUJBQXFCLFNBQW9DO0FBRXJFLFVBQU0sUUFBUSxRQUFRLFlBQVksRUFDL0IsUUFBUSxZQUFZLEdBQUcsRUFDdkIsTUFBTSxLQUFLLEVBQ1gsT0FBTyxVQUFRLEtBQUssU0FBUyxDQUFDO0FBRWpDLFVBQU0sYUFBYSxNQUFNLE9BQU8sQ0FBQyxLQUFLLFNBQVM7QUFDN0MsVUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSztBQUMvQixhQUFPO0FBQUEsSUFDVCxHQUFHLENBQUMsQ0FBMkI7QUFFL0IsV0FBTyxPQUFPLFFBQVEsVUFBVSxFQUM3QixLQUFLLENBQUMsQ0FBQyxFQUFDLENBQUMsR0FBRyxDQUFDLEVBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUMxQixNQUFNLEdBQUcsQ0FBQyxFQUNWLElBQUksQ0FBQyxDQUFDLElBQUksTUFBTSxJQUFJO0FBQUEsRUFDekI7QUFBQTtBQUFBLEVBR0EsTUFBTSxZQUFZLE9BQWVDLFdBSTdCLENBQUMsR0FBbUI7QUFDdEIsVUFBTSxFQUFFLGlCQUFpQixNQUFNLGFBQWEsVUFBVSxhQUFhLEdBQUcsSUFBSUE7QUFFMUUsUUFBSSxDQUFDLEtBQUssT0FBTztBQUFZLGFBQU8sQ0FBQztBQUVyQyxRQUFJO0FBQ0YsWUFBTSxpQkFBaUIsTUFBTSxLQUFLLE9BQU8sV0FBVyxXQUFXLEtBQUs7QUFDcEUsVUFBSSxVQUFpQixDQUFDO0FBRXRCLFVBQUksZUFBZSxjQUFjLGVBQWUsVUFBVTtBQUN4RCxjQUFNLGtCQUFrQixNQUFNLEtBQUssT0FBTyxjQUFjLGNBQWMsZ0JBQWdCLFVBQVU7QUFDaEcsZ0JBQVEsS0FBSyxHQUFHLGdCQUFnQixJQUFJLFFBQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxXQUFXLEVBQUUsQ0FBQztBQUFBLE1BQ3hFO0FBRUEsVUFBSSxlQUFlLGFBQWEsZUFBZSxVQUFVO0FBQ3ZELGNBQU0saUJBQWlCLE1BQU0sS0FBSyxjQUFjLE9BQU8sVUFBVTtBQUNqRSxnQkFBUSxLQUFLLEdBQUcsZUFBZSxJQUFJLFFBQU0sRUFBRSxHQUFHLEdBQUcsTUFBTSxVQUFVLEVBQUUsQ0FBQztBQUFBLE1BQ3RFO0FBR0EsWUFBTSxnQkFBZ0IsS0FBSyxtQkFBbUIsT0FBTztBQUNyRCxZQUFNLGdCQUFnQixjQUFjLEtBQUssQ0FBQyxHQUFHLE9BQU8sRUFBRSxTQUFTLE1BQU0sRUFBRSxTQUFTLEVBQUU7QUFFbEYsVUFBSSxnQkFBZ0I7QUFDbEIsZUFBTyxNQUFNLEtBQUsseUJBQXlCLGNBQWMsTUFBTSxHQUFHLFVBQVUsQ0FBQztBQUFBLE1BQy9FO0FBRUEsYUFBTyxjQUFjLE1BQU0sR0FBRyxVQUFVO0FBQUEsSUFDMUMsU0FBUyxHQUFHO0FBQ1YsY0FBUSxNQUFNLHdCQUF3QixDQUFDO0FBQ3ZDLGFBQU8sQ0FBQztBQUFBLElBQ1Y7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLGNBQWMsT0FBZSxZQUFvQztBQUM3RSxVQUFNLFFBQVEsTUFBTSxLQUFLLE9BQU8sWUFBWSxLQUFLO0FBQ2pELFVBQU0sYUFBYSxNQUFNLFlBQVksRUFBRSxNQUFNLEtBQUs7QUFFbEQsVUFBTSxVQUFVLE1BQU0sTUFDbkIsSUFBSSxDQUFDLFNBQWM7QUFDbEIsWUFBTSxVQUFVLEtBQUssUUFBUSxZQUFZO0FBQ3pDLFlBQU0sVUFBVSxXQUFXLE9BQU8sVUFBUSxRQUFRLFNBQVMsSUFBSSxDQUFDO0FBQ2hFLFlBQU0sUUFBUSxRQUFRLFNBQVMsV0FBVztBQUMxQyxhQUFPLEVBQUUsR0FBRyxNQUFNLE9BQU8sUUFBUTtBQUFBLElBQ25DLENBQUMsRUFDQSxPQUFPLENBQUMsU0FBYyxLQUFLLFFBQVEsQ0FBQyxFQUNwQyxLQUFLLENBQUMsR0FBUSxNQUFXLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFDMUMsTUFBTSxHQUFHLFVBQVU7QUFFdEIsV0FBTztBQUFBLEVBQ1Q7QUFBQTtBQUFBLEVBR1EscUJBQXFCLE9BQVksV0FBeUI7QUFDaEUsVUFBTSxpQkFBaUIsSUFBSTtBQUFBLE1BQ3pCLFVBQ0csT0FBTyxVQUFRLEtBQUssWUFBWSxXQUFXLFdBQVcsRUFDdEQsSUFBSSxVQUFRLEtBQUssRUFBRTtBQUFBLElBQ3hCO0FBRUEsV0FBTyxVQUFVLE9BQU8sVUFBUTtBQUM5QixVQUFJLEtBQUssWUFBWSxXQUFXO0FBQWEsZUFBTztBQUVwRCxZQUFNLGVBQWUsTUFBTSxNQUN4QixPQUFPLENBQUMsU0FBYyxLQUFLLE9BQU8sS0FBSyxNQUFNLEtBQUssU0FBUyxVQUFVLEVBQ3JFLElBQUksQ0FBQyxTQUFjLEtBQUssSUFBSTtBQUUvQixhQUFPLGFBQWEsTUFBTSxDQUFDLFFBQWdCLGVBQWUsSUFBSSxHQUFHLENBQUM7QUFBQSxJQUNwRSxDQUFDO0FBQUEsRUFDSDtBQUFBLEVBRUEsTUFBYyxpQkFBaUIsT0FBWSxXQUFxQztBQUM5RSxXQUFPLE1BQU0sTUFDVixJQUFJLENBQUMsVUFBZTtBQUFBLE1BQ25CLEdBQUc7QUFBQSxNQUNILFlBQVksS0FBSyxpQkFBaUIsV0FBVyxLQUFLLGNBQWMsQ0FBQyxDQUFDO0FBQUEsSUFDcEUsRUFBRSxFQUNELE9BQU8sQ0FBQyxTQUFjLEtBQUssYUFBYSxHQUFHLEVBQzNDLEtBQUssQ0FBQyxHQUFRLE1BQVcsRUFBRSxhQUFhLEVBQUUsVUFBVTtBQUFBLEVBQ3pEO0FBQUEsRUFFUSxpQkFBaUIsR0FBYSxHQUFxQjtBQUN6RCxRQUFJLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxXQUFXO0FBQUcsYUFBTztBQUVwRCxVQUFNLGFBQWEsRUFBRSxPQUFPLENBQUMsS0FBSyxLQUFLLE1BQU0sTUFBTSxNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUM7QUFDaEUsVUFBTSxhQUFhLEtBQUssS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLFFBQVEsTUFBTSxNQUFNLEtBQUssQ0FBQyxDQUFDO0FBQ3ZFLFVBQU0sYUFBYSxLQUFLLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxRQUFRLE1BQU0sTUFBTSxLQUFLLENBQUMsQ0FBQztBQUV2RSxXQUFPLGNBQWMsYUFBYTtBQUFBLEVBQ3BDO0FBQUEsRUFFUSxjQUFjLE9BQXlFO0FBQzdGLFVBQU0sU0FBUyxvQkFBSSxJQUFvRDtBQUV2RSxlQUFXLFFBQVEsTUFBTSxPQUFPO0FBQzlCLFlBQU0sUUFBUSxLQUFLLFFBQVEsWUFBWSxFQUNwQyxRQUFRLFlBQVksR0FBRyxFQUN2QixNQUFNLEtBQUssRUFDWCxPQUFPLENBQUMsU0FBaUIsS0FBSyxTQUFTLENBQUM7QUFFM0MsaUJBQVcsUUFBUSxPQUFPO0FBQ3hCLFlBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxHQUFHO0FBQ3JCLGlCQUFPLElBQUksTUFBTSxFQUFFLFdBQVcsR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDO0FBQUEsUUFDaEQ7QUFDQSxjQUFNLFFBQVEsT0FBTyxJQUFJLElBQUk7QUFDN0IsY0FBTTtBQUNOLFlBQUksS0FBSyxVQUFVLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxRQUFRLFNBQVMsS0FBSyxRQUFRLENBQUMsRUFBRSxFQUFFLEdBQUc7QUFDeEUsZ0JBQU0sUUFBUSxLQUFLLEtBQUssUUFBUSxDQUFDLEVBQUUsRUFBRTtBQUFBLFFBQ3ZDO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxXQUFPLE1BQU0sS0FBSyxPQUFPLFFBQVEsQ0FBQyxFQUMvQixJQUFJLENBQUMsQ0FBQyxNQUFNLElBQUksT0FBTyxFQUFFLE1BQU0sR0FBRyxLQUFLLEVBQUUsRUFDekMsT0FBTyxXQUFTLE1BQU0sWUFBWSxDQUFDLEVBQ25DLEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxZQUFZLEVBQUUsU0FBUztBQUFBLEVBQzdDO0FBQUEsRUFFUSxzQkFBc0IsT0FBeUU7QUFDckcsVUFBTSxTQUFTLG9CQUFJLElBQW1EO0FBRXRFLGVBQVcsUUFBUSxNQUFNLE9BQU87QUFDOUIsWUFBTSxVQUFVLEtBQUssUUFBUSxZQUFZO0FBQ3pDLFlBQU0sWUFBWSxRQUFRLE1BQU0sUUFBUTtBQUV4QyxpQkFBVyxZQUFZLFdBQVc7QUFDaEMsWUFBSSxTQUFTLFNBQVMsZUFBZSxLQUNqQyxTQUFTLFNBQVMsa0JBQW1CLEtBQ3JDLFNBQVMsU0FBUyxVQUFVLEtBQzVCLFNBQVMsU0FBUyxVQUFVLEdBQUc7QUFFakMsZ0JBQU0sUUFBUSxTQUFTLE1BQU0sS0FBSyxFQUFFLE9BQU8sVUFBUSxLQUFLLFNBQVMsQ0FBQztBQUNsRSxxQkFBVyxRQUFRLE9BQU87QUFDeEIsZ0JBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxHQUFHO0FBQ3JCLHFCQUFPLElBQUksTUFBTSxFQUFFLFVBQVUsR0FBRyxTQUFTLENBQUMsRUFBRSxDQUFDO0FBQUEsWUFDL0M7QUFDQSxrQkFBTSxRQUFRLE9BQU8sSUFBSSxJQUFJO0FBQzdCLGtCQUFNO0FBQ04sZ0JBQUksS0FBSyxVQUFVLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxRQUFRLFNBQVMsS0FBSyxRQUFRLENBQUMsRUFBRSxFQUFFLEdBQUc7QUFDeEUsb0JBQU0sUUFBUSxLQUFLLEtBQUssUUFBUSxDQUFDLEVBQUUsRUFBRTtBQUFBLFlBQ3ZDO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUVBLFdBQU8sTUFBTSxLQUFLLE9BQU8sUUFBUSxDQUFDLEVBQy9CLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxPQUFPLEVBQUUsT0FBTyxHQUFHLEtBQUssRUFBRSxFQUMzQyxPQUFPLFNBQU8sSUFBSSxZQUFZLENBQUMsRUFDL0IsS0FBSyxDQUFDLEdBQUcsTUFBTSxFQUFFLFdBQVcsRUFBRSxRQUFRO0FBQUEsRUFDM0M7QUFBQSxFQUVRLFlBQVksT0FBc0M7QUFDeEQsVUFBTSxTQUFpQyxDQUFDO0FBRXhDLGVBQVcsUUFBUSxPQUFPO0FBQ3hCLFlBQU0sUUFBUSxLQUFLLFFBQVEsWUFBWSxFQUNwQyxRQUFRLFlBQVksR0FBRyxFQUN2QixNQUFNLEtBQUssRUFDWCxPQUFPLENBQUMsU0FBaUIsS0FBSyxTQUFTLENBQUM7QUFFM0MsaUJBQVcsUUFBUSxPQUFPO0FBQ3hCLGVBQU8sSUFBSSxLQUFLLE9BQU8sSUFBSSxLQUFLLEtBQUs7QUFBQSxNQUN2QztBQUFBLElBQ0Y7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRVEsdUJBQXVCLFNBQTJCO0FBQ3hELFVBQU0sV0FBVztBQUNqQixVQUFNLFVBQVUsUUFBUSxNQUFNLFFBQVE7QUFDdEMsV0FBTyxVQUFVLFFBQVEsSUFBSSxTQUFPLElBQUksVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQUEsRUFDM0Q7QUFBQSxFQUVRLG1CQUFtQixTQUF1QjtBQUNoRCxVQUFNLE9BQU8sb0JBQUksSUFBWTtBQUM3QixXQUFPLFFBQVEsT0FBTyxZQUFVO0FBQzlCLFlBQU0sTUFBTSxPQUFPLE1BQU0sT0FBTyxRQUFRLEtBQUssVUFBVSxNQUFNO0FBQzdELFVBQUksS0FBSyxJQUFJLEdBQUc7QUFBRyxlQUFPO0FBQzFCLFdBQUssSUFBSSxHQUFHO0FBQ1osYUFBTztBQUFBLElBQ1QsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVBLE1BQWMseUJBQXlCLFNBQWdDO0FBQ3JFLFVBQU0sUUFBUSxNQUFNLEtBQUssT0FBTyxZQUFZLEtBQUs7QUFFakQsV0FBTyxRQUFRLElBQUksWUFBVTtBQUMzQixZQUFNLGVBQWUsTUFBTSxNQUFNO0FBQUEsUUFBTyxDQUFDLFNBQ3ZDLEtBQUssT0FBTyxPQUFPLE1BQ25CLEtBQUssaUJBQWlCLE9BQU8sY0FBYyxDQUFDLEdBQUcsS0FBSyxjQUFjLENBQUMsQ0FBQyxJQUFJO0FBQUEsTUFDMUUsRUFBRSxNQUFNLEdBQUcsQ0FBQztBQUVaLGFBQU87QUFBQSxRQUNMLEdBQUc7QUFBQSxRQUNILFNBQVM7QUFBQSxVQUNQLFNBQVMsYUFBYSxJQUFJLENBQUMsVUFBZTtBQUFBLFlBQ3hDLElBQUksS0FBSztBQUFBLFlBQ1QsU0FBUyxLQUFLO0FBQUEsWUFDZCxNQUFNLEtBQUs7QUFBQSxVQUNiLEVBQUU7QUFBQSxRQUNKO0FBQUEsTUFDRjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFBQTtBQUFBLEVBR0EsTUFBYyxlQUFlLE1BQTBCO0FBQ3JELFVBQU0sV0FBVyxVQUFVLEtBQUssUUFBUSxRQUFRLFlBQVksRUFBRSxDQUFDO0FBQy9ELFVBQU0sVUFBVSxLQUFLLEtBQUssT0FBTztBQUFBO0FBQUE7QUFBQSxFQUduQyxLQUFLLE9BQU87QUFBQTtBQUFBO0FBQUEsUUFHTixLQUFLLE9BQU87QUFBQTtBQUFBO0FBQUEsRUFHbEIsS0FBSyxZQUFZLFlBQVksU0FBUztBQUFBO0FBQUE7QUFBQSxFQUd0QyxLQUFLLFlBQVksWUFBWSxRQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtDQU1OLG9CQUFJLEtBQUssR0FBRSxtQkFBbUIsQ0FBQztBQUFBO0FBRzVELFVBQU0sS0FBSyxPQUFPLElBQUksTUFBTSxPQUFPLFVBQVUsT0FBTztBQUNwRCxRQUFJLHVCQUFPLHNCQUFzQixRQUFRLEVBQUU7QUFBQSxFQUM3QztBQUFBLEVBRUEsTUFBYyxpQkFBaUIsTUFBYSxNQUEwQjtBQUNwRSxVQUFNLFVBQVUsTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLEtBQUssSUFBSTtBQUNyRCxVQUFNLGFBQWEsS0FBSyxVQUFVLENBQUMsR0FBRztBQUV0QyxRQUFJLFlBQVk7QUFDZCxZQUFNLFdBQVc7QUFBQTtBQUFBO0FBQUEsTUFBdUIsVUFBVTtBQUFBO0FBQ2xELFlBQU0sS0FBSyxPQUFPLElBQUksTUFBTSxPQUFPLE1BQU0sVUFBVSxRQUFRO0FBQzNELFVBQUksdUJBQU8sdUJBQXVCLFVBQVUsRUFBRTtBQUFBLElBQ2hEO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYyxtQkFBbUIsT0FBOEI7QUFDN0QsVUFBTSxXQUFXLGNBQWMsS0FBSztBQUNwQyxVQUFNLFVBQVUsZUFBZSxLQUFLO0FBQUE7QUFBQTtBQUFBLHVDQUdELEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNDQWlCUCxvQkFBSSxLQUFLLEdBQUUsbUJBQW1CLENBQUM7QUFBQTtBQUdoRSxVQUFNLEtBQUssT0FBTyxJQUFJLE1BQU0sT0FBTyxVQUFVLE9BQU87QUFDcEQsUUFBSSx1QkFBTywwQkFBMEIsUUFBUSxFQUFFO0FBQUEsRUFDakQ7QUFDRjtBQUdPLElBQU0sd0JBQU4sY0FBb0Msc0JBQU07QUFBQSxFQUMvQyxZQUNVLFFBQ0EsYUFDUjtBQUNBLFVBQU0sT0FBTyxHQUFHO0FBSFI7QUFDQTtBQUFBLEVBR1Y7QUFBQSxFQUVBLFNBQVM7QUFDUCxVQUFNLEVBQUUsVUFBVSxJQUFJO0FBQ3RCLGNBQVUsU0FBUyxNQUFNLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUV0RCxRQUFJLEtBQUssWUFBWSxXQUFXLEdBQUc7QUFDakMsZ0JBQVUsU0FBUyxLQUFLLEVBQUUsTUFBTSwwQ0FBMEMsQ0FBQztBQUMzRTtBQUFBLElBQ0Y7QUFFQSxVQUFNLGtCQUFrQixVQUFVLFNBQVMsT0FBTyxFQUFFLEtBQUssbUJBQW1CLENBQUM7QUFFN0UsZUFBVyxjQUFjLEtBQUssYUFBYTtBQUN6QyxZQUFNLE9BQU8sZ0JBQWdCLFNBQVMsT0FBTyxFQUFFLEtBQUssa0JBQWtCLENBQUM7QUFFdkUsV0FBSyxTQUFTLE9BQU8sRUFBRSxLQUFLLG9CQUFvQixHQUFHLENBQUMsV0FBVztBQUM3RCxlQUFPLFNBQVMsTUFBTSxFQUFFLE1BQU0sV0FBVyxNQUFNLENBQUM7QUFDaEQsZUFBTyxTQUFTLFFBQVE7QUFBQSxVQUN0QixLQUFLO0FBQUEsVUFDTCxNQUFNLEdBQUcsS0FBSyxNQUFNLFdBQVcsYUFBYSxHQUFHLENBQUM7QUFBQSxRQUNsRCxDQUFDO0FBQUEsTUFDSCxDQUFDO0FBRUQsV0FBSyxTQUFTLEtBQUs7QUFBQSxRQUNqQixLQUFLO0FBQUEsUUFDTCxNQUFNLFdBQVc7QUFBQSxNQUNuQixDQUFDO0FBRUQsV0FBSyxTQUFTLFVBQVU7QUFBQSxRQUN0QixNQUFNO0FBQUEsUUFDTixLQUFLO0FBQUEsTUFDUCxDQUFDLEVBQUUsVUFBVSxZQUFZO0FBQ3ZCLGNBQU0sV0FBVyxPQUFPO0FBQ3hCLGFBQUssTUFBTTtBQUFBLE1BQ2I7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGOzs7QUNobUJBLElBQUFDLG1CQUF1QjtBQXdEaEIsSUFBTSxtQkFBTixNQUF1QjtBQUFBLEVBSTVCLFlBQW9CLFFBQXFCLFFBQXdCO0FBQTdDO0FBQ2xCLFNBQUssU0FBUztBQUNkLFNBQUssVUFBVSxPQUFPLFdBQVc7QUFBQSxFQUNuQztBQUFBLEVBRUEsTUFBTSxPQUFPLFNBQWlEO0FBQzVELFFBQUk7QUFDRixZQUFNLFdBQVcsTUFBTSxNQUFNLEdBQUcsS0FBSyxPQUFPLFdBQVc7QUFBQSxRQUNyRCxRQUFRO0FBQUEsUUFDUixTQUFTO0FBQUEsVUFDUCxnQkFBZ0I7QUFBQSxVQUNoQixpQkFBaUIsVUFBVSxLQUFLLE9BQU8sTUFBTTtBQUFBLFFBQy9DO0FBQUEsUUFDQSxNQUFNLEtBQUssVUFBVTtBQUFBLFVBQ25CLE9BQU8sUUFBUSxTQUFTLEtBQUssT0FBTyxTQUFTO0FBQUEsVUFDN0MsT0FBTyxRQUFRO0FBQUEsVUFDZixXQUFXLFFBQVE7QUFBQSxVQUNuQixPQUFPLFFBQVEsU0FBUztBQUFBLFVBQ3hCLGtCQUFrQixRQUFRLHFCQUFxQjtBQUFBLFFBQ2pELENBQUM7QUFBQSxNQUNILENBQUM7QUFFRCxVQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2hCLGNBQU0sWUFBWSxNQUFNLFNBQVMsS0FBSztBQUN0QyxjQUFNLElBQUksTUFBTSw0QkFBNEIsU0FBUyxNQUFNLElBQUksU0FBUyxFQUFFO0FBQUEsTUFDNUU7QUFFQSxZQUFNLFNBQVMsTUFBTSxTQUFTLEtBQUs7QUFDbkMsYUFBTztBQUFBLElBQ1QsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLDJCQUEyQixLQUFLO0FBQzlDLFlBQU07QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxNQUFNLFNBQXVEO0FBQ2pFLFFBQUk7QUFDRixZQUFNLFdBQVcsTUFBTSxNQUFNLEdBQUcsS0FBSyxPQUFPLGVBQWU7QUFBQSxRQUN6RCxRQUFRO0FBQUEsUUFDUixTQUFTO0FBQUEsVUFDUCxnQkFBZ0I7QUFBQSxVQUNoQixpQkFBaUIsVUFBVSxLQUFLLE9BQU8sTUFBTTtBQUFBLFFBQy9DO0FBQUEsUUFDQSxNQUFNLEtBQUssVUFBVTtBQUFBLFVBQ25CLE9BQU8sUUFBUSxTQUFTLEtBQUssT0FBTyxTQUFTO0FBQUEsVUFDN0MsT0FBTyxRQUFRO0FBQUEsVUFDZixZQUFZLFFBQVEsY0FBYztBQUFBLFVBQ2xDLFlBQVksUUFBUSxlQUFlO0FBQUEsUUFDckMsQ0FBQztBQUFBLE1BQ0gsQ0FBQztBQUVELFVBQUksQ0FBQyxTQUFTLElBQUk7QUFDaEIsY0FBTSxZQUFZLE1BQU0sU0FBUyxLQUFLO0FBQ3RDLGNBQU0sSUFBSSxNQUFNLCtCQUErQixTQUFTLE1BQU0sSUFBSSxTQUFTLEVBQUU7QUFBQSxNQUMvRTtBQUVBLFlBQU0sU0FBUyxNQUFNLFNBQVMsS0FBSztBQUNuQyxhQUFPO0FBQUEsSUFDVCxTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0sOEJBQThCLEtBQUs7QUFDakQsWUFBTTtBQUFBLElBQ1I7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLG9CQUNKLE9BQ0EsZUFDQUMsV0FHSSxDQUFDLEdBQytFO0FBQ3BGLFVBQU0sRUFBRSxPQUFPLElBQUksWUFBWSxFQUFJLElBQUlBO0FBRXZDLFFBQUksY0FBYyxXQUFXO0FBQUcsYUFBTyxDQUFDO0FBRXhDLFFBQUk7QUFDRixZQUFNLFlBQVksY0FBYyxJQUFJLFlBQVUsT0FBTyxJQUFJO0FBQ3pELFlBQU0saUJBQWlCLE1BQU0sS0FBSyxPQUFPO0FBQUEsUUFDdkM7QUFBQSxRQUNBO0FBQUEsUUFDQSxPQUFPLEtBQUssSUFBSSxNQUFNLFVBQVUsTUFBTTtBQUFBLFFBQ3RDLGtCQUFrQjtBQUFBLE1BQ3BCLENBQUM7QUFFRCxZQUFNLGtCQUFrQixlQUFlLEtBQ3BDLE9BQU8sWUFBVSxPQUFPLG1CQUFtQixTQUFTLEVBQ3BELElBQUksYUFBVztBQUFBLFFBQ2QsTUFBTSxPQUFPLFlBQVksY0FBYyxPQUFPLEtBQUssRUFBRTtBQUFBLFFBQ3JELE9BQU8sY0FBYyxPQUFPLEtBQUssRUFBRTtBQUFBLFFBQ25DLGFBQWEsT0FBTztBQUFBLFFBQ3BCLFVBQVU7QUFBQSxVQUNSLEdBQUcsY0FBYyxPQUFPLEtBQUssRUFBRTtBQUFBLFVBQy9CLGVBQWUsT0FBTztBQUFBLFVBQ3RCLGFBQWEsZUFBZTtBQUFBLFFBQzlCO0FBQUEsTUFDRixFQUFFO0FBRUosYUFBTztBQUFBLElBQ1QsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLGlDQUFpQyxLQUFLO0FBRXBELGFBQU8sY0FBYyxNQUFNLEdBQUcsSUFBSSxFQUFFLElBQUksYUFBVztBQUFBLFFBQ2pELEdBQUc7QUFBQSxRQUNILGFBQWEsT0FBTztBQUFBLE1BQ3RCLEVBQUU7QUFBQSxJQUNKO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxXQUNKLE9BQ0FBLFdBR0ksQ0FBQyxHQUNnQjtBQUNyQixVQUFNLEVBQUUsWUFBWSxZQUFZLFlBQVksSUFBSSxJQUFJQTtBQUNwRCxVQUFNLGFBQXlCLENBQUM7QUFFaEMsYUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSyxXQUFXO0FBQ2hELFlBQU0sUUFBUSxNQUFNLE1BQU0sR0FBRyxJQUFJLFNBQVM7QUFFMUMsVUFBSTtBQUNGLGNBQU0sV0FBVyxNQUFNLEtBQUssTUFBTTtBQUFBLFVBQ2hDLE9BQU87QUFBQSxVQUNQLFlBQVk7QUFBQSxRQUNkLENBQUM7QUFFRCxjQUFNLGtCQUFrQixTQUFTLEtBQzlCLEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUNoQyxJQUFJLFlBQVUsT0FBTyxTQUFTO0FBRWpDLG1CQUFXLEtBQUssR0FBRyxlQUFlO0FBQUEsTUFDcEMsU0FBUyxPQUFPO0FBQ2QsZ0JBQVEsTUFBTSxvQ0FBb0MsSUFBSSxZQUFZLENBQUMsS0FBSyxLQUFLO0FBRTdFLGNBQU0sYUFBYSxJQUFJLE1BQU0sSUFBSSxFQUFFLEtBQUssQ0FBQztBQUN6QyxpQkFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNyQyxxQkFBVyxLQUFLLFVBQVU7QUFBQSxRQUM1QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE1BQU0sZUFLSDtBQUVELFdBQU87QUFBQSxNQUNMLGtCQUFrQjtBQUFBLFFBQ2hCO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLE1BQ0EsZUFBZTtBQUFBLFFBQ2I7QUFBQSxRQUNBO0FBQUEsTUFDRjtBQUFBLE1BQ0EsbUJBQW1CO0FBQUEsTUFDbkIsZ0JBQWdCO0FBQUEsSUFDbEI7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLGlCQUFtQztBQUN2QyxRQUFJO0FBQ0YsWUFBTSxlQUFlLE1BQU0sS0FBSyxNQUFNO0FBQUEsUUFDcEMsT0FBTztBQUFBLFFBQ1AsWUFBWTtBQUFBLE1BQ2QsQ0FBQztBQUNELGFBQU8sYUFBYSxLQUFLLFNBQVM7QUFBQSxJQUNwQyxTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0scUNBQXFDLEtBQUs7QUFDeEQsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQUE7QUFBQSxFQUdBLE1BQU0sY0FDSixPQUNBLGdCQUNBQSxXQUlJLENBQUMsR0FDbUc7QUFDeEcsVUFBTTtBQUFBLE1BQ0osYUFBYTtBQUFBLE1BQ2Isa0JBQWtCO0FBQUEsTUFDbEIsbUJBQW1CO0FBQUEsSUFDckIsSUFBSUE7QUFHSixVQUFNLGtCQUFrQixNQUFNLEtBQUs7QUFBQSxNQUNqQztBQUFBLE1BQ0EsZUFBZSxNQUFNLEdBQUcsYUFBYSxDQUFDO0FBQUE7QUFBQSxNQUN0QyxFQUFFLE1BQU0sWUFBWSxXQUFXLGdCQUFnQjtBQUFBLElBQ2pEO0FBR0EsVUFBTSxrQkFBa0IsZ0JBQWdCLElBQUksWUFBVTtBQUNwRCxVQUFJLGFBQWEsT0FBTztBQUV4QixVQUFJLGtCQUFrQjtBQUVwQixxQkFBYyxPQUFPLFFBQVEsTUFBUSxPQUFPLGNBQWM7QUFBQSxNQUM1RDtBQUVBLGFBQU87QUFBQSxRQUNMLEdBQUc7QUFBQSxRQUNIO0FBQUEsTUFDRjtBQUFBLElBQ0YsQ0FBQztBQUdELG9CQUFnQixLQUFLLENBQUMsR0FBRyxNQUFNLEVBQUUsYUFBYSxFQUFFLFVBQVU7QUFFMUQsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE1BQU0sd0JBQXdCLE9BQWtDO0FBRTlELFVBQU0sYUFBYSxDQUFDLEtBQUs7QUFHekIsVUFBTSxRQUFRLE1BQU0sWUFBWSxFQUFFLE1BQU0sS0FBSztBQUc3QyxVQUFNLGFBQXVDO0FBQUEsTUFDM0MsUUFBUSxDQUFDLFVBQVUsVUFBVSxVQUFVO0FBQUEsTUFDdkMsT0FBTyxDQUFDLFFBQVEsV0FBVztBQUFBLE1BQzNCLFVBQVUsQ0FBQyxRQUFRLFNBQVMsVUFBVTtBQUFBLE1BQ3RDLFVBQVUsQ0FBQyxVQUFVLFdBQVc7QUFBQSxNQUNoQyxVQUFVLENBQUMsVUFBVSxVQUFVLE1BQU07QUFBQSxJQUN2QztBQUVBLGVBQVcsQ0FBQyxNQUFNLFFBQVEsS0FBSyxPQUFPLFFBQVEsVUFBVSxHQUFHO0FBQ3pELFVBQUksTUFBTSxTQUFTLElBQUksR0FBRztBQUN4QixtQkFBVyxXQUFXLFVBQVU7QUFDOUIsZ0JBQU0sWUFBWSxNQUFNLFFBQVEsSUFBSSxPQUFPLE1BQU0sSUFBSSxPQUFPLElBQUksR0FBRyxPQUFPO0FBQzFFLGNBQUksY0FBYyxPQUFPO0FBQ3ZCLHVCQUFXLEtBQUssU0FBUztBQUFBLFVBQzNCO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsV0FBTyxXQUFXLE1BQU0sR0FBRyxDQUFDO0FBQUEsRUFDOUI7QUFDRjtBQUdPLElBQU0sc0JBQU4sTUFBMEI7QUFBQSxFQUkvQixZQUFvQixRQUFxQjtBQUFyQjtBQUhwQixTQUFRLFdBQW9DO0FBQzVDLFNBQVEsWUFBWTtBQUFBLEVBRXNCO0FBQUEsRUFFMUMsTUFBTSxXQUFXLFFBQTBDO0FBQ3pELFFBQUk7QUFDRixXQUFLLFdBQVcsSUFBSSxpQkFBaUIsS0FBSyxRQUFRLE1BQU07QUFDeEQsWUFBTSxjQUFjLE1BQU0sS0FBSyxTQUFTLGVBQWU7QUFFdkQsVUFBSSxhQUFhO0FBQ2YsYUFBSyxZQUFZO0FBQ2pCLFlBQUksd0JBQU8sa0NBQWtDO0FBQzdDLGVBQU87QUFBQSxNQUNULE9BQU87QUFDTCxjQUFNLElBQUksTUFBTSx3QkFBd0I7QUFBQSxNQUMxQztBQUFBLElBQ0YsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLG9DQUFvQyxLQUFLO0FBQ3ZELFVBQUksd0JBQU8sb0NBQXFDLE1BQWdCLE9BQU8sRUFBRTtBQUN6RSxXQUFLLFlBQVk7QUFDakIsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQUEsRUFFQSxVQUFtQjtBQUNqQixXQUFPLEtBQUssYUFBYSxLQUFLLGFBQWE7QUFBQSxFQUM3QztBQUFBLEVBRUEsY0FBdUM7QUFDckMsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsTUFBTSxlQUNKLE9BQ0EsZ0JBQ3dHO0FBQ3hHLFFBQUksQ0FBQyxLQUFLLFFBQVEsS0FBSyxDQUFDLEtBQUssVUFBVTtBQUVyQyxhQUFPLGVBQWUsSUFBSSxhQUFXO0FBQUEsUUFDbkMsR0FBRztBQUFBLFFBQ0gsYUFBYSxPQUFPO0FBQUEsUUFDcEIsWUFBWSxPQUFPO0FBQUEsTUFDckIsRUFBRTtBQUFBLElBQ0o7QUFFQSxXQUFPLE1BQU0sS0FBSyxTQUFTLGNBQWMsT0FBTyxjQUFjO0FBQUEsRUFDaEU7QUFBQSxFQUVBLE1BQU0sV0FDSixPQUNBLFdBQ0EsTUFDZ0M7QUFDaEMsUUFBSSxDQUFDLEtBQUssUUFBUSxLQUFLLENBQUMsS0FBSyxVQUFVO0FBQ3JDLGFBQU87QUFBQSxJQUNUO0FBRUEsV0FBTyxNQUFNLEtBQUssU0FBUyxPQUFPO0FBQUEsTUFDaEM7QUFBQSxNQUNBO0FBQUEsTUFDQSxPQUFPO0FBQUEsSUFDVCxDQUFDO0FBQUEsRUFDSDtBQUFBLEVBRUEsTUFBTSxXQUNKLE9BQ0EsWUFBa0MsWUFDTjtBQUM1QixRQUFJLENBQUMsS0FBSyxRQUFRLEtBQUssQ0FBQyxLQUFLLFVBQVU7QUFDckMsYUFBTztBQUFBLElBQ1Q7QUFFQSxXQUFPLE1BQU0sS0FBSyxTQUFTLFdBQVcsT0FBTyxFQUFFLFVBQVUsQ0FBQztBQUFBLEVBQzVEO0FBQUEsRUFFQSxVQUFVO0FBQ1IsU0FBSyxXQUFXO0FBQ2hCLFNBQUssWUFBWTtBQUFBLEVBQ25CO0FBQ0Y7OztBQy9ZQSxJQUFBQyxtQkFBdUI7OztBQ0F2QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNBTyxJQUFJO0FBQUEsQ0FDVixTQUFVQyxPQUFNO0FBQ2IsRUFBQUEsTUFBSyxjQUFjLENBQUMsTUFBTTtBQUFBLEVBQUU7QUFDNUIsV0FBUyxTQUFTLE1BQU07QUFBQSxFQUFFO0FBQzFCLEVBQUFBLE1BQUssV0FBVztBQUNoQixXQUFTLFlBQVksSUFBSTtBQUNyQixVQUFNLElBQUksTUFBTTtBQUFBLEVBQ3BCO0FBQ0EsRUFBQUEsTUFBSyxjQUFjO0FBQ25CLEVBQUFBLE1BQUssY0FBYyxDQUFDLFVBQVU7QUFDMUIsVUFBTSxNQUFNLENBQUM7QUFDYixlQUFXLFFBQVEsT0FBTztBQUN0QixVQUFJLElBQUksSUFBSTtBQUFBLElBQ2hCO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFDQSxFQUFBQSxNQUFLLHFCQUFxQixDQUFDLFFBQVE7QUFDL0IsVUFBTSxZQUFZQSxNQUFLLFdBQVcsR0FBRyxFQUFFLE9BQU8sQ0FBQyxNQUFNLE9BQU8sSUFBSSxJQUFJLENBQUMsQ0FBQyxNQUFNLFFBQVE7QUFDcEYsVUFBTSxXQUFXLENBQUM7QUFDbEIsZUFBVyxLQUFLLFdBQVc7QUFDdkIsZUFBUyxDQUFDLElBQUksSUFBSSxDQUFDO0FBQUEsSUFDdkI7QUFDQSxXQUFPQSxNQUFLLGFBQWEsUUFBUTtBQUFBLEVBQ3JDO0FBQ0EsRUFBQUEsTUFBSyxlQUFlLENBQUMsUUFBUTtBQUN6QixXQUFPQSxNQUFLLFdBQVcsR0FBRyxFQUFFLElBQUksU0FBVSxHQUFHO0FBQ3pDLGFBQU8sSUFBSSxDQUFDO0FBQUEsSUFDaEIsQ0FBQztBQUFBLEVBQ0w7QUFDQSxFQUFBQSxNQUFLLGFBQWEsT0FBTyxPQUFPLFNBQVMsYUFDbkMsQ0FBQyxRQUFRLE9BQU8sS0FBSyxHQUFHLElBQ3hCLENBQUMsV0FBVztBQUNWLFVBQU0sT0FBTyxDQUFDO0FBQ2QsZUFBVyxPQUFPLFFBQVE7QUFDdEIsVUFBSSxPQUFPLFVBQVUsZUFBZSxLQUFLLFFBQVEsR0FBRyxHQUFHO0FBQ25ELGFBQUssS0FBSyxHQUFHO0FBQUEsTUFDakI7QUFBQSxJQUNKO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFDSixFQUFBQSxNQUFLLE9BQU8sQ0FBQyxLQUFLLFlBQVk7QUFDMUIsZUFBVyxRQUFRLEtBQUs7QUFDcEIsVUFBSSxRQUFRLElBQUk7QUFDWixlQUFPO0FBQUEsSUFDZjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQ0EsRUFBQUEsTUFBSyxZQUFZLE9BQU8sT0FBTyxjQUFjLGFBQ3ZDLENBQUMsUUFBUSxPQUFPLFVBQVUsR0FBRyxJQUM3QixDQUFDLFFBQVEsT0FBTyxRQUFRLFlBQVksT0FBTyxTQUFTLEdBQUcsS0FBSyxLQUFLLE1BQU0sR0FBRyxNQUFNO0FBQ3RGLFdBQVMsV0FBVyxPQUFPLFlBQVksT0FBTztBQUMxQyxXQUFPLE1BQU0sSUFBSSxDQUFDLFFBQVMsT0FBTyxRQUFRLFdBQVcsSUFBSSxHQUFHLE1BQU0sR0FBSSxFQUFFLEtBQUssU0FBUztBQUFBLEVBQzFGO0FBQ0EsRUFBQUEsTUFBSyxhQUFhO0FBQ2xCLEVBQUFBLE1BQUssd0JBQXdCLENBQUMsR0FBRyxVQUFVO0FBQ3ZDLFFBQUksT0FBTyxVQUFVLFVBQVU7QUFDM0IsYUFBTyxNQUFNLFNBQVM7QUFBQSxJQUMxQjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQ0osR0FBRyxTQUFTLE9BQU8sQ0FBQyxFQUFFO0FBQ2YsSUFBSTtBQUFBLENBQ1YsU0FBVUMsYUFBWTtBQUNuQixFQUFBQSxZQUFXLGNBQWMsQ0FBQyxPQUFPLFdBQVc7QUFDeEMsV0FBTztBQUFBLE1BQ0gsR0FBRztBQUFBLE1BQ0gsR0FBRztBQUFBO0FBQUEsSUFDUDtBQUFBLEVBQ0o7QUFDSixHQUFHLGVBQWUsYUFBYSxDQUFDLEVBQUU7QUFDM0IsSUFBTSxnQkFBZ0IsS0FBSyxZQUFZO0FBQUEsRUFDMUM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQ0osQ0FBQztBQUNNLElBQU0sZ0JBQWdCLENBQUMsU0FBUztBQUNuQyxRQUFNLElBQUksT0FBTztBQUNqQixVQUFRLEdBQUc7QUFBQSxJQUNQLEtBQUs7QUFDRCxhQUFPLGNBQWM7QUFBQSxJQUN6QixLQUFLO0FBQ0QsYUFBTyxjQUFjO0FBQUEsSUFDekIsS0FBSztBQUNELGFBQU8sT0FBTyxNQUFNLElBQUksSUFBSSxjQUFjLE1BQU0sY0FBYztBQUFBLElBQ2xFLEtBQUs7QUFDRCxhQUFPLGNBQWM7QUFBQSxJQUN6QixLQUFLO0FBQ0QsYUFBTyxjQUFjO0FBQUEsSUFDekIsS0FBSztBQUNELGFBQU8sY0FBYztBQUFBLElBQ3pCLEtBQUs7QUFDRCxhQUFPLGNBQWM7QUFBQSxJQUN6QixLQUFLO0FBQ0QsVUFBSSxNQUFNLFFBQVEsSUFBSSxHQUFHO0FBQ3JCLGVBQU8sY0FBYztBQUFBLE1BQ3pCO0FBQ0EsVUFBSSxTQUFTLE1BQU07QUFDZixlQUFPLGNBQWM7QUFBQSxNQUN6QjtBQUNBLFVBQUksS0FBSyxRQUFRLE9BQU8sS0FBSyxTQUFTLGNBQWMsS0FBSyxTQUFTLE9BQU8sS0FBSyxVQUFVLFlBQVk7QUFDaEcsZUFBTyxjQUFjO0FBQUEsTUFDekI7QUFDQSxVQUFJLE9BQU8sUUFBUSxlQUFlLGdCQUFnQixLQUFLO0FBQ25ELGVBQU8sY0FBYztBQUFBLE1BQ3pCO0FBQ0EsVUFBSSxPQUFPLFFBQVEsZUFBZSxnQkFBZ0IsS0FBSztBQUNuRCxlQUFPLGNBQWM7QUFBQSxNQUN6QjtBQUNBLFVBQUksT0FBTyxTQUFTLGVBQWUsZ0JBQWdCLE1BQU07QUFDckQsZUFBTyxjQUFjO0FBQUEsTUFDekI7QUFDQSxhQUFPLGNBQWM7QUFBQSxJQUN6QjtBQUNJLGFBQU8sY0FBYztBQUFBLEVBQzdCO0FBQ0o7OztBQ25JTyxJQUFNLGVBQWUsS0FBSyxZQUFZO0FBQUEsRUFDekM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDSixDQUFDO0FBQ00sSUFBTSxnQkFBZ0IsQ0FBQyxRQUFRO0FBQ2xDLFFBQU0sT0FBTyxLQUFLLFVBQVUsS0FBSyxNQUFNLENBQUM7QUFDeEMsU0FBTyxLQUFLLFFBQVEsZUFBZSxLQUFLO0FBQzVDO0FBQ08sSUFBTSxXQUFOLE1BQU0sa0JBQWlCLE1BQU07QUFBQSxFQUNoQyxJQUFJLFNBQVM7QUFDVCxXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBQ0EsWUFBWSxRQUFRO0FBQ2hCLFVBQU07QUFDTixTQUFLLFNBQVMsQ0FBQztBQUNmLFNBQUssV0FBVyxDQUFDLFFBQVE7QUFDckIsV0FBSyxTQUFTLENBQUMsR0FBRyxLQUFLLFFBQVEsR0FBRztBQUFBLElBQ3RDO0FBQ0EsU0FBSyxZQUFZLENBQUMsT0FBTyxDQUFDLE1BQU07QUFDNUIsV0FBSyxTQUFTLENBQUMsR0FBRyxLQUFLLFFBQVEsR0FBRyxJQUFJO0FBQUEsSUFDMUM7QUFDQSxVQUFNLGNBQWMsV0FBVztBQUMvQixRQUFJLE9BQU8sZ0JBQWdCO0FBRXZCLGFBQU8sZUFBZSxNQUFNLFdBQVc7QUFBQSxJQUMzQyxPQUNLO0FBQ0QsV0FBSyxZQUFZO0FBQUEsSUFDckI7QUFDQSxTQUFLLE9BQU87QUFDWixTQUFLLFNBQVM7QUFBQSxFQUNsQjtBQUFBLEVBQ0EsT0FBTyxTQUFTO0FBQ1osVUFBTSxTQUFTLFdBQ1gsU0FBVSxPQUFPO0FBQ2IsYUFBTyxNQUFNO0FBQUEsSUFDakI7QUFDSixVQUFNLGNBQWMsRUFBRSxTQUFTLENBQUMsRUFBRTtBQUNsQyxVQUFNLGVBQWUsQ0FBQyxVQUFVO0FBQzVCLGlCQUFXLFNBQVMsTUFBTSxRQUFRO0FBQzlCLFlBQUksTUFBTSxTQUFTLGlCQUFpQjtBQUNoQyxnQkFBTSxZQUFZLElBQUksWUFBWTtBQUFBLFFBQ3RDLFdBQ1MsTUFBTSxTQUFTLHVCQUF1QjtBQUMzQyx1QkFBYSxNQUFNLGVBQWU7QUFBQSxRQUN0QyxXQUNTLE1BQU0sU0FBUyxxQkFBcUI7QUFDekMsdUJBQWEsTUFBTSxjQUFjO0FBQUEsUUFDckMsV0FDUyxNQUFNLEtBQUssV0FBVyxHQUFHO0FBQzlCLHNCQUFZLFFBQVEsS0FBSyxPQUFPLEtBQUssQ0FBQztBQUFBLFFBQzFDLE9BQ0s7QUFDRCxjQUFJLE9BQU87QUFDWCxjQUFJLElBQUk7QUFDUixpQkFBTyxJQUFJLE1BQU0sS0FBSyxRQUFRO0FBQzFCLGtCQUFNLEtBQUssTUFBTSxLQUFLLENBQUM7QUFDdkIsa0JBQU0sV0FBVyxNQUFNLE1BQU0sS0FBSyxTQUFTO0FBQzNDLGdCQUFJLENBQUMsVUFBVTtBQUNYLG1CQUFLLEVBQUUsSUFBSSxLQUFLLEVBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxFQUFFO0FBQUEsWUFRekMsT0FDSztBQUNELG1CQUFLLEVBQUUsSUFBSSxLQUFLLEVBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQyxFQUFFO0FBQ3JDLG1CQUFLLEVBQUUsRUFBRSxRQUFRLEtBQUssT0FBTyxLQUFLLENBQUM7QUFBQSxZQUN2QztBQUNBLG1CQUFPLEtBQUssRUFBRTtBQUNkO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUNBLGlCQUFhLElBQUk7QUFDakIsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUNBLE9BQU8sT0FBTyxPQUFPO0FBQ2pCLFFBQUksRUFBRSxpQkFBaUIsWUFBVztBQUM5QixZQUFNLElBQUksTUFBTSxtQkFBbUIsS0FBSyxFQUFFO0FBQUEsSUFDOUM7QUFBQSxFQUNKO0FBQUEsRUFDQSxXQUFXO0FBQ1AsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFdBQU8sS0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLLHVCQUF1QixDQUFDO0FBQUEsRUFDcEU7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFdBQU8sS0FBSyxPQUFPLFdBQVc7QUFBQSxFQUNsQztBQUFBLEVBQ0EsUUFBUSxTQUFTLENBQUMsVUFBVSxNQUFNLFNBQVM7QUFDdkMsVUFBTSxjQUFjLENBQUM7QUFDckIsVUFBTSxhQUFhLENBQUM7QUFDcEIsZUFBVyxPQUFPLEtBQUssUUFBUTtBQUMzQixVQUFJLElBQUksS0FBSyxTQUFTLEdBQUc7QUFDckIsY0FBTSxVQUFVLElBQUksS0FBSyxDQUFDO0FBQzFCLG9CQUFZLE9BQU8sSUFBSSxZQUFZLE9BQU8sS0FBSyxDQUFDO0FBQ2hELG9CQUFZLE9BQU8sRUFBRSxLQUFLLE9BQU8sR0FBRyxDQUFDO0FBQUEsTUFDekMsT0FDSztBQUNELG1CQUFXLEtBQUssT0FBTyxHQUFHLENBQUM7QUFBQSxNQUMvQjtBQUFBLElBQ0o7QUFDQSxXQUFPLEVBQUUsWUFBWSxZQUFZO0FBQUEsRUFDckM7QUFBQSxFQUNBLElBQUksYUFBYTtBQUNiLFdBQU8sS0FBSyxRQUFRO0FBQUEsRUFDeEI7QUFDSjtBQUNBLFNBQVMsU0FBUyxDQUFDLFdBQVc7QUFDMUIsUUFBTSxRQUFRLElBQUksU0FBUyxNQUFNO0FBQ2pDLFNBQU87QUFDWDs7O0FDbElBLElBQU0sV0FBVyxDQUFDLE9BQU8sU0FBUztBQUM5QixNQUFJO0FBQ0osVUFBUSxNQUFNLE1BQU07QUFBQSxJQUNoQixLQUFLLGFBQWE7QUFDZCxVQUFJLE1BQU0sYUFBYSxjQUFjLFdBQVc7QUFDNUMsa0JBQVU7QUFBQSxNQUNkLE9BQ0s7QUFDRCxrQkFBVSxZQUFZLE1BQU0sUUFBUSxjQUFjLE1BQU0sUUFBUTtBQUFBLE1BQ3BFO0FBQ0E7QUFBQSxJQUNKLEtBQUssYUFBYTtBQUNkLGdCQUFVLG1DQUFtQyxLQUFLLFVBQVUsTUFBTSxVQUFVLEtBQUsscUJBQXFCLENBQUM7QUFDdkc7QUFBQSxJQUNKLEtBQUssYUFBYTtBQUNkLGdCQUFVLGtDQUFrQyxLQUFLLFdBQVcsTUFBTSxNQUFNLElBQUksQ0FBQztBQUM3RTtBQUFBLElBQ0osS0FBSyxhQUFhO0FBQ2QsZ0JBQVU7QUFDVjtBQUFBLElBQ0osS0FBSyxhQUFhO0FBQ2QsZ0JBQVUseUNBQXlDLEtBQUssV0FBVyxNQUFNLE9BQU8sQ0FBQztBQUNqRjtBQUFBLElBQ0osS0FBSyxhQUFhO0FBQ2QsZ0JBQVUsZ0NBQWdDLEtBQUssV0FBVyxNQUFNLE9BQU8sQ0FBQyxlQUFlLE1BQU0sUUFBUTtBQUNyRztBQUFBLElBQ0osS0FBSyxhQUFhO0FBQ2QsZ0JBQVU7QUFDVjtBQUFBLElBQ0osS0FBSyxhQUFhO0FBQ2QsZ0JBQVU7QUFDVjtBQUFBLElBQ0osS0FBSyxhQUFhO0FBQ2QsZ0JBQVU7QUFDVjtBQUFBLElBQ0osS0FBSyxhQUFhO0FBQ2QsVUFBSSxPQUFPLE1BQU0sZUFBZSxVQUFVO0FBQ3RDLFlBQUksY0FBYyxNQUFNLFlBQVk7QUFDaEMsb0JBQVUsZ0NBQWdDLE1BQU0sV0FBVyxRQUFRO0FBQ25FLGNBQUksT0FBTyxNQUFNLFdBQVcsYUFBYSxVQUFVO0FBQy9DLHNCQUFVLEdBQUcsT0FBTyxzREFBc0QsTUFBTSxXQUFXLFFBQVE7QUFBQSxVQUN2RztBQUFBLFFBQ0osV0FDUyxnQkFBZ0IsTUFBTSxZQUFZO0FBQ3ZDLG9CQUFVLG1DQUFtQyxNQUFNLFdBQVcsVUFBVTtBQUFBLFFBQzVFLFdBQ1MsY0FBYyxNQUFNLFlBQVk7QUFDckMsb0JBQVUsaUNBQWlDLE1BQU0sV0FBVyxRQUFRO0FBQUEsUUFDeEUsT0FDSztBQUNELGVBQUssWUFBWSxNQUFNLFVBQVU7QUFBQSxRQUNyQztBQUFBLE1BQ0osV0FDUyxNQUFNLGVBQWUsU0FBUztBQUNuQyxrQkFBVSxXQUFXLE1BQU0sVUFBVTtBQUFBLE1BQ3pDLE9BQ0s7QUFDRCxrQkFBVTtBQUFBLE1BQ2Q7QUFDQTtBQUFBLElBQ0osS0FBSyxhQUFhO0FBQ2QsVUFBSSxNQUFNLFNBQVM7QUFDZixrQkFBVSxzQkFBc0IsTUFBTSxRQUFRLFlBQVksTUFBTSxZQUFZLGFBQWEsV0FBVyxJQUFJLE1BQU0sT0FBTztBQUFBLGVBQ2hILE1BQU0sU0FBUztBQUNwQixrQkFBVSx1QkFBdUIsTUFBTSxRQUFRLFlBQVksTUFBTSxZQUFZLGFBQWEsTUFBTSxJQUFJLE1BQU0sT0FBTztBQUFBLGVBQzVHLE1BQU0sU0FBUztBQUNwQixrQkFBVSxrQkFBa0IsTUFBTSxRQUFRLHNCQUFzQixNQUFNLFlBQVksOEJBQThCLGVBQWUsR0FBRyxNQUFNLE9BQU87QUFBQSxlQUMxSSxNQUFNLFNBQVM7QUFDcEIsa0JBQVUsa0JBQWtCLE1BQU0sUUFBUSxzQkFBc0IsTUFBTSxZQUFZLDhCQUE4QixlQUFlLEdBQUcsTUFBTSxPQUFPO0FBQUEsZUFDMUksTUFBTSxTQUFTO0FBQ3BCLGtCQUFVLGdCQUFnQixNQUFNLFFBQVEsc0JBQXNCLE1BQU0sWUFBWSw4QkFBOEIsZUFBZSxHQUFHLElBQUksS0FBSyxPQUFPLE1BQU0sT0FBTyxDQUFDLENBQUM7QUFBQTtBQUUvSixrQkFBVTtBQUNkO0FBQUEsSUFDSixLQUFLLGFBQWE7QUFDZCxVQUFJLE1BQU0sU0FBUztBQUNmLGtCQUFVLHNCQUFzQixNQUFNLFFBQVEsWUFBWSxNQUFNLFlBQVksWUFBWSxXQUFXLElBQUksTUFBTSxPQUFPO0FBQUEsZUFDL0csTUFBTSxTQUFTO0FBQ3BCLGtCQUFVLHVCQUF1QixNQUFNLFFBQVEsWUFBWSxNQUFNLFlBQVksWUFBWSxPQUFPLElBQUksTUFBTSxPQUFPO0FBQUEsZUFDNUcsTUFBTSxTQUFTO0FBQ3BCLGtCQUFVLGtCQUFrQixNQUFNLFFBQVEsWUFBWSxNQUFNLFlBQVksMEJBQTBCLFdBQVcsSUFBSSxNQUFNLE9BQU87QUFBQSxlQUN6SCxNQUFNLFNBQVM7QUFDcEIsa0JBQVUsa0JBQWtCLE1BQU0sUUFBUSxZQUFZLE1BQU0sWUFBWSwwQkFBMEIsV0FBVyxJQUFJLE1BQU0sT0FBTztBQUFBLGVBQ3pILE1BQU0sU0FBUztBQUNwQixrQkFBVSxnQkFBZ0IsTUFBTSxRQUFRLFlBQVksTUFBTSxZQUFZLDZCQUE2QixjQUFjLElBQUksSUFBSSxLQUFLLE9BQU8sTUFBTSxPQUFPLENBQUMsQ0FBQztBQUFBO0FBRXBKLGtCQUFVO0FBQ2Q7QUFBQSxJQUNKLEtBQUssYUFBYTtBQUNkLGdCQUFVO0FBQ1Y7QUFBQSxJQUNKLEtBQUssYUFBYTtBQUNkLGdCQUFVO0FBQ1Y7QUFBQSxJQUNKLEtBQUssYUFBYTtBQUNkLGdCQUFVLGdDQUFnQyxNQUFNLFVBQVU7QUFDMUQ7QUFBQSxJQUNKLEtBQUssYUFBYTtBQUNkLGdCQUFVO0FBQ1Y7QUFBQSxJQUNKO0FBQ0ksZ0JBQVUsS0FBSztBQUNmLFdBQUssWUFBWSxLQUFLO0FBQUEsRUFDOUI7QUFDQSxTQUFPLEVBQUUsUUFBUTtBQUNyQjtBQUNBLElBQU8sYUFBUTs7O0FDM0dmLElBQUksbUJBQW1CO0FBRWhCLFNBQVMsWUFBWUMsTUFBSztBQUM3QixxQkFBbUJBO0FBQ3ZCO0FBQ08sU0FBUyxjQUFjO0FBQzFCLFNBQU87QUFDWDs7O0FDTk8sSUFBTSxZQUFZLENBQUMsV0FBVztBQUNqQyxRQUFNLEVBQUUsTUFBTSxNQUFNLFdBQVcsVUFBVSxJQUFJO0FBQzdDLFFBQU0sV0FBVyxDQUFDLEdBQUcsTUFBTSxHQUFJLFVBQVUsUUFBUSxDQUFDLENBQUU7QUFDcEQsUUFBTSxZQUFZO0FBQUEsSUFDZCxHQUFHO0FBQUEsSUFDSCxNQUFNO0FBQUEsRUFDVjtBQUNBLE1BQUksVUFBVSxZQUFZLFFBQVc7QUFDakMsV0FBTztBQUFBLE1BQ0gsR0FBRztBQUFBLE1BQ0gsTUFBTTtBQUFBLE1BQ04sU0FBUyxVQUFVO0FBQUEsSUFDdkI7QUFBQSxFQUNKO0FBQ0EsTUFBSSxlQUFlO0FBQ25CLFFBQU0sT0FBTyxVQUNSLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQ2pCLE1BQU0sRUFDTixRQUFRO0FBQ2IsYUFBV0MsUUFBTyxNQUFNO0FBQ3BCLG1CQUFlQSxLQUFJLFdBQVcsRUFBRSxNQUFNLGNBQWMsYUFBYSxDQUFDLEVBQUU7QUFBQSxFQUN4RTtBQUNBLFNBQU87QUFBQSxJQUNILEdBQUc7QUFBQSxJQUNILE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxFQUNiO0FBQ0o7QUFDTyxJQUFNLGFBQWEsQ0FBQztBQUNwQixTQUFTLGtCQUFrQixLQUFLLFdBQVc7QUFDOUMsUUFBTSxjQUFjLFlBQVk7QUFDaEMsUUFBTSxRQUFRLFVBQVU7QUFBQSxJQUNwQjtBQUFBLElBQ0EsTUFBTSxJQUFJO0FBQUEsSUFDVixNQUFNLElBQUk7QUFBQSxJQUNWLFdBQVc7QUFBQSxNQUNQLElBQUksT0FBTztBQUFBO0FBQUEsTUFDWCxJQUFJO0FBQUE7QUFBQSxNQUNKO0FBQUE7QUFBQSxNQUNBLGdCQUFnQixhQUFrQixTQUFZO0FBQUE7QUFBQSxJQUNsRCxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQUEsRUFDdkIsQ0FBQztBQUNELE1BQUksT0FBTyxPQUFPLEtBQUssS0FBSztBQUNoQztBQUNPLElBQU0sY0FBTixNQUFNLGFBQVk7QUFBQSxFQUNyQixjQUFjO0FBQ1YsU0FBSyxRQUFRO0FBQUEsRUFDakI7QUFBQSxFQUNBLFFBQVE7QUFDSixRQUFJLEtBQUssVUFBVTtBQUNmLFdBQUssUUFBUTtBQUFBLEVBQ3JCO0FBQUEsRUFDQSxRQUFRO0FBQ0osUUFBSSxLQUFLLFVBQVU7QUFDZixXQUFLLFFBQVE7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsT0FBTyxXQUFXLFFBQVEsU0FBUztBQUMvQixVQUFNLGFBQWEsQ0FBQztBQUNwQixlQUFXLEtBQUssU0FBUztBQUNyQixVQUFJLEVBQUUsV0FBVztBQUNiLGVBQU87QUFDWCxVQUFJLEVBQUUsV0FBVztBQUNiLGVBQU8sTUFBTTtBQUNqQixpQkFBVyxLQUFLLEVBQUUsS0FBSztBQUFBLElBQzNCO0FBQ0EsV0FBTyxFQUFFLFFBQVEsT0FBTyxPQUFPLE9BQU8sV0FBVztBQUFBLEVBQ3JEO0FBQUEsRUFDQSxhQUFhLGlCQUFpQixRQUFRLE9BQU87QUFDekMsVUFBTSxZQUFZLENBQUM7QUFDbkIsZUFBVyxRQUFRLE9BQU87QUFDdEIsWUFBTSxNQUFNLE1BQU0sS0FBSztBQUN2QixZQUFNLFFBQVEsTUFBTSxLQUFLO0FBQ3pCLGdCQUFVLEtBQUs7QUFBQSxRQUNYO0FBQUEsUUFDQTtBQUFBLE1BQ0osQ0FBQztBQUFBLElBQ0w7QUFDQSxXQUFPLGFBQVksZ0JBQWdCLFFBQVEsU0FBUztBQUFBLEVBQ3hEO0FBQUEsRUFDQSxPQUFPLGdCQUFnQixRQUFRLE9BQU87QUFDbEMsVUFBTSxjQUFjLENBQUM7QUFDckIsZUFBVyxRQUFRLE9BQU87QUFDdEIsWUFBTSxFQUFFLEtBQUssTUFBTSxJQUFJO0FBQ3ZCLFVBQUksSUFBSSxXQUFXO0FBQ2YsZUFBTztBQUNYLFVBQUksTUFBTSxXQUFXO0FBQ2pCLGVBQU87QUFDWCxVQUFJLElBQUksV0FBVztBQUNmLGVBQU8sTUFBTTtBQUNqQixVQUFJLE1BQU0sV0FBVztBQUNqQixlQUFPLE1BQU07QUFDakIsVUFBSSxJQUFJLFVBQVUsZ0JBQWdCLE9BQU8sTUFBTSxVQUFVLGVBQWUsS0FBSyxZQUFZO0FBQ3JGLG9CQUFZLElBQUksS0FBSyxJQUFJLE1BQU07QUFBQSxNQUNuQztBQUFBLElBQ0o7QUFDQSxXQUFPLEVBQUUsUUFBUSxPQUFPLE9BQU8sT0FBTyxZQUFZO0FBQUEsRUFDdEQ7QUFDSjtBQUNPLElBQU0sVUFBVSxPQUFPLE9BQU87QUFBQSxFQUNqQyxRQUFRO0FBQ1osQ0FBQztBQUNNLElBQU0sUUFBUSxDQUFDLFdBQVcsRUFBRSxRQUFRLFNBQVMsTUFBTTtBQUNuRCxJQUFNLEtBQUssQ0FBQyxXQUFXLEVBQUUsUUFBUSxTQUFTLE1BQU07QUFDaEQsSUFBTSxZQUFZLENBQUMsTUFBTSxFQUFFLFdBQVc7QUFDdEMsSUFBTSxVQUFVLENBQUMsTUFBTSxFQUFFLFdBQVc7QUFDcEMsSUFBTSxVQUFVLENBQUMsTUFBTSxFQUFFLFdBQVc7QUFDcEMsSUFBTSxVQUFVLENBQUMsTUFBTSxPQUFPLFlBQVksZUFBZSxhQUFhOzs7QUM1R3RFLElBQUk7QUFBQSxDQUNWLFNBQVVDLFlBQVc7QUFDbEIsRUFBQUEsV0FBVSxXQUFXLENBQUMsWUFBWSxPQUFPLFlBQVksV0FBVyxFQUFFLFFBQVEsSUFBSSxXQUFXLENBQUM7QUFFMUYsRUFBQUEsV0FBVSxXQUFXLENBQUMsWUFBWSxPQUFPLFlBQVksV0FBVyxVQUFVLFNBQVM7QUFDdkYsR0FBRyxjQUFjLFlBQVksQ0FBQyxFQUFFOzs7QUNBaEMsSUFBTSxxQkFBTixNQUF5QjtBQUFBLEVBQ3JCLFlBQVksUUFBUSxPQUFPLE1BQU0sS0FBSztBQUNsQyxTQUFLLGNBQWMsQ0FBQztBQUNwQixTQUFLLFNBQVM7QUFDZCxTQUFLLE9BQU87QUFDWixTQUFLLFFBQVE7QUFDYixTQUFLLE9BQU87QUFBQSxFQUNoQjtBQUFBLEVBQ0EsSUFBSSxPQUFPO0FBQ1AsUUFBSSxDQUFDLEtBQUssWUFBWSxRQUFRO0FBQzFCLFVBQUksTUFBTSxRQUFRLEtBQUssSUFBSSxHQUFHO0FBQzFCLGFBQUssWUFBWSxLQUFLLEdBQUcsS0FBSyxPQUFPLEdBQUcsS0FBSyxJQUFJO0FBQUEsTUFDckQsT0FDSztBQUNELGFBQUssWUFBWSxLQUFLLEdBQUcsS0FBSyxPQUFPLEtBQUssSUFBSTtBQUFBLE1BQ2xEO0FBQUEsSUFDSjtBQUNBLFdBQU8sS0FBSztBQUFBLEVBQ2hCO0FBQ0o7QUFDQSxJQUFNLGVBQWUsQ0FBQyxLQUFLLFdBQVc7QUFDbEMsTUFBSSxRQUFRLE1BQU0sR0FBRztBQUNqQixXQUFPLEVBQUUsU0FBUyxNQUFNLE1BQU0sT0FBTyxNQUFNO0FBQUEsRUFDL0MsT0FDSztBQUNELFFBQUksQ0FBQyxJQUFJLE9BQU8sT0FBTyxRQUFRO0FBQzNCLFlBQU0sSUFBSSxNQUFNLDJDQUEyQztBQUFBLElBQy9EO0FBQ0EsV0FBTztBQUFBLE1BQ0gsU0FBUztBQUFBLE1BQ1QsSUFBSSxRQUFRO0FBQ1IsWUFBSSxLQUFLO0FBQ0wsaUJBQU8sS0FBSztBQUNoQixjQUFNLFFBQVEsSUFBSSxTQUFTLElBQUksT0FBTyxNQUFNO0FBQzVDLGFBQUssU0FBUztBQUNkLGVBQU8sS0FBSztBQUFBLE1BQ2hCO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDSjtBQUNBLFNBQVMsb0JBQW9CLFFBQVE7QUFDakMsTUFBSSxDQUFDO0FBQ0QsV0FBTyxDQUFDO0FBQ1osUUFBTSxFQUFFLFVBQUFDLFdBQVUsb0JBQW9CLGdCQUFnQixZQUFZLElBQUk7QUFDdEUsTUFBSUEsY0FBYSxzQkFBc0IsaUJBQWlCO0FBQ3BELFVBQU0sSUFBSSxNQUFNLDBGQUEwRjtBQUFBLEVBQzlHO0FBQ0EsTUFBSUE7QUFDQSxXQUFPLEVBQUUsVUFBVUEsV0FBVSxZQUFZO0FBQzdDLFFBQU0sWUFBWSxDQUFDLEtBQUssUUFBUTtBQUM1QixVQUFNLEVBQUUsUUFBUSxJQUFJO0FBQ3BCLFFBQUksSUFBSSxTQUFTLHNCQUFzQjtBQUNuQyxhQUFPLEVBQUUsU0FBUyxXQUFXLElBQUksYUFBYTtBQUFBLElBQ2xEO0FBQ0EsUUFBSSxPQUFPLElBQUksU0FBUyxhQUFhO0FBQ2pDLGFBQU8sRUFBRSxTQUFTLFdBQVcsa0JBQWtCLElBQUksYUFBYTtBQUFBLElBQ3BFO0FBQ0EsUUFBSSxJQUFJLFNBQVM7QUFDYixhQUFPLEVBQUUsU0FBUyxJQUFJLGFBQWE7QUFDdkMsV0FBTyxFQUFFLFNBQVMsV0FBVyxzQkFBc0IsSUFBSSxhQUFhO0FBQUEsRUFDeEU7QUFDQSxTQUFPLEVBQUUsVUFBVSxXQUFXLFlBQVk7QUFDOUM7QUFDTyxJQUFNLFVBQU4sTUFBYztBQUFBLEVBQ2pCLElBQUksY0FBYztBQUNkLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFBQSxFQUNBLFNBQVMsT0FBTztBQUNaLFdBQU8sY0FBYyxNQUFNLElBQUk7QUFBQSxFQUNuQztBQUFBLEVBQ0EsZ0JBQWdCLE9BQU8sS0FBSztBQUN4QixXQUFRLE9BQU87QUFBQSxNQUNYLFFBQVEsTUFBTSxPQUFPO0FBQUEsTUFDckIsTUFBTSxNQUFNO0FBQUEsTUFDWixZQUFZLGNBQWMsTUFBTSxJQUFJO0FBQUEsTUFDcEMsZ0JBQWdCLEtBQUssS0FBSztBQUFBLE1BQzFCLE1BQU0sTUFBTTtBQUFBLE1BQ1osUUFBUSxNQUFNO0FBQUEsSUFDbEI7QUFBQSxFQUNKO0FBQUEsRUFDQSxvQkFBb0IsT0FBTztBQUN2QixXQUFPO0FBQUEsTUFDSCxRQUFRLElBQUksWUFBWTtBQUFBLE1BQ3hCLEtBQUs7QUFBQSxRQUNELFFBQVEsTUFBTSxPQUFPO0FBQUEsUUFDckIsTUFBTSxNQUFNO0FBQUEsUUFDWixZQUFZLGNBQWMsTUFBTSxJQUFJO0FBQUEsUUFDcEMsZ0JBQWdCLEtBQUssS0FBSztBQUFBLFFBQzFCLE1BQU0sTUFBTTtBQUFBLFFBQ1osUUFBUSxNQUFNO0FBQUEsTUFDbEI7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUFBLEVBQ0EsV0FBVyxPQUFPO0FBQ2QsVUFBTSxTQUFTLEtBQUssT0FBTyxLQUFLO0FBQ2hDLFFBQUksUUFBUSxNQUFNLEdBQUc7QUFDakIsWUFBTSxJQUFJLE1BQU0sd0NBQXdDO0FBQUEsSUFDNUQ7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsWUFBWSxPQUFPO0FBQ2YsVUFBTSxTQUFTLEtBQUssT0FBTyxLQUFLO0FBQ2hDLFdBQU8sUUFBUSxRQUFRLE1BQU07QUFBQSxFQUNqQztBQUFBLEVBQ0EsTUFBTSxNQUFNLFFBQVE7QUFDaEIsVUFBTSxTQUFTLEtBQUssVUFBVSxNQUFNLE1BQU07QUFDMUMsUUFBSSxPQUFPO0FBQ1AsYUFBTyxPQUFPO0FBQ2xCLFVBQU0sT0FBTztBQUFBLEVBQ2pCO0FBQUEsRUFDQSxVQUFVLE1BQU0sUUFBUTtBQUNwQixVQUFNLE1BQU07QUFBQSxNQUNSLFFBQVE7QUFBQSxRQUNKLFFBQVEsQ0FBQztBQUFBLFFBQ1QsT0FBTyxRQUFRLFNBQVM7QUFBQSxRQUN4QixvQkFBb0IsUUFBUTtBQUFBLE1BQ2hDO0FBQUEsTUFDQSxNQUFNLFFBQVEsUUFBUSxDQUFDO0FBQUEsTUFDdkIsZ0JBQWdCLEtBQUssS0FBSztBQUFBLE1BQzFCLFFBQVE7QUFBQSxNQUNSO0FBQUEsTUFDQSxZQUFZLGNBQWMsSUFBSTtBQUFBLElBQ2xDO0FBQ0EsVUFBTSxTQUFTLEtBQUssV0FBVyxFQUFFLE1BQU0sTUFBTSxJQUFJLE1BQU0sUUFBUSxJQUFJLENBQUM7QUFDcEUsV0FBTyxhQUFhLEtBQUssTUFBTTtBQUFBLEVBQ25DO0FBQUEsRUFDQSxZQUFZLE1BQU07QUFDZCxVQUFNLE1BQU07QUFBQSxNQUNSLFFBQVE7QUFBQSxRQUNKLFFBQVEsQ0FBQztBQUFBLFFBQ1QsT0FBTyxDQUFDLENBQUMsS0FBSyxXQUFXLEVBQUU7QUFBQSxNQUMvQjtBQUFBLE1BQ0EsTUFBTSxDQUFDO0FBQUEsTUFDUCxnQkFBZ0IsS0FBSyxLQUFLO0FBQUEsTUFDMUIsUUFBUTtBQUFBLE1BQ1I7QUFBQSxNQUNBLFlBQVksY0FBYyxJQUFJO0FBQUEsSUFDbEM7QUFDQSxRQUFJLENBQUMsS0FBSyxXQUFXLEVBQUUsT0FBTztBQUMxQixVQUFJO0FBQ0EsY0FBTSxTQUFTLEtBQUssV0FBVyxFQUFFLE1BQU0sTUFBTSxDQUFDLEdBQUcsUUFBUSxJQUFJLENBQUM7QUFDOUQsZUFBTyxRQUFRLE1BQU0sSUFDZjtBQUFBLFVBQ0UsT0FBTyxPQUFPO0FBQUEsUUFDbEIsSUFDRTtBQUFBLFVBQ0UsUUFBUSxJQUFJLE9BQU87QUFBQSxRQUN2QjtBQUFBLE1BQ1IsU0FDTyxLQUFLO0FBQ1IsWUFBSSxLQUFLLFNBQVMsWUFBWSxHQUFHLFNBQVMsYUFBYSxHQUFHO0FBQ3RELGVBQUssV0FBVyxFQUFFLFFBQVE7QUFBQSxRQUM5QjtBQUNBLFlBQUksU0FBUztBQUFBLFVBQ1QsUUFBUSxDQUFDO0FBQUEsVUFDVCxPQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0EsV0FBTyxLQUFLLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQyxHQUFHLFFBQVEsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLFdBQVcsUUFBUSxNQUFNLElBQ2xGO0FBQUEsTUFDRSxPQUFPLE9BQU87QUFBQSxJQUNsQixJQUNFO0FBQUEsTUFDRSxRQUFRLElBQUksT0FBTztBQUFBLElBQ3ZCLENBQUM7QUFBQSxFQUNUO0FBQUEsRUFDQSxNQUFNLFdBQVcsTUFBTSxRQUFRO0FBQzNCLFVBQU0sU0FBUyxNQUFNLEtBQUssZUFBZSxNQUFNLE1BQU07QUFDckQsUUFBSSxPQUFPO0FBQ1AsYUFBTyxPQUFPO0FBQ2xCLFVBQU0sT0FBTztBQUFBLEVBQ2pCO0FBQUEsRUFDQSxNQUFNLGVBQWUsTUFBTSxRQUFRO0FBQy9CLFVBQU0sTUFBTTtBQUFBLE1BQ1IsUUFBUTtBQUFBLFFBQ0osUUFBUSxDQUFDO0FBQUEsUUFDVCxvQkFBb0IsUUFBUTtBQUFBLFFBQzVCLE9BQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxNQUFNLFFBQVEsUUFBUSxDQUFDO0FBQUEsTUFDdkIsZ0JBQWdCLEtBQUssS0FBSztBQUFBLE1BQzFCLFFBQVE7QUFBQSxNQUNSO0FBQUEsTUFDQSxZQUFZLGNBQWMsSUFBSTtBQUFBLElBQ2xDO0FBQ0EsVUFBTSxtQkFBbUIsS0FBSyxPQUFPLEVBQUUsTUFBTSxNQUFNLElBQUksTUFBTSxRQUFRLElBQUksQ0FBQztBQUMxRSxVQUFNLFNBQVMsT0FBTyxRQUFRLGdCQUFnQixJQUFJLG1CQUFtQixRQUFRLFFBQVEsZ0JBQWdCO0FBQ3JHLFdBQU8sYUFBYSxLQUFLLE1BQU07QUFBQSxFQUNuQztBQUFBLEVBQ0EsT0FBTyxPQUFPLFNBQVM7QUFDbkIsVUFBTSxxQkFBcUIsQ0FBQyxRQUFRO0FBQ2hDLFVBQUksT0FBTyxZQUFZLFlBQVksT0FBTyxZQUFZLGFBQWE7QUFDL0QsZUFBTyxFQUFFLFFBQVE7QUFBQSxNQUNyQixXQUNTLE9BQU8sWUFBWSxZQUFZO0FBQ3BDLGVBQU8sUUFBUSxHQUFHO0FBQUEsTUFDdEIsT0FDSztBQUNELGVBQU87QUFBQSxNQUNYO0FBQUEsSUFDSjtBQUNBLFdBQU8sS0FBSyxZQUFZLENBQUMsS0FBSyxRQUFRO0FBQ2xDLFlBQU0sU0FBUyxNQUFNLEdBQUc7QUFDeEIsWUFBTSxXQUFXLE1BQU0sSUFBSSxTQUFTO0FBQUEsUUFDaEMsTUFBTSxhQUFhO0FBQUEsUUFDbkIsR0FBRyxtQkFBbUIsR0FBRztBQUFBLE1BQzdCLENBQUM7QUFDRCxVQUFJLE9BQU8sWUFBWSxlQUFlLGtCQUFrQixTQUFTO0FBQzdELGVBQU8sT0FBTyxLQUFLLENBQUMsU0FBUztBQUN6QixjQUFJLENBQUMsTUFBTTtBQUNQLHFCQUFTO0FBQ1QsbUJBQU87QUFBQSxVQUNYLE9BQ0s7QUFDRCxtQkFBTztBQUFBLFVBQ1g7QUFBQSxRQUNKLENBQUM7QUFBQSxNQUNMO0FBQ0EsVUFBSSxDQUFDLFFBQVE7QUFDVCxpQkFBUztBQUNULGVBQU87QUFBQSxNQUNYLE9BQ0s7QUFDRCxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFdBQVcsT0FBTyxnQkFBZ0I7QUFDOUIsV0FBTyxLQUFLLFlBQVksQ0FBQyxLQUFLLFFBQVE7QUFDbEMsVUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHO0FBQ2IsWUFBSSxTQUFTLE9BQU8sbUJBQW1CLGFBQWEsZUFBZSxLQUFLLEdBQUcsSUFBSSxjQUFjO0FBQzdGLGVBQU87QUFBQSxNQUNYLE9BQ0s7QUFDRCxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFlBQVksWUFBWTtBQUNwQixXQUFPLElBQUksV0FBVztBQUFBLE1BQ2xCLFFBQVE7QUFBQSxNQUNSLFVBQVUsc0JBQXNCO0FBQUEsTUFDaEMsUUFBUSxFQUFFLE1BQU0sY0FBYyxXQUFXO0FBQUEsSUFDN0MsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFlBQVksWUFBWTtBQUNwQixXQUFPLEtBQUssWUFBWSxVQUFVO0FBQUEsRUFDdEM7QUFBQSxFQUNBLFlBQVksS0FBSztBQUViLFNBQUssTUFBTSxLQUFLO0FBQ2hCLFNBQUssT0FBTztBQUNaLFNBQUssUUFBUSxLQUFLLE1BQU0sS0FBSyxJQUFJO0FBQ2pDLFNBQUssWUFBWSxLQUFLLFVBQVUsS0FBSyxJQUFJO0FBQ3pDLFNBQUssYUFBYSxLQUFLLFdBQVcsS0FBSyxJQUFJO0FBQzNDLFNBQUssaUJBQWlCLEtBQUssZUFBZSxLQUFLLElBQUk7QUFDbkQsU0FBSyxNQUFNLEtBQUssSUFBSSxLQUFLLElBQUk7QUFDN0IsU0FBSyxTQUFTLEtBQUssT0FBTyxLQUFLLElBQUk7QUFDbkMsU0FBSyxhQUFhLEtBQUssV0FBVyxLQUFLLElBQUk7QUFDM0MsU0FBSyxjQUFjLEtBQUssWUFBWSxLQUFLLElBQUk7QUFDN0MsU0FBSyxXQUFXLEtBQUssU0FBUyxLQUFLLElBQUk7QUFDdkMsU0FBSyxXQUFXLEtBQUssU0FBUyxLQUFLLElBQUk7QUFDdkMsU0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLLElBQUk7QUFDckMsU0FBSyxRQUFRLEtBQUssTUFBTSxLQUFLLElBQUk7QUFDakMsU0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLLElBQUk7QUFDckMsU0FBSyxLQUFLLEtBQUssR0FBRyxLQUFLLElBQUk7QUFDM0IsU0FBSyxNQUFNLEtBQUssSUFBSSxLQUFLLElBQUk7QUFDN0IsU0FBSyxZQUFZLEtBQUssVUFBVSxLQUFLLElBQUk7QUFDekMsU0FBSyxRQUFRLEtBQUssTUFBTSxLQUFLLElBQUk7QUFDakMsU0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLLElBQUk7QUFDckMsU0FBSyxRQUFRLEtBQUssTUFBTSxLQUFLLElBQUk7QUFDakMsU0FBSyxXQUFXLEtBQUssU0FBUyxLQUFLLElBQUk7QUFDdkMsU0FBSyxPQUFPLEtBQUssS0FBSyxLQUFLLElBQUk7QUFDL0IsU0FBSyxXQUFXLEtBQUssU0FBUyxLQUFLLElBQUk7QUFDdkMsU0FBSyxhQUFhLEtBQUssV0FBVyxLQUFLLElBQUk7QUFDM0MsU0FBSyxhQUFhLEtBQUssV0FBVyxLQUFLLElBQUk7QUFDM0MsU0FBSyxXQUFXLElBQUk7QUFBQSxNQUNoQixTQUFTO0FBQUEsTUFDVCxRQUFRO0FBQUEsTUFDUixVQUFVLENBQUMsU0FBUyxLQUFLLFdBQVcsRUFBRSxJQUFJO0FBQUEsSUFDOUM7QUFBQSxFQUNKO0FBQUEsRUFDQSxXQUFXO0FBQ1AsV0FBTyxZQUFZLE9BQU8sTUFBTSxLQUFLLElBQUk7QUFBQSxFQUM3QztBQUFBLEVBQ0EsV0FBVztBQUNQLFdBQU8sWUFBWSxPQUFPLE1BQU0sS0FBSyxJQUFJO0FBQUEsRUFDN0M7QUFBQSxFQUNBLFVBQVU7QUFDTixXQUFPLEtBQUssU0FBUyxFQUFFLFNBQVM7QUFBQSxFQUNwQztBQUFBLEVBQ0EsUUFBUTtBQUNKLFdBQU8sU0FBUyxPQUFPLElBQUk7QUFBQSxFQUMvQjtBQUFBLEVBQ0EsVUFBVTtBQUNOLFdBQU8sV0FBVyxPQUFPLE1BQU0sS0FBSyxJQUFJO0FBQUEsRUFDNUM7QUFBQSxFQUNBLEdBQUcsUUFBUTtBQUNQLFdBQU8sU0FBUyxPQUFPLENBQUMsTUFBTSxNQUFNLEdBQUcsS0FBSyxJQUFJO0FBQUEsRUFDcEQ7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFdBQU8sZ0JBQWdCLE9BQU8sTUFBTSxVQUFVLEtBQUssSUFBSTtBQUFBLEVBQzNEO0FBQUEsRUFDQSxVQUFVLFdBQVc7QUFDakIsV0FBTyxJQUFJLFdBQVc7QUFBQSxNQUNsQixHQUFHLG9CQUFvQixLQUFLLElBQUk7QUFBQSxNQUNoQyxRQUFRO0FBQUEsTUFDUixVQUFVLHNCQUFzQjtBQUFBLE1BQ2hDLFFBQVEsRUFBRSxNQUFNLGFBQWEsVUFBVTtBQUFBLElBQzNDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxRQUFRLEtBQUs7QUFDVCxVQUFNLG1CQUFtQixPQUFPLFFBQVEsYUFBYSxNQUFNLE1BQU07QUFDakUsV0FBTyxJQUFJLFdBQVc7QUFBQSxNQUNsQixHQUFHLG9CQUFvQixLQUFLLElBQUk7QUFBQSxNQUNoQyxXQUFXO0FBQUEsTUFDWCxjQUFjO0FBQUEsTUFDZCxVQUFVLHNCQUFzQjtBQUFBLElBQ3BDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxRQUFRO0FBQ0osV0FBTyxJQUFJLFdBQVc7QUFBQSxNQUNsQixVQUFVLHNCQUFzQjtBQUFBLE1BQ2hDLE1BQU07QUFBQSxNQUNOLEdBQUcsb0JBQW9CLEtBQUssSUFBSTtBQUFBLElBQ3BDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxNQUFNLEtBQUs7QUFDUCxVQUFNLGlCQUFpQixPQUFPLFFBQVEsYUFBYSxNQUFNLE1BQU07QUFDL0QsV0FBTyxJQUFJLFNBQVM7QUFBQSxNQUNoQixHQUFHLG9CQUFvQixLQUFLLElBQUk7QUFBQSxNQUNoQyxXQUFXO0FBQUEsTUFDWCxZQUFZO0FBQUEsTUFDWixVQUFVLHNCQUFzQjtBQUFBLElBQ3BDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxTQUFTLGFBQWE7QUFDbEIsVUFBTSxPQUFPLEtBQUs7QUFDbEIsV0FBTyxJQUFJLEtBQUs7QUFBQSxNQUNaLEdBQUcsS0FBSztBQUFBLE1BQ1I7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxLQUFLLFFBQVE7QUFDVCxXQUFPLFlBQVksT0FBTyxNQUFNLE1BQU07QUFBQSxFQUMxQztBQUFBLEVBQ0EsV0FBVztBQUNQLFdBQU8sWUFBWSxPQUFPLElBQUk7QUFBQSxFQUNsQztBQUFBLEVBQ0EsYUFBYTtBQUNULFdBQU8sS0FBSyxVQUFVLE1BQVMsRUFBRTtBQUFBLEVBQ3JDO0FBQUEsRUFDQSxhQUFhO0FBQ1QsV0FBTyxLQUFLLFVBQVUsSUFBSSxFQUFFO0FBQUEsRUFDaEM7QUFDSjtBQUNBLElBQU0sWUFBWTtBQUNsQixJQUFNLGFBQWE7QUFDbkIsSUFBTSxZQUFZO0FBR2xCLElBQU0sWUFBWTtBQUNsQixJQUFNLGNBQWM7QUFDcEIsSUFBTSxXQUFXO0FBQ2pCLElBQU0sZ0JBQWdCO0FBYXRCLElBQU0sYUFBYTtBQUluQixJQUFNLGNBQWM7QUFDcEIsSUFBSTtBQUVKLElBQU0sWUFBWTtBQUNsQixJQUFNLGdCQUFnQjtBQUd0QixJQUFNLFlBQVk7QUFDbEIsSUFBTSxnQkFBZ0I7QUFFdEIsSUFBTSxjQUFjO0FBRXBCLElBQU0saUJBQWlCO0FBTXZCLElBQU0sa0JBQWtCO0FBQ3hCLElBQU0sWUFBWSxJQUFJLE9BQU8sSUFBSSxlQUFlLEdBQUc7QUFDbkQsU0FBUyxnQkFBZ0IsTUFBTTtBQUMzQixNQUFJLHFCQUFxQjtBQUN6QixNQUFJLEtBQUssV0FBVztBQUNoQix5QkFBcUIsR0FBRyxrQkFBa0IsVUFBVSxLQUFLLFNBQVM7QUFBQSxFQUN0RSxXQUNTLEtBQUssYUFBYSxNQUFNO0FBQzdCLHlCQUFxQixHQUFHLGtCQUFrQjtBQUFBLEVBQzlDO0FBQ0EsUUFBTSxvQkFBb0IsS0FBSyxZQUFZLE1BQU07QUFDakQsU0FBTyw4QkFBOEIsa0JBQWtCLElBQUksaUJBQWlCO0FBQ2hGO0FBQ0EsU0FBUyxVQUFVLE1BQU07QUFDckIsU0FBTyxJQUFJLE9BQU8sSUFBSSxnQkFBZ0IsSUFBSSxDQUFDLEdBQUc7QUFDbEQ7QUFFTyxTQUFTLGNBQWMsTUFBTTtBQUNoQyxNQUFJLFFBQVEsR0FBRyxlQUFlLElBQUksZ0JBQWdCLElBQUksQ0FBQztBQUN2RCxRQUFNLE9BQU8sQ0FBQztBQUNkLE9BQUssS0FBSyxLQUFLLFFBQVEsT0FBTyxHQUFHO0FBQ2pDLE1BQUksS0FBSztBQUNMLFNBQUssS0FBSyxzQkFBc0I7QUFDcEMsVUFBUSxHQUFHLEtBQUssSUFBSSxLQUFLLEtBQUssR0FBRyxDQUFDO0FBQ2xDLFNBQU8sSUFBSSxPQUFPLElBQUksS0FBSyxHQUFHO0FBQ2xDO0FBQ0EsU0FBUyxVQUFVLElBQUlDLFVBQVM7QUFDNUIsT0FBS0EsYUFBWSxRQUFRLENBQUNBLGFBQVksVUFBVSxLQUFLLEVBQUUsR0FBRztBQUN0RCxXQUFPO0FBQUEsRUFDWDtBQUNBLE9BQUtBLGFBQVksUUFBUSxDQUFDQSxhQUFZLFVBQVUsS0FBSyxFQUFFLEdBQUc7QUFDdEQsV0FBTztBQUFBLEVBQ1g7QUFDQSxTQUFPO0FBQ1g7QUFDQSxTQUFTLFdBQVcsS0FBSyxLQUFLO0FBQzFCLE1BQUksQ0FBQyxTQUFTLEtBQUssR0FBRztBQUNsQixXQUFPO0FBQ1gsTUFBSTtBQUNBLFVBQU0sQ0FBQyxNQUFNLElBQUksSUFBSSxNQUFNLEdBQUc7QUFDOUIsUUFBSSxDQUFDO0FBQ0QsYUFBTztBQUVYLFVBQU0sU0FBUyxPQUNWLFFBQVEsTUFBTSxHQUFHLEVBQ2pCLFFBQVEsTUFBTSxHQUFHLEVBQ2pCLE9BQU8sT0FBTyxVQUFXLElBQUssT0FBTyxTQUFTLEtBQU0sR0FBSSxHQUFHO0FBQ2hFLFVBQU0sVUFBVSxLQUFLLE1BQU0sS0FBSyxNQUFNLENBQUM7QUFDdkMsUUFBSSxPQUFPLFlBQVksWUFBWSxZQUFZO0FBQzNDLGFBQU87QUFDWCxRQUFJLFNBQVMsV0FBVyxTQUFTLFFBQVE7QUFDckMsYUFBTztBQUNYLFFBQUksQ0FBQyxRQUFRO0FBQ1QsYUFBTztBQUNYLFFBQUksT0FBTyxRQUFRLFFBQVE7QUFDdkIsYUFBTztBQUNYLFdBQU87QUFBQSxFQUNYLFFBQ007QUFDRixXQUFPO0FBQUEsRUFDWDtBQUNKO0FBQ0EsU0FBUyxZQUFZLElBQUlBLFVBQVM7QUFDOUIsT0FBS0EsYUFBWSxRQUFRLENBQUNBLGFBQVksY0FBYyxLQUFLLEVBQUUsR0FBRztBQUMxRCxXQUFPO0FBQUEsRUFDWDtBQUNBLE9BQUtBLGFBQVksUUFBUSxDQUFDQSxhQUFZLGNBQWMsS0FBSyxFQUFFLEdBQUc7QUFDMUQsV0FBTztBQUFBLEVBQ1g7QUFDQSxTQUFPO0FBQ1g7QUFDTyxJQUFNLFlBQU4sTUFBTSxtQkFBa0IsUUFBUTtBQUFBLEVBQ25DLE9BQU8sT0FBTztBQUNWLFFBQUksS0FBSyxLQUFLLFFBQVE7QUFDbEIsWUFBTSxPQUFPLE9BQU8sTUFBTSxJQUFJO0FBQUEsSUFDbEM7QUFDQSxVQUFNLGFBQWEsS0FBSyxTQUFTLEtBQUs7QUFDdEMsUUFBSSxlQUFlLGNBQWMsUUFBUTtBQUNyQyxZQUFNQyxPQUFNLEtBQUssZ0JBQWdCLEtBQUs7QUFDdEMsd0JBQWtCQSxNQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsUUFDbkIsVUFBVSxjQUFjO0FBQUEsUUFDeEIsVUFBVUEsS0FBSTtBQUFBLE1BQ2xCLENBQUM7QUFDRCxhQUFPO0FBQUEsSUFDWDtBQUNBLFVBQU0sU0FBUyxJQUFJLFlBQVk7QUFDL0IsUUFBSSxNQUFNO0FBQ1YsZUFBVyxTQUFTLEtBQUssS0FBSyxRQUFRO0FBQ2xDLFVBQUksTUFBTSxTQUFTLE9BQU87QUFDdEIsWUFBSSxNQUFNLEtBQUssU0FBUyxNQUFNLE9BQU87QUFDakMsZ0JBQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHO0FBQ3JDLDRCQUFrQixLQUFLO0FBQUEsWUFDbkIsTUFBTSxhQUFhO0FBQUEsWUFDbkIsU0FBUyxNQUFNO0FBQUEsWUFDZixNQUFNO0FBQUEsWUFDTixXQUFXO0FBQUEsWUFDWCxPQUFPO0FBQUEsWUFDUCxTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxPQUFPO0FBQzNCLFlBQUksTUFBTSxLQUFLLFNBQVMsTUFBTSxPQUFPO0FBQ2pDLGdCQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRztBQUNyQyw0QkFBa0IsS0FBSztBQUFBLFlBQ25CLE1BQU0sYUFBYTtBQUFBLFlBQ25CLFNBQVMsTUFBTTtBQUFBLFlBQ2YsTUFBTTtBQUFBLFlBQ04sV0FBVztBQUFBLFlBQ1gsT0FBTztBQUFBLFlBQ1AsU0FBUyxNQUFNO0FBQUEsVUFDbkIsQ0FBQztBQUNELGlCQUFPLE1BQU07QUFBQSxRQUNqQjtBQUFBLE1BQ0osV0FDUyxNQUFNLFNBQVMsVUFBVTtBQUM5QixjQUFNLFNBQVMsTUFBTSxLQUFLLFNBQVMsTUFBTTtBQUN6QyxjQUFNLFdBQVcsTUFBTSxLQUFLLFNBQVMsTUFBTTtBQUMzQyxZQUFJLFVBQVUsVUFBVTtBQUNwQixnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsY0FBSSxRQUFRO0FBQ1IsOEJBQWtCLEtBQUs7QUFBQSxjQUNuQixNQUFNLGFBQWE7QUFBQSxjQUNuQixTQUFTLE1BQU07QUFBQSxjQUNmLE1BQU07QUFBQSxjQUNOLFdBQVc7QUFBQSxjQUNYLE9BQU87QUFBQSxjQUNQLFNBQVMsTUFBTTtBQUFBLFlBQ25CLENBQUM7QUFBQSxVQUNMLFdBQ1MsVUFBVTtBQUNmLDhCQUFrQixLQUFLO0FBQUEsY0FDbkIsTUFBTSxhQUFhO0FBQUEsY0FDbkIsU0FBUyxNQUFNO0FBQUEsY0FDZixNQUFNO0FBQUEsY0FDTixXQUFXO0FBQUEsY0FDWCxPQUFPO0FBQUEsY0FDUCxTQUFTLE1BQU07QUFBQSxZQUNuQixDQUFDO0FBQUEsVUFDTDtBQUNBLGlCQUFPLE1BQU07QUFBQSxRQUNqQjtBQUFBLE1BQ0osV0FDUyxNQUFNLFNBQVMsU0FBUztBQUM3QixZQUFJLENBQUMsV0FBVyxLQUFLLE1BQU0sSUFBSSxHQUFHO0FBQzlCLGdCQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRztBQUNyQyw0QkFBa0IsS0FBSztBQUFBLFlBQ25CLFlBQVk7QUFBQSxZQUNaLE1BQU0sYUFBYTtBQUFBLFlBQ25CLFNBQVMsTUFBTTtBQUFBLFVBQ25CLENBQUM7QUFDRCxpQkFBTyxNQUFNO0FBQUEsUUFDakI7QUFBQSxNQUNKLFdBQ1MsTUFBTSxTQUFTLFNBQVM7QUFDN0IsWUFBSSxDQUFDLFlBQVk7QUFDYix1QkFBYSxJQUFJLE9BQU8sYUFBYSxHQUFHO0FBQUEsUUFDNUM7QUFDQSxZQUFJLENBQUMsV0FBVyxLQUFLLE1BQU0sSUFBSSxHQUFHO0FBQzlCLGdCQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRztBQUNyQyw0QkFBa0IsS0FBSztBQUFBLFlBQ25CLFlBQVk7QUFBQSxZQUNaLE1BQU0sYUFBYTtBQUFBLFlBQ25CLFNBQVMsTUFBTTtBQUFBLFVBQ25CLENBQUM7QUFDRCxpQkFBTyxNQUFNO0FBQUEsUUFDakI7QUFBQSxNQUNKLFdBQ1MsTUFBTSxTQUFTLFFBQVE7QUFDNUIsWUFBSSxDQUFDLFVBQVUsS0FBSyxNQUFNLElBQUksR0FBRztBQUM3QixnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsNEJBQWtCLEtBQUs7QUFBQSxZQUNuQixZQUFZO0FBQUEsWUFDWixNQUFNLGFBQWE7QUFBQSxZQUNuQixTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxVQUFVO0FBQzlCLFlBQUksQ0FBQyxZQUFZLEtBQUssTUFBTSxJQUFJLEdBQUc7QUFDL0IsZ0JBQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHO0FBQ3JDLDRCQUFrQixLQUFLO0FBQUEsWUFDbkIsWUFBWTtBQUFBLFlBQ1osTUFBTSxhQUFhO0FBQUEsWUFDbkIsU0FBUyxNQUFNO0FBQUEsVUFDbkIsQ0FBQztBQUNELGlCQUFPLE1BQU07QUFBQSxRQUNqQjtBQUFBLE1BQ0osV0FDUyxNQUFNLFNBQVMsUUFBUTtBQUM1QixZQUFJLENBQUMsVUFBVSxLQUFLLE1BQU0sSUFBSSxHQUFHO0FBQzdCLGdCQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRztBQUNyQyw0QkFBa0IsS0FBSztBQUFBLFlBQ25CLFlBQVk7QUFBQSxZQUNaLE1BQU0sYUFBYTtBQUFBLFlBQ25CLFNBQVMsTUFBTTtBQUFBLFVBQ25CLENBQUM7QUFDRCxpQkFBTyxNQUFNO0FBQUEsUUFDakI7QUFBQSxNQUNKLFdBQ1MsTUFBTSxTQUFTLFNBQVM7QUFDN0IsWUFBSSxDQUFDLFdBQVcsS0FBSyxNQUFNLElBQUksR0FBRztBQUM5QixnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsNEJBQWtCLEtBQUs7QUFBQSxZQUNuQixZQUFZO0FBQUEsWUFDWixNQUFNLGFBQWE7QUFBQSxZQUNuQixTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxRQUFRO0FBQzVCLFlBQUksQ0FBQyxVQUFVLEtBQUssTUFBTSxJQUFJLEdBQUc7QUFDN0IsZ0JBQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHO0FBQ3JDLDRCQUFrQixLQUFLO0FBQUEsWUFDbkIsWUFBWTtBQUFBLFlBQ1osTUFBTSxhQUFhO0FBQUEsWUFDbkIsU0FBUyxNQUFNO0FBQUEsVUFDbkIsQ0FBQztBQUNELGlCQUFPLE1BQU07QUFBQSxRQUNqQjtBQUFBLE1BQ0osV0FDUyxNQUFNLFNBQVMsT0FBTztBQUMzQixZQUFJO0FBQ0EsY0FBSSxJQUFJLE1BQU0sSUFBSTtBQUFBLFFBQ3RCLFFBQ007QUFDRixnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsNEJBQWtCLEtBQUs7QUFBQSxZQUNuQixZQUFZO0FBQUEsWUFDWixNQUFNLGFBQWE7QUFBQSxZQUNuQixTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxTQUFTO0FBQzdCLGNBQU0sTUFBTSxZQUFZO0FBQ3hCLGNBQU0sYUFBYSxNQUFNLE1BQU0sS0FBSyxNQUFNLElBQUk7QUFDOUMsWUFBSSxDQUFDLFlBQVk7QUFDYixnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsNEJBQWtCLEtBQUs7QUFBQSxZQUNuQixZQUFZO0FBQUEsWUFDWixNQUFNLGFBQWE7QUFBQSxZQUNuQixTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxRQUFRO0FBQzVCLGNBQU0sT0FBTyxNQUFNLEtBQUssS0FBSztBQUFBLE1BQ2pDLFdBQ1MsTUFBTSxTQUFTLFlBQVk7QUFDaEMsWUFBSSxDQUFDLE1BQU0sS0FBSyxTQUFTLE1BQU0sT0FBTyxNQUFNLFFBQVEsR0FBRztBQUNuRCxnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsNEJBQWtCLEtBQUs7QUFBQSxZQUNuQixNQUFNLGFBQWE7QUFBQSxZQUNuQixZQUFZLEVBQUUsVUFBVSxNQUFNLE9BQU8sVUFBVSxNQUFNLFNBQVM7QUFBQSxZQUM5RCxTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxlQUFlO0FBQ25DLGNBQU0sT0FBTyxNQUFNLEtBQUssWUFBWTtBQUFBLE1BQ3hDLFdBQ1MsTUFBTSxTQUFTLGVBQWU7QUFDbkMsY0FBTSxPQUFPLE1BQU0sS0FBSyxZQUFZO0FBQUEsTUFDeEMsV0FDUyxNQUFNLFNBQVMsY0FBYztBQUNsQyxZQUFJLENBQUMsTUFBTSxLQUFLLFdBQVcsTUFBTSxLQUFLLEdBQUc7QUFDckMsZ0JBQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHO0FBQ3JDLDRCQUFrQixLQUFLO0FBQUEsWUFDbkIsTUFBTSxhQUFhO0FBQUEsWUFDbkIsWUFBWSxFQUFFLFlBQVksTUFBTSxNQUFNO0FBQUEsWUFDdEMsU0FBUyxNQUFNO0FBQUEsVUFDbkIsQ0FBQztBQUNELGlCQUFPLE1BQU07QUFBQSxRQUNqQjtBQUFBLE1BQ0osV0FDUyxNQUFNLFNBQVMsWUFBWTtBQUNoQyxZQUFJLENBQUMsTUFBTSxLQUFLLFNBQVMsTUFBTSxLQUFLLEdBQUc7QUFDbkMsZ0JBQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHO0FBQ3JDLDRCQUFrQixLQUFLO0FBQUEsWUFDbkIsTUFBTSxhQUFhO0FBQUEsWUFDbkIsWUFBWSxFQUFFLFVBQVUsTUFBTSxNQUFNO0FBQUEsWUFDcEMsU0FBUyxNQUFNO0FBQUEsVUFDbkIsQ0FBQztBQUNELGlCQUFPLE1BQU07QUFBQSxRQUNqQjtBQUFBLE1BQ0osV0FDUyxNQUFNLFNBQVMsWUFBWTtBQUNoQyxjQUFNLFFBQVEsY0FBYyxLQUFLO0FBQ2pDLFlBQUksQ0FBQyxNQUFNLEtBQUssTUFBTSxJQUFJLEdBQUc7QUFDekIsZ0JBQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHO0FBQ3JDLDRCQUFrQixLQUFLO0FBQUEsWUFDbkIsTUFBTSxhQUFhO0FBQUEsWUFDbkIsWUFBWTtBQUFBLFlBQ1osU0FBUyxNQUFNO0FBQUEsVUFDbkIsQ0FBQztBQUNELGlCQUFPLE1BQU07QUFBQSxRQUNqQjtBQUFBLE1BQ0osV0FDUyxNQUFNLFNBQVMsUUFBUTtBQUM1QixjQUFNLFFBQVE7QUFDZCxZQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sSUFBSSxHQUFHO0FBQ3pCLGdCQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRztBQUNyQyw0QkFBa0IsS0FBSztBQUFBLFlBQ25CLE1BQU0sYUFBYTtBQUFBLFlBQ25CLFlBQVk7QUFBQSxZQUNaLFNBQVMsTUFBTTtBQUFBLFVBQ25CLENBQUM7QUFDRCxpQkFBTyxNQUFNO0FBQUEsUUFDakI7QUFBQSxNQUNKLFdBQ1MsTUFBTSxTQUFTLFFBQVE7QUFDNUIsY0FBTSxRQUFRLFVBQVUsS0FBSztBQUM3QixZQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sSUFBSSxHQUFHO0FBQ3pCLGdCQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRztBQUNyQyw0QkFBa0IsS0FBSztBQUFBLFlBQ25CLE1BQU0sYUFBYTtBQUFBLFlBQ25CLFlBQVk7QUFBQSxZQUNaLFNBQVMsTUFBTTtBQUFBLFVBQ25CLENBQUM7QUFDRCxpQkFBTyxNQUFNO0FBQUEsUUFDakI7QUFBQSxNQUNKLFdBQ1MsTUFBTSxTQUFTLFlBQVk7QUFDaEMsWUFBSSxDQUFDLGNBQWMsS0FBSyxNQUFNLElBQUksR0FBRztBQUNqQyxnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsNEJBQWtCLEtBQUs7QUFBQSxZQUNuQixZQUFZO0FBQUEsWUFDWixNQUFNLGFBQWE7QUFBQSxZQUNuQixTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxNQUFNO0FBQzFCLFlBQUksQ0FBQyxVQUFVLE1BQU0sTUFBTSxNQUFNLE9BQU8sR0FBRztBQUN2QyxnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsNEJBQWtCLEtBQUs7QUFBQSxZQUNuQixZQUFZO0FBQUEsWUFDWixNQUFNLGFBQWE7QUFBQSxZQUNuQixTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxPQUFPO0FBQzNCLFlBQUksQ0FBQyxXQUFXLE1BQU0sTUFBTSxNQUFNLEdBQUcsR0FBRztBQUNwQyxnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsNEJBQWtCLEtBQUs7QUFBQSxZQUNuQixZQUFZO0FBQUEsWUFDWixNQUFNLGFBQWE7QUFBQSxZQUNuQixTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxRQUFRO0FBQzVCLFlBQUksQ0FBQyxZQUFZLE1BQU0sTUFBTSxNQUFNLE9BQU8sR0FBRztBQUN6QyxnQkFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUc7QUFDckMsNEJBQWtCLEtBQUs7QUFBQSxZQUNuQixZQUFZO0FBQUEsWUFDWixNQUFNLGFBQWE7QUFBQSxZQUNuQixTQUFTLE1BQU07QUFBQSxVQUNuQixDQUFDO0FBQ0QsaUJBQU8sTUFBTTtBQUFBLFFBQ2pCO0FBQUEsTUFDSixXQUNTLE1BQU0sU0FBUyxVQUFVO0FBQzlCLFlBQUksQ0FBQyxZQUFZLEtBQUssTUFBTSxJQUFJLEdBQUc7QUFDL0IsZ0JBQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHO0FBQ3JDLDRCQUFrQixLQUFLO0FBQUEsWUFDbkIsWUFBWTtBQUFBLFlBQ1osTUFBTSxhQUFhO0FBQUEsWUFDbkIsU0FBUyxNQUFNO0FBQUEsVUFDbkIsQ0FBQztBQUNELGlCQUFPLE1BQU07QUFBQSxRQUNqQjtBQUFBLE1BQ0osV0FDUyxNQUFNLFNBQVMsYUFBYTtBQUNqQyxZQUFJLENBQUMsZUFBZSxLQUFLLE1BQU0sSUFBSSxHQUFHO0FBQ2xDLGdCQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRztBQUNyQyw0QkFBa0IsS0FBSztBQUFBLFlBQ25CLFlBQVk7QUFBQSxZQUNaLE1BQU0sYUFBYTtBQUFBLFlBQ25CLFNBQVMsTUFBTTtBQUFBLFVBQ25CLENBQUM7QUFDRCxpQkFBTyxNQUFNO0FBQUEsUUFDakI7QUFBQSxNQUNKLE9BQ0s7QUFDRCxhQUFLLFlBQVksS0FBSztBQUFBLE1BQzFCO0FBQUEsSUFDSjtBQUNBLFdBQU8sRUFBRSxRQUFRLE9BQU8sT0FBTyxPQUFPLE1BQU0sS0FBSztBQUFBLEVBQ3JEO0FBQUEsRUFDQSxPQUFPLE9BQU8sWUFBWSxTQUFTO0FBQy9CLFdBQU8sS0FBSyxXQUFXLENBQUMsU0FBUyxNQUFNLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDL0M7QUFBQSxNQUNBLE1BQU0sYUFBYTtBQUFBLE1BQ25CLEdBQUcsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUNqQyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsVUFBVSxPQUFPO0FBQ2IsV0FBTyxJQUFJLFdBQVU7QUFBQSxNQUNqQixHQUFHLEtBQUs7QUFBQSxNQUNSLFFBQVEsQ0FBQyxHQUFHLEtBQUssS0FBSyxRQUFRLEtBQUs7QUFBQSxJQUN2QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsTUFBTSxTQUFTO0FBQ1gsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFNBQVMsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMzRTtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLE9BQU8sR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUN6RTtBQUFBLEVBQ0EsTUFBTSxTQUFTO0FBQ1gsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFNBQVMsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMzRTtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBQ0EsT0FBTyxTQUFTO0FBQ1osV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFVBQVUsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUM1RTtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBQ0EsTUFBTSxTQUFTO0FBQ1gsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFNBQVMsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMzRTtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBQ0EsT0FBTyxTQUFTO0FBQ1osV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFVBQVUsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUM1RTtBQUFBLEVBQ0EsVUFBVSxTQUFTO0FBRWYsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixHQUFHLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDakMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLElBQUlDLFVBQVM7QUFDVCxXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sT0FBTyxHQUFHLFVBQVUsU0FBU0EsUUFBTyxFQUFFLENBQUM7QUFBQSxFQUN6RTtBQUFBLEVBQ0EsR0FBR0EsVUFBUztBQUNSLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxNQUFNLEdBQUcsVUFBVSxTQUFTQSxRQUFPLEVBQUUsQ0FBQztBQUFBLEVBQ3hFO0FBQUEsRUFDQSxLQUFLQSxVQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsR0FBRyxVQUFVLFNBQVNBLFFBQU8sRUFBRSxDQUFDO0FBQUEsRUFDMUU7QUFBQSxFQUNBLFNBQVNBLFVBQVM7QUFDZCxRQUFJLE9BQU9BLGFBQVksVUFBVTtBQUM3QixhQUFPLEtBQUssVUFBVTtBQUFBLFFBQ2xCLE1BQU07QUFBQSxRQUNOLFdBQVc7QUFBQSxRQUNYLFFBQVE7QUFBQSxRQUNSLE9BQU87QUFBQSxRQUNQLFNBQVNBO0FBQUEsTUFDYixDQUFDO0FBQUEsSUFDTDtBQUNBLFdBQU8sS0FBSyxVQUFVO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ04sV0FBVyxPQUFPQSxVQUFTLGNBQWMsY0FBYyxPQUFPQSxVQUFTO0FBQUEsTUFDdkUsUUFBUUEsVUFBUyxVQUFVO0FBQUEsTUFDM0IsT0FBT0EsVUFBUyxTQUFTO0FBQUEsTUFDekIsR0FBRyxVQUFVLFNBQVNBLFVBQVMsT0FBTztBQUFBLElBQzFDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxLQUFLLFNBQVM7QUFDVixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sUUFBUSxRQUFRLENBQUM7QUFBQSxFQUNuRDtBQUFBLEVBQ0EsS0FBS0EsVUFBUztBQUNWLFFBQUksT0FBT0EsYUFBWSxVQUFVO0FBQzdCLGFBQU8sS0FBSyxVQUFVO0FBQUEsUUFDbEIsTUFBTTtBQUFBLFFBQ04sV0FBVztBQUFBLFFBQ1gsU0FBU0E7QUFBQSxNQUNiLENBQUM7QUFBQSxJQUNMO0FBQ0EsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixXQUFXLE9BQU9BLFVBQVMsY0FBYyxjQUFjLE9BQU9BLFVBQVM7QUFBQSxNQUN2RSxHQUFHLFVBQVUsU0FBU0EsVUFBUyxPQUFPO0FBQUEsSUFDMUMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFNBQVMsU0FBUztBQUNkLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxZQUFZLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDOUU7QUFBQSxFQUNBLE1BQU0sT0FBTyxTQUFTO0FBQ2xCLFdBQU8sS0FBSyxVQUFVO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBLEdBQUcsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUNqQyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsU0FBUyxPQUFPQSxVQUFTO0FBQ3JCLFdBQU8sS0FBSyxVQUFVO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBLFVBQVVBLFVBQVM7QUFBQSxNQUNuQixHQUFHLFVBQVUsU0FBU0EsVUFBUyxPQUFPO0FBQUEsSUFDMUMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFdBQVcsT0FBTyxTQUFTO0FBQ3ZCLFdBQU8sS0FBSyxVQUFVO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBLEdBQUcsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUNqQyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsU0FBUyxPQUFPLFNBQVM7QUFDckIsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTjtBQUFBLE1BQ0EsR0FBRyxVQUFVLFNBQVMsT0FBTztBQUFBLElBQ2pDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxJQUFJLFdBQVcsU0FBUztBQUNwQixXQUFPLEtBQUssVUFBVTtBQUFBLE1BQ2xCLE1BQU07QUFBQSxNQUNOLE9BQU87QUFBQSxNQUNQLEdBQUcsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUNqQyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsSUFBSSxXQUFXLFNBQVM7QUFDcEIsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxHQUFHLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDakMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLE9BQU8sS0FBSyxTQUFTO0FBQ2pCLFdBQU8sS0FBSyxVQUFVO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ04sT0FBTztBQUFBLE1BQ1AsR0FBRyxVQUFVLFNBQVMsT0FBTztBQUFBLElBQ2pDLENBQUM7QUFBQSxFQUNMO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxTQUFTLFNBQVM7QUFDZCxXQUFPLEtBQUssSUFBSSxHQUFHLFVBQVUsU0FBUyxPQUFPLENBQUM7QUFBQSxFQUNsRDtBQUFBLEVBQ0EsT0FBTztBQUNILFdBQU8sSUFBSSxXQUFVO0FBQUEsTUFDakIsR0FBRyxLQUFLO0FBQUEsTUFDUixRQUFRLENBQUMsR0FBRyxLQUFLLEtBQUssUUFBUSxFQUFFLE1BQU0sT0FBTyxDQUFDO0FBQUEsSUFDbEQsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLGNBQWM7QUFDVixXQUFPLElBQUksV0FBVTtBQUFBLE1BQ2pCLEdBQUcsS0FBSztBQUFBLE1BQ1IsUUFBUSxDQUFDLEdBQUcsS0FBSyxLQUFLLFFBQVEsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUFBLElBQ3pELENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxjQUFjO0FBQ1YsV0FBTyxJQUFJLFdBQVU7QUFBQSxNQUNqQixHQUFHLEtBQUs7QUFBQSxNQUNSLFFBQVEsQ0FBQyxHQUFHLEtBQUssS0FBSyxRQUFRLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFBQSxJQUN6RCxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsSUFBSSxhQUFhO0FBQ2IsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLFVBQVU7QUFBQSxFQUNqRTtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxhQUFhO0FBQ2IsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLFVBQVU7QUFBQSxFQUNqRTtBQUFBLEVBQ0EsSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUM5RDtBQUFBLEVBQ0EsSUFBSSxRQUFRO0FBQ1IsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLEtBQUs7QUFBQSxFQUM1RDtBQUFBLEVBQ0EsSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUM5RDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxXQUFXO0FBQ1gsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLFFBQVE7QUFBQSxFQUMvRDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUM5RDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxPQUFPO0FBQ1AsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLElBQUk7QUFBQSxFQUMzRDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxXQUFXO0FBQ1gsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLFFBQVE7QUFB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LEVBQ1IsYUFBYTtBQUFBLEVBQ2IsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsY0FBYztBQUFBLEVBQ2QsSUFBSTtBQUFBLEVBQ0osU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsYUFBYTtBQUFBLEVBQ2IsU0FBUztBQUFBLEVBQ1QsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUFBLEVBQ1IsU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsWUFBWTtBQUFBLEVBQ1osS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsVUFBVTtBQUFBLEVBQ1YsWUFBWTtBQUFBLEVBQ1osU0FBUztBQUFBLEVBQ1QsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsWUFBWTtBQUFBLEVBQ1osTUFBTTtBQUFBLEVBQ04sUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsWUFBWTtBQUFBLEVBQ1osV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsTUFBTTtBQUFBLEVBQ04sS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsYUFBYTtBQUFBLEVBQ2IsSUFBSTtBQUFBLEVBQ0osVUFBVTtBQUFBLEVBQ1YsT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsV0FBVztBQUFBLEVBQ1gsT0FBTztBQUFBLEVBQ1AsU0FBUztBQUFBLEVBQ1QsT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sTUFBTTtBQUFBLEVBQ04sVUFBVTtBQUFBLEVBQ1YsUUFBUTtBQUFBLEVBQ1IsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsT0FBTztBQUFBLEVBQ1AsUUFBUTtBQUFBLEVBQ1IsSUFBSTtBQUFBLEVBQ0osT0FBTztBQUFBLEVBQ1AsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sV0FBVztBQUFBLEVBQ1gsSUFBSTtBQUFBLEVBQ0osT0FBTztBQUNSO0FBQ0EsU0FBUyxTQUFTO0FBQ2hCLFFBQU0sV0FBVyxDQUFDO0FBQ2xCLFFBQU0sT0FBTyxPQUFPLEtBQUssT0FBTztBQUNoQyxRQUFNLFFBQVEsT0FBTyxLQUFLLEdBQUc7QUFDN0IsTUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJO0FBQ2pCLE9BQUssSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUs7QUFDaEMsU0FBSyxLQUFLLEtBQUssQ0FBQztBQUNoQixTQUFLLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ2pDLFVBQUksTUFBTSxDQUFDO0FBQ1gsV0FBSyxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsQ0FBQztBQUFBLElBQzNCO0FBQ0EsUUFBSSxTQUFTLFFBQVEsRUFBRSxHQUFHLEVBQUU7QUFDNUIsYUFBUyxFQUFFLElBQUksQ0FBQyxLQUFLLEtBQUssS0FBTSxLQUFLLElBQUksS0FBTSxJQUFJLEdBQUk7QUFBQSxFQUN6RDtBQUNBLFNBQU87QUFDVDtBQUVBLElBQUk7QUFDSixTQUFTLFVBQVUsS0FBSztBQUN0QixNQUFJLENBQUMsT0FBTztBQUNWLFlBQVEsT0FBTztBQUNmLFVBQU0sY0FBYyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFBQSxFQUNqQztBQUNBLFFBQU0sSUFBSSxNQUFNLElBQUksWUFBWSxDQUFDO0FBQ2pDLFNBQU8sS0FBSztBQUFBLElBQ1YsR0FBRyxFQUFFLENBQUM7QUFBQSxJQUNOLEdBQUcsRUFBRSxDQUFDO0FBQUEsSUFDTixHQUFHLEVBQUUsQ0FBQztBQUFBLElBQ04sR0FBRyxFQUFFLFdBQVcsSUFBSSxFQUFFLENBQUMsSUFBSTtBQUFBLEVBQzdCO0FBQ0Y7QUFFQSxJQUFNLFNBQVM7QUFDZixTQUFTLFNBQVMsS0FBSztBQUNyQixRQUFNLElBQUksT0FBTyxLQUFLLEdBQUc7QUFDekIsTUFBSSxJQUFJO0FBQ1IsTUFBSSxHQUFHLEdBQUc7QUFDVixNQUFJLENBQUMsR0FBRztBQUNOO0FBQUEsRUFDRjtBQUNBLE1BQUksRUFBRSxDQUFDLE1BQU0sR0FBRztBQUNkLFVBQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQztBQUNkLFFBQUksRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLEtBQUssR0FBRyxHQUFHO0FBQUEsRUFDekM7QUFDQSxNQUFJLENBQUMsRUFBRSxDQUFDO0FBQ1IsTUFBSSxDQUFDLEVBQUUsQ0FBQztBQUNSLE1BQUksQ0FBQyxFQUFFLENBQUM7QUFDUixNQUFJLE9BQU8sRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRztBQUN4QyxNQUFJLE9BQU8sRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRztBQUN4QyxNQUFJLE9BQU8sRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRztBQUN4QyxTQUFPO0FBQUEsSUFDTDtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDRjtBQUNBLFNBQVMsVUFBVSxHQUFHO0FBQ3BCLFNBQU8sTUFDTCxFQUFFLElBQUksTUFDRixRQUFRLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDLENBQUMsTUFDeEMsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7QUFFbEM7QUFFQSxJQUFNLEtBQUssT0FBSyxLQUFLLFdBQVksSUFBSSxRQUFRLEtBQUssSUFBSSxHQUFHLElBQU0sR0FBRyxJQUFJLFFBQVE7QUFDOUUsSUFBTSxPQUFPLE9BQUssS0FBSyxVQUFVLElBQUksUUFBUSxLQUFLLEtBQUssSUFBSSxTQUFTLE9BQU8sR0FBRztBQUM5RSxTQUFTLFlBQVksTUFBTSxNQUFNLEdBQUc7QUFDbEMsUUFBTSxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQztBQUMxQixRQUFNLElBQUksS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDO0FBQzFCLFFBQU0sSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLENBQUM7QUFDMUIsU0FBTztBQUFBLElBQ0wsR0FBRyxJQUFJLEdBQUcsSUFBSSxLQUFLLEtBQUssSUFBSSxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUFBLElBQzFDLEdBQUcsSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLLElBQUksS0FBSyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7QUFBQSxJQUMxQyxHQUFHLElBQUksR0FBRyxJQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0FBQUEsSUFDMUMsR0FBRyxLQUFLLElBQUksS0FBSyxLQUFLLElBQUksS0FBSztBQUFBLEVBQ2pDO0FBQ0Y7QUFFQSxTQUFTLE9BQU8sR0FBRyxHQUFHLE9BQU87QUFDM0IsTUFBSSxHQUFHO0FBQ0wsUUFBSSxNQUFNLFFBQVEsQ0FBQztBQUNuQixRQUFJLENBQUMsSUFBSSxLQUFLLElBQUksR0FBRyxLQUFLLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksT0FBTyxNQUFNLElBQUksTUFBTSxDQUFDLENBQUM7QUFDekUsVUFBTSxRQUFRLEdBQUc7QUFDakIsTUFBRSxJQUFJLElBQUksQ0FBQztBQUNYLE1BQUUsSUFBSSxJQUFJLENBQUM7QUFDWCxNQUFFLElBQUksSUFBSSxDQUFDO0FBQUEsRUFDYjtBQUNGO0FBQ0EsU0FBUyxNQUFNLEdBQUcsT0FBTztBQUN2QixTQUFPLElBQUksT0FBTyxPQUFPLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSTtBQUM3QztBQUNBLFNBQVMsV0FBVyxPQUFPO0FBQ3pCLE1BQUksSUFBSSxFQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBRztBQUNqQyxNQUFJLE1BQU0sUUFBUSxLQUFLLEdBQUc7QUFDeEIsUUFBSSxNQUFNLFVBQVUsR0FBRztBQUNyQixVQUFJLEVBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxHQUFHLE1BQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFHO0FBQ2xELFVBQUksTUFBTSxTQUFTLEdBQUc7QUFDcEIsVUFBRSxJQUFJLElBQUksTUFBTSxDQUFDLENBQUM7QUFBQSxNQUNwQjtBQUFBLElBQ0Y7QUFBQSxFQUNGLE9BQU87QUFDTCxRQUFJLE1BQU0sT0FBTyxFQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBQyxDQUFDO0FBQ3pDLE1BQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQztBQUFBLEVBQ2Y7QUFDQSxTQUFPO0FBQ1Q7QUFDQSxTQUFTLGNBQWMsS0FBSztBQUMxQixNQUFJLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSztBQUN6QixXQUFPLFNBQVMsR0FBRztBQUFBLEVBQ3JCO0FBQ0EsU0FBTyxTQUFTLEdBQUc7QUFDckI7QUFDQSxJQUFNLFFBQU4sTUFBTSxPQUFNO0FBQUEsRUFDVixZQUFZLE9BQU87QUFDakIsUUFBSSxpQkFBaUIsUUFBTztBQUMxQixhQUFPO0FBQUEsSUFDVDtBQUNBLFVBQU0sT0FBTyxPQUFPO0FBQ3BCLFFBQUk7QUFDSixRQUFJLFNBQVMsVUFBVTtBQUNyQixVQUFJLFdBQVcsS0FBSztBQUFBLElBQ3RCLFdBQVcsU0FBUyxVQUFVO0FBQzVCLFVBQUksU0FBUyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssY0FBYyxLQUFLO0FBQUEsSUFDaEU7QUFDQSxTQUFLLE9BQU87QUFDWixTQUFLLFNBQVMsQ0FBQyxDQUFDO0FBQUEsRUFDbEI7QUFBQSxFQUNBLElBQUksUUFBUTtBQUNWLFdBQU8sS0FBSztBQUFBLEVBQ2Q7QUFBQSxFQUNBLElBQUksTUFBTTtBQUNSLFFBQUksSUFBSSxNQUFNLEtBQUssSUFBSTtBQUN2QixRQUFJLEdBQUc7QUFDTCxRQUFFLElBQUksSUFBSSxFQUFFLENBQUM7QUFBQSxJQUNmO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLElBQUksSUFBSSxLQUFLO0FBQ1gsU0FBSyxPQUFPLFdBQVcsR0FBRztBQUFBLEVBQzVCO0FBQUEsRUFDQSxZQUFZO0FBQ1YsV0FBTyxLQUFLLFNBQVMsVUFBVSxLQUFLLElBQUksSUFBSTtBQUFBLEVBQzlDO0FBQUEsRUFDQSxZQUFZO0FBQ1YsV0FBTyxLQUFLLFNBQVMsVUFBVSxLQUFLLElBQUksSUFBSTtBQUFBLEVBQzlDO0FBQUEsRUFDQSxZQUFZO0FBQ1YsV0FBTyxLQUFLLFNBQVMsVUFBVSxLQUFLLElBQUksSUFBSTtBQUFBLEVBQzlDO0FBQUEsRUFDQSxJQUFJSyxRQUFPLFFBQVE7QUFDakIsUUFBSUEsUUFBTztBQUNULFlBQU0sS0FBSyxLQUFLO0FBQ2hCLFlBQU0sS0FBS0EsT0FBTTtBQUNqQixVQUFJO0FBQ0osWUFBTSxJQUFJLFdBQVcsS0FBSyxNQUFNO0FBQ2hDLFlBQU0sSUFBSSxJQUFJLElBQUk7QUFDbEIsWUFBTSxJQUFJLEdBQUcsSUFBSSxHQUFHO0FBQ3BCLFlBQU0sT0FBTyxJQUFJLE1BQU0sS0FBSyxLQUFLLElBQUksTUFBTSxJQUFJLElBQUksTUFBTSxLQUFLO0FBQzlELFdBQUssSUFBSTtBQUNULFNBQUcsSUFBSSxNQUFPLEtBQUssR0FBRyxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQ3RDLFNBQUcsSUFBSSxNQUFPLEtBQUssR0FBRyxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQ3RDLFNBQUcsSUFBSSxNQUFPLEtBQUssR0FBRyxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQ3RDLFNBQUcsSUFBSSxJQUFJLEdBQUcsS0FBSyxJQUFJLEtBQUssR0FBRztBQUMvQixXQUFLLE1BQU07QUFBQSxJQUNiO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFlBQVlBLFFBQU8sR0FBRztBQUNwQixRQUFJQSxRQUFPO0FBQ1QsV0FBSyxPQUFPLFlBQVksS0FBSyxNQUFNQSxPQUFNLE1BQU0sQ0FBQztBQUFBLElBQ2xEO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFFBQVE7QUFDTixXQUFPLElBQUksT0FBTSxLQUFLLEdBQUc7QUFBQSxFQUMzQjtBQUFBLEVBQ0EsTUFBTSxHQUFHO0FBQ1AsU0FBSyxLQUFLLElBQUksSUFBSSxDQUFDO0FBQ25CLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxRQUFRLE9BQU87QUFDYixVQUFNLE1BQU0sS0FBSztBQUNqQixRQUFJLEtBQUssSUFBSTtBQUNiLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxZQUFZO0FBQ1YsVUFBTSxNQUFNLEtBQUs7QUFDakIsVUFBTSxNQUFNLE1BQU0sSUFBSSxJQUFJLE1BQU0sSUFBSSxJQUFJLE9BQU8sSUFBSSxJQUFJLElBQUk7QUFDM0QsUUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFDeEIsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFFBQVEsT0FBTztBQUNiLFVBQU0sTUFBTSxLQUFLO0FBQ2pCLFFBQUksS0FBSyxJQUFJO0FBQ2IsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFNBQVM7QUFDUCxVQUFNLElBQUksS0FBSztBQUNmLE1BQUUsSUFBSSxNQUFNLEVBQUU7QUFDZCxNQUFFLElBQUksTUFBTSxFQUFFO0FBQ2QsTUFBRSxJQUFJLE1BQU0sRUFBRTtBQUNkLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxRQUFRLE9BQU87QUFDYixXQUFPLEtBQUssTUFBTSxHQUFHLEtBQUs7QUFDMUIsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLE9BQU8sT0FBTztBQUNaLFdBQU8sS0FBSyxNQUFNLEdBQUcsQ0FBQyxLQUFLO0FBQzNCLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFDQSxTQUFTLE9BQU87QUFDZCxXQUFPLEtBQUssTUFBTSxHQUFHLEtBQUs7QUFDMUIsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUNBLFdBQVcsT0FBTztBQUNoQixXQUFPLEtBQUssTUFBTSxHQUFHLENBQUMsS0FBSztBQUMzQixXQUFPO0FBQUEsRUFDVDtBQUFBLEVBQ0EsT0FBTyxLQUFLO0FBQ1YsV0FBTyxLQUFLLE1BQU0sR0FBRztBQUNyQixXQUFPO0FBQUEsRUFDVDtBQUNGOzs7QUM1akJPLFNBQVNDLE9BQU87QUFDckI7QUFNSyxJQUFNQyxNQUFPLHVCQUFNO0FBQ3hCLE1BQUlDLEtBQUs7QUFDVCxTQUFPLE1BQU1BO0FBQ2YsR0FBQTtBQU9PLFNBQVNDLGNBQWNDLE9BQTJDO0FBQ3ZFLFNBQU9BLFVBQVUsUUFBUUEsVUFBVUM7QUFDckM7QUFPTyxTQUFTQyxRQUFxQkYsT0FBOEI7QUFDakUsTUFBSUcsTUFBTUQsV0FBV0MsTUFBTUQsUUFBUUYsS0FBUSxHQUFBO0FBQ3pDLFdBQU87O0FBRVQsUUFBTUksT0FBT0MsT0FBT0MsVUFBVUMsU0FBU0MsS0FBS1IsS0FBQUE7QUFDNUMsTUFBSUksS0FBS0ssTUFBTSxHQUFHLENBQUEsTUFBTyxhQUFhTCxLQUFLSyxNQUFNLEVBQUMsTUFBTyxVQUFVO0FBQ2pFLFdBQU87O0FBRVQsU0FBTztBQUNUO0FBT08sU0FBU0MsU0FBU1YsT0FBb0M7QUFDM0QsU0FBT0EsVUFBVSxRQUFRSyxPQUFPQyxVQUFVQyxTQUFTQyxLQUFLUixLQUFXLE1BQUE7QUFDckU7QUFNQSxTQUFTVyxlQUFlWCxPQUFpQztBQUN2RCxVQUFRLE9BQU9BLFVBQVUsWUFBWUEsaUJBQWlCWSxXQUFXQyxTQUFTLENBQUNiLEtBQUFBO0FBQzdFO0FBVU8sU0FBU2MsZ0JBQWdCZCxPQUFnQmUsY0FBc0I7QUFDcEUsU0FBT0osZUFBZVgsS0FBU0EsSUFBQUEsUUFBUWU7QUFDekM7QUFPTyxTQUFTQyxlQUFrQmhCLE9BQXNCZSxjQUFpQjtBQUN2RSxTQUFPLE9BQU9mLFVBQVUsY0FBY2UsZUFBZWY7QUFDdkQ7SUFFYWlCLGVBQWUsQ0FBQ2pCLE9BQXdCa0IsY0FDbkQsT0FBT2xCLFVBQVUsWUFBWUEsTUFBTW1CLFNBQVMsR0FBQSxJQUMxQ0MsV0FBV3BCLEtBQUFBLElBQVMsTUFDbEIsQ0FBQ0EsUUFBUWtCO0lBRUZHLGNBQWMsQ0FBQ3JCLE9BQXdCa0IsY0FDbEQsT0FBT2xCLFVBQVUsWUFBWUEsTUFBTW1CLFNBQVMsR0FBQSxJQUMxQ0MsV0FBV3BCLEtBQUFBLElBQVMsTUFBTWtCLFlBQ3hCLENBQUNsQjtBQVNBLFNBQVNzQixTQUNkQyxJQUNBQyxNQUNBQyxTQUNlO0FBQ2YsTUFBSUYsTUFBTSxPQUFPQSxHQUFHZixTQUFTLFlBQVk7QUFDdkMsV0FBT2UsR0FBR0csTUFBTUQsU0FBU0QsSUFBQUE7O0FBRTdCO0FBdUJPLFNBQVNHLEtBQ2RDLFVBQ0FMLElBQ0FFLFNBQ0FJLFNBQ0E7QUFDQSxNQUFJQyxHQUFXQyxLQUFhQztBQUM1QixNQUFJOUIsUUFBUTBCLFFBQVcsR0FBQTtBQUNyQkcsVUFBTUgsU0FBU0s7QUFDZixRQUFJSixTQUFTO0FBQ1gsV0FBS0MsSUFBSUMsTUFBTSxHQUFHRCxLQUFLLEdBQUdBLEtBQUs7QUFDN0JQLFdBQUdmLEtBQUtpQixTQUFTRyxTQUFTRSxDQUFBQSxHQUFJQSxDQUFBQTtNQUNoQztXQUNLO0FBQ0wsV0FBS0EsSUFBSSxHQUFHQSxJQUFJQyxLQUFLRCxLQUFLO0FBQ3hCUCxXQUFHZixLQUFLaUIsU0FBU0csU0FBU0UsQ0FBQUEsR0FBSUEsQ0FBQUE7TUFDaEM7O2FBRU9wQixTQUFTa0IsUUFBVyxHQUFBO0FBQzdCSSxXQUFPM0IsT0FBTzJCLEtBQUtKLFFBQUFBO0FBQ25CRyxVQUFNQyxLQUFLQztBQUNYLFNBQUtILElBQUksR0FBR0EsSUFBSUMsS0FBS0QsS0FBSztBQUN4QlAsU0FBR2YsS0FBS2lCLFNBQVNHLFNBQVNJLEtBQUtGLENBQUFBLENBQUUsR0FBR0UsS0FBS0YsQ0FBRSxDQUFBO0lBQzdDOztBQUVKO0FBUU8sU0FBU0ksZUFBZUMsSUFBdUJDLElBQXVCO0FBQzNFLE1BQUlOLEdBQVdPLE1BQWNDLElBQXFCQztBQUVsRCxNQUFJLENBQUNKLE1BQU0sQ0FBQ0MsTUFBTUQsR0FBR0YsV0FBV0csR0FBR0gsUUFBUTtBQUN6QyxXQUFPOztBQUdULE9BQUtILElBQUksR0FBR08sT0FBT0YsR0FBR0YsUUFBUUgsSUFBSU8sTUFBTSxFQUFFUCxHQUFHO0FBQzNDUSxTQUFLSCxHQUFHTCxDQUFFO0FBQ1ZTLFNBQUtILEdBQUdOLENBQUU7QUFFVixRQUFJUSxHQUFHRSxpQkFBaUJELEdBQUdDLGdCQUFnQkYsR0FBR0csVUFBVUYsR0FBR0UsT0FBTztBQUNoRSxhQUFPOztFQUVYO0FBRUEsU0FBTztBQUNUO0FBTU8sU0FBU0MsT0FBU0MsUUFBYztBQUNyQyxNQUFJekMsUUFBUXlDLE1BQVMsR0FBQTtBQUNuQixXQUFPQSxPQUFPQyxJQUFJRixNQUFBQTs7QUFHcEIsTUFBSWhDLFNBQVNpQyxNQUFTLEdBQUE7QUFDcEIsVUFBTUUsU0FBU3hDLHVCQUFPeUMsT0FBTyxJQUFJO0FBQ2pDLFVBQU1kLE9BQU8zQixPQUFPMkIsS0FBS1csTUFBQUE7QUFDekIsVUFBTUksT0FBT2YsS0FBS0M7QUFDbEIsUUFBSWUsSUFBSTtBQUVSLFdBQU9BLElBQUlELE1BQU0sRUFBRUMsR0FBRztBQUNwQkgsYUFBT2IsS0FBS2dCLENBQUFBLENBQUUsSUFBSU4sT0FBTUMsT0FBT1gsS0FBS2dCLENBQUFBLENBQUUsQ0FBQztJQUN6QztBQUVBLFdBQU9IOztBQUdULFNBQU9GO0FBQ1Q7QUFFQSxTQUFTTSxXQUFXQyxLQUFhO0FBQy9CLFNBQU87SUFBQztJQUFhO0lBQWE7SUFBZUMsUUFBUUQsR0FBQUEsTUFBUztBQUNwRTtBQU9PLFNBQVNFLFFBQVFGLEtBQWFMLFFBQW1CRixRQUFtQlUsVUFBb0I7QUFDN0YsTUFBSSxDQUFDSixXQUFXQyxHQUFNLEdBQUE7QUFDcEI7O0FBR0YsUUFBTUksT0FBT1QsT0FBT0ssR0FBSTtBQUN4QixRQUFNSyxPQUFPWixPQUFPTyxHQUFJO0FBRXhCLE1BQUl4QyxTQUFTNEMsSUFBUzVDLEtBQUFBLFNBQVM2QyxJQUFPLEdBQUE7QUFFcENDLFVBQU1GLE1BQU1DLE1BQU1GLFFBQUFBO1NBQ2I7QUFDTFIsV0FBT0ssR0FBSSxJQUFHUixPQUFNYSxJQUFBQTs7QUFFeEI7QUEwQk8sU0FBU0MsTUFBU1gsUUFBV0YsUUFBcUJVLFVBQW1DO0FBQzFGLFFBQU1JLFVBQVV2RCxRQUFReUMsTUFBQUEsSUFBVUEsU0FBUztJQUFDQTtFQUFPO0FBQ25ELFFBQU1OLE9BQU9vQixRQUFReEI7QUFFckIsTUFBSSxDQUFDdkIsU0FBU21DLE1BQVMsR0FBQTtBQUNyQixXQUFPQTs7QUFHVFEsRUFBQUEsV0FBVUEsWUFBVyxDQUFBO0FBQ3JCLFFBQU1LLFNBQVNMLFNBQVFLLFVBQVVOO0FBQ2pDLE1BQUlPO0FBRUosV0FBUzdCLElBQUksR0FBR0EsSUFBSU8sTUFBTSxFQUFFUCxHQUFHO0FBQzdCNkIsY0FBVUYsUUFBUTNCLENBQUU7QUFDcEIsUUFBSSxDQUFDcEIsU0FBU2lELE9BQVUsR0FBQTtBQUN0Qjs7QUFHRixVQUFNM0IsT0FBTzNCLE9BQU8yQixLQUFLMkIsT0FBQUE7QUFDekIsYUFBU1gsSUFBSSxHQUFHRCxPQUFPZixLQUFLQyxRQUFRZSxJQUFJRCxNQUFNLEVBQUVDLEdBQUc7QUFDakRVLGFBQU8xQixLQUFLZ0IsQ0FBRSxHQUFFSCxRQUFRYyxTQUFTTixRQUFBQTtJQUNuQztFQUNGO0FBRUEsU0FBT1I7QUFDVDtBQWdCTyxTQUFTZSxRQUFXZixRQUFXRixRQUFnQztBQUVwRSxTQUFPYSxNQUFTWCxRQUFRRixRQUFRO0lBQUNlLFFBQVFHO0VBQVMsQ0FBQTtBQUNwRDtBQU1PLFNBQVNBLFVBQVVYLEtBQWFMLFFBQW1CRixRQUFtQjtBQUMzRSxNQUFJLENBQUNNLFdBQVdDLEdBQU0sR0FBQTtBQUNwQjs7QUFHRixRQUFNSSxPQUFPVCxPQUFPSyxHQUFJO0FBQ3hCLFFBQU1LLE9BQU9aLE9BQU9PLEdBQUk7QUFFeEIsTUFBSXhDLFNBQVM0QyxJQUFTNUMsS0FBQUEsU0FBUzZDLElBQU8sR0FBQTtBQUNwQ0ssWUFBUU4sTUFBTUMsSUFBQUE7YUFDTCxDQUFDbEQsT0FBT0MsVUFBVXdELGVBQWV0RCxLQUFLcUMsUUFBUUssR0FBTSxHQUFBO0FBQzdETCxXQUFPSyxHQUFJLElBQUdSLE9BQU1hLElBQUFBOztBQUV4QjtBQWFBLElBQU1RLGVBQWU7O0VBRW5CLElBQUlDLENBQUFBLE1BQUtBOztFQUVUQyxHQUFHQyxDQUFBQSxNQUFLQSxFQUFFRDtFQUNWRSxHQUFHRCxDQUFBQSxNQUFLQSxFQUFFQztBQUNaO0FBS08sU0FBU0MsVUFBVUMsS0FBYTtBQUNyQyxRQUFNQyxRQUFRRCxJQUFJRSxNQUFNLEdBQUE7QUFDeEIsUUFBTUMsT0FBaUIsQ0FBQTtBQUN2QixNQUFJQyxNQUFNO0FBQ1YsYUFBV0MsUUFBUUosT0FBTztBQUN4QkcsV0FBT0M7QUFDUCxRQUFJRCxJQUFJRSxTQUFTLElBQU8sR0FBQTtBQUN0QkYsWUFBTUEsSUFBSUcsTUFBTSxHQUFHLEVBQU0sSUFBQTtXQUNwQjtBQUNMSixXQUFLSyxLQUFLSixHQUFBQTtBQUNWQSxZQUFNOztFQUVWO0FBQ0EsU0FBT0Q7QUFDVDtBQUVBLFNBQVNNLGdCQUFnQlQsS0FBYTtBQUNwQyxRQUFNRyxPQUFPSixVQUFVQyxHQUFBQTtBQUN2QixTQUFPVSxDQUFBQSxRQUFPO0FBQ1osZUFBV0MsS0FBS1IsTUFBTTtBQUNwQixVQUFJUSxNQUFNLElBQUk7QUFHWjs7QUFFRkQsWUFBTUEsT0FBT0EsSUFBSUMsQ0FBRTtJQUNyQjtBQUNBLFdBQU9EO0VBQ1Q7QUFDRjtBQUVPLFNBQVNFLGlCQUFpQkYsS0FBZ0JWLEtBQWtCO0FBQ2pFLFFBQU1hLFdBQVduQixhQUFhTSxHQUFJLE1BQUtOLGFBQWFNLEdBQUFBLElBQU9TLGdCQUFnQlQsR0FBRztBQUM5RSxTQUFPYSxTQUFTSCxHQUFBQTtBQUNsQjtBQUtPLFNBQVNJLFlBQVlDLEtBQWE7QUFDdkMsU0FBT0EsSUFBSUMsT0FBTyxDQUFBLEVBQUdDLFlBQVcsSUFBS0YsSUFBSVIsTUFBTSxDQUFBO0FBQ2pEO0lBR2FXLFVBQVUsQ0FBQ0MsVUFBbUIsT0FBT0EsVUFBVTtJQUUvQ0MsYUFBYSxDQUFDRCxVQUFxRCxPQUFPQSxVQUFVO0FBR3BGRSxJQUFBQSxZQUFZLENBQUlDLEdBQVdDLE1BQWM7QUFDcEQsTUFBSUQsRUFBRUUsU0FBU0QsRUFBRUMsTUFBTTtBQUNyQixXQUFPOztBQUdULGFBQVdDLFFBQVFILEdBQUc7QUFDcEIsUUFBSSxDQUFDQyxFQUFFRyxJQUFJRCxJQUFPLEdBQUE7QUFDaEIsYUFBTzs7RUFFWDtBQUVBLFNBQU87QUFDVDtBQU1PLFNBQVNFLGNBQWNDLEdBQWU7QUFDM0MsU0FBT0EsRUFBRUMsU0FBUyxhQUFhRCxFQUFFQyxTQUFTLFdBQVdELEVBQUVDLFNBQVM7QUFDbEU7QUN2Wk8sSUFBTUMsS0FBS0MsS0FBS0Q7QUFDaEIsSUFBTUUsTUFBTSxJQUFJRjtBQUNoQixJQUFNRyxRQUFRRCxNQUFNRjtBQUNkSSxJQUFBQSxXQUFXQyxPQUFPQztBQUN4QixJQUFNQyxjQUFjUCxLQUFLO0FBQ3pCLElBQU1RLFVBQVVSLEtBQUs7QUFDckIsSUFBTVMsYUFBYVQsS0FBSztBQUNsQlUsSUFBQUEsZ0JBQWdCVixLQUFLLElBQUk7QUFFekJXLElBQUFBLFFBQVFWLEtBQUtVO0FBQ2JDLElBQUFBLE9BQU9YLEtBQUtXO0FBRWxCLFNBQVNDLGFBQWEvQyxHQUFXRSxHQUFXOEMsU0FBaUI7QUFDbEUsU0FBT2IsS0FBS2MsSUFBSWpELElBQUlFLENBQUs4QyxJQUFBQTtBQUMzQjtBQUtPLFNBQVNFLFFBQVFDLE9BQWU7QUFDckMsUUFBTUMsZUFBZWpCLEtBQUtrQixNQUFNRixLQUFBQTtBQUNoQ0EsVUFBUUosYUFBYUksT0FBT0MsY0FBY0QsUUFBUSxHQUFBLElBQVFDLGVBQWVEO0FBQ3pFLFFBQU1HLFlBQVluQixLQUFLb0IsSUFBSSxJQUFJcEIsS0FBS3FCLE1BQU1YLE1BQU1NLEtBQUFBLENBQUFBLENBQUFBO0FBQ2hELFFBQU1NLFdBQVdOLFFBQVFHO0FBQ3pCLFFBQU1JLGVBQWVELFlBQVksSUFBSSxJQUFJQSxZQUFZLElBQUksSUFBSUEsWUFBWSxJQUFJLElBQUk7QUFDakYsU0FBT0MsZUFBZUo7QUFDeEI7QUFNTyxTQUFTSyxXQUFXcEMsT0FBZTtBQUN4QyxRQUFNcUMsU0FBbUIsQ0FBQTtBQUN6QixRQUFNQyxPQUFPMUIsS0FBSzBCLEtBQUt0QyxLQUFBQTtBQUN2QixNQUFJdUM7QUFFSixPQUFLQSxJQUFJLEdBQUdBLElBQUlELE1BQU1DLEtBQUs7QUFDekIsUUFBSXZDLFFBQVF1QyxNQUFNLEdBQUc7QUFDbkJGLGFBQU9oRCxLQUFLa0QsQ0FBQUE7QUFDWkYsYUFBT2hELEtBQUtXLFFBQVF1QyxDQUFBQTs7RUFFeEI7QUFDQSxNQUFJRCxVQUFVQSxPQUFPLElBQUk7QUFDdkJELFdBQU9oRCxLQUFLaUQsSUFBQUE7O0FBR2RELFNBQU9HLEtBQUssQ0FBQ3JDLEdBQUdDLE1BQU1ELElBQUlDLENBQUFBLEVBQUdxQyxJQUFHO0FBQ2hDLFNBQU9KO0FBQ1Q7QUFLQSxTQUFTSyxlQUFlQyxHQUFZO0FBQ2xDLFNBQU8sT0FBT0EsTUFBTSxZQUFhLE9BQU9BLE1BQU0sWUFBWUEsTUFBTSxRQUFRLEVBQUVDLE9BQU9DLGVBQWVGLEtBQUssY0FBY0EsS0FBSyxhQUFhQTtBQUN2STtBQUVPLFNBQVNHLFNBQVNILEdBQXlCO0FBQ2hELFNBQU8sQ0FBQ0QsZUFBZUMsQ0FBQUEsS0FBTSxDQUFDSSxNQUFNQyxXQUFXTCxDQUFBQSxDQUFBQSxLQUFpQk0sU0FBU04sQ0FBQUE7QUFDM0U7QUFFTyxTQUFTTyxZQUFZekUsR0FBV2dELFNBQWlCO0FBQ3RELFFBQU0wQixVQUFVdkMsS0FBS2tCLE1BQU1yRCxDQUFBQTtBQUMzQixTQUFPLFVBQVlnRCxXQUFZaEQsS0FBUTBFLFVBQVUxQixXQUFZaEQ7QUFDL0Q7QUFLTyxTQUFTMkUsbUJBQ2RDLE9BQ0FDLFFBQ0FDLFVBQ0E7QUFDQSxNQUFJaEIsR0FBV2lCLE1BQWN4RDtBQUU3QixPQUFLdUMsSUFBSSxHQUFHaUIsT0FBT0gsTUFBTUksUUFBUWxCLElBQUlpQixNQUFNakIsS0FBSztBQUM5Q3ZDLFlBQVFxRCxNQUFNZCxDQUFFLEVBQUNnQixRQUFTO0FBQzFCLFFBQUksQ0FBQ1IsTUFBTS9DLEtBQVEsR0FBQTtBQUNqQnNELGFBQU9JLE1BQU05QyxLQUFLOEMsSUFBSUosT0FBT0ksS0FBSzFELEtBQUFBO0FBQ2xDc0QsYUFBT0ssTUFBTS9DLEtBQUsrQyxJQUFJTCxPQUFPSyxLQUFLM0QsS0FBQUE7O0VBRXRDO0FBQ0Y7QUFFTyxTQUFTNEQsVUFBVUMsU0FBaUI7QUFDekMsU0FBT0EsV0FBV2xELEtBQUs7QUFDekI7QUFFTyxTQUFTbUQsVUFBVUMsU0FBaUI7QUFDekMsU0FBT0EsV0FBVyxNQUFNcEQ7QUFDMUI7QUFTTyxTQUFTcUQsZUFBZXZGLEdBQVc7QUFDeEMsTUFBSSxDQUFDd0YsZUFBZXhGLENBQUksR0FBQTtBQUN0Qjs7QUFFRixNQUFJZ0MsSUFBSTtBQUNSLE1BQUl5RCxJQUFJO0FBQ1IsU0FBT3RELEtBQUtrQixNQUFNckQsSUFBSWdDLENBQUFBLElBQUtBLE1BQU1oQyxHQUFHO0FBQ2xDZ0MsU0FBSztBQUNMeUQ7RUFDRjtBQUNBLFNBQU9BO0FBQ1Q7QUFHTyxTQUFTQyxrQkFDZEMsYUFDQUMsWUFDQTtBQUNBLFFBQU1DLHNCQUFzQkQsV0FBVzVGLElBQUkyRixZQUFZM0Y7QUFDdkQsUUFBTThGLHNCQUFzQkYsV0FBVzFGLElBQUl5RixZQUFZekY7QUFDdkQsUUFBTTZGLDJCQUEyQjVELEtBQUswQixLQUFLZ0Msc0JBQXNCQSxzQkFBc0JDLHNCQUFzQkEsbUJBQUFBO0FBRTdHLE1BQUlFLFFBQVE3RCxLQUFLOEQsTUFBTUgscUJBQXFCRCxtQkFBQUE7QUFFNUMsTUFBSUcsUUFBUyxPQUFPOUQsSUFBSztBQUN2QjhELGFBQVM1RDs7QUFHWCxTQUFPO0lBQ0w0RDtJQUNBRSxVQUFVSDtFQUNaO0FBQ0Y7QUFFTyxTQUFTSSxzQkFBc0JDLEtBQVlDLEtBQVk7QUFDNUQsU0FBT2xFLEtBQUswQixLQUFLMUIsS0FBS29CLElBQUk4QyxJQUFJckcsSUFBSW9HLElBQUlwRyxHQUFHLENBQUEsSUFBS21DLEtBQUtvQixJQUFJOEMsSUFBSW5HLElBQUlrRyxJQUFJbEcsR0FBRyxDQUFBLENBQUE7QUFDeEU7QUFNTyxTQUFTb0csV0FBVzVFLEdBQVdDLEdBQVc7QUFDL0MsVUFBUUQsSUFBSUMsSUFBSVUsU0FBU0QsTUFBTUY7QUFDakM7QUFNTyxTQUFTcUUsZ0JBQWdCN0UsR0FBVztBQUN6QyxVQUFRQSxJQUFJVSxNQUFNQSxPQUFPQTtBQUMzQjtBQUtPLFNBQVNvRSxjQUFjUixPQUFlUyxPQUFlQyxLQUFhQyx1QkFBaUM7QUFDeEcsUUFBTWpGLElBQUk2RSxnQkFBZ0JQLEtBQUFBO0FBQzFCLFFBQU1ZLElBQUlMLGdCQUFnQkUsS0FBQUE7QUFDMUIsUUFBTXpFLElBQUl1RSxnQkFBZ0JHLEdBQUFBO0FBQzFCLFFBQU1HLGVBQWVOLGdCQUFnQkssSUFBSWxGLENBQUFBO0FBQ3pDLFFBQU1vRixhQUFhUCxnQkFBZ0J2RSxJQUFJTixDQUFBQTtBQUN2QyxRQUFNcUYsZUFBZVIsZ0JBQWdCN0UsSUFBSWtGLENBQUFBO0FBQ3pDLFFBQU1JLGFBQWFULGdCQUFnQjdFLElBQUlNLENBQUFBO0FBQ3ZDLFNBQU9OLE1BQU1rRixLQUFLbEYsTUFBTU0sS0FBTTJFLHlCQUF5QkMsTUFBTTVFLEtBQ3ZENkUsZUFBZUMsY0FBY0MsZUFBZUM7QUFDcEQ7QUFTTyxTQUFTQyxZQUFZMUYsT0FBZTBELEtBQWFDLEtBQWE7QUFDbkUsU0FBTy9DLEtBQUsrQyxJQUFJRCxLQUFLOUMsS0FBSzhDLElBQUlDLEtBQUszRCxLQUFBQSxDQUFBQTtBQUNyQztBQU1PLFNBQVMyRixZQUFZM0YsT0FBZTtBQUN6QyxTQUFPMEYsWUFBWTFGLE9BQU8sUUFBUSxLQUFBO0FBQ3BDO0FBU08sU0FBUzRGLFdBQVc1RixPQUFla0YsT0FBZUMsS0FBYTFELFVBQVUsTUFBTTtBQUNwRixTQUFPekIsU0FBU1ksS0FBSzhDLElBQUl3QixPQUFPQyxHQUFBQSxJQUFPMUQsV0FBV3pCLFNBQVNZLEtBQUsrQyxJQUFJdUIsT0FBT0MsR0FBTzFELElBQUFBO0FBQ3BGO0FDM0xPLFNBQVNvRSxRQUNkQyxPQUNBOUYsT0FDQStGLEtBQ0E7QUFDQUEsUUFBTUEsUUFBUSxDQUFDQyxXQUFVRixNQUFNRSxNQUFBQSxJQUFTaEc7QUFDeEMsTUFBSWlHLEtBQUtILE1BQU1yQyxTQUFTO0FBQ3hCLE1BQUl5QyxLQUFLO0FBQ1QsTUFBSUM7QUFFSixTQUFPRixLQUFLQyxLQUFLLEdBQUc7QUFDbEJDLFVBQU9ELEtBQUtELE1BQU87QUFDbkIsUUFBSUYsSUFBSUksR0FBTSxHQUFBO0FBQ1pELFdBQUtDO1dBQ0E7QUFDTEYsV0FBS0U7O0VBRVQ7QUFFQSxTQUFPO0lBQUNEO0lBQUlEO0VBQUU7QUFDaEI7QUFVTyxJQUFNRyxlQUFlLENBQzFCTixPQUNBakgsS0FDQW1CLE9BQ0FxRyxTQUVBUixRQUFRQyxPQUFPOUYsT0FBT3FHLE9BQ2xCTCxDQUFBQSxXQUFTO0FBQ1QsUUFBTU0sS0FBS1IsTUFBTUUsTUFBQUEsRUFBT25ILEdBQUk7QUFDNUIsU0FBT3lILEtBQUt0RyxTQUFTc0csT0FBT3RHLFNBQVM4RixNQUFNRSxTQUFRLENBQUEsRUFBR25ILEdBQUFBLE1BQVNtQjtJQUUvRGdHLENBQUFBLFdBQVNGLE1BQU1FLE1BQUFBLEVBQU9uSCxHQUFBQSxJQUFPbUIsS0FBSztBQVMzQnVHLElBQUFBLGdCQUFnQixDQUMzQlQsT0FDQWpILEtBQ0FtQixVQUVBNkYsUUFBUUMsT0FBTzlGLE9BQU9nRyxDQUFBQSxXQUFTRixNQUFNRSxNQUFBQSxFQUFPbkgsR0FBQUEsS0FBUW1CLEtBQU87QUFTdEQsU0FBU3dHLGVBQWVDLFFBQWtCL0MsS0FBYUMsS0FBYTtBQUN6RSxNQUFJdUIsUUFBUTtBQUNaLE1BQUlDLE1BQU1zQixPQUFPaEQ7QUFFakIsU0FBT3lCLFFBQVFDLE9BQU9zQixPQUFPdkIsS0FBQUEsSUFBU3hCLEtBQUs7QUFDekN3QjtFQUNGO0FBQ0EsU0FBT0MsTUFBTUQsU0FBU3VCLE9BQU90QixNQUFNLENBQUEsSUFBS3hCLEtBQUs7QUFDM0N3QjtFQUNGO0FBRUEsU0FBT0QsUUFBUSxLQUFLQyxNQUFNc0IsT0FBT2hELFNBQzdCZ0QsT0FBT3JILE1BQU04RixPQUFPQyxHQUFBQSxJQUNwQnNCO0FBQ047QUFFQSxJQUFNQyxjQUFjO0VBQUM7RUFBUTtFQUFPO0VBQVM7RUFBVTtBQUFVO0FBZ0IxRCxTQUFTQyxrQkFBa0J0RCxPQUFPdUQsVUFBVTtBQUNqRCxNQUFJdkQsTUFBTXdELFVBQVU7QUFDbEJ4RCxVQUFNd0QsU0FBU0MsVUFBVXpILEtBQUt1SCxRQUFBQTtBQUM5Qjs7QUFHRkcsU0FBT0MsZUFBZTNELE9BQU8sWUFBWTtJQUN2QzRELGNBQWM7SUFDZEMsWUFBWTtJQUNabEgsT0FBTztNQUNMOEcsV0FBVztRQUFDRjtNQUFTO0lBQ3ZCO0VBQ0YsQ0FBQTtBQUVBRixjQUFZUyxRQUFRLENBQUN0SSxRQUFRO0FBQzNCLFVBQU11SSxTQUFTLFlBQVl6SCxZQUFZZCxHQUFBQTtBQUN2QyxVQUFNd0ksT0FBT2hFLE1BQU14RSxHQUFJO0FBRXZCa0ksV0FBT0MsZUFBZTNELE9BQU94RSxLQUFLO01BQ2hDb0ksY0FBYztNQUNkQyxZQUFZO01BQ1psSCxTQUFTc0gsTUFBTTtBQUNiLGNBQU1DLE1BQU1GLEtBQUtHLE1BQU0sTUFBTUYsSUFBQUE7QUFFN0JqRSxjQUFNd0QsU0FBU0MsVUFBVUssUUFBUSxDQUFDTSxXQUFXO0FBQzNDLGNBQUksT0FBT0EsT0FBT0wsTUFBQUEsTUFBWSxZQUFZO0FBQ3hDSyxtQkFBT0wsTUFBQUEsRUFBV0UsR0FBQUEsSUFBQUE7O1FBRXRCLENBQUE7QUFFQSxlQUFPQztNQUNUO0lBQ0YsQ0FBQTtFQUNGLENBQUE7QUFDRjtBQVFPLFNBQVNHLG9CQUFvQnJFLE9BQU91RCxVQUFVO0FBQ25ELFFBQU1lLE9BQU90RSxNQUFNd0Q7QUFDbkIsTUFBSSxDQUFDYyxNQUFNO0FBQ1Q7O0FBR0YsUUFBTWIsWUFBWWEsS0FBS2I7QUFDdkIsUUFBTWQsU0FBUWMsVUFBVWMsUUFBUWhCLFFBQUFBO0FBQ2hDLE1BQUlaLFdBQVUsSUFBSTtBQUNoQmMsY0FBVWUsT0FBTzdCLFFBQU8sQ0FBQTs7QUFHMUIsTUFBSWMsVUFBVXJELFNBQVMsR0FBRztBQUN4Qjs7QUFHRmlELGNBQVlTLFFBQVEsQ0FBQ3RJLFFBQVE7QUFDM0IsV0FBT3dFLE1BQU14RSxHQUFJO0VBQ25CLENBQUE7QUFFQSxTQUFPd0UsTUFBTXdEO0FBQ2Y7QUFLTyxTQUFTaUIsYUFBZ0JDLE9BQVk7QUFDMUMsUUFBTUMsT0FBTSxJQUFJQyxJQUFPRixLQUFBQTtBQUV2QixNQUFJQyxLQUFJM0gsU0FBUzBILE1BQU10RSxRQUFRO0FBQzdCLFdBQU9zRTs7QUFHVCxTQUFPRyxNQUFNQyxLQUFLSCxJQUFBQTtBQUNwQjtBQ2xMYUksSUFBQUEsbUJBQW9CLFdBQVc7QUFDMUMsTUFBSSxPQUFPQyxXQUFXLGFBQWE7QUFDakMsV0FBTyxTQUFTQyxXQUFVO0FBQ3hCLGFBQU9BLFVBQUFBO0lBQ1Q7O0FBRUYsU0FBT0QsT0FBT0U7QUFDaEIsRUFBSztBQU1FLFNBQVNDLFVBQ2RDLElBQ0FDLFNBQ0E7QUFDQSxNQUFJQyxZQUFZLENBQUE7QUFDaEIsTUFBSUMsVUFBVTtBQUVkLFNBQU8sWUFBWUMsTUFBYTtBQUU5QkYsZ0JBQVlFO0FBQ1osUUFBSSxDQUFDRCxTQUFTO0FBQ1pBLGdCQUFVO0FBQ1ZSLHVCQUFpQlUsS0FBS1QsUUFBUSxNQUFNO0FBQ2xDTyxrQkFBVTtBQUNWSCxXQUFHTSxNQUFNTCxTQUFTQyxTQUFBQTtNQUNwQixDQUFBOztFQUVKO0FBQ0Y7QUFLTyxTQUFTSyxTQUFtQ1AsSUFBOEJRLE9BQWU7QUFDOUYsTUFBSUM7QUFDSixTQUFPLFlBQVlMLE1BQWE7QUFDOUIsUUFBSUksT0FBTztBQUNURSxtQkFBYUQsT0FBQUE7QUFDYkEsZ0JBQVVFLFdBQVdYLElBQUlRLE9BQU9KLElBQUFBO1dBQzNCO0FBQ0xKLFNBQUdNLE1BQU0sTUFBTUYsSUFBQUE7O0FBRWpCLFdBQU9JO0VBQ1Q7QUFDRjtBQU1PLElBQU1JLHFCQUFxQixDQUFDQyxVQUFzQ0EsVUFBVSxVQUFVLFNBQVNBLFVBQVUsUUFBUSxVQUFVO0FBTXJIQyxJQUFBQSxpQkFBaUIsQ0FBQ0QsT0FBbUNFLE9BQWVDLFFBQWdCSCxVQUFVLFVBQVVFLFFBQVFGLFVBQVUsUUFBUUcsT0FBT0QsUUFBUUMsT0FBTztBQU14SkMsSUFBQUEsU0FBUyxDQUFDSixPQUFvQ0ssTUFBY0MsT0FBZUMsUUFBaUI7QUFDdkcsUUFBTUMsUUFBUUQsTUFBTSxTQUFTO0FBQzdCLFNBQU9QLFVBQVVRLFFBQVFGLFFBQVFOLFVBQVUsWUFBWUssT0FBT0MsU0FBUyxJQUFJRDtBQUM3RTtBQU1PLFNBQVNJLGlDQUFpQ0MsTUFBcUNDLFFBQXdCQyxvQkFBNkI7QUFDekksUUFBTUMsYUFBYUYsT0FBT0c7QUFFMUIsTUFBSVosUUFBUTtBQUNaLE1BQUlhLFFBQVFGO0FBRVosTUFBSUgsS0FBS00sU0FBUztBQUNoQixVQUFNLEVBQUNDLFFBQVFDLFFBQVFDLFFBQUFBLElBQVdUO0FBQ2xDLFVBQU1VLFdBQVdWLEtBQUtXLFVBQVVYLEtBQUtXLFFBQVFDLFVBQVVaLEtBQUtXLFFBQVFDLFFBQVFGLFdBQVcsT0FBTztBQUM5RixVQUFNRyxPQUFPTixPQUFPTTtBQUNwQixVQUFNLEVBQUNDLEtBQUtDLEtBQUtDLFlBQVlDLFdBQVUsSUFBSVYsT0FBT1csY0FBYTtBQUUvRCxRQUFJRixZQUFZO0FBQ2R4QixjQUFRMkIsS0FBS0w7O1FBRVhNLGFBQWFYLFNBQVNJLE1BQU1DLEdBQUtPLEVBQUFBOztRQUVqQ25CLHFCQUFxQkMsYUFBYWlCLGFBQWFuQixRQUFRWSxNQUFNTixPQUFPZSxpQkFBaUJSLEdBQUFBLENBQUFBLEVBQU1PO01BQUU7QUFDL0YsVUFBSVgsVUFBVTtBQUNaLGNBQU1hLHNCQUF1QmQsUUFDMUJlLE1BQU0sR0FBR2hDLFFBQVEsQ0FBQSxFQUNqQmlDLFFBQU8sRUFDUEMsVUFDQ0MsQ0FBQUEsVUFBUyxDQUFDQyxjQUFjRCxNQUFNbkIsT0FBT0ssSUFBSSxDQUFDLENBQUE7QUFDOUNyQixpQkFBUzJCLEtBQUtKLElBQUksR0FBR1EsbUJBQUFBOztBQUV2Qi9CLGNBQVFxQyxZQUFZckMsT0FBTyxHQUFHVyxhQUFhLENBQUE7O0FBRTdDLFFBQUljLFlBQVk7QUFDZCxVQUFJeEIsTUFBTTBCLEtBQUtKOztRQUViSyxhQUFhWCxTQUFTRixPQUFPTSxNQUFNRSxLQUFLLElBQUksRUFBRWUsS0FBSzs7UUFFbkQ1QixxQkFBcUIsSUFBSWtCLGFBQWFuQixRQUFRWSxNQUFNTixPQUFPZSxpQkFBaUJQLEdBQUFBLEdBQU0sSUFBSSxFQUFFZSxLQUFLO01BQUM7QUFDaEcsVUFBSXBCLFVBQVU7QUFDWixjQUFNcUIsc0JBQXVCdEIsUUFDMUJlLE1BQU0vQixNQUFNLENBQUEsRUFDWmlDLFVBQ0NDLENBQUFBLFVBQVMsQ0FBQ0MsY0FBY0QsTUFBTW5CLE9BQU9LLElBQUksQ0FBQyxDQUFBO0FBQzlDcEIsZUFBTzBCLEtBQUtKLElBQUksR0FBR2dCLG1CQUFBQTs7QUFFckIxQixjQUFRd0IsWUFBWXBDLEtBQUtELE9BQU9XLFVBQWNYLElBQUFBO1dBQ3pDO0FBQ0xhLGNBQVFGLGFBQWFYOzs7QUFJekIsU0FBTztJQUFDQTtJQUFPYTtFQUFLO0FBQ3RCO0FBUU8sU0FBUzJCLG9CQUFvQmhDLE1BQU07QUFDeEMsUUFBTSxFQUFDaUMsUUFBUUMsUUFBUUMsYUFBQUEsSUFBZ0JuQztBQUN2QyxRQUFNb0MsWUFBWTtJQUNoQkMsTUFBTUosT0FBT25CO0lBQ2J3QixNQUFNTCxPQUFPbEI7SUFDYndCLE1BQU1MLE9BQU9wQjtJQUNiMEIsTUFBTU4sT0FBT25CO0VBQ2Y7QUFDQSxNQUFJLENBQUNvQixjQUFjO0FBQ2pCbkMsU0FBS21DLGVBQWVDO0FBQ3BCLFdBQU87O0FBRVQsUUFBTUssVUFBVU4sYUFBYUUsU0FBU0osT0FBT25CLE9BQzFDcUIsYUFBYUcsU0FBU0wsT0FBT2xCLE9BQzdCb0IsYUFBYUksU0FBU0wsT0FBT3BCLE9BQzdCcUIsYUFBYUssU0FBU04sT0FBT25CO0FBRWhDMkIsU0FBT0MsT0FBT1IsY0FBY0MsU0FBQUE7QUFDNUIsU0FBT0s7QUFDVDtBQ2hLQSxJQUFNRyxTQUFTLENBQUNDLE1BQWNBLE1BQU0sS0FBS0EsTUFBTTtBQUMvQyxJQUFNQyxZQUFZLENBQUNELEdBQVdFLEdBQVdDLE1BQWMsRUFBRTdCLEtBQUs4QixJQUFJLEdBQUcsTUFBTUosS0FBSyxFQUFNMUIsSUFBQUEsS0FBSytCLEtBQUtMLElBQUlFLEtBQUtJLE1BQU1ILENBQUM7QUFDaEgsSUFBTUksYUFBYSxDQUFDUCxHQUFXRSxHQUFXQyxNQUFjN0IsS0FBSzhCLElBQUksR0FBRyxNQUFNSixDQUFLMUIsSUFBQUEsS0FBSytCLEtBQUtMLElBQUlFLEtBQUtJLE1BQU1ILENBQUssSUFBQTtBQU01RyxJQUNLSyxVQUFVO0VBQ2RDLFFBQVEsQ0FBQ1QsTUFBY0E7RUFFdkJVLFlBQVksQ0FBQ1YsTUFBY0EsSUFBSUE7RUFFL0JXLGFBQWEsQ0FBQ1gsTUFBYyxDQUFDQSxLQUFLQSxJQUFJO0VBRXRDWSxlQUFlLENBQUNaLE9BQWdCQSxLQUFLLE9BQU8sSUFDeEMsTUFBTUEsSUFBSUEsSUFDVixRQUFTLEVBQUVBLEtBQU1BLElBQUksS0FBSztFQUU5QmEsYUFBYSxDQUFDYixNQUFjQSxJQUFJQSxJQUFJQTtFQUVwQ2MsY0FBYyxDQUFDZCxPQUFlQSxLQUFLLEtBQUtBLElBQUlBLElBQUk7RUFFaERlLGdCQUFnQixDQUFDZixPQUFnQkEsS0FBSyxPQUFPLElBQ3pDLE1BQU1BLElBQUlBLElBQUlBLElBQ2QsUUFBUUEsS0FBSyxLQUFLQSxJQUFJQSxJQUFJO0VBRTlCZ0IsYUFBYSxDQUFDaEIsTUFBY0EsSUFBSUEsSUFBSUEsSUFBSUE7RUFFeENpQixjQUFjLENBQUNqQixNQUFjLEdBQUdBLEtBQUssS0FBS0EsSUFBSUEsSUFBSUEsSUFBSTtFQUV0RGtCLGdCQUFnQixDQUFDbEIsT0FBZ0JBLEtBQUssT0FBTyxJQUN6QyxNQUFNQSxJQUFJQSxJQUFJQSxJQUFJQSxJQUNsQixTQUFTQSxLQUFLLEtBQUtBLElBQUlBLElBQUlBLElBQUk7RUFFbkNtQixhQUFhLENBQUNuQixNQUFjQSxJQUFJQSxJQUFJQSxJQUFJQSxJQUFJQTtFQUU1Q29CLGNBQWMsQ0FBQ3BCLE9BQWVBLEtBQUssS0FBS0EsSUFBSUEsSUFBSUEsSUFBSUEsSUFBSTtFQUV4RHFCLGdCQUFnQixDQUFDckIsT0FBZ0JBLEtBQUssT0FBTyxJQUN6QyxNQUFNQSxJQUFJQSxJQUFJQSxJQUFJQSxJQUFJQSxJQUN0QixRQUFRQSxLQUFLLEtBQUtBLElBQUlBLElBQUlBLElBQUlBLElBQUk7RUFFdENzQixZQUFZLENBQUN0QixNQUFjLENBQUMxQixLQUFLaUQsSUFBSXZCLElBQUl3QixPQUFXLElBQUE7RUFFcERDLGFBQWEsQ0FBQ3pCLE1BQWMxQixLQUFLK0IsSUFBSUwsSUFBSXdCLE9BQUFBO0VBRXpDRSxlQUFlLENBQUMxQixNQUFjLFFBQVExQixLQUFLaUQsSUFBSUksS0FBSzNCLENBQUFBLElBQUs7RUFFekQ0QixZQUFZLENBQUM1QixNQUFjLE1BQU8sSUFBSyxJQUFJMUIsS0FBSzhCLElBQUksR0FBRyxNQUFNSixJQUFJLEVBQUc7RUFFcEU2QixhQUFhLENBQUM3QixNQUFjLE1BQU8sSUFBSyxJQUFJLENBQUMxQixLQUFLOEIsSUFBSSxHQUFHLE1BQU1KLENBQUFBLElBQUs7RUFFcEU4QixlQUFlLENBQUM5QixNQUFjRCxPQUFPQyxDQUFBQSxJQUFLQSxJQUFJQSxJQUFJLE1BQzlDLE1BQU0xQixLQUFLOEIsSUFBSSxHQUFHLE1BQU1KLElBQUksSUFBSSxFQUFBLElBQ2hDLE9BQU8sQ0FBQzFCLEtBQUs4QixJQUFJLEdBQUcsT0FBT0osSUFBSSxJQUFJLEVBQUEsSUFBTTtFQUU3QytCLFlBQVksQ0FBQy9CLE1BQWMsS0FBTSxJQUFLQSxJQUFJLEVBQUUxQixLQUFLMEQsS0FBSyxJQUFJaEMsSUFBSUEsQ0FBQUEsSUFBSztFQUVuRWlDLGFBQWEsQ0FBQ2pDLE1BQWMxQixLQUFLMEQsS0FBSyxLQUFLaEMsS0FBSyxLQUFLQSxDQUFBQTtFQUVyRGtDLGVBQWUsQ0FBQ2xDLE9BQWdCQSxLQUFLLE9BQU8sSUFDeEMsUUFBUTFCLEtBQUswRCxLQUFLLElBQUloQyxJQUFJQSxDQUFBQSxJQUFLLEtBQy9CLE9BQU8xQixLQUFLMEQsS0FBSyxLQUFLaEMsS0FBSyxLQUFLQSxDQUFBQSxJQUFLO0VBRXpDbUMsZUFBZSxDQUFDbkMsTUFBY0QsT0FBT0MsQ0FBQUEsSUFBS0EsSUFBSUMsVUFBVUQsR0FBRyxPQUFPLEdBQUk7RUFFdEVvQyxnQkFBZ0IsQ0FBQ3BDLE1BQWNELE9BQU9DLENBQUFBLElBQUtBLElBQUlPLFdBQVdQLEdBQUcsT0FBTyxHQUFJO0VBRXhFcUMsaUJBQWlCckMsR0FBVztBQUMxQixVQUFNRSxJQUFJO0FBQ1YsVUFBTUMsSUFBSTtBQUNWLFdBQU9KLE9BQU9DLENBQUtBLElBQUFBLElBQ2pCQSxJQUFJLE1BQ0EsTUFBTUMsVUFBVUQsSUFBSSxHQUFHRSxHQUFHQyxDQUFBQSxJQUMxQixNQUFNLE1BQU1JLFdBQVdQLElBQUksSUFBSSxHQUFHRSxHQUFHQyxDQUFFO0VBQy9DO0VBRUFtQyxXQUFXdEMsR0FBVztBQUNwQixVQUFNRSxJQUFJO0FBQ1YsV0FBT0YsSUFBSUEsTUFBTUUsSUFBSSxLQUFLRixJQUFJRTtFQUNoQztFQUVBcUMsWUFBWXZDLEdBQVc7QUFDckIsVUFBTUUsSUFBSTtBQUNWLFlBQVFGLEtBQUssS0FBS0EsTUFBTUUsSUFBSSxLQUFLRixJQUFJRSxLQUFLO0VBQzVDO0VBRUFzQyxjQUFjeEMsR0FBVztBQUN2QixRQUFJRSxJQUFJO0FBQ1IsU0FBS0YsS0FBSyxPQUFPLEdBQUc7QUFDbEIsYUFBTyxPQUFPQSxJQUFJQSxPQUFPRSxLQUFNLFNBQVUsS0FBS0YsSUFBSUU7O0FBRXBELFdBQU8sUUFBUUYsS0FBSyxLQUFLQSxPQUFPRSxLQUFNLFNBQVUsS0FBS0YsSUFBSUUsS0FBSztFQUNoRTtFQUVBdUMsY0FBYyxDQUFDekMsTUFBYyxJQUFJUSxRQUFRa0MsY0FBYyxJQUFJMUMsQ0FBQUE7RUFFM0QwQyxjQUFjMUMsR0FBVztBQUN2QixVQUFNMkMsSUFBSTtBQUNWLFVBQU1DLElBQUk7QUFDVixRQUFJNUMsSUFBSyxJQUFJNEMsR0FBSTtBQUNmLGFBQU9ELElBQUkzQyxJQUFJQTs7QUFFakIsUUFBSUEsSUFBSyxJQUFJNEMsR0FBSTtBQUNmLGFBQU9ELEtBQUszQyxLQUFNLE1BQU00QyxLQUFNNUMsSUFBSTs7QUFFcEMsUUFBSUEsSUFBSyxNQUFNNEMsR0FBSTtBQUNqQixhQUFPRCxLQUFLM0MsS0FBTSxPQUFPNEMsS0FBTTVDLElBQUk7O0FBRXJDLFdBQU8yQyxLQUFLM0MsS0FBTSxRQUFRNEMsS0FBTTVDLElBQUk7RUFDdEM7RUFFQTZDLGlCQUFpQixDQUFDN0MsTUFBZUEsSUFBSSxNQUNqQ1EsUUFBUWlDLGFBQWF6QyxJQUFJLENBQUssSUFBQSxNQUM5QlEsUUFBUWtDLGNBQWMxQyxJQUFJLElBQUksQ0FBQSxJQUFLLE1BQU07QUFDL0M7QUNySE8sU0FBUzhDLG9CQUFvQkMsT0FBeUQ7QUFDM0YsTUFBSUEsU0FBUyxPQUFPQSxVQUFVLFVBQVU7QUFDdEMsVUFBTUMsT0FBT0QsTUFBTUUsU0FBUTtBQUMzQixXQUFPRCxTQUFTLDRCQUE0QkEsU0FBUzs7QUFHdkQsU0FBTztBQUNUO0FBV08sU0FBU0UsTUFBTUgsT0FBTztBQUMzQixTQUFPRCxvQkFBb0JDLEtBQUFBLElBQVNBLFFBQVEsSUFBSUksTUFBTUosS0FBTTtBQUM5RDtBQUtPLFNBQVNLLGNBQWNMLE9BQU87QUFDbkMsU0FBT0Qsb0JBQW9CQyxLQUFBQSxJQUN2QkEsUUFDQSxJQUFJSSxNQUFNSixLQUFBQSxFQUFPTSxTQUFTLEdBQUtDLEVBQUFBLE9BQU8sR0FBQSxFQUFLQyxVQUFTO0FBQzFEO0FDL0JBLElBQU1DLFVBQVU7RUFBQztFQUFLO0VBQUs7RUFBZTtFQUFVO0FBQVU7QUFDOUQsSUFBTUMsU0FBUztFQUFDO0VBQVM7RUFBZTtBQUFrQjtBQUVuRCxTQUFTQyx3QkFBd0JDLFdBQVU7QUFDaERBLEVBQUFBLFVBQVNDLElBQUksYUFBYTtJQUN4QnhILE9BQU95SDtJQUNQQyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUm5JLElBQUlpSTtJQUNKRyxNQUFNSDtJQUNOSSxNQUFNSjtJQUNOSyxJQUFJTDtJQUNKYixNQUFNYTtFQUNSLENBQUE7QUFFQUYsRUFBQUEsVUFBU1EsU0FBUyxhQUFhO0lBQzdCQyxXQUFXO0lBQ1hDLFlBQVk7SUFDWkMsYUFBYSxDQUFDQyxTQUFTQSxTQUFTLGdCQUFnQkEsU0FBUyxnQkFBZ0JBLFNBQVM7RUFDcEYsQ0FBQTtBQUVBWixFQUFBQSxVQUFTQyxJQUFJLGNBQWM7SUFDekJILFFBQVE7TUFDTlQsTUFBTTtNQUNOd0IsWUFBWWY7SUFDZDtJQUNBRCxTQUFTO01BQ1BSLE1BQU07TUFDTndCLFlBQVloQjtJQUNkO0VBQ0YsQ0FBQTtBQUVBRyxFQUFBQSxVQUFTUSxTQUFTLGNBQWM7SUFDOUJDLFdBQVc7RUFDYixDQUFBO0FBRUFULEVBQUFBLFVBQVNDLElBQUksZUFBZTtJQUMxQmEsUUFBUTtNQUNOQyxXQUFXO1FBQ1RaLFVBQVU7TUFDWjtJQUNGO0lBQ0FhLFFBQVE7TUFDTkQsV0FBVztRQUNUWixVQUFVO01BQ1o7SUFDRjtJQUNBYyxNQUFNO01BQ0pDLFlBQVk7UUFDVnBCLFFBQVE7VUFDTk8sTUFBTTtRQUNSO1FBQ0FjLFNBQVM7VUFDUDlCLE1BQU07VUFDTmMsVUFBVTtRQUNaO01BQ0Y7SUFDRjtJQUNBaUIsTUFBTTtNQUNKRixZQUFZO1FBQ1ZwQixRQUFRO1VBQ05TLElBQUk7UUFDTjtRQUNBWSxTQUFTO1VBQ1A5QixNQUFNO1VBQ05lLFFBQVE7VUFDUm5JLElBQUlvSixDQUFBQSxNQUFLQSxJQUFJO1FBQ2Y7TUFDRjtJQUNGO0VBQ0YsQ0FBQTtBQUNGO0FDdkVPLFNBQVNDLHFCQUFxQnRCLFdBQVU7QUFDN0NBLEVBQUFBLFVBQVNDLElBQUksVUFBVTtJQUNyQnNCLGFBQWE7SUFDYkMsU0FBUztNQUNQQyxLQUFLO01BQ0xySSxPQUFPO01BQ1BzSSxRQUFRO01BQ1J2SSxNQUFNO0lBQ1I7RUFDRixDQUFBO0FBQ0Y7QUNUQSxJQUFNd0ksWUFBWSxvQkFBSUMsSUFBQUE7QUFFdEIsU0FBU0MsZ0JBQWdCQyxRQUFnQjFILFVBQW9DO0FBQzNFQSxFQUFBQSxXQUFVQSxZQUFXLENBQUE7QUFDckIsUUFBTTJILFdBQVdELFNBQVNFLEtBQUtDLFVBQVU3SCxRQUFBQTtBQUN6QyxNQUFJOEgsWUFBWVAsVUFBVVEsSUFBSUosUUFBQUE7QUFDOUIsTUFBSSxDQUFDRyxXQUFXO0FBQ2RBLGdCQUFZLElBQUlFLEtBQUtDLGFBQWFQLFFBQVExSCxRQUFBQTtBQUMxQ3VILGNBQVUxQixJQUFJOEIsVUFBVUcsU0FBQUE7O0FBRTFCLFNBQU9BO0FBQ1Q7QUFFTyxTQUFTSSxhQUFhQyxLQUFhVCxRQUFnQjFILFVBQW9DO0FBQzVGLFNBQU95SCxnQkFBZ0JDLFFBQVExSCxRQUFTb0ksRUFBQUEsT0FBT0QsR0FBQUE7QUFDakQ7QUNSQSxJQUFNRSxhQUFhO0VBT2pCQyxPQUFPdEQsT0FBTztBQUNaLFdBQU91RCxRQUFRdkQsS0FBUyxJQUF5QkEsUUFBUyxLQUFLQTtFQUNqRTtFQVVBd0QsUUFBUUMsV0FBV0MsUUFBT0MsT0FBTztBQUMvQixRQUFJRixjQUFjLEdBQUc7QUFDbkIsYUFBTzs7QUFHVCxVQUFNZixTQUFTLEtBQUtrQixNQUFNNUksUUFBUTBIO0FBQ2xDLFFBQUltQjtBQUNKLFFBQUlDLFFBQVFMO0FBRVosUUFBSUUsTUFBTW5KLFNBQVMsR0FBRztBQUVwQixZQUFNdUosVUFBVXhJLEtBQUtKLElBQUlJLEtBQUt5SSxJQUFJTCxNQUFNLENBQUUsRUFBQzNELEtBQUssR0FBR3pFLEtBQUt5SSxJQUFJTCxNQUFNQSxNQUFNbkosU0FBUyxDQUFFLEVBQUN3RixLQUFLLENBQUE7QUFDekYsVUFBSStELFVBQVUsUUFBUUEsVUFBVSxNQUFPO0FBQ3JDRixtQkFBVzs7QUFHYkMsY0FBUUcsZUFBZVIsV0FBV0UsS0FBQUE7O0FBR3BDLFVBQU1PLFdBQVdDLE1BQU01SSxLQUFLeUksSUFBSUYsS0FBQUEsQ0FBQUE7QUFPaEMsVUFBTU0sYUFBYUMsTUFBTUgsUUFBQUEsSUFBWSxJQUFJM0ksS0FBS0osSUFBSUksS0FBS0wsSUFBSSxLQUFLSyxLQUFLK0ksTUFBTUosUUFBQUEsR0FBVyxFQUFBLEdBQUssQ0FBRTtBQUU3RixVQUFNbEosV0FBVTtNQUFDNkk7TUFBVVUsdUJBQXVCSDtNQUFZSSx1QkFBdUJKO0lBQVU7QUFDL0Z0SCxXQUFPQyxPQUFPL0IsVUFBUyxLQUFLQSxRQUFRMkksTUFBTVAsTUFBTTtBQUVoRCxXQUFPRixhQUFhTyxXQUFXZixRQUFRMUgsUUFBQUE7RUFDekM7RUFXQXlKLFlBQVloQixXQUFXQyxRQUFPQyxPQUFPO0FBQ25DLFFBQUlGLGNBQWMsR0FBRztBQUNuQixhQUFPOztBQUVULFVBQU1pQixTQUFTZixNQUFNRCxNQUFBQSxFQUFPaUIsZUFBZ0JsQixZQUFhbEksS0FBSzhCLElBQUksSUFBSTlCLEtBQUsrSSxNQUFNSCxNQUFNVixTQUFBQSxDQUFBQSxDQUFBQTtBQUN2RixRQUFJO01BQUM7TUFBRztNQUFHO01BQUc7TUFBRztNQUFJO0lBQUcsRUFBQ21CLFNBQVNGLE1BQUFBLEtBQVdoQixTQUFRLE1BQU1DLE1BQU1uSixRQUFRO0FBQ3ZFLGFBQU82SSxXQUFXRyxRQUFRdEssS0FBSyxNQUFNdUssV0FBV0MsUUFBT0MsS0FBQUE7O0FBRXpELFdBQU87RUFDVDtBQUVGO0FBR0EsU0FBU00sZUFBZVIsV0FBV0UsT0FBTztBQUd4QyxNQUFJRyxRQUFRSCxNQUFNbkosU0FBUyxJQUFJbUosTUFBTSxDQUFFLEVBQUMzRCxRQUFRMkQsTUFBTSxDQUFFLEVBQUMzRCxRQUFRMkQsTUFBTSxDQUFFLEVBQUMzRCxRQUFRMkQsTUFBTSxDQUFFLEVBQUMzRDtBQUczRixNQUFJekUsS0FBS3lJLElBQUlGLEtBQUFBLEtBQVUsS0FBS0wsY0FBY2xJLEtBQUsrSSxNQUFNYixTQUFZLEdBQUE7QUFFL0RLLFlBQVFMLFlBQVlsSSxLQUFLK0ksTUFBTWIsU0FBQUE7O0FBRWpDLFNBQU9LO0FBQ1Q7QUFNQSxJQUFBLFFBQWU7RUFBQ1Q7QUFBVTtBQ25HbkIsU0FBU3dCLG1CQUFtQmpFLFdBQVU7QUFDM0NBLEVBQUFBLFVBQVNDLElBQUksU0FBUztJQUNwQmlFLFNBQVM7SUFDVEMsUUFBUTtJQUNSbEosU0FBUztJQUNUbUosYUFBYTtJQVNiQyxRQUFRO0lBRVJDLE1BQU07SUFNTkMsT0FBTztJQUdQQyxNQUFNO01BQ0pOLFNBQVM7TUFDVE8sV0FBVztNQUNYQyxpQkFBaUI7TUFDakJDLFdBQVc7TUFDWEMsWUFBWTtNQUNaQyxXQUFXLENBQUNDLE1BQU0xSyxhQUFZQSxTQUFRcUs7TUFDdENNLFdBQVcsQ0FBQ0QsTUFBTTFLLGFBQVlBLFNBQVFtRjtNQUN0QzRFLFFBQVE7SUFDVjtJQUVBYSxRQUFRO01BQ05kLFNBQVM7TUFDVGUsTUFBTSxDQUFBO01BQ05DLFlBQVk7TUFDWkMsT0FBTztJQUNUO0lBR0FDLE9BQU87TUFFTGxCLFNBQVM7TUFHVG1CLE1BQU07TUFHTjdELFNBQVM7UUFDUEMsS0FBSztRQUNMQyxRQUFRO01BQ1Y7SUFDRjtJQUdBcUIsT0FBTztNQUNMdUMsYUFBYTtNQUNiQyxhQUFhO01BQ2JDLFFBQVE7TUFDUkMsaUJBQWlCO01BQ2pCQyxpQkFBaUI7TUFDakJsRSxTQUFTO01BQ1QwQyxTQUFTO01BQ1R5QixVQUFVO01BQ1ZDLGlCQUFpQjtNQUNqQkMsYUFBYTtNQUViL04sVUFBVWdPLE1BQU1yRCxXQUFXQztNQUMzQnFELE9BQU8sQ0FBQTtNQUNQQyxPQUFPLENBQUE7TUFDUGxOLE9BQU87TUFDUG1OLFlBQVk7TUFFWkMsbUJBQW1CO01BQ25CQyxlQUFlO01BQ2ZDLGlCQUFpQjtJQUNuQjtFQUNGLENBQUE7QUFFQXBHLEVBQUFBLFVBQVNxRyxNQUFNLGVBQWUsU0FBUyxJQUFJLE9BQUE7QUFDM0NyRyxFQUFBQSxVQUFTcUcsTUFBTSxjQUFjLFNBQVMsSUFBSSxhQUFBO0FBQzFDckcsRUFBQUEsVUFBU3FHLE1BQU0sZ0JBQWdCLFNBQVMsSUFBSSxhQUFBO0FBQzVDckcsRUFBQUEsVUFBU3FHLE1BQU0sZUFBZSxTQUFTLElBQUksT0FBQTtBQUUzQ3JHLEVBQUFBLFVBQVNRLFNBQVMsU0FBUztJQUN6QkMsV0FBVztJQUNYRSxhQUFhLENBQUNDLFNBQVMsQ0FBQ0EsS0FBSzBGLFdBQVcsUUFBQSxLQUFhLENBQUMxRixLQUFLMEYsV0FBVyxPQUFZMUYsS0FBQUEsU0FBUyxjQUFjQSxTQUFTO0lBQ2xIRixZQUFZLENBQUNFLFNBQVNBLFNBQVMsZ0JBQWdCQSxTQUFTLG9CQUFvQkEsU0FBUztFQUN2RixDQUFBO0FBRUFaLEVBQUFBLFVBQVNRLFNBQVMsVUFBVTtJQUMxQkMsV0FBVztFQUNiLENBQUE7QUFFQVQsRUFBQUEsVUFBU1EsU0FBUyxlQUFlO0lBQy9CRyxhQUFhLENBQUNDLFNBQVNBLFNBQVMscUJBQXFCQSxTQUFTO0lBQzlERixZQUFZLENBQUNFLFNBQVNBLFNBQVM7RUFDakMsQ0FBQTtBQUNGO0lDbEdhMkYsWUFBWXJLLHVCQUFPc0ssT0FBTyxJQUFJO0lBQzlCQyxjQUFjdkssdUJBQU9zSyxPQUFPLElBQUk7QUFPN0MsU0FBU0UsV0FBU0MsTUFBTUMsS0FBSztBQUMzQixNQUFJLENBQUNBLEtBQUs7QUFDUixXQUFPRDs7QUFFVCxRQUFNRSxPQUFPRCxJQUFJRSxNQUFNLEdBQUE7QUFDdkIsV0FBU0MsSUFBSSxHQUFHQyxJQUFJSCxLQUFLak4sUUFBUW1OLElBQUlDLEdBQUcsRUFBRUQsR0FBRztBQUMzQyxVQUFNRSxJQUFJSixLQUFLRSxDQUFFO0FBQ2pCSixXQUFPQSxLQUFLTSxDQUFFLE1BQUtOLEtBQUtNLENBQUFBLElBQUsvSyx1QkFBT3NLLE9BQU8sSUFBSTtFQUNqRDtBQUNBLFNBQU9HO0FBQ1Q7QUFFQSxTQUFTMUcsSUFBSWlILE1BQU1DLE9BQU96RSxRQUFRO0FBQ2hDLE1BQUksT0FBT3lFLFVBQVUsVUFBVTtBQUM3QixXQUFPQyxNQUFNVixXQUFTUSxNQUFNQyxLQUFRekUsR0FBQUEsTUFBQUE7O0FBRXRDLFNBQU8wRSxNQUFNVixXQUFTUSxNQUFNLEVBQUtDLEdBQUFBLEtBQUFBO0FBQ25DO0FBTU8sSUFBTUUsV0FBTixNQUFNQTtFQUNYQyxZQUFZQyxlQUFjQyxXQUFXO0FBQ25DLFNBQUt6RyxZQUFZYjtBQUNqQixTQUFLdUgsa0JBQWtCO0FBQ3ZCLFNBQUtDLGNBQWM7QUFDbkIsU0FBS25JLFFBQVE7QUFDYixTQUFLb0ksV0FBVyxDQUFBO0FBQ2hCLFNBQUtDLG1CQUFtQixDQUFDQyxZQUFZQSxRQUFRN0UsTUFBTThFLFNBQVNDLG9CQUFtQjtBQUMvRSxTQUFLQyxXQUFXLENBQUE7QUFDaEIsU0FBS0MsU0FBUztNQUNaO01BQ0E7TUFDQTtNQUNBO01BQ0E7SUFDRDtBQUNELFNBQUtDLE9BQU87TUFDVkMsUUFBUTtNQUNSQyxNQUFNO01BQ05DLE9BQU87TUFDUEMsWUFBWTtNQUNaQyxRQUFRO0lBQ1Y7QUFDQSxTQUFLQyxRQUFRLENBQUE7QUFDYixTQUFLQyx1QkFBdUIsQ0FBQ0MsS0FBS3RPLGFBQVlxRixjQUFjckYsU0FBUXFOLGVBQWU7QUFDbkYsU0FBS2tCLG1CQUFtQixDQUFDRCxLQUFLdE8sYUFBWXFGLGNBQWNyRixTQUFRc04sV0FBVztBQUMzRSxTQUFLa0IsYUFBYSxDQUFDRixLQUFLdE8sYUFBWXFGLGNBQWNyRixTQUFRbUYsS0FBSztBQUMvRCxTQUFLc0osWUFBWTtBQUNqQixTQUFLQyxjQUFjO01BQ2pCQyxNQUFNO01BQ05DLFdBQVc7TUFDWEMsa0JBQWtCO0lBQ3BCO0FBQ0EsU0FBS0Msc0JBQXNCO0FBQzNCLFNBQUtDLFVBQVU7QUFDZixTQUFLQyxVQUFVO0FBQ2YsU0FBS0MsVUFBVTtBQUNmLFNBQUtDLFVBQVUsQ0FBQTtBQUNmLFNBQUtDLGFBQWE7QUFDbEIsU0FBS0MsUUFBUXRKO0FBQ2IsU0FBS3VKLFNBQVMsQ0FBQTtBQUNkLFNBQUtDLFdBQVc7QUFDaEIsU0FBS0MsMEJBQTBCO0FBRS9CLFNBQUtuSixTQUFTK0csYUFBQUE7QUFDZCxTQUFLaFAsTUFBTWlQLFNBQUFBO0VBQ2I7RUFNQXZILElBQUlrSCxPQUFPekUsUUFBUTtBQUNqQixXQUFPekMsSUFBSSxNQUFNa0gsT0FBT3pFLE1BQUFBO0VBQzFCO0VBS0FQLElBQUlnRixPQUFPO0FBQ1QsV0FBT1QsV0FBUyxNQUFNUyxLQUFBQTtFQUN4QjtFQU1BM0csU0FBUzJHLE9BQU96RSxRQUFRO0FBQ3RCLFdBQU96QyxJQUFJd0csYUFBYVUsT0FBT3pFLE1BQUFBO0VBQ2pDO0VBRUFrSCxTQUFTekMsT0FBT3pFLFFBQVE7QUFDdEIsV0FBT3pDLElBQUlzRyxXQUFXWSxPQUFPekUsTUFBQUE7RUFDL0I7RUFtQkEyRCxNQUFNYyxPQUFPdkcsTUFBTWlKLGFBQWFDLFlBQVk7QUFDMUMsVUFBTUMsY0FBY3JELFdBQVMsTUFBTVMsS0FBQUE7QUFDbkMsVUFBTTZDLG9CQUFvQnRELFdBQVMsTUFBTW1ELFdBQUFBO0FBQ3pDLFVBQU1JLGNBQWMsTUFBTXJKO0FBRTFCMUUsV0FBT2dPLGlCQUFpQkgsYUFBYTtNQUVuQyxDQUFDRSxXQUFBQSxHQUFjO1FBQ2I3SyxPQUFPMkssWUFBWW5KLElBQUs7UUFDeEJ1SixVQUFVO01BQ1o7TUFFQSxDQUFDdkosSUFBQUEsR0FBTztRQUNOd0osWUFBWTtRQUNaakksTUFBTTtBQUNKLGdCQUFNa0ksUUFBUSxLQUFLSixXQUFZO0FBQy9CLGdCQUFNSyxTQUFTTixrQkFBa0JGLFVBQVc7QUFDNUMsY0FBSVMsU0FBU0YsS0FBUSxHQUFBO0FBQ25CLG1CQUFPbk8sT0FBT0MsT0FBTyxDQUFBLEdBQUltTyxRQUFRRCxLQUFBQTs7QUFFbkMsaUJBQU9HLGVBQWVILE9BQU9DLE1BQUFBO1FBQy9CO1FBQ0FySyxJQUFJYixPQUFPO0FBQ1QsZUFBSzZLLFdBQUFBLElBQWU3SztRQUN0QjtNQUNGO0lBQ0YsQ0FBQTtFQUNGO0VBRUE3RyxNQUFNa1MsVUFBVTtBQUNkQSxhQUFTQyxRQUFRLENBQUNuUyxVQUFVQSxNQUFNLElBQUksQ0FBQTtFQUN4QztBQUNGO0FBR0EsSUFBQSxXQUErQixvQkFBSThPLFNBQVM7RUFDMUMxRyxhQUFhLENBQUNDLFNBQVMsQ0FBQ0EsS0FBSzBGLFdBQVcsSUFBQTtFQUN4QzVGLFlBQVksQ0FBQ0UsU0FBU0EsU0FBUztFQUMvQjRILE9BQU87SUFDTC9ILFdBQVc7RUFDYjtFQUNBcUksYUFBYTtJQUNYbkksYUFBYTtJQUNiRCxZQUFZO0VBQ2Q7QUFDRixHQUFHO0VBQUNYO0VBQXlCdUI7RUFBc0IyQztDQUFtQjtBQ3RKL0QsU0FBUzBHLGFBQWF6QyxNQUFnQjtBQUMzQyxNQUFJLENBQUNBLFFBQVE5TSxjQUFjOE0sS0FBS0UsSUFBSSxLQUFLaE4sY0FBYzhNLEtBQUtDLE1BQU0sR0FBRztBQUNuRSxXQUFPOztBQUdULFVBQVFELEtBQUtHLFFBQVFILEtBQUtHLFFBQVEsTUFBTSxPQUNyQ0gsS0FBS0ssU0FBU0wsS0FBS0ssU0FBUyxNQUFNLE1BQ25DTCxLQUFLRSxPQUFPLFFBQ1pGLEtBQUtDO0FBQ1Q7QUFLTyxTQUFTeUMsYUFDZGxDLEtBQ0FtQyxNQUNBQyxJQUNBQyxTQUNBQyxRQUNBO0FBQ0EsTUFBSUMsWUFBWUosS0FBS0csTUFBTztBQUM1QixNQUFJLENBQUNDLFdBQVc7QUFDZEEsZ0JBQVlKLEtBQUtHLE1BQU8sSUFBR3RDLElBQUl3QyxZQUFZRixNQUFBQSxFQUFRN0Y7QUFDbkQyRixPQUFHSyxLQUFLSCxNQUFBQTs7QUFFVixNQUFJQyxZQUFZRixTQUFTO0FBQ3ZCQSxjQUFVRTs7QUFFWixTQUFPRjtBQUNUO0FBU08sU0FBU0ssYUFDZDFDLEtBQ0FSLE1BQ0FtRCxlQUNBQyxPQUNBO0FBQ0FBLFVBQVFBLFNBQVMsQ0FBQTtBQUNqQixNQUFJVCxPQUFPUyxNQUFNVCxPQUFPUyxNQUFNVCxRQUFRLENBQUE7QUFDdEMsTUFBSUMsS0FBS1EsTUFBTUMsaUJBQWlCRCxNQUFNQyxrQkFBa0IsQ0FBQTtBQUV4RCxNQUFJRCxNQUFNcEQsU0FBU0EsTUFBTTtBQUN2QjJDLFdBQU9TLE1BQU1ULE9BQU8sQ0FBQTtBQUNwQkMsU0FBS1EsTUFBTUMsaUJBQWlCLENBQUE7QUFDNUJELFVBQU1wRCxPQUFPQTs7QUFHZlEsTUFBSThDLEtBQUk7QUFFUjlDLE1BQUlSLE9BQU9BO0FBQ1gsTUFBSTZDLFVBQVU7QUFDZCxRQUFNVSxPQUFPSixjQUFjelI7QUFDM0IsTUFBSW1OLEdBQVcyRSxHQUFXQyxNQUFjQyxPQUF3QkM7QUFDaEUsT0FBSzlFLElBQUksR0FBR0EsSUFBSTBFLE1BQU0xRSxLQUFLO0FBQ3pCNkUsWUFBUVAsY0FBY3RFLENBQUU7QUFHeEIsUUFBSTZFLFVBQVUxTCxVQUFhMEwsVUFBVSxRQUFRLENBQUNqSixRQUFRaUosS0FBUSxHQUFBO0FBQzVEYixnQkFBVUgsYUFBYWxDLEtBQUttQyxNQUFNQyxJQUFJQyxTQUFTYSxLQUFBQTtlQUN0Q2pKLFFBQVFpSixLQUFRLEdBQUE7QUFHekIsV0FBS0YsSUFBSSxHQUFHQyxPQUFPQyxNQUFNaFMsUUFBUThSLElBQUlDLE1BQU1ELEtBQUs7QUFDOUNHLHNCQUFjRCxNQUFNRixDQUFFO0FBRXRCLFlBQUlHLGdCQUFnQjNMLFVBQWEyTCxnQkFBZ0IsUUFBUSxDQUFDbEosUUFBUWtKLFdBQWMsR0FBQTtBQUM5RWQsb0JBQVVILGFBQWFsQyxLQUFLbUMsTUFBTUMsSUFBSUMsU0FBU2MsV0FBQUE7O01BRW5EOztFQUVKO0FBRUFuRCxNQUFJb0QsUUFBTztBQUVYLFFBQU1DLFFBQVFqQixHQUFHbFIsU0FBUztBQUMxQixNQUFJbVMsUUFBUVYsY0FBY3pSLFFBQVE7QUFDaEMsU0FBS21OLElBQUksR0FBR0EsSUFBSWdGLE9BQU9oRixLQUFLO0FBQzFCLGFBQU84RCxLQUFLQyxHQUFHL0QsQ0FBQUEsQ0FBRTtJQUNuQjtBQUNBK0QsT0FBR2tCLE9BQU8sR0FBR0QsS0FBQUE7O0FBRWYsU0FBT2hCO0FBQ1Q7QUFVTyxTQUFTa0IsWUFBWWpKLE9BQWNrSixPQUFlL0csT0FBZTtBQUN0RSxRQUFNeUMsbUJBQW1CNUUsTUFBTW1KO0FBQy9CLFFBQU1DLFlBQVlqSCxVQUFVLElBQUl4SyxLQUFLSixJQUFJNEssUUFBUSxHQUFHLEdBQUEsSUFBTztBQUMzRCxTQUFPeEssS0FBSzBSLE9BQU9ILFFBQVFFLGFBQWF4RSxnQkFBQUEsSUFBb0JBLG1CQUFtQndFO0FBQ2pGO0FBS08sU0FBU0UsWUFBWUMsUUFBNEI3RCxLQUFnQztBQUN0RixNQUFJLENBQUNBLE9BQU8sQ0FBQzZELFFBQVE7QUFDbkI7O0FBR0Y3RCxRQUFNQSxPQUFPNkQsT0FBT0MsV0FBVyxJQUFBO0FBRS9COUQsTUFBSThDLEtBQUk7QUFHUjlDLE1BQUkrRCxlQUFjO0FBQ2xCL0QsTUFBSWdFLFVBQVUsR0FBRyxHQUFHSCxPQUFPcEgsT0FBT29ILE9BQU9JLE1BQU07QUFDL0NqRSxNQUFJb0QsUUFBTztBQUNiO0FBU08sU0FBU2MsVUFDZGxFLEtBQ0F0TyxVQUNBeVMsR0FDQUMsR0FDQTtBQUVBQyxrQkFBZ0JyRSxLQUFLdE8sVUFBU3lTLEdBQUdDLEdBQUcsSUFBSTtBQUMxQztBQUdPLFNBQVNDLGdCQUNkckUsS0FDQXRPLFVBQ0F5UyxHQUNBQyxHQUNBRSxHQUNBO0FBQ0EsTUFBSTNOLE1BQWM0TixTQUFpQkMsU0FBaUI5RSxNQUFjK0UsY0FBc0JoSSxPQUFlaUksVUFBa0JDO0FBQ3pILFFBQU1oRixRQUFRak8sU0FBUWtUO0FBQ3RCLFFBQU1DLFdBQVduVCxTQUFRbVQ7QUFDekIsUUFBTUMsU0FBU3BULFNBQVFvVDtBQUN2QixNQUFJQyxPQUFPRixZQUFZLEtBQUtHO0FBRTVCLE1BQUlyRixTQUFTLE9BQU9BLFVBQVUsVUFBVTtBQUN0Q2hKLFdBQU9nSixNQUFNL0ksU0FBUTtBQUNyQixRQUFJRCxTQUFTLCtCQUErQkEsU0FBUyw4QkFBOEI7QUFDakZxSixVQUFJOEMsS0FBSTtBQUNSOUMsVUFBSWlGLFVBQVVkLEdBQUdDLENBQUFBO0FBQ2pCcEUsVUFBSWtGLE9BQU9ILEdBQUFBO0FBQ1gvRSxVQUFJbUYsVUFBVXhGLE9BQU8sQ0FBQ0EsTUFBTWxELFFBQVEsR0FBRyxDQUFDa0QsTUFBTXNFLFNBQVMsR0FBR3RFLE1BQU1sRCxPQUFPa0QsTUFBTXNFLE1BQU07QUFDbkZqRSxVQUFJb0QsUUFBTztBQUNYOzs7QUFJSixNQUFJckksTUFBTStKLE1BQVdBLEtBQUFBLFVBQVUsR0FBRztBQUNoQzs7QUFHRjlFLE1BQUlvRixVQUFTO0FBRWIsVUFBUXpGLE9BQUFBO0lBRU47QUFDRSxVQUFJMkUsR0FBRztBQUNMdEUsWUFBSXFGLFFBQVFsQixHQUFHQyxHQUFHRSxJQUFJLEdBQUdRLFFBQVEsR0FBRyxHQUFHN1EsR0FBQUE7YUFDbEM7QUFDTCtMLFlBQUlzRixJQUFJbkIsR0FBR0MsR0FBR1UsUUFBUSxHQUFHN1EsR0FBQUE7O0FBRTNCK0wsVUFBSXVGLFVBQVM7QUFDYjtJQUNGLEtBQUs7QUFDSDlJLGNBQVE2SCxJQUFJQSxJQUFJLElBQUlRO0FBQ3BCOUUsVUFBSXdGLE9BQU9yQixJQUFJbFMsS0FBSytCLElBQUkrUSxHQUFPdEksSUFBQUEsT0FBTzJILElBQUluUyxLQUFLaUQsSUFBSTZQLEdBQU9ELElBQUFBLE1BQUFBO0FBQzFEQyxhQUFPVTtBQUNQekYsVUFBSTBGLE9BQU92QixJQUFJbFMsS0FBSytCLElBQUkrUSxHQUFPdEksSUFBQUEsT0FBTzJILElBQUluUyxLQUFLaUQsSUFBSTZQLEdBQU9ELElBQUFBLE1BQUFBO0FBQzFEQyxhQUFPVTtBQUNQekYsVUFBSTBGLE9BQU92QixJQUFJbFMsS0FBSytCLElBQUkrUSxHQUFPdEksSUFBQUEsT0FBTzJILElBQUluUyxLQUFLaUQsSUFBSTZQLEdBQU9ELElBQUFBLE1BQUFBO0FBQzFEOUUsVUFBSXVGLFVBQVM7QUFDYjtJQUNGLEtBQUs7QUFRSGQscUJBQWVLLFNBQVM7QUFDeEJwRixhQUFPb0YsU0FBU0w7QUFDaEJGLGdCQUFVdFMsS0FBS2lELElBQUk2UCxNQUFNWSxVQUFjakcsSUFBQUE7QUFDdkNnRixpQkFBV3pTLEtBQUtpRCxJQUFJNlAsTUFBTVksVUFBQUEsS0FBZXJCLElBQUlBLElBQUksSUFBSUcsZUFBZS9FO0FBQ3BFOEUsZ0JBQVV2UyxLQUFLK0IsSUFBSStRLE1BQU1ZLFVBQWNqRyxJQUFBQTtBQUN2Q2lGLGlCQUFXMVMsS0FBSytCLElBQUkrUSxNQUFNWSxVQUFBQSxLQUFlckIsSUFBSUEsSUFBSSxJQUFJRyxlQUFlL0U7QUFDcEVNLFVBQUlzRixJQUFJbkIsSUFBSU8sVUFBVU4sSUFBSUksU0FBU0MsY0FBY00sTUFBTXpQLElBQUl5UCxNQUFNNVAsT0FBQUE7QUFDakU2SyxVQUFJc0YsSUFBSW5CLElBQUlRLFVBQVVQLElBQUlHLFNBQVNFLGNBQWNNLE1BQU01UCxTQUFTNFAsR0FBQUE7QUFDaEUvRSxVQUFJc0YsSUFBSW5CLElBQUlPLFVBQVVOLElBQUlJLFNBQVNDLGNBQWNNLEtBQUtBLE1BQU01UCxPQUFBQTtBQUM1RDZLLFVBQUlzRixJQUFJbkIsSUFBSVEsVUFBVVAsSUFBSUcsU0FBU0UsY0FBY00sTUFBTTVQLFNBQVM0UCxNQUFNelAsRUFBQUE7QUFDdEUwSyxVQUFJdUYsVUFBUztBQUNiO0lBQ0YsS0FBSztBQUNILFVBQUksQ0FBQ1YsVUFBVTtBQUNibkYsZUFBT3pOLEtBQUsyVCxVQUFVZDtBQUN0QnJJLGdCQUFRNkgsSUFBSUEsSUFBSSxJQUFJNUU7QUFDcEJNLFlBQUk2RixLQUFLMUIsSUFBSTFILE9BQU8ySCxJQUFJMUUsTUFBTSxJQUFJakQsT0FBTyxJQUFJaUQsSUFBQUE7QUFDN0M7O0FBRUZxRixhQUFPWTtJQUVULEtBQUs7QUFDSGpCLGlCQUFXelMsS0FBS2lELElBQUk2UCxHQUFBQSxLQUFRVCxJQUFJQSxJQUFJLElBQUlRO0FBQ3hDUCxnQkFBVXRTLEtBQUtpRCxJQUFJNlAsR0FBT0QsSUFBQUE7QUFDMUJOLGdCQUFVdlMsS0FBSytCLElBQUkrUSxHQUFPRCxJQUFBQTtBQUMxQkgsaUJBQVcxUyxLQUFLK0IsSUFBSStRLEdBQUFBLEtBQVFULElBQUlBLElBQUksSUFBSVE7QUFDeEM5RSxVQUFJd0YsT0FBT3JCLElBQUlPLFVBQVVOLElBQUlJLE9BQUFBO0FBQzdCeEUsVUFBSTBGLE9BQU92QixJQUFJUSxVQUFVUCxJQUFJRyxPQUFBQTtBQUM3QnZFLFVBQUkwRixPQUFPdkIsSUFBSU8sVUFBVU4sSUFBSUksT0FBQUE7QUFDN0J4RSxVQUFJMEYsT0FBT3ZCLElBQUlRLFVBQVVQLElBQUlHLE9BQUFBO0FBQzdCdkUsVUFBSXVGLFVBQVM7QUFDYjtJQUNGLEtBQUs7QUFDSFIsYUFBT1k7SUFFVCxLQUFLO0FBQ0hqQixpQkFBV3pTLEtBQUtpRCxJQUFJNlAsR0FBQUEsS0FBUVQsSUFBSUEsSUFBSSxJQUFJUTtBQUN4Q1AsZ0JBQVV0UyxLQUFLaUQsSUFBSTZQLEdBQU9ELElBQUFBO0FBQzFCTixnQkFBVXZTLEtBQUsrQixJQUFJK1EsR0FBT0QsSUFBQUE7QUFDMUJILGlCQUFXMVMsS0FBSytCLElBQUkrUSxHQUFBQSxLQUFRVCxJQUFJQSxJQUFJLElBQUlRO0FBQ3hDOUUsVUFBSXdGLE9BQU9yQixJQUFJTyxVQUFVTixJQUFJSSxPQUFBQTtBQUM3QnhFLFVBQUkwRixPQUFPdkIsSUFBSU8sVUFBVU4sSUFBSUksT0FBQUE7QUFDN0J4RSxVQUFJd0YsT0FBT3JCLElBQUlRLFVBQVVQLElBQUlHLE9BQUFBO0FBQzdCdkUsVUFBSTBGLE9BQU92QixJQUFJUSxVQUFVUCxJQUFJRyxPQUFBQTtBQUM3QjtJQUNGLEtBQUs7QUFDSEcsaUJBQVd6UyxLQUFLaUQsSUFBSTZQLEdBQUFBLEtBQVFULElBQUlBLElBQUksSUFBSVE7QUFDeENQLGdCQUFVdFMsS0FBS2lELElBQUk2UCxHQUFPRCxJQUFBQTtBQUMxQk4sZ0JBQVV2UyxLQUFLK0IsSUFBSStRLEdBQU9ELElBQUFBO0FBQzFCSCxpQkFBVzFTLEtBQUsrQixJQUFJK1EsR0FBQUEsS0FBUVQsSUFBSUEsSUFBSSxJQUFJUTtBQUN4QzlFLFVBQUl3RixPQUFPckIsSUFBSU8sVUFBVU4sSUFBSUksT0FBQUE7QUFDN0J4RSxVQUFJMEYsT0FBT3ZCLElBQUlPLFVBQVVOLElBQUlJLE9BQUFBO0FBQzdCeEUsVUFBSXdGLE9BQU9yQixJQUFJUSxVQUFVUCxJQUFJRyxPQUFBQTtBQUM3QnZFLFVBQUkwRixPQUFPdkIsSUFBSVEsVUFBVVAsSUFBSUcsT0FBQUE7QUFDN0JRLGFBQU9ZO0FBQ1BqQixpQkFBV3pTLEtBQUtpRCxJQUFJNlAsR0FBQUEsS0FBUVQsSUFBSUEsSUFBSSxJQUFJUTtBQUN4Q1AsZ0JBQVV0UyxLQUFLaUQsSUFBSTZQLEdBQU9ELElBQUFBO0FBQzFCTixnQkFBVXZTLEtBQUsrQixJQUFJK1EsR0FBT0QsSUFBQUE7QUFDMUJILGlCQUFXMVMsS0FBSytCLElBQUkrUSxHQUFBQSxLQUFRVCxJQUFJQSxJQUFJLElBQUlRO0FBQ3hDOUUsVUFBSXdGLE9BQU9yQixJQUFJTyxVQUFVTixJQUFJSSxPQUFBQTtBQUM3QnhFLFVBQUkwRixPQUFPdkIsSUFBSU8sVUFBVU4sSUFBSUksT0FBQUE7QUFDN0J4RSxVQUFJd0YsT0FBT3JCLElBQUlRLFVBQVVQLElBQUlHLE9BQUFBO0FBQzdCdkUsVUFBSTBGLE9BQU92QixJQUFJUSxVQUFVUCxJQUFJRyxPQUFBQTtBQUM3QjtJQUNGLEtBQUs7QUFDSEEsZ0JBQVVELElBQUlBLElBQUksSUFBSXJTLEtBQUtpRCxJQUFJNlAsR0FBQUEsSUFBT0Q7QUFDdENOLGdCQUFVdlMsS0FBSytCLElBQUkrUSxHQUFPRCxJQUFBQTtBQUMxQjlFLFVBQUl3RixPQUFPckIsSUFBSUksU0FBU0gsSUFBSUksT0FBQUE7QUFDNUJ4RSxVQUFJMEYsT0FBT3ZCLElBQUlJLFNBQVNILElBQUlJLE9BQUFBO0FBQzVCO0lBQ0YsS0FBSztBQUNIeEUsVUFBSXdGLE9BQU9yQixHQUFHQyxDQUFBQTtBQUNkcEUsVUFBSTBGLE9BQU92QixJQUFJbFMsS0FBS2lELElBQUk2UCxHQUFBQSxLQUFRVCxJQUFJQSxJQUFJLElBQUlRLFNBQVNWLElBQUluUyxLQUFLK0IsSUFBSStRLEdBQU9ELElBQUFBLE1BQUFBO0FBQ3pFO0lBQ0YsS0FBSztBQUNIOUUsVUFBSXVGLFVBQVM7QUFDYjtFQUNKO0FBRUF2RixNQUFJOEYsS0FBSTtBQUNSLE1BQUlwVSxTQUFRcVUsY0FBYyxHQUFHO0FBQzNCL0YsUUFBSWdHLE9BQU07O0FBRWQ7QUFTTyxTQUFTQyxlQUNkeFQsT0FDQXlULE1BQ0FDLFFBQ0E7QUFDQUEsV0FBU0EsVUFBVTtBQUVuQixTQUFPLENBQUNELFFBQVN6VCxTQUFTQSxNQUFNMFIsSUFBSStCLEtBQUt6VixPQUFPMFYsVUFBVTFULE1BQU0wUixJQUFJK0IsS0FBS3hWLFFBQVF5VixVQUNqRjFULE1BQU0yUixJQUFJOEIsS0FBS25OLE1BQU1vTixVQUFVMVQsTUFBTTJSLElBQUk4QixLQUFLbE4sU0FBU21OO0FBQ3pEO0FBRU8sU0FBU0MsU0FBU3BHLEtBQStCa0csTUFBWTtBQUNsRWxHLE1BQUk4QyxLQUFJO0FBQ1I5QyxNQUFJb0YsVUFBUztBQUNicEYsTUFBSTZGLEtBQUtLLEtBQUt6VixNQUFNeVYsS0FBS25OLEtBQUttTixLQUFLeFYsUUFBUXdWLEtBQUt6VixNQUFNeVYsS0FBS2xOLFNBQVNrTixLQUFLbk4sR0FBRztBQUM1RWlILE1BQUlwRSxLQUFJO0FBQ1Y7QUFFTyxTQUFTeUssV0FBV3JHLEtBQStCO0FBQ3hEQSxNQUFJb0QsUUFBTztBQUNiO0FBS08sU0FBU2tELGVBQ2R0RyxLQUNBdUcsVUFDQTNFLFFBQ0E0RSxNQUNBbkcsTUFDQTtBQUNBLE1BQUksQ0FBQ2tHLFVBQVU7QUFDYixXQUFPdkcsSUFBSTBGLE9BQU85RCxPQUFPdUMsR0FBR3ZDLE9BQU93QyxDQUFDOztBQUV0QyxNQUFJL0QsU0FBUyxVQUFVO0FBQ3JCLFVBQU1vRyxZQUFZRixTQUFTcEMsSUFBSXZDLE9BQU91QyxLQUFLO0FBQzNDbkUsUUFBSTBGLE9BQU9lLFVBQVVGLFNBQVNuQyxDQUFDO0FBQy9CcEUsUUFBSTBGLE9BQU9lLFVBQVU3RSxPQUFPd0MsQ0FBQztFQUMvQixXQUFXL0QsU0FBUyxZQUFZLENBQUMsQ0FBQ21HLE1BQU07QUFDdEN4RyxRQUFJMEYsT0FBT2EsU0FBU3BDLEdBQUd2QyxPQUFPd0MsQ0FBQztTQUMxQjtBQUNMcEUsUUFBSTBGLE9BQU85RCxPQUFPdUMsR0FBR29DLFNBQVNuQyxDQUFDOztBQUVqQ3BFLE1BQUkwRixPQUFPOUQsT0FBT3VDLEdBQUd2QyxPQUFPd0MsQ0FBQztBQUMvQjtBQUtPLFNBQVNzQyxlQUNkMUcsS0FDQXVHLFVBQ0EzRSxRQUNBNEUsTUFDQTtBQUNBLE1BQUksQ0FBQ0QsVUFBVTtBQUNiLFdBQU92RyxJQUFJMEYsT0FBTzlELE9BQU91QyxHQUFHdkMsT0FBT3dDLENBQUM7O0FBRXRDcEUsTUFBSTJHLGNBQ0ZILE9BQU9ELFNBQVNLLE9BQU9MLFNBQVNNLE1BQ2hDTCxPQUFPRCxTQUFTTyxPQUFPUCxTQUFTUSxNQUNoQ1AsT0FBTzVFLE9BQU9pRixPQUFPakYsT0FBT2dGLE1BQzVCSixPQUFPNUUsT0FBT21GLE9BQU9uRixPQUFPa0YsTUFDNUJsRixPQUFPdUMsR0FDUHZDLE9BQU93QyxDQUFDO0FBQ1o7QUFFQSxTQUFTNEMsY0FBY2hILEtBQStCaUgsTUFBc0I7QUFDMUUsTUFBSUEsS0FBS0MsYUFBYTtBQUNwQmxILFFBQUlpRixVQUFVZ0MsS0FBS0MsWUFBWSxDQUFBLEdBQUlELEtBQUtDLFlBQVksQ0FBRSxDQUFBOztBQUd4RCxNQUFJLENBQUN4VSxjQUFjdVUsS0FBS3BDLFFBQVEsR0FBRztBQUNqQzdFLFFBQUlrRixPQUFPK0IsS0FBS3BDLFFBQVE7O0FBRzFCLE1BQUlvQyxLQUFLcFEsT0FBTztBQUNkbUosUUFBSW1ILFlBQVlGLEtBQUtwUTs7QUFHdkIsTUFBSW9RLEtBQUtHLFdBQVc7QUFDbEJwSCxRQUFJb0gsWUFBWUgsS0FBS0c7O0FBR3ZCLE1BQUlILEtBQUtJLGNBQWM7QUFDckJySCxRQUFJcUgsZUFBZUosS0FBS0k7O0FBRTVCO0FBRUEsU0FBU0MsYUFDUHRILEtBQ0FtRSxHQUNBQyxHQUNBbUQsTUFDQU4sTUFDQTtBQUNBLE1BQUlBLEtBQUtPLGlCQUFpQlAsS0FBS1EsV0FBVztBQVF4QyxVQUFNQyxVQUFVMUgsSUFBSXdDLFlBQVkrRSxJQUFBQTtBQUNoQyxVQUFNOVcsT0FBTzBULElBQUl1RCxRQUFRQztBQUN6QixVQUFNalgsUUFBUXlULElBQUl1RCxRQUFRRTtBQUMxQixVQUFNN08sTUFBTXFMLElBQUlzRCxRQUFRRztBQUN4QixVQUFNN08sU0FBU29MLElBQUlzRCxRQUFRSTtBQUMzQixVQUFNQyxjQUFjZCxLQUFLTyxpQkFBaUJ6TyxNQUFNQyxVQUFVLElBQUlBO0FBRTlEZ0gsUUFBSWdJLGNBQWNoSSxJQUFJbUg7QUFDdEJuSCxRQUFJb0YsVUFBUztBQUNicEYsUUFBSWpFLFlBQVlrTCxLQUFLZ0IsbUJBQW1CO0FBQ3hDakksUUFBSXdGLE9BQU8vVSxNQUFNc1gsV0FBQUE7QUFDakIvSCxRQUFJMEYsT0FBT2hWLE9BQU9xWCxXQUFBQTtBQUNsQi9ILFFBQUlnRyxPQUFNOztBQUVkO0FBRUEsU0FBU2tDLGFBQWFsSSxLQUErQmlILE1BQXVCO0FBQzFFLFFBQU1rQixXQUFXbkksSUFBSW1IO0FBRXJCbkgsTUFBSW1ILFlBQVlGLEtBQUtwUTtBQUNyQm1KLE1BQUlvSSxTQUFTbkIsS0FBS3hXLE1BQU13VyxLQUFLbE8sS0FBS2tPLEtBQUt4SyxPQUFPd0ssS0FBS2hELE1BQU07QUFDekRqRSxNQUFJbUgsWUFBWWdCO0FBQ2xCO0FBS08sU0FBU0UsV0FDZHJJLEtBQ0FyRCxNQUNBd0gsR0FDQUMsR0FDQTVFLE1BQ0F5SCxPQUF1QixDQUFBLEdBQ3ZCO0FBQ0EsUUFBTXFCLFFBQVFyTyxRQUFRMEMsSUFBQUEsSUFBUUEsT0FBTztJQUFDQTtFQUFLO0FBQzNDLFFBQU1xSixTQUFTaUIsS0FBS3NCLGNBQWMsS0FBS3RCLEtBQUt1QixnQkFBZ0I7QUFDNUQsTUFBSW5LLEdBQVdrSjtBQUVmdkgsTUFBSThDLEtBQUk7QUFDUjlDLE1BQUlSLE9BQU9BLEtBQUs4QztBQUNoQjBFLGdCQUFjaEgsS0FBS2lILElBQUFBO0FBRW5CLE9BQUs1SSxJQUFJLEdBQUdBLElBQUlpSyxNQUFNcFgsUUFBUSxFQUFFbU4sR0FBRztBQUNqQ2tKLFdBQU9lLE1BQU1qSyxDQUFFO0FBRWYsUUFBSTRJLEtBQUt3QixVQUFVO0FBQ2pCUCxtQkFBYWxJLEtBQUtpSCxLQUFLd0IsUUFBUTs7QUFHakMsUUFBSXpDLFFBQVE7QUFDVixVQUFJaUIsS0FBS3VCLGFBQWE7QUFDcEJ4SSxZQUFJZ0ksY0FBY2YsS0FBS3VCOztBQUd6QixVQUFJLENBQUM5VixjQUFjdVUsS0FBS3NCLFdBQVcsR0FBRztBQUNwQ3ZJLFlBQUlqRSxZQUFZa0wsS0FBS3NCOztBQUd2QnZJLFVBQUkwSSxXQUFXbkIsTUFBTXBELEdBQUdDLEdBQUc2QyxLQUFLMEIsUUFBUTs7QUFHMUMzSSxRQUFJNEksU0FBU3JCLE1BQU1wRCxHQUFHQyxHQUFHNkMsS0FBSzBCLFFBQVE7QUFDdENyQixpQkFBYXRILEtBQUttRSxHQUFHQyxHQUFHbUQsTUFBTU4sSUFBQUE7QUFFOUI3QyxTQUFLeUUsT0FBT3JKLEtBQUtJLFVBQVU7RUFDN0I7QUFFQUksTUFBSW9ELFFBQU87QUFDYjtBQU9PLFNBQVMwRixtQkFDZDlJLEtBQ0E2RixNQUNBO0FBQ0EsUUFBTSxFQUFDMUIsR0FBR0MsR0FBR0UsR0FBR3lFLEdBQUdqRSxPQUFNLElBQUllO0FBRzdCN0YsTUFBSXNGLElBQUluQixJQUFJVyxPQUFPa0UsU0FBUzVFLElBQUlVLE9BQU9rRSxTQUFTbEUsT0FBT2tFLFNBQVMsTUFBTTFULElBQUlBLElBQUksSUFBSTtBQUdsRjBLLE1BQUkwRixPQUFPdkIsR0FBR0MsSUFBSTJFLElBQUlqRSxPQUFPbUUsVUFBVTtBQUd2Q2pKLE1BQUlzRixJQUFJbkIsSUFBSVcsT0FBT21FLFlBQVk3RSxJQUFJMkUsSUFBSWpFLE9BQU9tRSxZQUFZbkUsT0FBT21FLFlBQVkzVCxJQUFJSCxTQUFTLElBQUk7QUFHOUY2SyxNQUFJMEYsT0FBT3ZCLElBQUlHLElBQUlRLE9BQU9vRSxhQUFhOUUsSUFBSTJFLENBQUFBO0FBRzNDL0ksTUFBSXNGLElBQUluQixJQUFJRyxJQUFJUSxPQUFPb0UsYUFBYTlFLElBQUkyRSxJQUFJakUsT0FBT29FLGFBQWFwRSxPQUFPb0UsYUFBYS9ULFNBQVMsR0FBRyxJQUFJO0FBR3BHNkssTUFBSTBGLE9BQU92QixJQUFJRyxHQUFHRixJQUFJVSxPQUFPcUUsUUFBUTtBQUdyQ25KLE1BQUlzRixJQUFJbkIsSUFBSUcsSUFBSVEsT0FBT3FFLFVBQVUvRSxJQUFJVSxPQUFPcUUsVUFBVXJFLE9BQU9xRSxVQUFVLEdBQUcsQ0FBQ2hVLFNBQVMsSUFBSTtBQUd4RjZLLE1BQUkwRixPQUFPdkIsSUFBSVcsT0FBT2tFLFNBQVM1RSxDQUFBQTtBQUNqQztBQ3hnQkEsSUFBTWdGLGNBQWM7QUFDcEIsSUFBTUMsYUFBYTtBQWNaLFNBQVNDLGFBQWE1UyxPQUF3QmdKLE1BQXNCO0FBQ3pFLFFBQU02SixXQUFXLEtBQUs3UyxPQUFPOFMsTUFBTUosV0FBQUE7QUFDbkMsTUFBSSxDQUFDRyxXQUFXQSxRQUFRLENBQUEsTUFBTyxVQUFVO0FBQ3ZDLFdBQU83SixPQUFPOztBQUdoQmhKLFVBQVEsQ0FBQzZTLFFBQVEsQ0FBRTtBQUVuQixVQUFRQSxRQUFRLENBQUUsR0FBQTtJQUNoQixLQUFLO0FBQ0gsYUFBTzdTO0lBQ1QsS0FBSztBQUNIQSxlQUFTO0FBQ1Q7RUFHSjtBQUVBLFNBQU9nSixPQUFPaEo7QUFDaEI7QUFFQSxJQUFNK1MsZUFBZSxDQUFDOVEsTUFBZSxDQUFDQSxLQUFLO0FBUXBDLFNBQVMrUSxrQkFBa0JoVCxPQUF3Q2lULE9BQTBDO0FBQ2xILFFBQU1DLE1BQU0sQ0FBQTtBQUNaLFFBQU1DLFdBQVdoSSxTQUFTOEgsS0FBQUE7QUFDMUIsUUFBTXhMLE9BQU8wTCxXQUFXclcsT0FBTzJLLEtBQUt3TCxLQUFBQSxJQUFTQTtBQUM3QyxRQUFNRyxPQUFPakksU0FBU25MLEtBQUFBLElBQ2xCbVQsV0FDRUUsQ0FBQUEsU0FBUWpJLGVBQWVwTCxNQUFNcVQsSUFBQUEsR0FBT3JULE1BQU1pVCxNQUFNSSxJQUFLLENBQUEsQ0FBQyxJQUN0REEsQ0FBQUEsU0FBUXJULE1BQU1xVCxJQUFBQSxJQUNoQixNQUFNclQ7QUFFVixhQUFXcVQsUUFBUTVMLE1BQU07QUFDdkJ5TCxRQUFJRyxJQUFBQSxJQUFRTixhQUFhSyxLQUFLQyxJQUFBQSxDQUFBQTtFQUNoQztBQUNBLFNBQU9IO0FBQ1Q7QUFVTyxTQUFTSSxPQUFPdFQsT0FBOEI7QUFDbkQsU0FBT2dULGtCQUFrQmhULE9BQU87SUFBQ3FDLEtBQUs7SUFBS3JJLE9BQU87SUFBS3NJLFFBQVE7SUFBS3ZJLE1BQU07RUFBRyxDQUFBO0FBQy9FO0FBU08sU0FBU3daLGNBQWN2VCxPQUE2QjtBQUN6RCxTQUFPZ1Qsa0JBQWtCaFQsT0FBTztJQUFDO0lBQVc7SUFBWTtJQUFjO0VBQWMsQ0FBQTtBQUN0RjtBQVVPLFNBQVN3VCxVQUFVeFQsT0FBa0M7QUFDMUQsUUFBTXlULE1BQU1ILE9BQU90VCxLQUFBQTtBQUVuQnlULE1BQUkxTixRQUFRME4sSUFBSTFaLE9BQU8wWixJQUFJelo7QUFDM0J5WixNQUFJbEcsU0FBU2tHLElBQUlwUixNQUFNb1IsSUFBSW5SO0FBRTNCLFNBQU9tUjtBQUNUO0FBVU8sU0FBU0MsT0FBTzFZLFVBQTRCMlksVUFBOEI7QUFDL0UzWSxFQUFBQSxXQUFVQSxZQUFXLENBQUE7QUFDckIyWSxhQUFXQSxZQUFZL1MsU0FBU2tJO0FBRWhDLE1BQUlFLE9BQU9vQyxlQUFlcFEsU0FBUWdPLE1BQU0ySyxTQUFTM0ssSUFBSTtBQUVyRCxNQUFJLE9BQU9BLFNBQVMsVUFBVTtBQUM1QkEsV0FBTzRLLFNBQVM1SyxNQUFNLEVBQUE7O0FBRXhCLE1BQUlDLFFBQVFtQyxlQUFlcFEsU0FBUWlPLE9BQU8wSyxTQUFTMUssS0FBSztBQUN4RCxNQUFJQSxTQUFTLEVBQUUsS0FBS0EsT0FBTzZKLE1BQU1ILFVBQWEsR0FBQTtBQUM1Q2tCLFlBQVFDLEtBQUssb0NBQW9DN0ssUUFBUSxHQUFBO0FBQ3pEQSxZQUFRbkk7O0FBR1YsUUFBTWdJLE9BQU87SUFDWEMsUUFBUXFDLGVBQWVwUSxTQUFRK04sUUFBUTRLLFNBQVM1SyxNQUFNO0lBQ3RERyxZQUFZMEosYUFBYXhILGVBQWVwUSxTQUFRa08sWUFBWXlLLFNBQVN6SyxVQUFVLEdBQUdGLElBQUFBO0lBQ2xGQTtJQUNBQztJQUNBRSxRQUFRaUMsZUFBZXBRLFNBQVFtTyxRQUFRd0ssU0FBU3hLLE1BQU07SUFDdER5QyxRQUFRO0VBQ1Y7QUFFQTlDLE9BQUs4QyxTQUFTTCxhQUFhekMsSUFBQUE7QUFDM0IsU0FBT0E7QUFDVDtBQWFPLFNBQVNpTCxRQUFRQyxRQUF3QnZMLFNBQWtCL0UsUUFBZ0J1USxNQUErQjtBQUMvRyxNQUFJQyxZQUFZO0FBQ2hCLE1BQUl2TSxHQUFXMEUsTUFBY3JNO0FBRTdCLE9BQUsySCxJQUFJLEdBQUcwRSxPQUFPMkgsT0FBT3haLFFBQVFtTixJQUFJMEUsTUFBTSxFQUFFMUUsR0FBRztBQUMvQzNILFlBQVFnVSxPQUFPck0sQ0FBRTtBQUNqQixRQUFJM0gsVUFBVWMsUUFBVztBQUN2Qjs7QUFFRixRQUFJMkgsWUFBWTNILFVBQWEsT0FBT2QsVUFBVSxZQUFZO0FBQ3hEQSxjQUFRQSxNQUFNeUksT0FBQUE7QUFDZHlMLGtCQUFZOztBQUVkLFFBQUl4USxXQUFVNUMsVUFBYXlDLFFBQVF2RCxLQUFRLEdBQUE7QUFDekNBLGNBQVFBLE1BQU0wRCxTQUFRMUQsTUFBTXhGLE1BQU07QUFDbEMwWixrQkFBWTs7QUFFZCxRQUFJbFUsVUFBVWMsUUFBVztBQUN2QixVQUFJbVQsUUFBUSxDQUFDQyxXQUFXO0FBQ3RCRCxhQUFLQyxZQUFZOztBQUVuQixhQUFPbFU7O0VBRVg7QUFDRjtBQVFPLFNBQVNtVSxVQUFVQyxRQUF1Q2pQLE9BQXdCSCxhQUFzQjtBQUM3RyxRQUFNLEVBQUM5SixLQUFLQyxJQUFBQSxJQUFPaVo7QUFDbkIsUUFBTUMsU0FBU0MsWUFBWW5QLFFBQVFoSyxNQUFNRCxPQUFPLENBQUE7QUFDaEQsUUFBTXFaLFdBQVcsQ0FBQ3ZVLE9BQWV3VSxRQUFnQnhQLGVBQWVoRixVQUFVLElBQUksSUFBSUEsUUFBUXdVO0FBQzFGLFNBQU87SUFDTHRaLEtBQUtxWixTQUFTclosS0FBSyxDQUFDSyxLQUFLeUksSUFBSXFRLE1BQUFBLENBQUFBO0lBQzdCbFosS0FBS29aLFNBQVNwWixLQUFLa1osTUFBQUE7RUFDckI7QUFDRjtBQVVPLFNBQVNJLGNBQWNDLGVBQXVCak0sU0FBaUI7QUFDcEUsU0FBTzNMLE9BQU9DLE9BQU9ELE9BQU9zSyxPQUFPc04sYUFBZ0JqTSxHQUFBQSxPQUFBQTtBQUNyRDtBQ25MTyxTQUFTa00sZ0JBSWRDLFFBQ0FDLFdBQVc7RUFBQztHQUNaQyxZQUNBbkIsVUFDQW9CLFlBQVksTUFBTUgsT0FBTyxDQUFBLEdBQ3pCO0FBQ0EsUUFBTUksa0JBQWtCRixjQUFjRjtBQUN0QyxNQUFJLE9BQU9qQixhQUFhLGFBQWE7QUFDbkNBLGVBQVdzQixTQUFTLGFBQWFMLE1BQUFBOztBQUVuQyxRQUFNMUksUUFBNkI7SUFDakMsQ0FBQ2dKLE9BQU9DLFdBQVcsR0FBRztJQUN0QkMsWUFBWTtJQUNaQyxTQUFTVDtJQUNUVSxhQUFhTjtJQUNiM1QsV0FBV3NTO0lBQ1g0QixZQUFZUjtJQUNadkssVUFBVSxDQUFDekMsVUFBcUI0TSxnQkFBZ0I7TUFBQzVNO01BQVU2TSxHQUFBQTtJQUFPLEdBQUVDLFVBQVVHLGlCQUFpQnJCLFFBQUFBO0VBQ2pHO0FBQ0EsU0FBTyxJQUFJNkIsTUFBTXRKLE9BQU87Ozs7SUFJdEJ1SixlQUFldkssUUFBUW1JLE1BQWM7QUFDbkMsYUFBT25JLE9BQU9tSSxJQUFLO0FBQ25CLGFBQU9uSSxPQUFPd0s7QUFDZCxhQUFPZCxPQUFPLENBQUEsRUFBR3ZCLElBQUFBO0FBQ2pCLGFBQU87SUFDVDs7OztJQUtBdFEsSUFBSW1JLFFBQVFtSSxNQUFjO0FBQ3hCLGFBQU9zQyxRQUFRekssUUFBUW1JLE1BQ3JCLE1BQU11QyxxQkFBcUJ2QyxNQUFNd0IsVUFBVUQsUUFBUTFKLE1BQUFBLENBQUFBO0lBQ3ZEOzs7OztJQU1BMksseUJBQXlCM0ssUUFBUW1JLE1BQU07QUFDckMsYUFBT3lDLFFBQVFELHlCQUF5QjNLLE9BQU9tSyxRQUFRLENBQUEsR0FBSWhDLElBQUFBO0lBQzdEOzs7O0lBS0EwQyxpQkFBaUI7QUFDZixhQUFPRCxRQUFRQyxlQUFlbkIsT0FBTyxDQUFFLENBQUE7SUFDekM7Ozs7SUFLQW9CLElBQUk5SyxRQUFRbUksTUFBYztBQUN4QixhQUFPNEMscUJBQXFCL0ssTUFBUXRHLEVBQUFBLFNBQVN5TyxJQUFBQTtJQUMvQzs7OztJQUtBNkMsUUFBUWhMLFFBQVE7QUFDZCxhQUFPK0sscUJBQXFCL0ssTUFBQUE7SUFDOUI7Ozs7SUFLQXJLLElBQUlxSyxRQUFRbUksTUFBY3JULE9BQU87QUFDL0IsWUFBTW1XLFVBQVVqTCxPQUFPa0wsYUFBYWxMLE9BQU9rTCxXQUFXckIsVUFBVTtBQUNoRTdKLGFBQU9tSSxJQUFBQSxJQUFROEMsUUFBUTlDLElBQUssSUFBR3JUO0FBQy9CLGFBQU9rTCxPQUFPd0s7QUFDZCxhQUFPO0lBQ1Q7RUFDRixDQUFBO0FBQ0Y7QUFVTyxTQUFTVyxlQUlkQyxPQUNBN04sU0FDQThOLFVBQ0FDLG9CQUNBO0FBQ0EsUUFBTXRLLFFBQTRCO0lBQ2hDa0osWUFBWTtJQUNacUIsUUFBUUg7SUFDUkksVUFBVWpPO0lBQ1ZrTyxXQUFXSjtJQUNYSyxRQUFRLG9CQUFJQyxJQUFBQTtJQUNaMU8sY0FBY0EsYUFBYW1PLE9BQU9FLGtCQUFBQTtJQUNsQ00sWUFBWSxDQUFDeE4sUUFBbUIrTSxlQUFlQyxPQUFPaE4sS0FBS2lOLFVBQVVDLGtCQUFBQTtJQUNyRWhNLFVBQVUsQ0FBQ3pDLFVBQXFCc08sZUFBZUMsTUFBTTlMLFNBQVN6QyxLQUFBQSxHQUFRVSxTQUFTOE4sVUFBVUMsa0JBQUFBO0VBQzNGO0FBQ0EsU0FBTyxJQUFJaEIsTUFBTXRKLE9BQU87Ozs7SUFJdEJ1SixlQUFldkssUUFBUW1JLE1BQU07QUFDM0IsYUFBT25JLE9BQU9tSSxJQUFLO0FBQ25CLGFBQU9pRCxNQUFNakQsSUFBSztBQUNsQixhQUFPO0lBQ1Q7Ozs7SUFLQXRRLElBQUltSSxRQUFRbUksTUFBYzBELFVBQVU7QUFDbEMsYUFBT3BCLFFBQVF6SyxRQUFRbUksTUFDckIsTUFBTTJELG9CQUFvQjlMLFFBQVFtSSxNQUFNMEQsUUFBQUEsQ0FBQUE7SUFDNUM7Ozs7O0lBTUFsQix5QkFBeUIzSyxRQUFRbUksTUFBTTtBQUNyQyxhQUFPbkksT0FBTy9DLGFBQWE4TyxVQUN2Qm5CLFFBQVFFLElBQUlNLE9BQU9qRCxJQUFRLElBQUE7UUFBQ3JJLFlBQVk7UUFBTWtNLGNBQWM7TUFBSSxJQUFJcFcsU0FDcEVnVixRQUFRRCx5QkFBeUJTLE9BQU9qRCxJQUFLO0lBQ25EOzs7O0lBS0EwQyxpQkFBaUI7QUFDZixhQUFPRCxRQUFRQyxlQUFlTyxLQUFBQTtJQUNoQzs7OztJQUtBTixJQUFJOUssUUFBUW1JLE1BQU07QUFDaEIsYUFBT3lDLFFBQVFFLElBQUlNLE9BQU9qRCxJQUFBQTtJQUM1Qjs7OztJQUtBNkMsVUFBVTtBQUNSLGFBQU9KLFFBQVFJLFFBQVFJLEtBQUFBO0lBQ3pCOzs7O0lBS0F6VixJQUFJcUssUUFBUW1JLE1BQU1yVCxPQUFPO0FBQ3ZCc1csWUFBTWpELElBQUFBLElBQVFyVDtBQUNkLGFBQU9rTCxPQUFPbUksSUFBSztBQUNuQixhQUFPO0lBQ1Q7RUFDRixDQUFBO0FBQ0Y7QUFLTyxTQUFTbEwsYUFDZG1PLE9BQ0ExVixZQUErQjtFQUFDdVcsWUFBWTtFQUFNQyxXQUFXO0FBQUksR0FDckQ7QUFDWixRQUFNLEVBQUM3VixjQUFjWCxVQUFTdVcsWUFBWTdWLGFBQWFWLFVBQVN3VyxXQUFXQyxXQUFXelcsVUFBU3FXLFFBQU8sSUFBSVg7QUFDMUcsU0FBTztJQUNMVyxTQUFTSTtJQUNURixZQUFZNVY7SUFDWjZWLFdBQVc5VjtJQUNYZ1csY0FBY0MsV0FBV2hXLFdBQUFBLElBQWVBLGNBQWMsTUFBTUE7SUFDNURpVyxhQUFhRCxXQUFXalcsVUFBQUEsSUFBY0EsYUFBYSxNQUFNQTtFQUMzRDtBQUNGO0FBRUEsSUFBTW1XLFVBQVUsQ0FBQ0MsUUFBZ0JsVyxTQUFpQmtXLFNBQVNBLFNBQVNDLFlBQVluVyxJQUFBQSxJQUFRQTtBQUN4RixJQUFNb1csbUJBQW1CLENBQUN2RSxNQUFjclQsVUFBbUJtTCxTQUFTbkwsS0FBQUEsS0FBVXFULFNBQVMsZUFDcEZ2VyxPQUFPaVosZUFBZS9WLEtBQVcsTUFBQSxRQUFRQSxNQUFNa0ksZ0JBQWdCcEw7QUFFbEUsU0FBUzZZLFFBQ1B6SyxRQUNBbUksTUFDQVUsVUFDQTtBQUNBLE1BQUlqWCxPQUFPK2EsVUFBVUMsZUFBZTVlLEtBQUtnUyxRQUFRbUksSUFBU0EsS0FBQUEsU0FBUyxlQUFlO0FBQ2hGLFdBQU9uSSxPQUFPbUksSUFBSzs7QUFHckIsUUFBTXJULFFBQVErVCxTQUFBQTtBQUVkN0ksU0FBT21JLElBQUFBLElBQVFyVDtBQUNmLFNBQU9BO0FBQ1Q7QUFFQSxTQUFTZ1gsb0JBQ1A5TCxRQUNBbUksTUFDQTBELFVBQ0E7QUFDQSxRQUFNLEVBQUNOLFFBQVFDLFVBQVVDLFdBQVd4TyxjQUFjZCxhQUFXLElBQUk2RDtBQUNqRSxNQUFJbEwsUUFBUXlXLE9BQU9wRCxJQUFBQTtBQUduQixNQUFJa0UsV0FBV3ZYLEtBQUFBLEtBQVVxSCxhQUFZaVEsYUFBYWpFLElBQU8sR0FBQTtBQUN2RHJULFlBQVErWCxtQkFBbUIxRSxNQUFNclQsT0FBT2tMLFFBQVE2TCxRQUFBQTs7QUFFbEQsTUFBSXhULFFBQVF2RCxLQUFBQSxLQUFVQSxNQUFNeEYsUUFBUTtBQUNsQ3dGLFlBQVFnWSxjQUFjM0UsTUFBTXJULE9BQU9rTCxRQUFRN0QsYUFBWW1RLFdBQVc7O0FBRXBFLE1BQUlJLGlCQUFpQnZFLE1BQU1yVCxLQUFRLEdBQUE7QUFFakNBLFlBQVFxVyxlQUFlclcsT0FBTzBXLFVBQVVDLGFBQWFBLFVBQVV0RCxJQUFBQSxHQUFPaE0sWUFBQUE7O0FBRXhFLFNBQU9ySDtBQUNUO0FBRUEsU0FBUytYLG1CQUNQMUUsTUFDQTRFLFVBQ0EvTSxRQUNBNkwsVUFDQTtBQUNBLFFBQU0sRUFBQ04sUUFBUUMsVUFBVUMsV0FBV0MsT0FBTSxJQUFJMUw7QUFDOUMsTUFBSTBMLE9BQU9aLElBQUkzQyxJQUFPLEdBQUE7QUFDcEIsVUFBTSxJQUFJNkUsTUFBTSx5QkFBeUJDLE1BQU1sWCxLQUFLMlYsTUFBQUEsRUFBUXdCLEtBQUssSUFBUSxJQUFBLE9BQU8vRSxJQUFNOztBQUV4RnVELFNBQU9wQyxJQUFJbkIsSUFBQUE7QUFDWCxNQUFJclQsUUFBUWlZLFNBQVN2QixVQUFVQyxhQUFhSSxRQUFBQTtBQUM1Q0gsU0FBT3lCLE9BQU9oRixJQUFBQTtBQUNkLE1BQUl1RSxpQkFBaUJ2RSxNQUFNclQsS0FBUSxHQUFBO0FBRWpDQSxZQUFRc1ksa0JBQWtCN0IsT0FBT3BCLFNBQVNvQixRQUFRcEQsTUFBTXJULEtBQUFBOztBQUUxRCxTQUFPQTtBQUNUO0FBRUEsU0FBU2dZLGNBQ1AzRSxNQUNBclQsT0FDQWtMLFFBQ0FzTSxhQUNBO0FBQ0EsUUFBTSxFQUFDZixRQUFRQyxVQUFVQyxXQUFXeE8sY0FBY2QsYUFBVyxJQUFJNkQ7QUFFakUsTUFBSSxPQUFPd0wsU0FBU2hULFVBQVUsZUFBZThULFlBQVluRSxJQUFPLEdBQUE7QUFDOUQsV0FBT3JULE1BQU0wVyxTQUFTaFQsUUFBUTFELE1BQU14RixNQUFNO0VBQzVDLFdBQVcyUSxTQUFTbkwsTUFBTSxDQUFBLENBQUUsR0FBRztBQUU3QixVQUFNdVksTUFBTXZZO0FBQ1osVUFBTTRVLFNBQVM2QixPQUFPcEIsUUFBUW1ELE9BQU9yYixDQUFBQSxNQUFLQSxNQUFNb2IsR0FBQUE7QUFDaER2WSxZQUFRLENBQUE7QUFDUixlQUFXeVksUUFBUUYsS0FBSztBQUN0QixZQUFNRyxXQUFXSixrQkFBa0IxRCxRQUFRNkIsUUFBUXBELE1BQU1vRixJQUFBQTtBQUN6RHpZLFlBQU0rTCxLQUFLc0ssZUFBZXFDLFVBQVVoQyxVQUFVQyxhQUFhQSxVQUFVdEQsSUFBQUEsR0FBT2hNLFlBQUFBLENBQUFBO0lBQzlFOztBQUVGLFNBQU9ySDtBQUNUO0FBRUEsU0FBUzJZLGdCQUNQaEYsVUFDQU4sTUFDQXJULE9BQ0E7QUFDQSxTQUFPdVgsV0FBVzVELFFBQUFBLElBQVlBLFNBQVNOLE1BQU1yVCxLQUFBQSxJQUFTMlQ7QUFDeEQ7QUFFQSxJQUFNck0sV0FBVyxDQUFDRSxLQUF3Qm9SLFdBQXNCcFIsUUFBUSxPQUFPb1IsU0FDM0UsT0FBT3BSLFFBQVEsV0FBV3FSLGlCQUFpQkQsUUFBUXBSLEdBQUFBLElBQU8xRztBQUU5RCxTQUFTZ1ksVUFDUGpZLE1BQ0FrWSxjQUNBdlIsS0FDQXdSLGdCQUNBaFosT0FDQTtBQUNBLGFBQVc0WSxVQUFVRyxjQUFjO0FBQ2pDLFVBQU1oUixRQUFRVCxTQUFTRSxLQUFLb1IsTUFBQUE7QUFDNUIsUUFBSTdRLE9BQU87QUFDVGxILE1BQUFBLEtBQUkyVCxJQUFJek0sS0FBQUE7QUFDUixZQUFNNEwsV0FBV2dGLGdCQUFnQjVRLE1BQU0xRyxXQUFXbUcsS0FBS3hILEtBQUFBO0FBQ3ZELFVBQUksT0FBTzJULGFBQWEsZUFBZUEsYUFBYW5NLE9BQU9tTSxhQUFhcUYsZ0JBQWdCO0FBR3RGLGVBQU9yRjs7ZUFFQTVMLFVBQVUsU0FBUyxPQUFPaVIsbUJBQW1CLGVBQWV4UixRQUFRd1IsZ0JBQWdCO0FBRzdGLGFBQU87O0VBRVg7QUFDQSxTQUFPO0FBQ1Q7QUFFQSxTQUFTVixrQkFDUFMsY0FDQUwsVUFDQXJGLE1BQ0FyVCxPQUNBO0FBQ0EsUUFBTThVLGFBQWE0RCxTQUFTcEQ7QUFDNUIsUUFBTTNCLFdBQVdnRixnQkFBZ0JELFNBQVNyWCxXQUFXZ1MsTUFBTXJULEtBQUFBO0FBQzNELFFBQU1pWixZQUFZO0lBQUlGLEdBQUFBO0lBQWlCakUsR0FBQUE7RUFBVztBQUNsRCxRQUFNalUsT0FBTSxvQkFBSWdXLElBQUFBO0FBQ2hCaFcsRUFBQUEsS0FBSTJULElBQUl4VSxLQUFBQTtBQUNSLE1BQUl3SCxNQUFNMFIsaUJBQWlCclksTUFBS29ZLFdBQVc1RixNQUFNTSxZQUFZTixNQUFNclQsS0FBQUE7QUFDbkUsTUFBSXdILFFBQVEsTUFBTTtBQUNoQixXQUFPOztBQUVULE1BQUksT0FBT21NLGFBQWEsZUFBZUEsYUFBYU4sTUFBTTtBQUN4RDdMLFVBQU0wUixpQkFBaUJyWSxNQUFLb1ksV0FBV3RGLFVBQVVuTSxLQUFLeEgsS0FBQUE7QUFDdEQsUUFBSXdILFFBQVEsTUFBTTtBQUNoQixhQUFPOzs7QUFHWCxTQUFPbU4sZ0JBQWdCd0QsTUFBTWxYLEtBQUtKLElBQU0sR0FBQTtJQUFDO0VBQUcsR0FBRWlVLFlBQVluQixVQUN4RCxNQUFNd0YsYUFBYVQsVUFBVXJGLE1BQWdCclQsS0FBQUEsQ0FBQUE7QUFDakQ7QUFFQSxTQUFTa1osaUJBQ1ByWSxNQUNBb1ksV0FDQXpSLEtBQ0FtTSxVQUNBOEUsTUFDQTtBQUNBLFNBQU9qUixLQUFLO0FBQ1ZBLFVBQU1zUixVQUFValksTUFBS29ZLFdBQVd6UixLQUFLbU0sVUFBVThFLElBQUFBO0VBQ2pEO0FBQ0EsU0FBT2pSO0FBQ1Q7QUFFQSxTQUFTMlIsYUFDUFQsVUFDQXJGLE1BQ0FyVCxPQUNBO0FBQ0EsUUFBTTRZLFNBQVNGLFNBQVNuRCxXQUFVO0FBQ2xDLE1BQUksRUFBRWxDLFFBQVF1RixTQUFTO0FBQ3JCQSxXQUFPdkYsSUFBSyxJQUFHLENBQUE7O0FBRWpCLFFBQU1uSSxTQUFTME4sT0FBT3ZGLElBQUs7QUFDM0IsTUFBSTlQLFFBQVEySCxNQUFXQyxLQUFBQSxTQUFTbkwsS0FBUSxHQUFBO0FBRXRDLFdBQU9BOztBQUVULFNBQU9rTCxVQUFVLENBQUE7QUFDbkI7QUFFQSxTQUFTMEsscUJBQ1B2QyxNQUNBd0IsVUFDQUQsUUFDQTBCLE9BQ0E7QUFDQSxNQUFJdFc7QUFDSixhQUFXMFgsVUFBVTdDLFVBQVU7QUFDN0I3VSxZQUFRaVYsU0FBU3dDLFFBQVFDLFFBQVFyRSxJQUFPdUIsR0FBQUEsTUFBQUE7QUFDeEMsUUFBSSxPQUFPNVUsVUFBVSxhQUFhO0FBQ2hDLGFBQU80WCxpQkFBaUJ2RSxNQUFNclQsS0FDMUJzWSxJQUFBQSxrQkFBa0IxRCxRQUFRMEIsT0FBT2pELE1BQU1yVCxLQUFBQSxJQUN2Q0E7O0VBRVI7QUFDRjtBQUVBLFNBQVNpVixTQUFTek4sS0FBYW9OLFFBQXFCO0FBQ2xELGFBQVc3TSxTQUFTNk0sUUFBUTtBQUMxQixRQUFJLENBQUM3TSxPQUFPO0FBQ1Y7O0FBRUYsVUFBTS9ILFFBQVErSCxNQUFNUCxHQUFJO0FBQ3hCLFFBQUksT0FBT3hILFVBQVUsYUFBYTtBQUNoQyxhQUFPQTs7RUFFWDtBQUNGO0FBRUEsU0FBU2lXLHFCQUFxQi9LLFFBQXVCO0FBQ25ELE1BQUl6RCxPQUFPeUQsT0FBT3dLO0FBQ2xCLE1BQUksQ0FBQ2pPLE1BQU07QUFDVEEsV0FBT3lELE9BQU93SyxRQUFRMEQseUJBQXlCbE8sT0FBT21LLE9BQU87O0FBRS9ELFNBQU81TjtBQUNUO0FBRUEsU0FBUzJSLHlCQUF5QnhFLFFBQXFCO0FBQ3JELFFBQU0vVCxPQUFNLG9CQUFJZ1csSUFBQUE7QUFDaEIsYUFBVzlPLFNBQVM2TSxRQUFRO0FBQzFCLGVBQVdwTixPQUFPMUssT0FBTzJLLEtBQUtNLEtBQU95USxFQUFBQSxPQUFPM1EsQ0FBQUEsTUFBSyxDQUFDQSxFQUFFWCxXQUFXLEdBQU8sQ0FBQSxHQUFBO0FBQ3BFckcsTUFBQUEsS0FBSTJULElBQUloTixHQUFBQTtJQUNWO0VBQ0Y7QUFDQSxTQUFPMlEsTUFBTWxYLEtBQUtKLElBQUFBO0FBQ3BCO0FBRU8sU0FBU3dZLDRCQUNkamYsTUFDQXFSLE1BQ0E3UixPQUNBYSxPQUNBO0FBQ0EsUUFBTSxFQUFDRSxPQUFNLElBQUlQO0FBQ2pCLFFBQU0sRUFBQ29OLE1BQU0sSUFBQSxJQUFPLEtBQUs4UjtBQUN6QixRQUFNQyxTQUFTLElBQUlwQixNQUFvQjFkLEtBQUFBO0FBQ3ZDLE1BQUlrTixHQUFXMEUsTUFBYzNJLFFBQWUrVTtBQUU1QyxPQUFLOVEsSUFBSSxHQUFHMEUsT0FBTzVSLE9BQU9rTixJQUFJMEUsTUFBTSxFQUFFMUUsR0FBRztBQUN2Q2pFLElBQUFBLFNBQVFpRSxJQUFJL047QUFDWjZlLFdBQU9oTixLQUFLL0gsTUFBTTtBQUNsQjZWLFdBQU81UixDQUFBQSxJQUFLO01BQ1Y2UixHQUFHN2UsT0FBTzhlLE1BQU1aLGlCQUFpQkosTUFBTWpSLEdBQU05RCxHQUFBQSxNQUFBQTtJQUMvQztFQUNGO0FBQ0EsU0FBTzZWO0FBQ1Q7QUNsY0EsSUFBTUcsVUFBVXZILE9BQU91SCxXQUFXO0FBR2xDLElBQU1DLFdBQVcsQ0FBQ3RmLFFBQXVCc04sTUFBbUNBLElBQUl0TixPQUFPRyxVQUFVLENBQUNILE9BQU9zTixDQUFFLEVBQUNpUyxRQUFRdmYsT0FBT3NOLENBQUU7QUFDN0gsSUFBTWtTLGVBQWUsQ0FBQ3BRLGNBQXlCQSxjQUFjLE1BQU0sTUFBTTtBQUVsRSxTQUFTcVEsWUFDZEMsWUFDQUMsYUFDQUMsWUFDQWhkLEdBSUU7QUFNRixRQUFNNFMsV0FBV2tLLFdBQVdILE9BQU9JLGNBQWNEO0FBQ2pELFFBQU1HLFVBQVVGO0FBQ2hCLFFBQU1HLE9BQU9GLFdBQVdMLE9BQU9JLGNBQWNDO0FBQzdDLFFBQU1HLE1BQU1DLHNCQUFzQkgsU0FBU3JLLFFBQUFBO0FBQzNDLFFBQU15SyxNQUFNRCxzQkFBc0JGLE1BQU1ELE9BQUFBO0FBRXhDLE1BQUlLLE1BQU1ILE9BQU9BLE1BQU1FO0FBQ3ZCLE1BQUlFLE1BQU1GLE9BQU9GLE1BQU1FO0FBR3ZCQyxRQUFNbFcsTUFBTWtXLEdBQU8sSUFBQSxJQUFJQTtBQUN2QkMsUUFBTW5XLE1BQU1tVyxHQUFPLElBQUEsSUFBSUE7QUFFdkIsUUFBTUMsS0FBS3hkLElBQUlzZDtBQUNmLFFBQU1HLEtBQUt6ZCxJQUFJdWQ7QUFFZixTQUFPO0lBQ0wzSyxVQUFVO01BQ1JwQyxHQUFHeU0sUUFBUXpNLElBQUlnTixNQUFNTixLQUFLMU0sSUFBSW9DLFNBQVNwQztNQUN2Q0MsR0FBR3dNLFFBQVF4TSxJQUFJK00sTUFBTU4sS0FBS3pNLElBQUltQyxTQUFTbkM7SUFDekM7SUFDQXlNLE1BQU07TUFDSjFNLEdBQUd5TSxRQUFRek0sSUFBSWlOLE1BQU1QLEtBQUsxTSxJQUFJb0MsU0FBU3BDO01BQ3ZDQyxHQUFHd00sUUFBUXhNLElBQUlnTixNQUFNUCxLQUFLek0sSUFBSW1DLFNBQVNuQztJQUN6QztFQUNGO0FBQ0Y7QUFLQSxTQUFTaU4sZUFBZXRnQixRQUF1QnVnQixRQUFrQkMsSUFBYztBQUM3RSxRQUFNQyxZQUFZemdCLE9BQU9HO0FBRXpCLE1BQUl1Z0IsUUFBZ0JDLE9BQWVDLE1BQWNDLGtCQUEwQkM7QUFDM0UsTUFBSUMsYUFBYXpCLFNBQVN0ZixRQUFRLENBQUE7QUFDbEMsV0FBU3NOLElBQUksR0FBR0EsSUFBSW1ULFlBQVksR0FBRyxFQUFFblQsR0FBRztBQUN0Q3dULG1CQUFlQztBQUNmQSxpQkFBYXpCLFNBQVN0ZixRQUFRc04sSUFBSSxDQUFBO0FBQ2xDLFFBQUksQ0FBQ3dULGdCQUFnQixDQUFDQyxZQUFZO0FBQ2hDOztBQUdGLFFBQUlDLGFBQWFULE9BQU9qVCxDQUFFLEdBQUUsR0FBRytSLE9BQVUsR0FBQTtBQUN2Q21CLFNBQUdsVCxDQUFFLElBQUdrVCxHQUFHbFQsSUFBSSxDQUFBLElBQUs7QUFDcEI7O0FBR0ZvVCxhQUFTRixHQUFHbFQsQ0FBQUEsSUFBS2lULE9BQU9qVCxDQUFFO0FBQzFCcVQsWUFBUUgsR0FBR2xULElBQUksQ0FBQSxJQUFLaVQsT0FBT2pULENBQUU7QUFDN0J1VCx1QkFBbUIzZixLQUFLOEIsSUFBSTBkLFFBQVEsQ0FBQSxJQUFLeGYsS0FBSzhCLElBQUkyZCxPQUFPLENBQUE7QUFDekQsUUFBSUUsb0JBQW9CLEdBQUc7QUFDekI7O0FBR0ZELFdBQU8sSUFBSTFmLEtBQUswRCxLQUFLaWMsZ0JBQUFBO0FBQ3JCTCxPQUFHbFQsQ0FBRSxJQUFHb1QsU0FBU0UsT0FBT0wsT0FBT2pULENBQUU7QUFDakNrVCxPQUFHbFQsSUFBSSxDQUFFLElBQUdxVCxRQUFRQyxPQUFPTCxPQUFPalQsQ0FBRTtFQUN0QztBQUNGO0FBRUEsU0FBUzJULGdCQUFnQmpoQixRQUF1QndnQixJQUFjcFIsWUFBdUIsS0FBSztBQUN4RixRQUFNOFIsWUFBWTFCLGFBQWFwUSxTQUFBQTtBQUMvQixRQUFNcVIsWUFBWXpnQixPQUFPRztBQUN6QixNQUFJc0osT0FBZTBYLGFBQWtDTDtBQUNyRCxNQUFJQyxhQUFhekIsU0FBU3RmLFFBQVEsQ0FBQTtBQUVsQyxXQUFTc04sSUFBSSxHQUFHQSxJQUFJbVQsV0FBVyxFQUFFblQsR0FBRztBQUNsQzZULGtCQUFjTDtBQUNkQSxtQkFBZUM7QUFDZkEsaUJBQWF6QixTQUFTdGYsUUFBUXNOLElBQUksQ0FBQTtBQUNsQyxRQUFJLENBQUN3VCxjQUFjO0FBQ2pCOztBQUdGLFVBQU1NLFNBQVNOLGFBQWExUixTQUFVO0FBQ3RDLFVBQU1pUyxTQUFTUCxhQUFhSSxTQUFVO0FBQ3RDLFFBQUlDLGFBQWE7QUFDZjFYLGVBQVMyWCxTQUFTRCxZQUFZL1IsU0FBQUEsS0FBYztBQUM1QzBSLG1CQUFhLE1BQU0xUixTQUFBQSxFQUFXLElBQUlnUyxTQUFTM1g7QUFDM0NxWCxtQkFBYSxNQUFNSSxTQUFVLEVBQUMsSUFBSUcsU0FBUzVYLFFBQVErVyxHQUFHbFQsQ0FBRTs7QUFFMUQsUUFBSXlULFlBQVk7QUFDZHRYLGVBQVNzWCxXQUFXM1IsU0FBVSxJQUFHZ1MsVUFBVTtBQUMzQ04sbUJBQWEsTUFBTTFSLFNBQUFBLEVBQVcsSUFBSWdTLFNBQVMzWDtBQUMzQ3FYLG1CQUFhLE1BQU1JLFNBQVUsRUFBQyxJQUFJRyxTQUFTNVgsUUFBUStXLEdBQUdsVCxDQUFFOztFQUU1RDtBQUNGO0FBUU8sU0FBU2dVLG9CQUFvQnRoQixRQUF1Qm9QLFlBQXVCLEtBQUs7QUFDckYsUUFBTThSLFlBQVkxQixhQUFhcFEsU0FBQUE7QUFDL0IsUUFBTXFSLFlBQVl6Z0IsT0FBT0c7QUFDekIsUUFBTW9nQixTQUFtQnpDLE1BQU0yQyxTQUFXMUwsRUFBQUEsS0FBSyxDQUFBO0FBQy9DLFFBQU15TCxLQUFlMUMsTUFBTTJDLFNBQUFBO0FBRzNCLE1BQUluVCxHQUFHNlQsYUFBa0NMO0FBQ3pDLE1BQUlDLGFBQWF6QixTQUFTdGYsUUFBUSxDQUFBO0FBRWxDLE9BQUtzTixJQUFJLEdBQUdBLElBQUltVCxXQUFXLEVBQUVuVCxHQUFHO0FBQzlCNlQsa0JBQWNMO0FBQ2RBLG1CQUFlQztBQUNmQSxpQkFBYXpCLFNBQVN0ZixRQUFRc04sSUFBSSxDQUFBO0FBQ2xDLFFBQUksQ0FBQ3dULGNBQWM7QUFDakI7O0FBR0YsUUFBSUMsWUFBWTtBQUNkLFlBQU1RLGFBQWFSLFdBQVczUixTQUFBQSxJQUFhMFIsYUFBYTFSLFNBQVU7QUFHbEVtUixhQUFPalQsQ0FBRSxJQUFHaVUsZUFBZSxLQUFLUixXQUFXRyxTQUFBQSxJQUFhSixhQUFhSSxTQUFBQSxLQUFjSyxhQUFhOztBQUVsR2YsT0FBR2xULENBQUUsSUFBRyxDQUFDNlQsY0FBY1osT0FBT2pULENBQUUsSUFDNUIsQ0FBQ3lULGFBQWFSLE9BQU9qVCxJQUFJLENBQUEsSUFDdEJrVSxLQUFLakIsT0FBT2pULElBQUksQ0FBQSxDQUFFLE1BQU1rVSxLQUFLakIsT0FBT2pULENBQUUsQ0FBQSxJQUFLLEtBQ3pDaVQsT0FBT2pULElBQUksQ0FBQSxJQUFLaVQsT0FBT2pULENBQUUsS0FBSTtFQUN4QztBQUVBZ1QsaUJBQWV0Z0IsUUFBUXVnQixRQUFRQyxFQUFBQTtBQUUvQlMsa0JBQWdCamhCLFFBQVF3Z0IsSUFBSXBSLFNBQUFBO0FBQzlCO0FBRUEsU0FBU3FTLGdCQUFnQkMsSUFBWTdnQixLQUFhQyxLQUFhO0FBQzdELFNBQU9JLEtBQUtKLElBQUlJLEtBQUtMLElBQUk2Z0IsSUFBSTVnQixHQUFNRCxHQUFBQSxHQUFBQTtBQUNyQztBQUVBLFNBQVM4Z0IsZ0JBQWdCM2hCLFFBQXVCbVYsTUFBaUI7QUFDL0QsTUFBSTdILEdBQUcwRSxNQUFNdFEsT0FBT2tnQixRQUFRQztBQUM1QixNQUFJQyxhQUFhNU0sZUFBZWxWLE9BQU8sQ0FBQSxHQUFJbVYsSUFBQUE7QUFDM0MsT0FBSzdILElBQUksR0FBRzBFLE9BQU9oUyxPQUFPRyxRQUFRbU4sSUFBSTBFLE1BQU0sRUFBRTFFLEdBQUc7QUFDL0N1VSxpQkFBYUQ7QUFDYkEsYUFBU0U7QUFDVEEsaUJBQWF4VSxJQUFJMEUsT0FBTyxLQUFLa0QsZUFBZWxWLE9BQU9zTixJQUFJLENBQUEsR0FBSTZILElBQUFBO0FBQzNELFFBQUksQ0FBQ3lNLFFBQVE7QUFDWDs7QUFFRmxnQixZQUFRMUIsT0FBT3NOLENBQUU7QUFDakIsUUFBSXVVLFlBQVk7QUFDZG5nQixZQUFNbVUsT0FBTzRMLGdCQUFnQi9mLE1BQU1tVSxNQUFNVixLQUFLelYsTUFBTXlWLEtBQUt4VixLQUFLO0FBQzlEK0IsWUFBTXFVLE9BQU8wTCxnQkFBZ0IvZixNQUFNcVUsTUFBTVosS0FBS25OLEtBQUttTixLQUFLbE4sTUFBTTs7QUFFaEUsUUFBSTZaLFlBQVk7QUFDZHBnQixZQUFNb1UsT0FBTzJMLGdCQUFnQi9mLE1BQU1vVSxNQUFNWCxLQUFLelYsTUFBTXlWLEtBQUt4VixLQUFLO0FBQzlEK0IsWUFBTXNVLE9BQU95TCxnQkFBZ0IvZixNQUFNc1UsTUFBTWIsS0FBS25OLEtBQUttTixLQUFLbE4sTUFBTTs7RUFFbEU7QUFDRjtBQUtPLFNBQVM4WiwyQkFDZC9oQixRQUNBVyxVQUNBd1UsTUFDQXRPLE1BQ0F1SSxXQUNBO0FBQ0EsTUFBSTlCLEdBQVcwRSxNQUFjdFEsT0FBb0JzZ0I7QUFHakQsTUFBSXJoQixTQUFRRixVQUFVO0FBQ3BCVCxhQUFTQSxPQUFPbWUsT0FBTyxDQUFDdUQsT0FBTyxDQUFDQSxHQUFHbkMsSUFBSTs7QUFHekMsTUFBSTVlLFNBQVFzaEIsMkJBQTJCLFlBQVk7QUFDakRYLHdCQUFvQnRoQixRQUFRb1AsU0FBQUE7U0FDdkI7QUFDTCxRQUFJOFMsT0FBT3JiLE9BQU83RyxPQUFPQSxPQUFPRyxTQUFTLENBQUUsSUFBR0gsT0FBTyxDQUFFO0FBQ3ZELFNBQUtzTixJQUFJLEdBQUcwRSxPQUFPaFMsT0FBT0csUUFBUW1OLElBQUkwRSxNQUFNLEVBQUUxRSxHQUFHO0FBQy9DNUwsY0FBUTFCLE9BQU9zTixDQUFFO0FBQ2pCMFUsc0JBQWdCdkMsWUFDZHlDLE1BQ0F4Z0IsT0FDQTFCLE9BQU9rQixLQUFLTCxJQUFJeU0sSUFBSSxHQUFHMEUsUUFBUW5MLE9BQU8sSUFBSSxFQUFBLElBQU1tTCxJQUFLLEdBQ3JEclIsU0FBUXdoQixPQUFPO0FBRWpCemdCLFlBQU1tVSxPQUFPbU0sY0FBY3hNLFNBQVNwQztBQUNwQzFSLFlBQU1xVSxPQUFPaU0sY0FBY3hNLFNBQVNuQztBQUNwQzNSLFlBQU1vVSxPQUFPa00sY0FBY2xDLEtBQUsxTTtBQUNoQzFSLFlBQU1zVSxPQUFPZ00sY0FBY2xDLEtBQUt6TTtBQUNoQzZPLGFBQU94Z0I7SUFDVDs7QUFHRixNQUFJZixTQUFRZ2hCLGlCQUFpQjtBQUMzQkEsb0JBQWdCM2hCLFFBQVFtVixJQUFBQTs7QUFFNUI7QUN0Tk8sU0FBU2lOLGtCQUEyQjtBQUN6QyxTQUFPLE9BQU9oa0IsV0FBVyxlQUFlLE9BQU9pa0IsYUFBYTtBQUM5RDtBQUtPLFNBQVNDLGVBQWVDLFNBQStDO0FBQzVFLE1BQUloRSxTQUFTZ0UsUUFBUUM7QUFDckIsTUFBSWpFLFVBQVVBLE9BQU8xWSxTQUFRLE1BQU8sdUJBQXVCO0FBQ3pEMFksYUFBVUEsT0FBc0JrRTs7QUFFbEMsU0FBT2xFO0FBQ1Q7QUFPQSxTQUFTbUUsY0FBY0MsWUFBNkJ6VixNQUFtQjBWLGdCQUF3QjtBQUM3RixNQUFJQztBQUNKLE1BQUksT0FBT0YsZUFBZSxVQUFVO0FBQ2xDRSxvQkFBZ0J0SixTQUFTb0osWUFBWSxFQUFBO0FBRXJDLFFBQUlBLFdBQVdHLFFBQVEsR0FBQSxNQUFTLElBQUk7QUFFbENELHNCQUFnQixnQkFBaUIsTUFBTzNWLEtBQUtzVixXQUFXSSxjQUFlOztTQUVwRTtBQUNMQyxvQkFBZ0JGOztBQUdsQixTQUFPRTtBQUNUO0FBRUEsSUFBTUUsbUJBQW1CLENBQUNDLFlBQ3hCQSxRQUFRQyxjQUFjQyxZQUFZSCxpQkFBaUJDLFNBQVMsSUFBSTtBQUUzRCxTQUFTRyxTQUFTQyxJQUFpQkMsVUFBMEI7QUFDbEUsU0FBT04saUJBQWlCSyxFQUFJRSxFQUFBQSxpQkFBaUJELFFBQUFBO0FBQy9DO0FBRUEsSUFBTUUsWUFBWTtFQUFDO0VBQU87RUFBUztFQUFVO0FBQU87QUFDcEQsU0FBU0MsbUJBQW1CQyxRQUE2QjdVLE9BQWU4VSxRQUE0QjtBQUNsRyxRQUFNQyxTQUFTLENBQUE7QUFDZkQsV0FBU0EsU0FBUyxNQUFNQSxTQUFTO0FBQ2pDLFdBQVNwVyxJQUFJLEdBQUdBLElBQUksR0FBR0EsS0FBSztBQUMxQixVQUFNc1csTUFBTUwsVUFBVWpXLENBQUU7QUFDeEJxVyxXQUFPQyxHQUFJLElBQUdDLFdBQVdKLE9BQU83VSxRQUFRLE1BQU1nVixNQUFNRixNQUFBQSxDQUFPLEtBQUs7RUFDbEU7QUFDQUMsU0FBT2pZLFFBQVFpWSxPQUFPamtCLE9BQU9pa0IsT0FBT2hrQjtBQUNwQ2drQixTQUFPelEsU0FBU3lRLE9BQU8zYixNQUFNMmIsT0FBTzFiO0FBQ3BDLFNBQU8wYjtBQUNUO0FBRUEsSUFBTUcsZUFBZSxDQUFDMVEsR0FBV0MsR0FBV3hDLFlBQ3pDdUMsSUFBSSxLQUFLQyxJQUFJLE9BQU8sQ0FBQ3hDLFVBQVUsQ0FBQyxPQUF3QmtUO0FBTzNELFNBQVNDLGtCQUNQQyxHQUNBblIsUUFLRTtBQUNGLFFBQU1vUixVQUFVLEVBQWtCQTtBQUNsQyxRQUFNQyxTQUFVRCxXQUFXQSxRQUFRL2pCLFNBQVMrakIsUUFBUSxDQUFFLElBQUdEO0FBQ3pELFFBQU0sRUFBQ0csU0FBU0MsUUFBQUEsSUFBV0Y7QUFDM0IsTUFBSUcsTUFBTTtBQUNWLE1BQUlsUixHQUFHQztBQUNQLE1BQUl5USxhQUFhTSxTQUFTQyxTQUFTSixFQUFFcFQsTUFBTSxHQUFHO0FBQzVDdUMsUUFBSWdSO0FBQ0ovUSxRQUFJZ1I7U0FDQztBQUNMLFVBQU12UCxPQUFPaEMsT0FBT3lSLHNCQUFxQjtBQUN6Q25SLFFBQUkrUSxPQUFPSyxVQUFVMVAsS0FBS3BWO0FBQzFCMlQsUUFBSThRLE9BQU9NLFVBQVUzUCxLQUFLOU07QUFDMUJzYyxVQUFNOztBQUVSLFNBQU87SUFBQ2xSO0lBQUdDO0lBQUdpUjtFQUFHO0FBQ25CO0FBU08sU0FBU0ksb0JBQ2RDLE9BQ0FwYixPQUMwQjtBQUMxQixNQUFJLFlBQVlvYixPQUFPO0FBQ3JCLFdBQU9BOztBQUdULFFBQU0sRUFBQzdSLFFBQVFKLHdCQUFBQSxJQUEyQm5KO0FBQzFDLFFBQU1xRixRQUFRbVUsaUJBQWlCalEsTUFBQUE7QUFDL0IsUUFBTThSLFlBQVloVyxNQUFNaVcsY0FBYztBQUN0QyxRQUFNQyxXQUFXdEIsbUJBQW1CNVUsT0FBTyxTQUFBO0FBQzNDLFFBQU1tVyxVQUFVdkIsbUJBQW1CNVUsT0FBTyxVQUFVLE9BQUE7QUFDcEQsUUFBTSxFQUFDd0UsR0FBR0MsR0FBR2lSLElBQUcsSUFBSU4sa0JBQWtCVyxPQUFPN1IsTUFBQUE7QUFDN0MsUUFBTVUsVUFBVXNSLFNBQVNwbEIsUUFBUTRrQixPQUFPUyxRQUFRcmxCO0FBQ2hELFFBQU0rVCxVQUFVcVIsU0FBUzljLE9BQU9zYyxPQUFPUyxRQUFRL2M7QUFFL0MsTUFBSSxFQUFDMEQsT0FBT3dILE9BQUFBLElBQVUzSjtBQUN0QixNQUFJcWIsV0FBVztBQUNibFosYUFBU29aLFNBQVNwWixRQUFRcVosUUFBUXJaO0FBQ2xDd0gsY0FBVTRSLFNBQVM1UixTQUFTNlIsUUFBUTdSOztBQUV0QyxTQUFPO0lBQ0xFLEdBQUdsUyxLQUFLMFIsT0FBT1EsSUFBSUksV0FBVzlILFFBQVFvSCxPQUFPcEgsUUFBUWdILHVCQUFBQTtJQUNyRFcsR0FBR25TLEtBQUswUixPQUFPUyxJQUFJSSxXQUFXUCxTQUFTSixPQUFPSSxTQUFTUix1QkFBQUE7RUFDekQ7QUFDRjtBQUVBLFNBQVNzUyxpQkFBaUJsUyxRQUEyQnBILE9BQWV3SCxRQUFnQztBQUNsRyxNQUFJMEUsVUFBa0JxTjtBQUV0QixNQUFJdlosVUFBVWpGLFVBQWF5TSxXQUFXek0sUUFBVztBQUMvQyxVQUFNeWUsWUFBWXBTLFVBQVV3UCxlQUFleFAsTUFBQUE7QUFDM0MsUUFBSSxDQUFDb1MsV0FBVztBQUNkeFosY0FBUW9ILE9BQU9xUztBQUNmalMsZUFBU0osT0FBT3NTO1dBQ1g7QUFDTCxZQUFNdFEsT0FBT29RLFVBQVVYLHNCQUFxQjtBQUM1QyxZQUFNYyxpQkFBaUJ0QyxpQkFBaUJtQyxTQUFBQTtBQUN4QyxZQUFNSSxrQkFBa0I5QixtQkFBbUI2QixnQkFBZ0IsVUFBVSxPQUFBO0FBQ3JFLFlBQU1FLG1CQUFtQi9CLG1CQUFtQjZCLGdCQUFnQixTQUFBO0FBQzVEM1osY0FBUW9KLEtBQUtwSixRQUFRNlosaUJBQWlCN1osUUFBUTRaLGdCQUFnQjVaO0FBQzlEd0gsZUFBUzRCLEtBQUs1QixTQUFTcVMsaUJBQWlCclMsU0FBU29TLGdCQUFnQnBTO0FBQ2pFMEUsaUJBQVc4SyxjQUFjMkMsZUFBZXpOLFVBQVVzTixXQUFXLGFBQUE7QUFDN0RELGtCQUFZdkMsY0FBYzJDLGVBQWVKLFdBQVdDLFdBQVcsY0FBQTs7O0FBR25FLFNBQU87SUFDTHhaO0lBQ0F3SDtJQUNBMEUsVUFBVUEsWUFBWTROO0lBQ3RCUCxXQUFXQSxhQUFhTztFQUMxQjtBQUNGO0FBRUEsSUFBTUMsU0FBUyxDQUFDN2QsTUFBYzFHLEtBQUswUixNQUFNaEwsSUFBSSxFQUFNLElBQUE7QUFHNUMsU0FBUzhkLGVBQ2Q1UyxRQUNBNlMsU0FDQUMsVUFDQUMsYUFDbUM7QUFDbkMsUUFBTWpYLFFBQVFtVSxpQkFBaUJqUSxNQUFBQTtBQUMvQixRQUFNZ1QsVUFBVXRDLG1CQUFtQjVVLE9BQU8sUUFBQTtBQUMxQyxRQUFNZ0osV0FBVzhLLGNBQWM5VCxNQUFNZ0osVUFBVTlFLFFBQVEsYUFBa0IwUyxLQUFBQTtBQUN6RSxRQUFNUCxZQUFZdkMsY0FBYzlULE1BQU1xVyxXQUFXblMsUUFBUSxjQUFtQjBTLEtBQUFBO0FBQzVFLFFBQU1PLGdCQUFnQmYsaUJBQWlCbFMsUUFBUTZTLFNBQVNDLFFBQUFBO0FBQ3hELE1BQUksRUFBQ2xhLE9BQU93SCxPQUFBQSxJQUFVNlM7QUFFdEIsTUFBSW5YLE1BQU1pVyxjQUFjLGVBQWU7QUFDckMsVUFBTUUsVUFBVXZCLG1CQUFtQjVVLE9BQU8sVUFBVSxPQUFBO0FBQ3BELFVBQU1rVyxXQUFXdEIsbUJBQW1CNVUsT0FBTyxTQUFBO0FBQzNDbEQsYUFBU29aLFNBQVNwWixRQUFRcVosUUFBUXJaO0FBQ2xDd0gsY0FBVTRSLFNBQVM1UixTQUFTNlIsUUFBUTdSOztBQUV0Q3hILFVBQVF4SyxLQUFLSixJQUFJLEdBQUc0SyxRQUFRb2EsUUFBUXBhLEtBQUs7QUFDekN3SCxXQUFTaFMsS0FBS0osSUFBSSxHQUFHK2tCLGNBQWNuYSxRQUFRbWEsY0FBYzNTLFNBQVM0UyxRQUFRNVMsTUFBTTtBQUNoRnhILFVBQVErWixPQUFPdmtCLEtBQUtMLElBQUk2SyxPQUFPa00sVUFBVW1PLGNBQWNuTyxRQUFRLENBQUE7QUFDL0QxRSxXQUFTdVMsT0FBT3ZrQixLQUFLTCxJQUFJcVMsUUFBUStSLFdBQVdjLGNBQWNkLFNBQVMsQ0FBQTtBQUNuRSxNQUFJdlosU0FBUyxDQUFDd0gsUUFBUTtBQUdwQkEsYUFBU3VTLE9BQU8vWixRQUFRLENBQUE7O0FBRzFCLFFBQU1zYSxpQkFBaUJMLFlBQVlsZixVQUFhbWYsYUFBYW5mO0FBRTdELE1BQUl1ZixrQkFBa0JILGVBQWVFLGNBQWM3UyxVQUFVQSxTQUFTNlMsY0FBYzdTLFFBQVE7QUFDMUZBLGFBQVM2UyxjQUFjN1M7QUFDdkJ4SCxZQUFRK1osT0FBT3ZrQixLQUFLK0ksTUFBTWlKLFNBQVMyUyxXQUFBQSxDQUFBQTs7QUFHckMsU0FBTztJQUFDbmE7SUFBT3dIO0VBQU07QUFDdkI7QUFRTyxTQUFTK1MsWUFDZDFjLE9BQ0EyYyxZQUNBQyxZQUNnQjtBQUNoQixRQUFNQyxhQUFhRixjQUFjO0FBQ2pDLFFBQU1HLGVBQWVubEIsS0FBSytJLE1BQU1WLE1BQU0ySixTQUFTa1QsVUFBQUE7QUFDL0MsUUFBTUUsY0FBY3BsQixLQUFLK0ksTUFBTVYsTUFBTW1DLFFBQVEwYSxVQUFBQTtBQUU1QzdjLFFBQXVCMkosU0FBU2hTLEtBQUsrSSxNQUFNVixNQUFNMkosTUFBTTtBQUN2RDNKLFFBQXVCbUMsUUFBUXhLLEtBQUsrSSxNQUFNVixNQUFNbUMsS0FBSztBQUV0RCxRQUFNb0gsU0FBU3ZKLE1BQU11SjtBQUtyQixNQUFJQSxPQUFPbEUsVUFBVXVYLGNBQWUsQ0FBQ3JULE9BQU9sRSxNQUFNc0UsVUFBVSxDQUFDSixPQUFPbEUsTUFBTWxELFFBQVM7QUFDakZvSCxXQUFPbEUsTUFBTXNFLFNBQVMsR0FBRzNKLE1BQU0ySixNQUFNO0FBQ3JDSixXQUFPbEUsTUFBTWxELFFBQVEsR0FBR25DLE1BQU1tQyxLQUFLOztBQUdyQyxNQUFJbkMsTUFBTW1KLDRCQUE0QjBULGNBQy9CdFQsT0FBT0ksV0FBV21ULGdCQUNsQnZULE9BQU9wSCxVQUFVNGEsYUFBYTtBQUNsQy9jLFVBQXVCbUosMEJBQTBCMFQ7QUFDbER0VCxXQUFPSSxTQUFTbVQ7QUFDaEJ2VCxXQUFPcEgsUUFBUTRhO0FBQ2YvYyxVQUFNMEYsSUFBSXNYLGFBQWFILFlBQVksR0FBRyxHQUFHQSxZQUFZLEdBQUcsQ0FBQTtBQUN4RCxXQUFPOztBQUVULFNBQU87QUFDVDtBQU9hSSxJQUFBQSwrQkFBZ0MsV0FBVztBQUN0RCxNQUFJQyxtQkFBbUI7QUFDdkIsTUFBSTtBQUNGLFVBQU05bEIsV0FBVTtNQUNkLElBQUkrbEIsVUFBVTtBQUNaRCwyQkFBbUI7QUFDbkIsZUFBTztNQUNUO0lBQ0Y7QUFFQSxRQUFJckUsZ0JBQW1CLEdBQUE7QUFDckJoa0IsYUFBT3VvQixpQkFBaUIsUUFBUSxNQUFNaG1CLFFBQUFBO0FBQ3RDdkMsYUFBT3dvQixvQkFBb0IsUUFBUSxNQUFNam1CLFFBQUFBOztFQUU3QyxTQUFTc2pCLEdBQUc7RUFFWjtBQUNBLFNBQU93QztBQUNULEVBQUs7QUFZRSxTQUFTSSxhQUNkN0QsU0FDQUssVUFDb0I7QUFDcEIsUUFBTTFkLFFBQVF3ZCxTQUFTSCxTQUFTSyxRQUFBQTtBQUNoQyxRQUFNN0ssVUFBVTdTLFNBQVNBLE1BQU04UyxNQUFNLG1CQUFBO0FBQ3JDLFNBQU9ELFVBQVUsQ0FBQ0EsUUFBUSxDQUFBLElBQUsvUjtBQUNqQztBQ3RSTyxTQUFTcWdCLGFBQWFDLElBQVdDLElBQVdwa0IsR0FBVzBNLE1BQU87QUFDbkUsU0FBTztJQUNMOEQsR0FBRzJULEdBQUczVCxJQUFJeFEsS0FBS29rQixHQUFHNVQsSUFBSTJULEdBQUczVDtJQUN6QkMsR0FBRzBULEdBQUcxVCxJQUFJelEsS0FBS29rQixHQUFHM1QsSUFBSTBULEdBQUcxVDtFQUMzQjtBQUNGO0FBS08sU0FBUzRULHNCQUNkRixJQUNBQyxJQUNBcGtCLEdBQVcwTSxNQUNYO0FBQ0EsU0FBTztJQUNMOEQsR0FBRzJULEdBQUczVCxJQUFJeFEsS0FBS29rQixHQUFHNVQsSUFBSTJULEdBQUczVDtJQUN6QkMsR0FBRy9ELFNBQVMsV0FBVzFNLElBQUksTUFBTW1rQixHQUFHMVQsSUFBSTJULEdBQUczVCxJQUN2Qy9ELFNBQVMsVUFBVTFNLElBQUksSUFBSW1rQixHQUFHMVQsSUFBSTJULEdBQUczVCxJQUNuQ3pRLElBQUksSUFBSW9rQixHQUFHM1QsSUFBSTBULEdBQUcxVDtFQUMxQjtBQUNGO0FBS08sU0FBUzZULHFCQUFxQkgsSUFBaUJDLElBQWlCcGtCLEdBQVcwTSxNQUFPO0FBQ3ZGLFFBQU02WCxNQUFNO0lBQUMvVCxHQUFHMlQsR0FBR2pSO0lBQU16QyxHQUFHMFQsR0FBRy9RO0VBQUk7QUFDbkMsUUFBTW9SLE1BQU07SUFBQ2hVLEdBQUc0VCxHQUFHblI7SUFBTXhDLEdBQUcyVCxHQUFHalI7RUFBSTtBQUNuQyxRQUFNc1IsSUFBSVAsYUFBYUMsSUFBSUksS0FBS3ZrQixDQUFBQTtBQUNoQyxRQUFNMGtCLElBQUlSLGFBQWFLLEtBQUtDLEtBQUt4a0IsQ0FBQUE7QUFDakMsUUFBTTJrQixJQUFJVCxhQUFhTSxLQUFLSixJQUFJcGtCLENBQUFBO0FBQ2hDLFFBQU00QyxJQUFJc2hCLGFBQWFPLEdBQUdDLEdBQUcxa0IsQ0FBQUE7QUFDN0IsUUFBTXFoQixJQUFJNkMsYUFBYVEsR0FBR0MsR0FBRzNrQixDQUFBQTtBQUM3QixTQUFPa2tCLGFBQWF0aEIsR0FBR3llLEdBQUdyaEIsQ0FBQUE7QUFDNUI7QUNoQ0EsSUFBTTRrQix3QkFBd0IsU0FBU0MsT0FBZS9iLE9BQTJCO0FBQy9FLFNBQU87SUFDTDBILEVBQUVBLEdBQUc7QUFDSCxhQUFPcVUsUUFBUUEsUUFBUS9iLFFBQVEwSDtJQUNqQztJQUNBc1UsU0FBU25VLEdBQUc7QUFDVjdILGNBQVE2SDtJQUNWO0lBQ0E4QyxVQUFVaFgsT0FBTztBQUNmLFVBQUlBLFVBQVUsVUFBVTtBQUN0QixlQUFPQTs7QUFFVCxhQUFPQSxVQUFVLFVBQVUsU0FBUztJQUN0QztJQUNBc29CLE1BQU12VSxHQUFHek4sT0FBTztBQUNkLGFBQU95TixJQUFJek47SUFDYjtJQUNBaWlCLFdBQVd4VSxHQUFHeVUsV0FBVztBQUN2QixhQUFPelUsSUFBSXlVO0lBQ2I7RUFDRjtBQUNGO0FBRUEsSUFBTUMsd0JBQXdCLFdBQXVCO0FBQ25ELFNBQU87SUFDTDFVLEVBQUVBLEdBQUc7QUFDSCxhQUFPQTtJQUNUO0lBQ0FzVSxTQUFTblUsR0FBRztJQUFBO0lBRVo4QyxVQUFVaFgsT0FBTztBQUNmLGFBQU9BO0lBQ1Q7SUFDQXNvQixNQUFNdlUsR0FBR3pOLE9BQU87QUFDZCxhQUFPeU4sSUFBSXpOO0lBQ2I7SUFDQWlpQixXQUFXeFUsR0FBRzJVLFlBQVk7QUFDeEIsYUFBTzNVO0lBQ1Q7RUFDRjtBQUNGO0FBRU8sU0FBUzRVLGNBQWNwb0IsS0FBYzZuQixPQUFlL2IsT0FBZTtBQUN4RSxTQUFPOUwsTUFBTTRuQixzQkFBc0JDLE9BQU8vYixLQUFBQSxJQUFTb2Msc0JBQXVCO0FBQzVFO0FBRU8sU0FBU0csc0JBQXNCaFosS0FBK0JpWixXQUEwQjtBQUM3RixNQUFJdFosT0FBNEJ1WjtBQUNoQyxNQUFJRCxjQUFjLFNBQVNBLGNBQWMsT0FBTztBQUM5Q3RaLFlBQVFLLElBQUk2RCxPQUFPbEU7QUFDbkJ1WixlQUFXO01BQ1R2WixNQUFNMFUsaUJBQWlCLFdBQUE7TUFDdkIxVSxNQUFNd1osb0JBQW9CLFdBQUE7SUFDM0I7QUFFRHhaLFVBQU15WixZQUFZLGFBQWFILFdBQVcsV0FBQTtBQUN6Q2paLFFBQWlEcVosb0JBQW9CSDs7QUFFMUU7QUFFTyxTQUFTSSxxQkFBcUJ0WixLQUErQmtaLFVBQTZCO0FBQy9GLE1BQUlBLGFBQWExaEIsUUFBVztBQUMxQixXQUFRd0ksSUFBaURxWjtBQUN6RHJaLFFBQUk2RCxPQUFPbEUsTUFBTXlaLFlBQVksYUFBYUYsU0FBUyxDQUFBLEdBQUlBLFNBQVMsQ0FBRSxDQUFBOztBQUV0RTtBQy9EQSxTQUFTSyxXQUFXbkYsVUFBVTtBQUM1QixNQUFJQSxhQUFhLFNBQVM7QUFDeEIsV0FBTztNQUNMb0YsU0FBU0M7TUFDVEMsU0FBU0M7TUFDVEMsV0FBV0M7SUFDYjs7QUFFRixTQUFPO0lBQ0xMLFNBQVNNO0lBQ1RKLFNBQVMsQ0FBQ3RCLEdBQUdDLE1BQU1ELElBQUlDO0lBQ3ZCdUIsV0FBV3pWLENBQUFBLE1BQUtBO0VBQ2xCO0FBQ0Y7QUFFQSxTQUFTNFYsaUJBQWlCLEVBQUN6cEIsT0FBT0MsS0FBS1ksT0FBT3lHLE1BQU0rSCxNQUFLLEdBQUc7QUFDMUQsU0FBTztJQUNMclAsT0FBT0EsUUFBUWE7SUFDZlosS0FBS0EsTUFBTVk7SUFDWHlHLE1BQU1BLFNBQVNySCxNQUFNRCxRQUFRLEtBQUthLFVBQVU7SUFDNUN3TztFQUNGO0FBQ0Y7QUFFQSxTQUFTcWEsV0FBV0MsU0FBU2xwQixRQUFRNEssUUFBUTtBQUMzQyxRQUFNLEVBQUN5WSxVQUFVOWpCLE9BQU80cEIsWUFBWTNwQixLQUFLNHBCLFNBQVEsSUFBSXhlO0FBQ3JELFFBQU0sRUFBQzZkLFNBQVNJLFVBQVMsSUFBSUwsV0FBV25GLFFBQUFBO0FBQ3hDLFFBQU1qakIsUUFBUUosT0FBT0c7QUFFckIsTUFBSSxFQUFDWixPQUFPQyxLQUFLcUgsS0FBQUEsSUFBUXFpQjtBQUN6QixNQUFJNWIsR0FBRzBFO0FBRVAsTUFBSW5MLE1BQU07QUFDUnRILGFBQVNhO0FBQ1RaLFdBQU9ZO0FBQ1AsU0FBS2tOLElBQUksR0FBRzBFLE9BQU81UixPQUFPa04sSUFBSTBFLE1BQU0sRUFBRTFFLEdBQUc7QUFDdkMsVUFBSSxDQUFDbWIsUUFBUUksVUFBVTdvQixPQUFPVCxRQUFRYSxLQUFBQSxFQUFPaWpCLFFBQUFBLENBQVMsR0FBRzhGLFlBQVlDLFFBQVcsR0FBQTtBQUM5RTs7QUFFRjdwQjtBQUNBQztJQUNGO0FBQ0FELGFBQVNhO0FBQ1RaLFdBQU9ZOztBQUdULE1BQUlaLE1BQU1ELE9BQU87QUFDZkMsV0FBT1k7O0FBRVQsU0FBTztJQUFDYjtJQUFPQztJQUFLcUg7SUFBTStILE9BQU9zYSxRQUFRdGE7RUFBSztBQUNoRDtBQWdCTyxTQUFTeWEsY0FBY0gsU0FBU2xwQixRQUFRNEssUUFBUTtBQUNyRCxNQUFJLENBQUNBLFFBQVE7QUFDWCxXQUFPO01BQUNzZTtJQUFROztBQUdsQixRQUFNLEVBQUM3RixVQUFVOWpCLE9BQU80cEIsWUFBWTNwQixLQUFLNHBCLFNBQVEsSUFBSXhlO0FBQ3JELFFBQU14SyxRQUFRSixPQUFPRztBQUNyQixRQUFNLEVBQUN3b0IsU0FBU0YsU0FBU0ksVUFBUyxJQUFJTCxXQUFXbkYsUUFBQUE7QUFDakQsUUFBTSxFQUFDOWpCLE9BQU9DLEtBQUtxSCxNQUFNK0gsTUFBQUEsSUFBU3FhLFdBQVdDLFNBQVNscEIsUUFBUTRLLE1BQUFBO0FBRTlELFFBQU0rWSxTQUFTLENBQUE7QUFDZixNQUFJMkYsU0FBUztBQUNiLE1BQUlDLFdBQVc7QUFDZixNQUFJNWpCLE9BQU9qRSxPQUFPOG5CO0FBRWxCLFFBQU1DLGdCQUFnQixNQUFNaEIsUUFBUVUsWUFBWUssV0FBVzdqQixLQUFVZ2pCLEtBQUFBLFFBQVFRLFlBQVlLLFNBQWUsTUFBQTtBQUN4RyxRQUFNRSxjQUFjLE1BQU1mLFFBQVFTLFVBQVV6akIsS0FBQUEsTUFBVyxLQUFLOGlCLFFBQVFXLFVBQVVJLFdBQVc3akIsS0FBQUE7QUFDekYsUUFBTWdrQixjQUFjLE1BQU1MLFVBQVVHLGNBQUFBO0FBQ3BDLFFBQU1HLGFBQWEsTUFBTSxDQUFDTixVQUFVSSxZQUFBQTtBQUVwQyxXQUFTcGMsSUFBSS9OLE9BQU8yaUIsT0FBTzNpQixPQUFPK04sS0FBSzlOLEtBQUssRUFBRThOLEdBQUc7QUFDL0M1TCxZQUFRMUIsT0FBT3NOLElBQUlsTixLQUFNO0FBRXpCLFFBQUlzQixNQUFNNmQsTUFBTTtBQUNkOztBQUdGNVosWUFBUWtqQixVQUFVbm5CLE1BQU0yaEIsUUFBUyxDQUFBO0FBRWpDLFFBQUkxZCxVQUFVNmpCLFdBQVc7QUFDdkI7O0FBR0ZGLGFBQVNiLFFBQVE5aUIsT0FBT3dqQixZQUFZQyxRQUFBQTtBQUVwQyxRQUFJRyxhQUFhLFFBQVFJLFlBQWUsR0FBQTtBQUN0Q0osaUJBQVdaLFFBQVFoakIsT0FBT3dqQixVQUFnQixNQUFBLElBQUk3YixJQUFJNFU7O0FBR3BELFFBQUlxSCxhQUFhLFFBQVFLLFdBQWMsR0FBQTtBQUNyQ2pHLGFBQU9qUyxLQUFLc1gsaUJBQWlCO1FBQUN6cEIsT0FBT2dxQjtRQUFVL3BCLEtBQUs4TjtRQUFHekc7UUFBTXpHO1FBQU93TztNQUFLLENBQUEsQ0FBQTtBQUN6RTJhLGlCQUFXOztBQUVickgsV0FBTzVVO0FBQ1BrYyxnQkFBWTdqQjtFQUNkO0FBRUEsTUFBSTRqQixhQUFhLE1BQU07QUFDckI1RixXQUFPalMsS0FBS3NYLGlCQUFpQjtNQUFDenBCLE9BQU9ncUI7TUFBVS9wQjtNQUFLcUg7TUFBTXpHO01BQU93TztJQUFLLENBQUEsQ0FBQTs7QUFHeEUsU0FBTytVO0FBQ1Q7QUFZTyxTQUFTa0csZUFBZXJULE1BQU01TCxRQUFRO0FBQzNDLFFBQU0rWSxTQUFTLENBQUE7QUFDZixRQUFNbUcsV0FBV3RULEtBQUtzVDtBQUV0QixXQUFTeGMsSUFBSSxHQUFHQSxJQUFJd2MsU0FBUzNwQixRQUFRbU4sS0FBSztBQUN4QyxVQUFNeWMsTUFBTVYsY0FBY1MsU0FBU3hjLENBQUFBLEdBQUlrSixLQUFLeFcsUUFBUTRLLE1BQUFBO0FBQ3BELFFBQUltZixJQUFJNXBCLFFBQVE7QUFDZHdqQixhQUFPalMsS0FBUXFZLEdBQUFBLEdBQUFBOztFQUVuQjtBQUNBLFNBQU9wRztBQUNUO0FBS0EsU0FBU3FHLGdCQUFnQmhxQixRQUFRSSxPQUFPeUcsTUFBTXBHLFVBQVU7QUFDdEQsTUFBSWxCLFFBQVE7QUFDWixNQUFJQyxNQUFNWSxRQUFRO0FBRWxCLE1BQUl5RyxRQUFRLENBQUNwRyxVQUFVO0FBRXJCLFdBQU9sQixRQUFRYSxTQUFTLENBQUNKLE9BQU9ULEtBQU0sRUFBQ2dnQixNQUFNO0FBQzNDaGdCO0lBQ0Y7O0FBSUYsU0FBT0EsUUFBUWEsU0FBU0osT0FBT1QsS0FBTSxFQUFDZ2dCLE1BQU07QUFDMUNoZ0I7RUFDRjtBQUdBQSxXQUFTYTtBQUVULE1BQUl5RyxNQUFNO0FBRVJySCxXQUFPRDs7QUFHVCxTQUFPQyxNQUFNRCxTQUFTUyxPQUFPUixNQUFNWSxLQUFNLEVBQUNtZixNQUFNO0FBQzlDL2Y7RUFDRjtBQUdBQSxTQUFPWTtBQUVQLFNBQU87SUFBQ2I7SUFBT0M7RUFBRztBQUNwQjtBQVNBLFNBQVN5cUIsY0FBY2pxQixRQUFRVCxPQUFPdUIsS0FBSytGLE1BQU07QUFDL0MsUUFBTXpHLFFBQVFKLE9BQU9HO0FBQ3JCLFFBQU13akIsU0FBUyxDQUFBO0FBQ2YsTUFBSXVHLE9BQU8zcUI7QUFDWCxNQUFJMmlCLE9BQU9saUIsT0FBT1QsS0FBTTtBQUN4QixNQUFJQztBQUVKLE9BQUtBLE1BQU1ELFFBQVEsR0FBR0MsT0FBT3NCLEtBQUssRUFBRXRCLEtBQUs7QUFDdkMsVUFBTTJxQixNQUFNbnFCLE9BQU9SLE1BQU1ZLEtBQU07QUFDL0IsUUFBSStwQixJQUFJNUssUUFBUTRLLElBQUlDLE1BQU07QUFDeEIsVUFBSSxDQUFDbEksS0FBSzNDLE1BQU07QUFDZDFZLGVBQU87QUFDUDhjLGVBQU9qUyxLQUFLO1VBQUNuUyxPQUFPQSxRQUFRYTtVQUFPWixNQUFNQSxNQUFNLEtBQUtZO1VBQU95RztRQUFJLENBQUE7QUFFL0R0SCxnQkFBUTJxQixPQUFPQyxJQUFJQyxPQUFPNXFCLE1BQU07O1dBRTdCO0FBQ0wwcUIsYUFBTzFxQjtBQUNQLFVBQUkwaUIsS0FBSzNDLE1BQU07QUFDYmhnQixnQkFBUUM7OztBQUdaMGlCLFdBQU9pSTtFQUNUO0FBRUEsTUFBSUQsU0FBUyxNQUFNO0FBQ2pCdkcsV0FBT2pTLEtBQUs7TUFBQ25TLE9BQU9BLFFBQVFhO01BQU9aLEtBQUswcUIsT0FBTzlwQjtNQUFPeUc7SUFBSSxDQUFBOztBQUc1RCxTQUFPOGM7QUFDVDtBQVVPLFNBQVMwRyxpQkFBaUI3VCxNQUFNOFQsZ0JBQWdCO0FBQ3JELFFBQU10cUIsU0FBU3dXLEtBQUt4VztBQUNwQixRQUFNUyxXQUFXK1YsS0FBSzdWLFFBQVFGO0FBQzlCLFFBQU1MLFFBQVFKLE9BQU9HO0FBRXJCLE1BQUksQ0FBQ0MsT0FBTztBQUNWLFdBQU8sQ0FBQTs7QUFHVCxRQUFNeUcsT0FBTyxDQUFDLENBQUMyUCxLQUFLK1Q7QUFDcEIsUUFBTSxFQUFDaHJCLE9BQU9DLElBQUFBLElBQU93cUIsZ0JBQWdCaHFCLFFBQVFJLE9BQU95RyxNQUFNcEcsUUFBQUE7QUFFMUQsTUFBSUEsYUFBYSxNQUFNO0FBQ3JCLFdBQU8rcEIsY0FBY2hVLE1BQU07TUFBQztRQUFDalg7UUFBT0M7UUFBS3FIO01BQUk7SUFBRSxHQUFFN0csUUFBUXNxQixjQUFBQTs7QUFHM0QsUUFBTXhwQixNQUFNdEIsTUFBTUQsUUFBUUMsTUFBTVksUUFBUVo7QUFDeEMsUUFBTWlyQixlQUFlLENBQUMsQ0FBQ2pVLEtBQUtrVSxhQUFhbnJCLFVBQVUsS0FBS0MsUUFBUVksUUFBUTtBQUN4RSxTQUFPb3FCLGNBQWNoVSxNQUFNeVQsY0FBY2pxQixRQUFRVCxPQUFPdUIsS0FBSzJwQixZQUFBQSxHQUFlenFCLFFBQVFzcUIsY0FBQUE7QUFDdEY7QUFRQSxTQUFTRSxjQUFjaFUsTUFBTXNULFVBQVU5cEIsUUFBUXNxQixnQkFBZ0I7QUFDN0QsTUFBSSxDQUFDQSxrQkFBa0IsQ0FBQ0EsZUFBZTdOLGNBQWMsQ0FBQ3pjLFFBQVE7QUFDNUQsV0FBTzhwQjs7QUFFVCxTQUFPYSxnQkFBZ0JuVSxNQUFNc1QsVUFBVTlwQixRQUFRc3FCLGNBQUFBO0FBQ2pEO0FBU0EsU0FBU0ssZ0JBQWdCblUsTUFBTXNULFVBQVU5cEIsUUFBUXNxQixnQkFBZ0I7QUFDL0QsUUFBTU0sZUFBZXBVLEtBQUtxVSxPQUFPOVgsV0FBVTtBQUMzQyxRQUFNK1gsWUFBWUMsVUFBVXZVLEtBQUs3VixPQUFPO0FBQ3hDLFFBQU0sRUFBQ3FxQixlQUFlQyxjQUFjdHFCLFNBQVMsRUFBQ0YsU0FBUSxFQUFDLElBQUkrVjtBQUMzRCxRQUFNcFcsUUFBUUosT0FBT0c7QUFDckIsUUFBTXdqQixTQUFTLENBQUE7QUFDZixNQUFJdUgsWUFBWUo7QUFDaEIsTUFBSXZyQixRQUFRdXFCLFNBQVMsQ0FBQSxFQUFHdnFCO0FBQ3hCLE1BQUkrTixJQUFJL047QUFFUixXQUFTNHJCLFNBQVNyb0IsR0FBR21oQixHQUFHbUgsR0FBR0MsSUFBSTtBQUM3QixVQUFNQyxNQUFNN3FCLFdBQVcsS0FBSztBQUM1QixRQUFJcUMsTUFBTW1oQixHQUFHO0FBQ1g7O0FBR0ZuaEIsU0FBSzFDO0FBQ0wsV0FBT0osT0FBTzhDLElBQUkxQyxLQUFNLEVBQUNtZixNQUFNO0FBQzdCemMsV0FBS3dvQjtJQUNQO0FBQ0EsV0FBT3RyQixPQUFPaWtCLElBQUk3akIsS0FBTSxFQUFDbWYsTUFBTTtBQUM3QjBFLFdBQUtxSDtJQUNQO0FBQ0EsUUFBSXhvQixJQUFJMUMsVUFBVTZqQixJQUFJN2pCLE9BQU87QUFDM0J1akIsYUFBT2pTLEtBQUs7UUFBQ25TLE9BQU91RCxJQUFJMUM7UUFBT1osS0FBS3lrQixJQUFJN2pCO1FBQU95RyxNQUFNdWtCO1FBQUd4YyxPQUFPeWM7TUFBRSxDQUFBO0FBQ2pFSCxrQkFBWUc7QUFDWjlyQixjQUFRMGtCLElBQUk3akI7O0VBRWhCO0FBRUEsYUFBVzhvQixXQUFXWSxVQUFVO0FBQzlCdnFCLFlBQVFrQixXQUFXbEIsUUFBUTJwQixRQUFRM3BCO0FBQ25DLFFBQUkyaUIsT0FBT2xpQixPQUFPVCxRQUFRYSxLQUFNO0FBQ2hDLFFBQUl3TztBQUNKLFNBQUt0QixJQUFJL04sUUFBUSxHQUFHK04sS0FBSzRiLFFBQVExcEIsS0FBSzhOLEtBQUs7QUFDekMsWUFBTW9VLEtBQUsxaEIsT0FBT3NOLElBQUlsTixLQUFNO0FBQzVCd08sY0FBUW1jLFVBQVVULGVBQWU3TixXQUFXckMsY0FBY3dRLGNBQWM7UUFDdEVobEIsTUFBTTtRQUNOMmxCLElBQUlySjtRQUNKNkUsSUFBSXJGO1FBQ0o4SixjQUFjbGUsSUFBSSxLQUFLbE47UUFDdkJxckIsYUFBYW5lLElBQUlsTjtRQUNqQjZxQjtNQUNGLENBQUEsQ0FBQSxDQUFBO0FBQ0EsVUFBSVMsYUFBYTljLE9BQU9zYyxTQUFZLEdBQUE7QUFDbENDLGlCQUFTNXJCLE9BQU8rTixJQUFJLEdBQUc0YixRQUFRcmlCLE1BQU1xa0IsU0FBQUE7O0FBRXZDaEosYUFBT1I7QUFDUHdKLGtCQUFZdGM7SUFDZDtBQUNBLFFBQUlyUCxRQUFRK04sSUFBSSxHQUFHO0FBQ2pCNmQsZUFBUzVyQixPQUFPK04sSUFBSSxHQUFHNGIsUUFBUXJpQixNQUFNcWtCLFNBQUFBOztFQUV6QztBQUVBLFNBQU92SDtBQUNUO0FBRUEsU0FBU29ILFVBQVVwcUIsVUFBUztBQUMxQixTQUFPO0lBQ0xxTixpQkFBaUJyTixTQUFRcU47SUFDekIyZCxnQkFBZ0JockIsU0FBUWdyQjtJQUN4QkMsWUFBWWpyQixTQUFRaXJCO0lBQ3BCQyxrQkFBa0JsckIsU0FBUWtyQjtJQUMxQkMsaUJBQWlCbnJCLFNBQVFtckI7SUFDekI5VyxhQUFhclUsU0FBUXFVO0lBQ3JCL0csYUFBYXROLFNBQVFzTjtFQUN2QjtBQUNGO0FBRUEsU0FBU3lkLGFBQWE5YyxPQUFPc2MsV0FBVztBQUN0QyxNQUFJLENBQUNBLFdBQVc7QUFDZCxXQUFPOztBQUVULFFBQU1yWixRQUFRLENBQUE7QUFDZCxRQUFNa2EsV0FBVyxTQUFTNWUsS0FBS3hILE9BQU87QUFDcEMsUUFBSSxDQUFDRCxvQkFBb0JDLEtBQVEsR0FBQTtBQUMvQixhQUFPQTs7QUFFVCxRQUFJLENBQUNrTSxNQUFNdEgsU0FBUzVFLEtBQVEsR0FBQTtBQUMxQmtNLFlBQU1ILEtBQUsvTCxLQUFBQTs7QUFFYixXQUFPa00sTUFBTWlSLFFBQVFuZCxLQUFBQTtFQUN2QjtBQUNBLFNBQU80QyxLQUFLQyxVQUFVb0csT0FBT21kLFFBQUFBLE1BQWN4akIsS0FBS0MsVUFBVTBpQixXQUFXYSxRQUFBQTtBQUN2RTtBQ3pXQSxTQUFTQyxlQUFlamMsT0FBY2tjLFdBQXNCQyxPQUF3QjtBQUNsRixTQUFPbmMsTUFBTXBQLFFBQVFrSyxPQUFPa0YsTUFBTW1jLEtBQU0sSUFBR0QsVUFBVUMsS0FBTTtBQUM3RDtBQUVBLFNBQVNDLGVBQWVwc0IsTUFBaUJrc0IsV0FBNEI7QUFDbkUsUUFBTSxFQUFDanFCLFFBQVFDLE9BQUFBLElBQVVsQztBQUN6QixNQUFJaUMsVUFBVUMsUUFBUTtBQUNwQixXQUFPO01BQ0x2QyxNQUFNc3NCLGVBQWVocUIsUUFBUWlxQixXQUFXLE1BQUE7TUFDeEN0c0IsT0FBT3FzQixlQUFlaHFCLFFBQVFpcUIsV0FBVyxPQUFBO01BQ3pDamtCLEtBQUtna0IsZUFBZS9wQixRQUFRZ3FCLFdBQVcsS0FBQTtNQUN2Q2hrQixRQUFRK2pCLGVBQWUvcEIsUUFBUWdxQixXQUFXLFFBQUE7SUFDNUM7O0FBRUYsU0FBT0E7QUFDVDtBQUVPLFNBQVNHLG1CQUFtQjdpQixPQUFjeEosTUFBK0I7QUFDOUUsUUFBTThLLE9BQU85SyxLQUFLc3NCO0FBQ2xCLE1BQUl4aEIsS0FBS3loQixVQUFVO0FBQ2pCLFdBQU87O0FBRVQsUUFBTW5YLE9BQU9nWCxlQUFlcHNCLE1BQU13SixNQUFNMGlCLFNBQVM7QUFFakQsU0FBTztJQUNMdnNCLE1BQU1tTCxLQUFLbkwsU0FBUyxRQUFRLElBQUl5VixLQUFLelYsUUFBUW1MLEtBQUtuTCxTQUFTLE9BQU8sSUFBSW1MLEtBQUtuTDtJQUMzRUMsT0FBT2tMLEtBQUtsTCxVQUFVLFFBQVE0SixNQUFNbUMsUUFBUXlKLEtBQUt4VixTQUFTa0wsS0FBS2xMLFVBQVUsT0FBTyxJQUFJa0wsS0FBS2xMO0lBQ3pGcUksS0FBSzZDLEtBQUs3QyxRQUFRLFFBQVEsSUFBSW1OLEtBQUtuTixPQUFPNkMsS0FBSzdDLFFBQVEsT0FBTyxJQUFJNkMsS0FBSzdDO0lBQ3ZFQyxRQUFRNEMsS0FBSzVDLFdBQVcsUUFBUXNCLE1BQU0ySixTQUFTaUMsS0FBS2xOLFVBQVU0QyxLQUFLNUMsV0FBVyxPQUFPLElBQUk0QyxLQUFLNUM7RUFDaEc7QUFDRjs7O0FDckJPLElBQU1za0IsV0FBTixNQUFNQTtFQUNYQyxjQUFjO0FBQ1osU0FBS0MsV0FBVztBQUNoQixTQUFLQyxVQUFVLG9CQUFJQyxJQUFBQTtBQUNuQixTQUFLQyxXQUFXO0FBQ2hCLFNBQUtDLFlBQVlDO0VBQ25CO0VBS0FDLFFBQVFDLE9BQU9DLE9BQU9DLE1BQU1DLE1BQU07QUFDaEMsVUFBTUMsWUFBWUgsTUFBTUksVUFBVUYsSUFBSztBQUN2QyxVQUFNRyxXQUFXTCxNQUFNTTtBQUV2QkgsY0FBVUksUUFBUUMsQ0FBQUEsT0FBTUEsR0FBRztNQUN6QlQ7TUFDQVUsU0FBU1QsTUFBTVM7TUFDZko7TUFDQUssYUFBYUMsS0FBS0MsSUFBSVgsT0FBT0QsTUFBTWEsT0FBT1IsUUFBQUE7SUFDNUMsQ0FBQSxDQUFBO0VBQ0Y7RUFLQVMsV0FBVztBQUNULFFBQUksS0FBS3RCLFVBQVU7QUFDakI7O0FBRUYsU0FBS0csV0FBVztBQUVoQixTQUFLSCxXQUFXdUIsaUJBQWlCQyxLQUFLQyxRQUFRLE1BQU07QUFDbEQsV0FBS0MsUUFBTztBQUNaLFdBQUsxQixXQUFXO0FBRWhCLFVBQUksS0FBS0csVUFBVTtBQUNqQixhQUFLbUIsU0FBUTs7SUFFakIsQ0FBQTtFQUNGO0VBS0FJLFFBQVFqQixPQUFPa0IsS0FBS0MsSUFBRyxHQUFJO0FBQ3pCLFFBQUlDLFlBQVk7QUFFaEIsU0FBSzVCLFFBQVFjLFFBQVEsQ0FBQ1AsT0FBT0QsVUFBVTtBQUNyQyxVQUFJLENBQUNDLE1BQU1zQixXQUFXLENBQUN0QixNQUFNdUIsTUFBTUMsUUFBUTtBQUN6Qzs7QUFFRixZQUFNRCxRQUFRdkIsTUFBTXVCO0FBQ3BCLFVBQUlFLElBQUlGLE1BQU1DLFNBQVM7QUFDdkIsVUFBSUUsUUFBTztBQUNYLFVBQUlDO0FBRUosYUFBT0YsS0FBSyxHQUFHLEVBQUVBLEdBQUc7QUFDbEJFLGVBQU9KLE1BQU1FLENBQUU7QUFFZixZQUFJRSxLQUFLQyxTQUFTO0FBQ2hCLGNBQUlELEtBQUtFLFNBQVM3QixNQUFNTSxVQUFVO0FBR2hDTixrQkFBTU0sV0FBV3FCLEtBQUtFOztBQUV4QkYsZUFBS0csS0FBSzdCLElBQUFBO0FBQ1Z5QixVQUFBQSxRQUFPO2VBQ0Y7QUFHTEgsZ0JBQU1FLENBQUFBLElBQUtGLE1BQU1BLE1BQU1DLFNBQVMsQ0FBRTtBQUNsQ0QsZ0JBQU1RLElBQUc7O01BRWI7QUFFQSxVQUFJTCxPQUFNO0FBQ1IzQixjQUFNMkIsS0FBSTtBQUNWLGFBQUs1QixRQUFRQyxPQUFPQyxPQUFPQyxNQUFNLFVBQUE7O0FBR25DLFVBQUksQ0FBQ3NCLE1BQU1DLFFBQVE7QUFDakJ4QixjQUFNc0IsVUFBVTtBQUNoQixhQUFLeEIsUUFBUUMsT0FBT0MsT0FBT0MsTUFBTSxVQUFBO0FBQ2pDRCxjQUFNUyxVQUFVOztBQUdsQlksbUJBQWFFLE1BQU1DO0lBQ3JCLENBQUE7QUFFQSxTQUFLNUIsWUFBWUs7QUFFakIsUUFBSW9CLGNBQWMsR0FBRztBQUNuQixXQUFLMUIsV0FBVzs7RUFFcEI7RUFLQXFDLFVBQVVqQyxPQUFPO0FBQ2YsVUFBTWtDLFNBQVMsS0FBS3hDO0FBQ3BCLFFBQUlPLFFBQVFpQyxPQUFPQyxJQUFJbkMsS0FBQUE7QUFDdkIsUUFBSSxDQUFDQyxPQUFPO0FBQ1ZBLGNBQVE7UUFDTnNCLFNBQVM7UUFDVGIsU0FBUztRQUNUYyxPQUFPLENBQUE7UUFDUG5CLFdBQVc7VUFDVCtCLFVBQVUsQ0FBQTtVQUNWQyxVQUFVLENBQUE7UUFDWjtNQUNGO0FBQ0FILGFBQU9JLElBQUl0QyxPQUFPQyxLQUFBQTs7QUFFcEIsV0FBT0E7RUFDVDtFQU9Bc0MsT0FBT3ZDLE9BQU93QyxPQUFPQyxJQUFJO0FBQ3ZCLFNBQUtSLFVBQVVqQyxLQUFBQSxFQUFPSyxVQUFVbUMsS0FBQUEsRUFBT0UsS0FBS0QsRUFBQUE7RUFDOUM7RUFPQUUsSUFBSTNDLE9BQU93QixPQUFPO0FBQ2hCLFFBQUksQ0FBQ0EsU0FBUyxDQUFDQSxNQUFNQyxRQUFRO0FBQzNCOztBQUVGLFNBQUtRLFVBQVVqQyxLQUFBQSxFQUFPd0IsTUFBTWtCLEtBQVFsQixHQUFBQSxLQUFBQTtFQUN0QztFQU1Bb0IsSUFBSTVDLE9BQU87QUFDVCxXQUFPLEtBQUtpQyxVQUFVakMsS0FBQUEsRUFBT3dCLE1BQU1DLFNBQVM7RUFDOUM7RUFNQVgsTUFBTWQsT0FBTztBQUNYLFVBQU1DLFFBQVEsS0FBS1AsUUFBUXlDLElBQUluQyxLQUFBQTtBQUMvQixRQUFJLENBQUNDLE9BQU87QUFDVjs7QUFFRkEsVUFBTXNCLFVBQVU7QUFDaEJ0QixVQUFNYSxRQUFRTSxLQUFLQyxJQUFHO0FBQ3RCcEIsVUFBTU0sV0FBV04sTUFBTXVCLE1BQU1xQixPQUFPLENBQUNDLEtBQUtDLFFBQVFuQyxLQUFLb0MsSUFBSUYsS0FBS0MsSUFBSUUsU0FBUyxHQUFHLENBQUE7QUFDaEYsU0FBS2xDLFNBQVE7RUFDZjtFQUVBUSxRQUFRdkIsT0FBTztBQUNiLFFBQUksQ0FBQyxLQUFLSixVQUFVO0FBQ2xCLGFBQU87O0FBRVQsVUFBTUssUUFBUSxLQUFLUCxRQUFReUMsSUFBSW5DLEtBQUFBO0FBQy9CLFFBQUksQ0FBQ0MsU0FBUyxDQUFDQSxNQUFNc0IsV0FBVyxDQUFDdEIsTUFBTXVCLE1BQU1DLFFBQVE7QUFDbkQsYUFBTzs7QUFFVCxXQUFPO0VBQ1Q7RUFNQXlCLEtBQUtsRCxPQUFPO0FBQ1YsVUFBTUMsUUFBUSxLQUFLUCxRQUFReUMsSUFBSW5DLEtBQUFBO0FBQy9CLFFBQUksQ0FBQ0MsU0FBUyxDQUFDQSxNQUFNdUIsTUFBTUMsUUFBUTtBQUNqQzs7QUFFRixVQUFNRCxRQUFRdkIsTUFBTXVCO0FBQ3BCLFFBQUlFLElBQUlGLE1BQU1DLFNBQVM7QUFFdkIsV0FBT0MsS0FBSyxHQUFHLEVBQUVBLEdBQUc7QUFDbEJGLFlBQU1FLENBQUUsRUFBQ3lCLE9BQU07SUFDakI7QUFDQWxELFVBQU11QixRQUFRLENBQUE7QUFDZCxTQUFLekIsUUFBUUMsT0FBT0MsT0FBT21CLEtBQUtDLElBQUcsR0FBSSxVQUFBO0VBQ3pDO0VBTUErQixPQUFPcEQsT0FBTztBQUNaLFdBQU8sS0FBS04sUUFBUTJELE9BQU9yRCxLQUFBQTtFQUM3QjtBQUNGO0FBR0EsSUFBQSxXQUErQixvQkFBSVQsU0FBVztBQ2pOOUMsSUFBTStELGNBQWM7QUFDcEIsSUFBTUMsZ0JBQWdCO0VBQ3BCQyxRQUFRQyxPQUFNQyxLQUFJQyxRQUFRO0FBQ3hCLFdBQU9BLFNBQVMsTUFBTUQsTUFBS0Q7RUFDN0I7RUFNQUcsTUFBTUgsT0FBTUMsS0FBSUMsUUFBUTtBQUN0QixVQUFNRSxLQUFLQyxNQUFhTCxTQUFRSCxXQUFBQTtBQUNoQyxVQUFNUyxLQUFLRixHQUFHRyxTQUFTRixNQUFhSixPQUFNSixXQUFBQTtBQUMxQyxXQUFPUyxNQUFNQSxHQUFHQyxRQUNaRCxHQUFHRSxJQUFJSixJQUFJRixNQUFBQSxFQUFRTyxVQUFTLElBQzVCUjtFQUNOO0VBQ0FTLE9BQU9WLE9BQU1DLEtBQUlDLFFBQVE7QUFDdkIsV0FBT0YsU0FBUUMsTUFBS0QsU0FBUUU7RUFDOUI7QUFDRjtBQUVlLElBQU1TLFlBQU4sTUFBTUE7RUFDbkI1RSxZQUFZNkUsS0FBS0MsUUFBUUMsTUFBTWIsS0FBSTtBQUNqQyxVQUFNYyxlQUFlRixPQUFPQyxJQUFLO0FBRWpDYixJQUFBQSxNQUFLZSxRQUFRO01BQUNKLElBQUlYO01BQUlBO01BQUljO01BQWNILElBQUlaO0lBQUssQ0FBQTtBQUNqRCxVQUFNQSxRQUFPZ0IsUUFBUTtNQUFDSixJQUFJWjtNQUFNZTtNQUFjZDtJQUFHLENBQUE7QUFFakQsU0FBSzdCLFVBQVU7QUFDZixTQUFLNkMsTUFBTUwsSUFBSTVELE1BQU04QyxjQUFjYyxJQUFJbEUsUUFBUSxPQUFPc0QsS0FBSztBQUMzRCxTQUFLa0IsVUFBVUMsUUFBUVAsSUFBSVEsTUFBTSxLQUFLRCxRQUFRRTtBQUM5QyxTQUFLQyxTQUFTbkUsS0FBS29FLE1BQU01RCxLQUFLQyxJQUFHLEtBQU1nRCxJQUFJWSxTQUFTLEVBQUE7QUFDcEQsU0FBS2hDLFlBQVksS0FBS25CLFNBQVNsQixLQUFLb0UsTUFBTVgsSUFBSTlELFFBQVE7QUFDdEQsU0FBSzJFLFFBQVEsQ0FBQyxDQUFDYixJQUFJYztBQUNuQixTQUFLQyxVQUFVZDtBQUNmLFNBQUtlLFFBQVFkO0FBQ2IsU0FBS2UsUUFBUTdCO0FBQ2IsU0FBSzhCLE1BQU03QjtBQUNYLFNBQUs4QixZQUFZMUY7RUFDbkI7RUFFQTJGLFNBQVM7QUFDUCxXQUFPLEtBQUs1RDtFQUNkO0VBRUE2RCxPQUFPckIsS0FBS1gsS0FBSXhELE1BQU07QUFDcEIsUUFBSSxLQUFLMkIsU0FBUztBQUNoQixXQUFLOUIsUUFBUSxLQUFLO0FBRWxCLFlBQU15RSxlQUFlLEtBQUtZLFFBQVEsS0FBS0MsS0FBSztBQUM1QyxZQUFNTSxVQUFVekYsT0FBTyxLQUFLNkU7QUFDNUIsWUFBTWEsU0FBUyxLQUFLM0MsWUFBWTBDO0FBQ2hDLFdBQUtaLFNBQVM3RTtBQUNkLFdBQUsrQyxZQUFZckMsS0FBS29FLE1BQU1wRSxLQUFLb0MsSUFBSTRDLFFBQVF2QixJQUFJOUQsUUFBUSxDQUFBO0FBQ3pELFdBQUt1QixVQUFVNkQ7QUFDZixXQUFLVCxRQUFRLENBQUMsQ0FBQ2IsSUFBSWM7QUFDbkIsV0FBS0ksTUFBTWQsUUFBUTtRQUFDSixJQUFJWDtRQUFJQTtRQUFJYztRQUFjSCxJQUFJWjtNQUFLLENBQUE7QUFDdkQsV0FBSzZCLFFBQVFiLFFBQVE7UUFBQ0osSUFBSVo7UUFBTWU7UUFBY2Q7TUFBRyxDQUFBOztFQUVyRDtFQUVBUCxTQUFTO0FBQ1AsUUFBSSxLQUFLdEIsU0FBUztBQUVoQixXQUFLRSxLQUFLWCxLQUFLQyxJQUFHLENBQUE7QUFDbEIsV0FBS1EsVUFBVTtBQUNmLFdBQUs5QixRQUFRLEtBQUs7O0VBRXRCO0VBRUFnQyxLQUFLN0IsTUFBTTtBQUNULFVBQU15RixVQUFVekYsT0FBTyxLQUFLNkU7QUFDNUIsVUFBTXhFLFdBQVcsS0FBSzBDO0FBQ3RCLFVBQU1zQixPQUFPLEtBQUtjO0FBQ2xCLFVBQU01QixRQUFPLEtBQUs2QjtBQUNsQixVQUFNSCxPQUFPLEtBQUtEO0FBQ2xCLFVBQU14QixNQUFLLEtBQUs2QjtBQUNoQixRQUFJNUI7QUFFSixTQUFLOUIsVUFBVTRCLFVBQVNDLFFBQU95QixRQUFTUSxVQUFVcEY7QUFFbEQsUUFBSSxDQUFDLEtBQUtzQixTQUFTO0FBQ2pCLFdBQUt1RCxRQUFRYixJQUFBQSxJQUFRYjtBQUNyQixXQUFLM0QsUUFBUSxJQUFJO0FBQ2pCOztBQUdGLFFBQUk0RixVQUFVLEdBQUc7QUFDZixXQUFLUCxRQUFRYixJQUFBQSxJQUFRZDtBQUNyQjs7QUFHRkUsYUFBVWdDLFVBQVVwRixXQUFZO0FBQ2hDb0QsYUFBU3dCLFFBQVF4QixTQUFTLElBQUksSUFBSUEsU0FBU0E7QUFDM0NBLGFBQVMsS0FBS2dCLFFBQVEvRCxLQUFLQyxJQUFJLEdBQUdELEtBQUtvQyxJQUFJLEdBQUdXLE1BQUFBLENBQUFBLENBQUFBO0FBRTlDLFNBQUt5QixRQUFRYixJQUFLLElBQUcsS0FBS0csSUFBSWpCLE9BQU1DLEtBQUlDLE1BQUFBO0VBQzFDO0VBRUFrQyxPQUFPO0FBQ0wsVUFBTUMsV0FBVyxLQUFLTixjQUFjLEtBQUtBLFlBQVksQ0FBQTtBQUNyRCxXQUFPLElBQUlPLFFBQVEsQ0FBQ0MsS0FBS0MsUUFBUTtBQUMvQkgsZUFBU3BELEtBQUs7UUFBQ3NEO1FBQUtDO01BQUcsQ0FBQTtJQUN6QixDQUFBO0VBQ0Y7RUFFQWxHLFFBQVFtRyxVQUFVO0FBQ2hCLFVBQU1DLFNBQVNELFdBQVcsUUFBUTtBQUNsQyxVQUFNSixXQUFXLEtBQUtOLGFBQWEsQ0FBQTtBQUNuQyxhQUFTOUQsSUFBSSxHQUFHQSxJQUFJb0UsU0FBU3JFLFFBQVFDLEtBQUs7QUFDeENvRSxlQUFTcEUsQ0FBRSxFQUFDeUUsTUFBTyxFQUFBO0lBQ3JCO0VBQ0Y7QUFDRjtBQ2pIZSxJQUFNQyxhQUFOLE1BQU1BO0VBQ25CNUcsWUFBWVEsT0FBT3FHLFFBQVE7QUFDekIsU0FBS0MsU0FBU3RHO0FBQ2QsU0FBS3VHLGNBQWMsb0JBQUk1RyxJQUFBQTtBQUN2QixTQUFLNkcsVUFBVUgsTUFBQUE7RUFDakI7RUFFQUcsVUFBVUgsUUFBUTtBQUNoQixRQUFJLENBQUNJLFNBQVNKLE1BQVMsR0FBQTtBQUNyQjs7QUFHRixVQUFNSyxtQkFBbUJDLE9BQU9DLEtBQUtDLFNBQVNDLFNBQVM7QUFDdkQsVUFBTUMsZ0JBQWdCLEtBQUtSO0FBRTNCSSxXQUFPSyxvQkFBb0JYLE1BQUFBLEVBQVE3RixRQUFReUcsQ0FBQUEsUUFBTztBQUNoRCxZQUFNNUMsTUFBTWdDLE9BQU9ZLEdBQUk7QUFDdkIsVUFBSSxDQUFDUixTQUFTcEMsR0FBTSxHQUFBO0FBQ2xCOztBQUVGLFlBQU02QixXQUFXLENBQUE7QUFDakIsaUJBQVdnQixVQUFVUixrQkFBa0I7QUFDckNSLGlCQUFTZ0IsTUFBQUEsSUFBVTdDLElBQUk2QyxNQUFPO01BQ2hDO0FBRUNDLE9BQUFBLFFBQVE5QyxJQUFJK0MsVUFBVSxLQUFLL0MsSUFBSStDLGNBQWM7UUFBQ0g7TUFBSSxHQUFFekcsUUFBUSxDQUFDK0QsU0FBUztBQUNyRSxZQUFJQSxTQUFTMEMsT0FBTyxDQUFDRixjQUFjbkUsSUFBSTJCLElBQU8sR0FBQTtBQUM1Q3dDLHdCQUFjekUsSUFBSWlDLE1BQU0yQixRQUFBQTs7TUFFNUIsQ0FBQTtJQUNGLENBQUE7RUFDRjtFQU1BbUIsZ0JBQWdCL0MsUUFBUWdELFFBQVE7QUFDOUIsVUFBTUMsYUFBYUQsT0FBT0U7QUFDMUIsVUFBTUEsV0FBVUMscUJBQXFCbkQsUUFBUWlELFVBQUFBO0FBQzdDLFFBQUksQ0FBQ0MsVUFBUztBQUNaLGFBQU8sQ0FBQTs7QUFHVCxVQUFNRSxhQUFhLEtBQUtDLGtCQUFrQkgsVUFBU0QsVUFBQUE7QUFDbkQsUUFBSUEsV0FBV0ssU0FBUztBQUl0QkMsZUFBU3ZELE9BQU9rRCxRQUFRTSxhQUFhUCxVQUFZUSxFQUFBQSxLQUFLLE1BQU07QUFDMUR6RCxlQUFPa0QsVUFBVUQ7TUFDbkIsR0FBRyxNQUFNO01BRVQsQ0FBQTs7QUFHRixXQUFPRztFQUNUO0VBS0FDLGtCQUFrQnJELFFBQVFnRCxRQUFRO0FBQ2hDLFVBQU1QLGdCQUFnQixLQUFLUjtBQUMzQixVQUFNbUIsYUFBYSxDQUFBO0FBQ25CLFVBQU1uRyxVQUFVK0MsT0FBT3dELGdCQUFnQnhELE9BQU93RCxjQUFjLENBQUE7QUFDNUQsVUFBTUUsUUFBUXJCLE9BQU9DLEtBQUtVLE1BQUFBO0FBQzFCLFVBQU1wSCxPQUFPa0IsS0FBS0MsSUFBRztBQUNyQixRQUFJSztBQUVKLFNBQUtBLElBQUlzRyxNQUFNdkcsU0FBUyxHQUFHQyxLQUFLLEdBQUcsRUFBRUEsR0FBRztBQUN0QyxZQUFNNkMsT0FBT3lELE1BQU10RyxDQUFFO0FBQ3JCLFVBQUk2QyxLQUFLMEQsT0FBTyxDQUFBLE1BQU8sS0FBSztBQUMxQjs7QUFHRixVQUFJMUQsU0FBUyxXQUFXO0FBQ3RCbUQsbUJBQVdoRixLQUFRLEdBQUEsS0FBSzJFLGdCQUFnQi9DLFFBQVFnRCxNQUFBQSxDQUFBQTtBQUNoRDs7QUFFRixZQUFNWSxRQUFRWixPQUFPL0MsSUFBSztBQUMxQixVQUFJdUMsWUFBWXZGLFFBQVFnRCxJQUFLO0FBQzdCLFlBQU1GLE1BQU0wQyxjQUFjNUUsSUFBSW9DLElBQUFBO0FBRTlCLFVBQUl1QyxXQUFXO0FBQ2IsWUFBSXpDLE9BQU95QyxVQUFVckIsT0FBTSxHQUFJO0FBRTdCcUIsb0JBQVVwQixPQUFPckIsS0FBSzZELE9BQU9oSSxJQUFBQTtBQUM3QjtlQUNLO0FBQ0w0RyxvQkFBVTNELE9BQU07OztBQUdwQixVQUFJLENBQUNrQixPQUFPLENBQUNBLElBQUk5RCxVQUFVO0FBRXpCK0QsZUFBT0MsSUFBQUEsSUFBUTJEO0FBQ2Y7O0FBR0YzRyxjQUFRZ0QsSUFBQUEsSUFBUXVDLFlBQVksSUFBSTFDLFVBQVVDLEtBQUtDLFFBQVFDLE1BQU0yRCxLQUFBQTtBQUM3RFIsaUJBQVdoRixLQUFLb0UsU0FBQUE7SUFDbEI7QUFDQSxXQUFPWTtFQUNUO0VBU0FoQyxPQUFPcEIsUUFBUWdELFFBQVE7QUFDckIsUUFBSSxLQUFLZixZQUFZNEIsU0FBUyxHQUFHO0FBRS9CeEIsYUFBT3lCLE9BQU85RCxRQUFRZ0QsTUFBQUE7QUFDdEI7O0FBR0YsVUFBTUksYUFBYSxLQUFLQyxrQkFBa0JyRCxRQUFRZ0QsTUFBQUE7QUFFbEQsUUFBSUksV0FBV2pHLFFBQVE7QUFDckI0RyxlQUFTMUYsSUFBSSxLQUFLMkQsUUFBUW9CLFVBQUFBO0FBQzFCLGFBQU87O0VBRVg7QUFDRjtBQUVBLFNBQVNHLFNBQVNILFlBQVlOLFlBQVk7QUFDeEMsUUFBTTdGLFVBQVUsQ0FBQTtBQUNoQixRQUFNcUYsT0FBT0QsT0FBT0MsS0FBS1EsVUFBQUE7QUFDekIsV0FBUzFGLElBQUksR0FBR0EsSUFBSWtGLEtBQUtuRixRQUFRQyxLQUFLO0FBQ3BDLFVBQU00RyxPQUFPWixXQUFXZCxLQUFLbEYsQ0FBQUEsQ0FBRTtBQUMvQixRQUFJNEcsUUFBUUEsS0FBSzdDLE9BQU0sR0FBSTtBQUN6QmxFLGNBQVFtQixLQUFLNEYsS0FBS3pDLEtBQUksQ0FBQTs7RUFFMUI7QUFFQSxTQUFPRSxRQUFRd0MsSUFBSWhILE9BQUFBO0FBQ3JCO0FBRUEsU0FBU2tHLHFCQUFxQm5ELFFBQVFpRCxZQUFZO0FBQ2hELE1BQUksQ0FBQ0EsWUFBWTtBQUNmOztBQUVGLE1BQUlDLFdBQVVsRCxPQUFPa0Q7QUFDckIsTUFBSSxDQUFDQSxVQUFTO0FBQ1psRCxXQUFPa0QsVUFBVUQ7QUFDakI7O0FBRUYsTUFBSUMsU0FBUUksU0FBUztBQUduQnRELFdBQU9rRCxVQUFVQSxXQUFVYixPQUFPeUIsT0FBTyxDQUFBLEdBQUlaLFVBQVM7TUFBQ0ksU0FBUztNQUFPRSxhQUFhLENBQUE7SUFBRSxDQUFBOztBQUV4RixTQUFPTjtBQUNUO0FDdEpBLFNBQVNnQixVQUFVQyxPQUFPQyxpQkFBaUI7QUFDekMsUUFBTUMsT0FBT0YsU0FBU0EsTUFBTWpCLFdBQVcsQ0FBQTtBQUN2QyxRQUFNb0IsVUFBVUQsS0FBS0M7QUFDckIsUUFBTS9ILE1BQU04SCxLQUFLOUgsUUFBUWYsU0FBWTRJLGtCQUFrQjtBQUN2RCxRQUFNMUYsTUFBTTJGLEtBQUszRixRQUFRbEQsU0FBWTRJLGtCQUFrQjtBQUN2RCxTQUFPO0lBQ0w1SCxPQUFPOEgsVUFBVTVGLE1BQU1uQztJQUN2QmdJLEtBQUtELFVBQVUvSCxNQUFNbUM7RUFDdkI7QUFDRjtBQUVBLFNBQVM4RixZQUFZQyxRQUFRQyxRQUFRTixpQkFBaUI7QUFDcEQsTUFBSUEsb0JBQW9CLE9BQU87QUFDN0IsV0FBTzs7QUFFVCxRQUFNTyxJQUFJVCxVQUFVTyxRQUFRTCxlQUFBQTtBQUM1QixRQUFNUSxJQUFJVixVQUFVUSxRQUFRTixlQUFBQTtBQUU1QixTQUFPO0lBQ0xTLEtBQUtELEVBQUVMO0lBQ1BPLE9BQU9ILEVBQUVKO0lBQ1RRLFFBQVFILEVBQUVwSTtJQUNWd0ksTUFBTUwsRUFBRW5JO0VBQ1Y7QUFDRjtBQUVBLFNBQVN5SSxPQUFPckIsT0FBTztBQUNyQixNQUFJc0IsR0FBR0MsR0FBR0MsR0FBR0M7QUFFYixNQUFJbEQsU0FBU3lCLEtBQVEsR0FBQTtBQUNuQnNCLFFBQUl0QixNQUFNaUI7QUFDVk0sUUFBSXZCLE1BQU1rQjtBQUNWTSxRQUFJeEIsTUFBTW1CO0FBQ1ZNLFFBQUl6QixNQUFNb0I7U0FDTDtBQUNMRSxRQUFJQyxJQUFJQyxJQUFJQyxJQUFJekI7O0FBR2xCLFNBQU87SUFDTGlCLEtBQUtLO0lBQ0xKLE9BQU9LO0lBQ1BKLFFBQVFLO0lBQ1JKLE1BQU1LO0lBQ05DLFVBQVUxQixVQUFVO0VBQ3RCO0FBQ0Y7QUFFQSxTQUFTMkIsd0JBQXdCN0osT0FBTzhKLGVBQWU7QUFDckQsUUFBTWxELE9BQU8sQ0FBQTtBQUNiLFFBQU1tRCxXQUFXL0osTUFBTWdLLHVCQUF1QkYsYUFBQUE7QUFDOUMsTUFBSXBJLEdBQUd1STtBQUVQLE9BQUt2SSxJQUFJLEdBQUd1SSxPQUFPRixTQUFTdEksUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDakRrRixTQUFLbEUsS0FBS3FILFNBQVNySSxDQUFBQSxFQUFHd0ksS0FBSztFQUM3QjtBQUNBLFNBQU90RDtBQUNUO0FBRUEsU0FBU3VELFdBQVdDLE9BQU9sQyxPQUFPbUMsU0FBUzdDLFdBQVUsQ0FBQSxHQUFJO0FBQ3ZELFFBQU1aLE9BQU93RCxNQUFNeEQ7QUFDbkIsUUFBTTBELGFBQWE5QyxTQUFRK0MsU0FBUztBQUNwQyxNQUFJN0ksR0FBR3VJLE1BQU1PLGNBQWNDO0FBRTNCLE1BQUl2QyxVQUFVLE1BQU07QUFDbEI7O0FBR0YsTUFBSXdDLFFBQVE7QUFDWixPQUFLaEosSUFBSSxHQUFHdUksT0FBT3JELEtBQUtuRixRQUFRQyxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUM3QzhJLG1CQUFlLENBQUM1RCxLQUFLbEYsQ0FBRTtBQUN2QixRQUFJOEksaUJBQWlCSCxTQUFTO0FBQzVCSyxjQUFRO0FBQ1IsVUFBSWxELFNBQVFlLEtBQUs7QUFDZjs7QUFFRjs7QUFFRmtDLGlCQUFhTCxNQUFNOUMsT0FBT2tELFlBQWE7QUFDdkMsUUFBSUcsZUFBU0YsVUFBZ0JILE1BQUFBLGNBQWVwQyxVQUFVLEtBQUswQyxLQUFLMUMsS0FBQUEsTUFBVzBDLEtBQUtILFVBQUFBLElBQWU7QUFDN0Z2QyxlQUFTdUM7O0VBRWI7QUFFQSxNQUFJLENBQUNDLFNBQVMsQ0FBQ2xELFNBQVFlLEtBQUs7QUFDMUIsV0FBTzs7QUFHVCxTQUFPTDtBQUNUO0FBRUEsU0FBUzJDLHlCQUF5QkMsTUFBTUMsTUFBTTtBQUM1QyxRQUFNLEVBQUNDLFFBQVFDLE9BQUFBLElBQVVGO0FBQ3pCLFFBQU1HLFdBQVdGLE9BQU9HLFNBQVMsTUFBTSxNQUFNO0FBQzdDLFFBQU1DLFdBQVdILE9BQU9FLFNBQVMsTUFBTSxNQUFNO0FBQzdDLFFBQU12RSxPQUFPRCxPQUFPQyxLQUFLa0UsSUFBQUE7QUFDekIsUUFBTU8sUUFBUSxJQUFJQyxNQUFNMUUsS0FBS25GLE1BQU07QUFDbkMsTUFBSUMsR0FBR3VJLE1BQU1oRDtBQUNiLE9BQUt2RixJQUFJLEdBQUd1SSxPQUFPckQsS0FBS25GLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQzdDdUYsVUFBTUwsS0FBS2xGLENBQUU7QUFDYjJKLFVBQU0zSixDQUFBQSxJQUFLO01BQ1QsQ0FBQ3dKLFFBQUFBLEdBQVdqRTtNQUNaLENBQUNtRSxRQUFTLEdBQUVOLEtBQUs3RCxHQUFJO0lBQ3ZCO0VBQ0Y7QUFDQSxTQUFPb0U7QUFDVDtBQUVBLFNBQVNFLFVBQVU5QyxPQUFPc0MsTUFBTTtBQUM5QixRQUFNUyxVQUFVL0MsU0FBU0EsTUFBTWpCLFFBQVFnRTtBQUN2QyxTQUFPQSxXQUFZQSxZQUFZMUwsVUFBYWlMLEtBQUtYLFVBQVV0SztBQUM3RDtBQUVBLFNBQVMyTCxZQUFZQyxZQUFZQyxZQUFZWixNQUFNO0FBQ2pELFNBQU8sR0FBR1csV0FBV0UsRUFBRSxJQUFJRCxXQUFXQyxFQUFFLElBQUliLEtBQUtYLFNBQVNXLEtBQUs1SyxJQUFJO0FBQ3JFO0FBRUEsU0FBUzBMLGNBQWNwRCxPQUFPO0FBQzVCLFFBQU0sRUFBQzVILEtBQUttQyxLQUFLOEksWUFBWUMsV0FBVSxJQUFJdEQsTUFBTW9ELGNBQWE7QUFDOUQsU0FBTztJQUNMaEwsS0FBS2lMLGFBQWFqTCxNQUFNbUwsT0FBT0M7SUFDL0JqSixLQUFLK0ksYUFBYS9JLE1BQU1nSixPQUFPRTtFQUNqQztBQUNGO0FBRUEsU0FBU0MsaUJBQWlCQyxRQUFRQyxVQUFVQyxZQUFZO0FBQ3RELFFBQU1DLFdBQVdILE9BQU9DLFFBQVMsTUFBS0QsT0FBT0MsUUFBQUEsSUFBWSxDQUFBO0FBQ3pELFNBQU9FLFNBQVNELFVBQUFBLE1BQWdCQyxTQUFTRCxVQUFBQSxJQUFjLENBQUE7QUFDekQ7QUFFQSxTQUFTRSxvQkFBb0JwQyxPQUFPYSxRQUFRd0IsVUFBVXRNLE1BQU07QUFDMUQsYUFBVzRLLFFBQVFFLE9BQU95Qix3QkFBd0J2TSxJQUFBQSxFQUFNeUksUUFBTyxHQUFJO0FBQ2pFLFVBQU1WLFFBQVFrQyxNQUFNVyxLQUFLYixLQUFLO0FBQzlCLFFBQUksWUFBYWhDLFFBQVEsS0FBTyxDQUFDdUUsWUFBWXZFLFFBQVEsR0FBSTtBQUN2RCxhQUFPNkMsS0FBS2I7O0VBRWhCO0FBRUEsU0FBTztBQUNUO0FBRUEsU0FBU3lDLGFBQWFDLFlBQVlDLFFBQVE7QUFDeEMsUUFBTSxFQUFDN00sT0FBTzhNLGFBQWEvQixLQUFBQSxJQUFRNkI7QUFDbkMsUUFBTVIsU0FBU3BNLE1BQU0rTSxZQUFZL00sTUFBTStNLFVBQVUsQ0FBQTtBQUNqRCxRQUFNLEVBQUMvQixRQUFRQyxRQUFRZixPQUFPTSxhQUFBQSxJQUFnQk87QUFDOUMsUUFBTWlDLFFBQVFoQyxPQUFPRztBQUNyQixRQUFNOEIsUUFBUWhDLE9BQU9FO0FBQ3JCLFFBQU1sRSxNQUFNd0UsWUFBWVQsUUFBUUMsUUFBUUYsSUFBQUE7QUFDeEMsUUFBTWQsT0FBTzRDLE9BQU9wTDtBQUNwQixNQUFJMkk7QUFFSixXQUFTMUksSUFBSSxHQUFHQSxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUM3QixVQUFNRSxPQUFPaUwsT0FBT25MLENBQUU7QUFDdEIsVUFBTSxFQUFDLENBQUNzTCxLQUFBQSxHQUFROUMsUUFBTyxDQUFDK0MsS0FBTSxHQUFFL0UsTUFBSyxJQUFJdEc7QUFDekMsVUFBTXNMLGFBQWF0TCxLQUFLbUwsWUFBWW5MLEtBQUttTCxVQUFVLENBQUE7QUFDbkQzQyxZQUFROEMsV0FBV0QsS0FBQUEsSUFBU2QsaUJBQWlCQyxRQUFRbkYsS0FBS2lELE1BQUFBO0FBQzFERSxVQUFNSSxZQUFBQSxJQUFnQnRDO0FBRXRCa0MsVUFBTStDLE9BQU9YLG9CQUFvQnBDLE9BQU9hLFFBQVEsTUFBTUYsS0FBSzVLLElBQUk7QUFDL0RpSyxVQUFNZ0QsVUFBVVosb0JBQW9CcEMsT0FBT2EsUUFBUSxPQUFPRixLQUFLNUssSUFBSTtBQUVuRSxVQUFNa04sZUFBZWpELE1BQU1rRCxrQkFBa0JsRCxNQUFNa0QsZ0JBQWdCLENBQUE7QUFDbkVELGlCQUFhN0MsWUFBQUEsSUFBZ0J0QztFQUMvQjtBQUNGO0FBRUEsU0FBU3FGLGdCQUFnQnZOLE9BQU9tTCxNQUFNO0FBQ3BDLFFBQU1xQyxVQUFTeE4sTUFBTXdOO0FBQ3JCLFNBQU83RyxPQUFPQyxLQUFLNEcsT0FBQUEsRUFBUUMsT0FBT3hHLENBQUFBLFFBQU91RyxRQUFPdkcsR0FBSSxFQUFDa0UsU0FBU0EsSUFBQUEsRUFBTXVDLE1BQUs7QUFDM0U7QUFFQSxTQUFTQyxxQkFBcUJDLFFBQVExRCxRQUFPO0FBQzNDLFNBQU8yRCxjQUFjRCxRQUNuQjtJQUNFbkksUUFBUTtJQUNScUksU0FBU2hPO0lBQ1QwSyxjQUFjTjtJQUNkQSxPQUFBQTtJQUNBSyxNQUFNO0lBQ05wSyxNQUFNO0VBQ1IsQ0FBQTtBQUVKO0FBRUEsU0FBUzROLGtCQUFrQkgsUUFBUTFELFFBQU84RCxTQUFTO0FBQ2pELFNBQU9ILGNBQWNELFFBQVE7SUFDM0JuSSxRQUFRO0lBQ1J3SSxXQUFXL0Q7SUFDWDJDLFFBQVEvTTtJQUNSb08sS0FBS3BPO0lBQ0xrTztJQUNBOUQsT0FBQUE7SUFDQUssTUFBTTtJQUNOcEssTUFBTTtFQUNSLENBQUE7QUFDRjtBQUVBLFNBQVNnTyxZQUFZcEQsTUFBTXZKLE9BQU87QUFFaEMsUUFBTWdKLGVBQWVPLEtBQUs2QixXQUFXMUM7QUFDckMsUUFBTWlCLE9BQU9KLEtBQUtFLFVBQVVGLEtBQUtFLE9BQU9FO0FBQ3hDLE1BQUksQ0FBQ0EsTUFBTTtBQUNUOztBQUdGM0osVUFBUUEsU0FBU3VKLEtBQUtxRDtBQUN0QixhQUFXdkIsVUFBVXJMLE9BQU87QUFDMUIsVUFBTTRLLFNBQVNTLE9BQU9FO0FBQ3RCLFFBQUksQ0FBQ1gsVUFBVUEsT0FBT2pCLElBQUssTUFBS3JMLFVBQWFzTSxPQUFPakIsSUFBQUEsRUFBTVgsWUFBQUEsTUFBa0IxSyxRQUFXO0FBQ3JGOztBQUVGLFdBQU9zTSxPQUFPakIsSUFBSyxFQUFDWCxZQUFhO0FBQ2pDLFFBQUk0QixPQUFPakIsSUFBSyxFQUFDbUMsa0JBQWtCeE4sVUFBYXNNLE9BQU9qQixJQUFBQSxFQUFNbUMsY0FBYzlDLFlBQUFBLE1BQWtCMUssUUFBVztBQUN0RyxhQUFPc00sT0FBT2pCLElBQUFBLEVBQU1tQyxjQUFjOUMsWUFBYTs7RUFFbkQ7QUFDRjtBQUVBLElBQU02RCxxQkFBcUIsQ0FBQzlELFNBQVNBLFNBQVMsV0FBV0EsU0FBUztBQUNsRSxJQUFNK0QsbUJBQW1CLENBQUNDLFFBQVFDLFdBQVdBLFNBQVNELFNBQVM1SCxPQUFPeUIsT0FBTyxDQUFBLEdBQUltRyxNQUFPO0FBQ3hGLElBQU1FLGNBQWMsQ0FBQ0MsVUFBVTNELE1BQU0vSyxVQUFVME8sWUFBWSxDQUFDM0QsS0FBSzRELFVBQVU1RCxLQUFLNkQsWUFDM0U7RUFBQ2hJLE1BQU1pRCx3QkFBd0I3SixPQUFPLElBQUk7RUFBR3NILFFBQVE7QUFBSTtBQUUvQyxJQUFNdUgsb0JBQU4sTUFBTUE7RUFxQm5CclAsWUFBWVEsT0FBT3dLLGNBQWM7QUFDL0IsU0FBS3hLLFFBQVFBO0FBQ2IsU0FBSzhPLE9BQU85TyxNQUFNK087QUFDbEIsU0FBSzdFLFFBQVFNO0FBQ2IsU0FBS3dFLGtCQUFrQixDQUFBO0FBQ3ZCLFNBQUtsQyxjQUFjLEtBQUttQyxRQUFPO0FBQy9CLFNBQUtDLFFBQVEsS0FBS3BDLFlBQVkzTTtBQUM5QixTQUFLcUgsVUFBVTFIO0FBRWYsU0FBS3FQLFdBQVc7QUFDaEIsU0FBS0MsUUFBUXRQO0FBQ2IsU0FBS3VQLGNBQWN2UDtBQUNuQixTQUFLd1AsaUJBQWlCeFA7QUFDdEIsU0FBS3lQLGFBQWF6UDtBQUNsQixTQUFLMFAsYUFBYTFQO0FBQ2xCLFNBQUsyUCxzQkFBc0I7QUFDM0IsU0FBS0MscUJBQXFCO0FBQzFCLFNBQUtDLFdBQVc3UDtBQUNoQixTQUFLOFAsWUFBWSxDQUFBO0FBQ2pCLFNBQUtDLHFCQUFxQixXQUFXQTtBQUNyQyxTQUFLQyxrQkFBa0IsV0FBV0E7QUFFbEMsU0FBS0MsV0FBVTtFQUNqQjtFQUVBQSxhQUFhO0FBQ1gsVUFBTWhGLE9BQU8sS0FBSytCO0FBQ2xCLFNBQUt0RyxVQUFTO0FBQ2QsU0FBS3dKLFdBQVU7QUFDZmpGLFNBQUs2RCxXQUFXckQsVUFBVVIsS0FBS0UsUUFBUUYsSUFBQUE7QUFDdkMsU0FBS2tGLFlBQVc7QUFFaEIsUUFBSSxLQUFLekksUUFBUTBJLFFBQVEsQ0FBQyxLQUFLbFEsTUFBTW1RLGdCQUFnQixRQUFXLEdBQUE7QUFDOURDLGNBQVFDLEtBQUssb0tBQUE7O0VBRWpCO0VBRUFDLFlBQVk5RixjQUFjO0FBQ3hCLFFBQUksS0FBS04sVUFBVU0sY0FBYztBQUMvQjJELGtCQUFZLEtBQUtyQixXQUFXOztBQUU5QixTQUFLNUMsUUFBUU07RUFDZjtFQUVBd0YsYUFBYTtBQUNYLFVBQU1oUSxRQUFRLEtBQUtBO0FBQ25CLFVBQU0rSyxPQUFPLEtBQUsrQjtBQUNsQixVQUFNZ0IsVUFBVSxLQUFLeUMsV0FBVTtBQUUvQixVQUFNQyxXQUFXLENBQUNyRixNQUFNbEMsR0FBR0MsR0FBR08sTUFBTTBCLFNBQVMsTUFBTWxDLElBQUlrQyxTQUFTLE1BQU0xQixJQUFJUDtBQUUxRSxVQUFNdUgsTUFBTTFGLEtBQUsyRixVQUFVQyxlQUFlN0MsUUFBUTRDLFNBQVNuRCxnQkFBZ0J2TixPQUFPLEdBQUEsQ0FBQTtBQUNsRixVQUFNNFEsTUFBTTdGLEtBQUs4RixVQUFVRixlQUFlN0MsUUFBUStDLFNBQVN0RCxnQkFBZ0J2TixPQUFPLEdBQUEsQ0FBQTtBQUNsRixVQUFNOFEsTUFBTS9GLEtBQUtnRyxVQUFVSixlQUFlN0MsUUFBUWlELFNBQVN4RCxnQkFBZ0J2TixPQUFPLEdBQUEsQ0FBQTtBQUNsRixVQUFNZ1IsWUFBWWpHLEtBQUtpRztBQUN2QixVQUFNQyxNQUFNbEcsS0FBS21HLFVBQVVWLFNBQVNRLFdBQVdQLEtBQUtHLEtBQUtFLEdBQUFBO0FBQ3pELFVBQU1LLE1BQU1wRyxLQUFLcUcsVUFBVVosU0FBU1EsV0FBV0osS0FBS0gsS0FBS0ssR0FBQUE7QUFDekQvRixTQUFLaEMsU0FBUyxLQUFLc0ksY0FBY1osR0FBQUE7QUFDakMxRixTQUFLL0IsU0FBUyxLQUFLcUksY0FBY1QsR0FBQUE7QUFDakM3RixTQUFLdUcsU0FBUyxLQUFLRCxjQUFjUCxHQUFBQTtBQUNqQy9GLFNBQUtDLFNBQVMsS0FBS3FHLGNBQWNKLEdBQUFBO0FBQ2pDbEcsU0FBS0UsU0FBUyxLQUFLb0csY0FBY0YsR0FBQUE7RUFDbkM7RUFFQVosYUFBYTtBQUNYLFdBQU8sS0FBS3ZRLE1BQU04SyxLQUFLeUcsU0FBUyxLQUFLckgsS0FBSztFQUM1QztFQUVBK0UsVUFBVTtBQUNSLFdBQU8sS0FBS2pQLE1BQU13UixlQUFlLEtBQUt0SCxLQUFLO0VBQzdDO0VBTUFtSCxjQUFjSSxTQUFTO0FBQ3JCLFdBQU8sS0FBS3pSLE1BQU13TixPQUFPaUUsT0FBUTtFQUNuQztFQUtBQyxlQUFlakosT0FBTztBQUNwQixVQUFNc0MsT0FBTyxLQUFLK0I7QUFDbEIsV0FBT3JFLFVBQVVzQyxLQUFLQyxTQUNsQkQsS0FBS0UsU0FDTEYsS0FBS0M7RUFDWDtFQUVBMkcsUUFBUTtBQUNOLFNBQUt4USxRQUFRLE9BQUE7RUFDZjtFQUtBeVEsV0FBVztBQUNULFVBQU03RyxPQUFPLEtBQUsrQjtBQUNsQixRQUFJLEtBQUtzQyxPQUFPO0FBQ2R5QywwQkFBb0IsS0FBS3pDLE9BQU8sSUFBSTs7QUFFdEMsUUFBSXJFLEtBQUs2RCxVQUFVO0FBQ2pCVCxrQkFBWXBELElBQUFBOztFQUVoQjtFQUtBK0csYUFBYTtBQUNYLFVBQU1oRSxVQUFVLEtBQUt5QyxXQUFVO0FBQy9CLFVBQU16RixPQUFPZ0QsUUFBUWhELFNBQVNnRCxRQUFRaEQsT0FBTyxDQUFBO0FBQzdDLFVBQU1zRSxRQUFRLEtBQUtBO0FBTW5CLFFBQUkzSSxTQUFTcUUsSUFBTyxHQUFBO0FBQ2xCLFlBQU1DLE9BQU8sS0FBSytCO0FBQ2xCLFdBQUtzQyxRQUFRdkUseUJBQXlCQyxNQUFNQyxJQUFBQTtlQUNuQ3FFLFVBQVV0RSxNQUFNO0FBQ3pCLFVBQUlzRSxPQUFPO0FBRVR5Qyw0QkFBb0J6QyxPQUFPLElBQUk7QUFFL0IsY0FBTXJFLE9BQU8sS0FBSytCO0FBQ2xCcUIsb0JBQVlwRCxJQUFBQTtBQUNaQSxhQUFLcUQsVUFBVSxDQUFBOztBQUVqQixVQUFJdEQsUUFBUW5FLE9BQU9vTCxhQUFhakgsSUFBTyxHQUFBO0FBQ3JDa0gsMEJBQWtCbEgsTUFBTSxJQUFJOztBQUU5QixXQUFLOEUsWUFBWSxDQUFBO0FBQ2pCLFdBQUtSLFFBQVF0RTs7RUFFakI7RUFFQW1GLGNBQWM7QUFDWixVQUFNbEYsT0FBTyxLQUFLK0I7QUFFbEIsU0FBS2dGLFdBQVU7QUFFZixRQUFJLEtBQUtqQyxvQkFBb0I7QUFDM0I5RSxXQUFLK0MsVUFBVSxJQUFJLEtBQUsrQixtQkFBa0I7O0VBRTlDO0VBRUFvQyxzQkFBc0JDLGtCQUFrQjtBQUN0QyxVQUFNbkgsT0FBTyxLQUFLK0I7QUFDbEIsVUFBTWdCLFVBQVUsS0FBS3lDLFdBQVU7QUFDL0IsUUFBSTRCLGVBQWU7QUFFbkIsU0FBS0wsV0FBVTtBQUdmLFVBQU1NLGFBQWFySCxLQUFLNkQ7QUFDeEI3RCxTQUFLNkQsV0FBV3JELFVBQVVSLEtBQUtFLFFBQVFGLElBQUFBO0FBR3ZDLFFBQUlBLEtBQUtYLFVBQVUwRCxRQUFRMUQsT0FBTztBQUNoQytILHFCQUFlO0FBRWZoRSxrQkFBWXBELElBQUFBO0FBQ1pBLFdBQUtYLFFBQVEwRCxRQUFRMUQ7O0FBS3ZCLFNBQUtpSSxnQkFBZ0JILGdCQUFBQTtBQUdyQixRQUFJQyxnQkFBZ0JDLGVBQWVySCxLQUFLNkQsVUFBVTtBQUNoRGpDLG1CQUFhLE1BQU01QixLQUFLcUQsT0FBTztBQUMvQnJELFdBQUs2RCxXQUFXckQsVUFBVVIsS0FBS0UsUUFBUUYsSUFBQUE7O0VBRTNDO0VBTUF2RSxZQUFZO0FBQ1YsVUFBTUgsU0FBUyxLQUFLckcsTUFBTXFHO0FBQzFCLFVBQU1pTSxZQUFZak0sT0FBT2tNLGlCQUFpQixLQUFLckQsS0FBSztBQUNwRCxVQUFNc0QsU0FBU25NLE9BQU9vTSxnQkFBZ0IsS0FBS2xDLFdBQVUsR0FBSStCLFdBQVcsSUFBSTtBQUN4RSxTQUFLOUssVUFBVW5CLE9BQU9xTSxlQUFlRixRQUFRLEtBQUtHLFdBQVUsQ0FBQTtBQUM1RCxTQUFLeEQsV0FBVyxLQUFLM0gsUUFBUW9MO0FBQzdCLFNBQUs1RCxrQkFBa0IsQ0FBQTtFQUN6QjtFQU1BNkQsTUFBTS9SLE9BQU9nUyxPQUFPO0FBQ2xCLFVBQU0sRUFBQ2hHLGFBQWEvQixNQUFNcUUsT0FBT3RFLEtBQUksSUFBSTtBQUN6QyxVQUFNLEVBQUNFLFFBQVE0RCxTQUFBQSxJQUFZN0Q7QUFDM0IsVUFBTWlDLFFBQVFoQyxPQUFPRztBQUVyQixRQUFJNEgsU0FBU2pTLFVBQVUsS0FBS2dTLFVBQVVoSSxLQUFLckosU0FBUyxPQUFPc0osS0FBS2lJO0FBQ2hFLFFBQUlDLE9BQU9uUyxRQUFRLEtBQUtpSyxLQUFLcUQsUUFBUXROLFFBQVEsQ0FBRTtBQUMvQyxRQUFJWSxHQUFHcUIsS0FBSzhKO0FBRVosUUFBSSxLQUFLc0MsYUFBYSxPQUFPO0FBQzNCcEUsV0FBS3FELFVBQVV0RDtBQUNmQyxXQUFLaUksVUFBVTtBQUNmbkcsZUFBUy9CO1dBQ0o7QUFDTCxVQUFJM0QsUUFBUTJELEtBQUtoSyxLQUFBQSxDQUFNLEdBQUc7QUFDeEIrTCxpQkFBUyxLQUFLcUcsZUFBZW5JLE1BQU1ELE1BQU1oSyxPQUFPZ1MsS0FBQUE7TUFDbEQsV0FBV3JNLFNBQVNxRSxLQUFLaEssS0FBQUEsQ0FBTSxHQUFHO0FBQ2hDK0wsaUJBQVMsS0FBS3NHLGdCQUFnQnBJLE1BQU1ELE1BQU1oSyxPQUFPZ1MsS0FBQUE7YUFDNUM7QUFDTGpHLGlCQUFTLEtBQUt1RyxtQkFBbUJySSxNQUFNRCxNQUFNaEssT0FBT2dTLEtBQUFBOztBQUd0RCxZQUFNTyw2QkFBNkIsTUFBTXRRLElBQUlpSyxLQUFBQSxNQUFXLFFBQVNpRyxRQUFRbFEsSUFBSWlLLEtBQUFBLElBQVNpRyxLQUFLakcsS0FBTTtBQUNqRyxXQUFLdEwsSUFBSSxHQUFHQSxJQUFJb1IsT0FBTyxFQUFFcFIsR0FBRztBQUMxQnFKLGFBQUtxRCxRQUFRMU0sSUFBSVosS0FBQUEsSUFBU2lDLE1BQU04SixPQUFPbkwsQ0FBRTtBQUN6QyxZQUFJcVIsUUFBUTtBQUNWLGNBQUlNLDJCQUE4QixHQUFBO0FBQ2hDTixxQkFBUzs7QUFFWEUsaUJBQU9sUTs7TUFFWDtBQUNBZ0ksV0FBS2lJLFVBQVVEOztBQUdqQixRQUFJbkUsVUFBVTtBQUNaakMsbUJBQWEsTUFBTUUsTUFBQUE7O0VBRXZCO0VBYUF1RyxtQkFBbUJySSxNQUFNRCxNQUFNaEssT0FBT2dTLE9BQU87QUFDM0MsVUFBTSxFQUFDOUgsUUFBUUMsT0FBQUEsSUFBVUY7QUFDekIsVUFBTWlDLFFBQVFoQyxPQUFPRztBQUNyQixVQUFNOEIsUUFBUWhDLE9BQU9FO0FBQ3JCLFVBQU1tSSxTQUFTdEksT0FBT3VJLFVBQVM7QUFDL0IsVUFBTUMsY0FBY3hJLFdBQVdDO0FBQy9CLFVBQU00QixTQUFTLElBQUl2QixNQUFNd0gsS0FBQUE7QUFDekIsUUFBSXBSLEdBQUd1SSxNQUFNQztBQUViLFNBQUt4SSxJQUFJLEdBQUd1SSxPQUFPNkksT0FBT3BSLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ3ZDd0ksTUFBQUEsU0FBUXhJLElBQUlaO0FBQ1orTCxhQUFPbkwsQ0FBQUEsSUFBSztRQUNWLENBQUNzTCxLQUFBQSxHQUFRd0csZUFBZXhJLE9BQU82SCxNQUFNUyxPQUFPcEosTUFBQUEsR0FBUUEsTUFBQUE7UUFDcEQsQ0FBQytDLEtBQUFBLEdBQVFoQyxPQUFPNEgsTUFBTS9ILEtBQUtaLE1BQUFBLEdBQVFBLE1BQUFBO01BQ3JDO0lBQ0Y7QUFDQSxXQUFPMkM7RUFDVDtFQWFBcUcsZUFBZW5JLE1BQU1ELE1BQU1oSyxPQUFPZ1MsT0FBTztBQUN2QyxVQUFNLEVBQUMvSixRQUFRQyxPQUFBQSxJQUFVK0I7QUFDekIsVUFBTThCLFNBQVMsSUFBSXZCLE1BQU13SCxLQUFBQTtBQUN6QixRQUFJcFIsR0FBR3VJLE1BQU1DLFFBQU90STtBQUVwQixTQUFLRixJQUFJLEdBQUd1SSxPQUFPNkksT0FBT3BSLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ3ZDd0ksTUFBQUEsU0FBUXhJLElBQUlaO0FBQ1pjLGFBQU9rSixLQUFLWixNQUFNO0FBQ2xCMkMsYUFBT25MLENBQUFBLElBQUs7UUFDVnVILEdBQUdGLE9BQU84SixNQUFNalIsS0FBSyxDQUFBLEdBQUlzSSxNQUFBQTtRQUN6QmhCLEdBQUdGLE9BQU82SixNQUFNalIsS0FBSyxDQUFBLEdBQUlzSSxNQUFBQTtNQUMzQjtJQUNGO0FBQ0EsV0FBTzJDO0VBQ1Q7RUFhQXNHLGdCQUFnQnBJLE1BQU1ELE1BQU1oSyxPQUFPZ1MsT0FBTztBQUN4QyxVQUFNLEVBQUMvSixRQUFRQyxPQUFBQSxJQUFVK0I7QUFDekIsVUFBTSxFQUFDMEksV0FBVyxLQUFLQyxXQUFXLElBQUEsSUFBTyxLQUFLdkU7QUFDOUMsVUFBTXRDLFNBQVMsSUFBSXZCLE1BQU13SCxLQUFBQTtBQUN6QixRQUFJcFIsR0FBR3VJLE1BQU1DLFFBQU90STtBQUVwQixTQUFLRixJQUFJLEdBQUd1SSxPQUFPNkksT0FBT3BSLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ3ZDd0ksTUFBQUEsU0FBUXhJLElBQUlaO0FBQ1pjLGFBQU9rSixLQUFLWixNQUFNO0FBQ2xCMkMsYUFBT25MLENBQUFBLElBQUs7UUFDVnVILEdBQUdGLE9BQU84SixNQUFNYyxpQkFBaUIvUixNQUFNNlIsUUFBV3ZKLEdBQUFBLE1BQUFBO1FBQ2xEaEIsR0FBR0YsT0FBTzZKLE1BQU1jLGlCQUFpQi9SLE1BQU04UixRQUFXeEosR0FBQUEsTUFBQUE7TUFDcEQ7SUFDRjtBQUNBLFdBQU8yQztFQUNUO0VBS0ErRyxVQUFVMUosUUFBTztBQUNmLFdBQU8sS0FBSzRDLFlBQVlzQixRQUFRbEUsTUFBTTtFQUN4QztFQUtBMkosZUFBZTNKLFFBQU87QUFDcEIsV0FBTyxLQUFLNEMsWUFBWWhDLEtBQUtaLE1BQU07RUFDckM7RUFLQUMsV0FBVzFCLE9BQU9vRSxRQUFRdEMsTUFBTTtBQUM5QixVQUFNdkssUUFBUSxLQUFLQTtBQUNuQixVQUFNK0ssT0FBTyxLQUFLK0I7QUFDbEIsVUFBTTVFLFFBQVEyRSxPQUFPcEUsTUFBTTBDLElBQUk7QUFDL0IsVUFBTWYsUUFBUTtNQUNaeEQsTUFBTWlELHdCQUF3QjdKLE9BQU8sSUFBSTtNQUN6Q3NILFFBQVF1RixPQUFPRSxRQUFRdEUsTUFBTTBDLElBQUksRUFBRW1DO0lBQ3JDO0FBQ0EsV0FBT25ELFdBQVdDLE9BQU9sQyxPQUFPNkMsS0FBS2IsT0FBTztNQUFDSztJQUFJLENBQUE7RUFDbkQ7RUFLQXVKLHNCQUFzQkMsT0FBT3RMLE9BQU9vRSxRQUFRekMsT0FBTztBQUNqRCxVQUFNNEosY0FBY25ILE9BQU9wRSxNQUFNMEMsSUFBSTtBQUNyQyxRQUFJakQsUUFBUThMLGdCQUFnQixPQUFPQyxNQUFNRDtBQUN6QyxVQUFNMU0sU0FBUzhDLFNBQVN5QyxPQUFPRSxRQUFRdEUsTUFBTTBDLElBQUk7QUFDakQsUUFBSWYsU0FBUzlDLFFBQVE7QUFDbkI4QyxZQUFNOUMsU0FBU0E7QUFDZlksY0FBUWlDLFdBQVdDLE9BQU80SixhQUFhLEtBQUtsSCxZQUFZNUMsS0FBSzs7QUFFL0Q2SixVQUFNbFQsTUFBTUQsS0FBS0MsSUFBSWtULE1BQU1sVCxLQUFLcUgsS0FBQUE7QUFDaEM2TCxVQUFNL1EsTUFBTXBDLEtBQUtvQyxJQUFJK1EsTUFBTS9RLEtBQUtrRixLQUFBQTtFQUNsQztFQUtBZ00sVUFBVXpMLE9BQU9pRyxVQUFVO0FBQ3pCLFVBQU0zRCxPQUFPLEtBQUsrQjtBQUNsQixVQUFNc0IsVUFBVXJELEtBQUtxRDtBQUNyQixVQUFNMkUsU0FBU2hJLEtBQUtpSSxXQUFXdkssVUFBVXNDLEtBQUtDO0FBQzlDLFVBQU1mLE9BQU9tRSxRQUFRM007QUFDckIsVUFBTTBTLGFBQWEsS0FBS3pDLGVBQWVqSixLQUFBQTtBQUN2QyxVQUFNMkIsUUFBUXFFLFlBQVlDLFVBQVUzRCxNQUFNLEtBQUsvSyxLQUFLO0FBQ3BELFVBQU0rVCxRQUFRO01BQUNsVCxLQUFLbUwsT0FBT0U7TUFBbUJsSixLQUFLZ0osT0FBT0M7SUFBaUI7QUFDM0UsVUFBTSxFQUFDcEwsS0FBS3VULFVBQVVwUixLQUFLcVIsU0FBUSxJQUFJeEksY0FBY3NJLFVBQUFBO0FBQ3JELFFBQUl6UyxHQUFHbUw7QUFFUCxhQUFTeUgsUUFBUTtBQUNmekgsZUFBU3VCLFFBQVExTSxDQUFFO0FBQ25CLFlBQU0rSSxhQUFhb0MsT0FBT3NILFdBQVdoSixJQUFJO0FBQ3pDLGFBQU8sQ0FBQ1IsZUFBU2tDLE9BQU9wRSxNQUFNMEMsSUFBSSxDQUFDLEtBQUtpSixXQUFXM0osY0FBYzRKLFdBQVc1SjtJQUM5RTtBQUVBLFNBQUsvSSxJQUFJLEdBQUdBLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ3pCLFVBQUk0UyxNQUFTLEdBQUE7QUFDWDs7QUFFRixXQUFLUixzQkFBc0JDLE9BQU90TCxPQUFPb0UsUUFBUXpDLEtBQUFBO0FBQ2pELFVBQUkySSxRQUFRO0FBRVY7O0lBRUo7QUFDQSxRQUFJQSxRQUFRO0FBRVYsV0FBS3JSLElBQUl1SSxPQUFPLEdBQUd2SSxLQUFLLEdBQUcsRUFBRUEsR0FBRztBQUM5QixZQUFJNFMsTUFBUyxHQUFBO0FBQ1g7O0FBRUYsYUFBS1Isc0JBQXNCQyxPQUFPdEwsT0FBT29FLFFBQVF6QyxLQUFBQTtBQUNqRDtNQUNGOztBQUVGLFdBQU8ySjtFQUNUO0VBRUFRLG1CQUFtQjlMLE9BQU87QUFDeEIsVUFBTW9FLFNBQVMsS0FBS0MsWUFBWXNCO0FBQ2hDLFVBQU05RyxTQUFTLENBQUE7QUFDZixRQUFJNUYsR0FBR3VJLE1BQU0vQjtBQUViLFNBQUt4RyxJQUFJLEdBQUd1SSxPQUFPNEMsT0FBT3BMLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQy9Dd0csY0FBUTJFLE9BQU9uTCxDQUFBQSxFQUFHK0csTUFBTTBDLElBQUk7QUFDNUIsVUFBSVIsZUFBU3pDLEtBQVEsR0FBQTtBQUNuQlosZUFBTzVFLEtBQUt3RixLQUFBQTs7SUFFaEI7QUFDQSxXQUFPWjtFQUNUO0VBTUFrTixpQkFBaUI7QUFDZixXQUFPO0VBQ1Q7RUFLQUMsaUJBQWlCdkssUUFBTztBQUN0QixVQUFNYSxPQUFPLEtBQUsrQjtBQUNsQixVQUFNOUIsU0FBU0QsS0FBS0M7QUFDcEIsVUFBTUMsU0FBU0YsS0FBS0U7QUFDcEIsVUFBTTRCLFNBQVMsS0FBSytHLFVBQVUxSixNQUFBQTtBQUM5QixXQUFPO01BQ0x3SyxPQUFPMUosU0FBUyxLQUFLQSxPQUFPMkosaUJBQWlCOUgsT0FBTzdCLE9BQU9HLElBQUksQ0FBQyxJQUFJO01BQ3BFakQsT0FBTytDLFNBQVMsS0FBS0EsT0FBTzBKLGlCQUFpQjlILE9BQU81QixPQUFPRSxJQUFJLENBQUMsSUFBSTtJQUN0RTtFQUNGO0VBS0FoSyxRQUFRb0osTUFBTTtBQUNaLFVBQU1RLE9BQU8sS0FBSytCO0FBQ2xCLFNBQUtwSCxPQUFPNkUsUUFBUSxTQUFBO0FBQ3BCUSxTQUFLNkosUUFBUXJMLE9BQU9vSCxlQUFlLEtBQUtuSixRQUFRcU4sTUFBTS9MLFlBQVlpQyxLQUFLaEMsUUFBUWdDLEtBQUsvQixRQUFRLEtBQUt3TCxlQUFjLENBQUEsQ0FBQSxDQUFBO0VBQ2pIO0VBS0E5TyxPQUFPNkUsTUFBTTtFQUFBO0VBRWI1SSxPQUFPO0FBQ0wsVUFBTW9OLE1BQU0sS0FBS0Q7QUFDakIsVUFBTTlPLFFBQVEsS0FBS0E7QUFDbkIsVUFBTStLLE9BQU8sS0FBSytCO0FBQ2xCLFVBQU1nSSxZQUFXL0osS0FBS0QsUUFBUSxDQUFBO0FBQzlCLFVBQU1pSyxPQUFPL1UsTUFBTWdWO0FBQ25CLFVBQU12UCxTQUFTLENBQUE7QUFDZixVQUFNM0UsUUFBUSxLQUFLeU8sY0FBYztBQUNqQyxVQUFNdUQsUUFBUSxLQUFLdEQsY0FBZXNGLFVBQVNyVCxTQUFTWDtBQUNwRCxVQUFNbVUsMEJBQTBCLEtBQUt6TixRQUFReU47QUFDN0MsUUFBSXZUO0FBRUosUUFBSXFKLEtBQUsrQyxTQUFTO0FBQ2hCL0MsV0FBSytDLFFBQVFuTSxLQUFLb04sS0FBS2dHLE1BQU1qVSxPQUFPZ1MsS0FBQUE7O0FBR3RDLFNBQUtwUixJQUFJWixPQUFPWSxJQUFJWixRQUFRZ1MsT0FBTyxFQUFFcFIsR0FBRztBQUN0QyxZQUFNc00sVUFBVThHLFVBQVNwVCxDQUFFO0FBQzNCLFVBQUlzTSxRQUFRVyxRQUFRO0FBQ2xCOztBQUVGLFVBQUlYLFFBQVF2SSxVQUFVd1AseUJBQXlCO0FBQzdDeFAsZUFBTy9DLEtBQUtzTCxPQUFBQTthQUNQO0FBQ0xBLGdCQUFRck0sS0FBS29OLEtBQUtnRyxJQUFBQTs7SUFFdEI7QUFFQSxTQUFLclQsSUFBSSxHQUFHQSxJQUFJK0QsT0FBT2hFLFFBQVEsRUFBRUMsR0FBRztBQUNsQytELGFBQU8vRCxDQUFBQSxFQUFHQyxLQUFLb04sS0FBS2dHLElBQUFBO0lBQ3RCO0VBQ0Y7RUFTQUcsU0FBU2hMLFFBQU96RSxRQUFRO0FBQ3RCLFVBQU04RSxPQUFPOUUsU0FBUyxXQUFXO0FBQ2pDLFdBQU95RSxXQUFVcEssVUFBYSxLQUFLZ04sWUFBWWdCLFVBQzNDLEtBQUtxSCw2QkFBNkI1SyxJQUFBQSxJQUNsQyxLQUFLNkssMEJBQTBCbEwsVUFBUyxHQUFHSyxJQUFLO0VBQ3REO0VBS0FvSSxXQUFXekksUUFBT3pFLFFBQVE4RSxNQUFNO0FBQzlCLFVBQU11RCxVQUFVLEtBQUt5QyxXQUFVO0FBQy9CLFFBQUk4RTtBQUNKLFFBQUluTCxVQUFTLEtBQUtBLFNBQVEsS0FBSzRDLFlBQVloQyxLQUFLckosUUFBUTtBQUN0RCxZQUFNdU0sVUFBVSxLQUFLbEIsWUFBWWhDLEtBQUtaLE1BQU07QUFDNUNtTCxnQkFBVXJILFFBQVEyQixhQUNmM0IsUUFBUTJCLFdBQVc1QixrQkFBa0IsS0FBSzRFLFdBQVUsR0FBSXpJLFFBQU84RCxPQUFPO0FBQ3pFcUgsY0FBUXhJLFNBQVMsS0FBSytHLFVBQVUxSixNQUFBQTtBQUNoQ21MLGNBQVFuSCxNQUFNSixRQUFRaEQsS0FBS1osTUFBTTtBQUNqQ21MLGNBQVFuTCxRQUFRbUwsUUFBUXBILFlBQVkvRDtXQUMvQjtBQUNMbUwsZ0JBQVUsS0FBSzFGLGFBQ1osS0FBS0EsV0FBV2hDLHFCQUFxQixLQUFLM04sTUFBTTJTLFdBQVUsR0FBSSxLQUFLekksS0FBSztBQUMzRW1MLGNBQVF2SCxVQUFVQTtBQUNsQnVILGNBQVFuTCxRQUFRbUwsUUFBUTdLLGVBQWUsS0FBS047O0FBRzlDbUwsWUFBUTVQLFNBQVMsQ0FBQyxDQUFDQTtBQUNuQjRQLFlBQVE5SyxPQUFPQTtBQUNmLFdBQU84SztFQUNUO0VBTUFGLDZCQUE2QjVLLE1BQU07QUFDakMsV0FBTyxLQUFLK0ssdUJBQXVCLEtBQUt6RixtQkFBbUJqRSxJQUFJckIsSUFBQUE7RUFDakU7RUFPQTZLLDBCQUEwQmxMLFFBQU9LLE1BQU07QUFDckMsV0FBTyxLQUFLK0ssdUJBQXVCLEtBQUt4RixnQkFBZ0JsRSxJQUFJckIsTUFBTUwsTUFBQUE7RUFDcEU7RUFLQW9MLHVCQUF1QkMsYUFBYWhMLE9BQU8sV0FBV0wsUUFBTztBQUMzRCxVQUFNekUsU0FBUzhFLFNBQVM7QUFDeEIsVUFBTWlMLFFBQVEsS0FBS3hHO0FBQ25CLFVBQU15RyxXQUFXRixjQUFjLE1BQU1oTDtBQUNyQyxVQUFNZ0UsU0FBU2lILE1BQU1DLFFBQVM7QUFDOUIsVUFBTUMsVUFBVSxLQUFLakcsdUJBQXVCa0csUUFBUXpMLE1BQUFBO0FBQ3BELFFBQUlxRSxRQUFRO0FBQ1YsYUFBT0QsaUJBQWlCQyxRQUFRbUgsT0FBQUE7O0FBRWxDLFVBQU1yUCxTQUFTLEtBQUtyRyxNQUFNcUc7QUFDMUIsVUFBTWlNLFlBQVlqTSxPQUFPdVAsd0JBQXdCLEtBQUsxRyxPQUFPcUcsV0FBQUE7QUFDN0QsVUFBTU0sV0FBV3BRLFNBQVM7TUFBQyxHQUFHOFAsV0FBWTtNQUFRO01BQVNBO01BQWE7UUFBTTtNQUFDQTtNQUFhO0lBQUc7QUFDL0YsVUFBTS9DLFNBQVNuTSxPQUFPb00sZ0JBQWdCLEtBQUtsQyxXQUFVLEdBQUkrQixTQUFBQTtBQUN6RCxVQUFNd0QsU0FBUW5QLE9BQU9DLEtBQUtDLFNBQVNpTyxTQUFTUyxXQUFZLENBQUE7QUFHeEQsVUFBTUYsVUFBVSxNQUFNLEtBQUsxQyxXQUFXekksUUFBT3pFLFFBQVE4RSxJQUFBQTtBQUNyRCxVQUFNakQsU0FBU2pCLE9BQU8wUCxvQkFBb0J2RCxRQUFRc0QsUUFBT1QsU0FBU1EsUUFBQUE7QUFFbEUsUUFBSXZPLE9BQU9NLFNBQVM7QUFHbEJOLGFBQU9NLFVBQVU4TjtBQUtqQkYsWUFBTUMsUUFBUyxJQUFHOU8sT0FBT3FQLE9BQU8xSCxpQkFBaUJoSCxRQUFRb08sT0FBQUEsQ0FBQUE7O0FBRzNELFdBQU9wTztFQUNUO0VBTUEyTyxtQkFBbUIvTCxRQUFPZ00sWUFBWXpRLFFBQVE7QUFDNUMsVUFBTXpGLFFBQVEsS0FBS0E7QUFDbkIsVUFBTXdWLFFBQVEsS0FBS3hHO0FBQ25CLFVBQU15RyxXQUFXLGFBQWFTLFVBQUFBO0FBQzlCLFVBQU0zSCxTQUFTaUgsTUFBTUMsUUFBUztBQUM5QixRQUFJbEgsUUFBUTtBQUNWLGFBQU9BOztBQUVULFFBQUkvRztBQUNKLFFBQUl4SCxNQUFNd0gsUUFBUVYsY0FBYyxPQUFPO0FBQ3JDLFlBQU1ULFNBQVMsS0FBS3JHLE1BQU1xRztBQUMxQixZQUFNaU0sWUFBWWpNLE9BQU84UCwwQkFBMEIsS0FBS2pILE9BQU9nSCxVQUFBQTtBQUMvRCxZQUFNMUQsU0FBU25NLE9BQU9vTSxnQkFBZ0IsS0FBS2xDLFdBQVUsR0FBSStCLFNBQUFBO0FBQ3pEOUssTUFBQUEsV0FBVW5CLE9BQU9xTSxlQUFlRixRQUFRLEtBQUtHLFdBQVd6SSxRQUFPekUsUUFBUXlRLFVBQUFBLENBQUFBOztBQUV6RSxVQUFNeE8sYUFBYSxJQUFJdEIsV0FBV3BHLE9BQU93SCxZQUFXQSxTQUFRRSxVQUFVO0FBQ3RFLFFBQUlGLFlBQVdBLFNBQVE0TyxZQUFZO0FBQ2pDWixZQUFNQyxRQUFBQSxJQUFZOU8sT0FBT3FQLE9BQU90TyxVQUFBQTs7QUFFbEMsV0FBT0E7RUFDVDtFQU1BMk8saUJBQWlCN08sVUFBUztBQUN4QixRQUFJLENBQUNBLFNBQVFJLFNBQVM7QUFDcEI7O0FBRUYsV0FBTyxLQUFLMEgsbUJBQW1CLEtBQUtBLGlCQUFpQjNJLE9BQU95QixPQUFPLENBQUEsR0FBSVosUUFBTztFQUNoRjtFQU1BOE8sZUFBZS9MLE1BQU1nTSxlQUFlO0FBQ2xDLFdBQU8sQ0FBQ0EsaUJBQWlCbEksbUJBQW1COUQsSUFBQUEsS0FBUyxLQUFLdkssTUFBTXdXO0VBQ2xFO0VBS0FDLGtCQUFrQjNWLE9BQU95SixNQUFNO0FBQzdCLFVBQU1tTSxZQUFZLEtBQUt0QiwwQkFBMEJ0VSxPQUFPeUosSUFBQUE7QUFDeEQsVUFBTW9NLDBCQUEwQixLQUFLckg7QUFDckMsVUFBTWlILGdCQUFnQixLQUFLRixpQkFBaUJLLFNBQUFBO0FBQzVDLFVBQU1KLGlCQUFpQixLQUFLQSxlQUFlL0wsTUFBTWdNLGFBQUFBLEtBQW1CQSxrQkFBa0JJO0FBQ3RGLFNBQUtDLG9CQUFvQkwsZUFBZWhNLE1BQU1tTSxTQUFBQTtBQUM5QyxXQUFPO01BQUNIO01BQWVEO0lBQWM7RUFDdkM7RUFNQU8sY0FBYzdJLFNBQVM5RCxRQUFPOUMsWUFBWW1ELE1BQU07QUFDOUMsUUFBSThELG1CQUFtQjlELElBQU8sR0FBQTtBQUM1QjVELGFBQU95QixPQUFPNEYsU0FBUzVHLFVBQUFBO1dBQ2xCO0FBQ0wsV0FBSzZPLG1CQUFtQi9MLFFBQU9LLElBQU03RSxFQUFBQSxPQUFPc0ksU0FBUzVHLFVBQUFBOztFQUV6RDtFQU1Bd1Asb0JBQW9CTCxlQUFlaE0sTUFBTWhELFlBQVk7QUFDbkQsUUFBSWdQLGlCQUFpQixDQUFDbEksbUJBQW1COUQsSUFBTyxHQUFBO0FBQzlDLFdBQUswTCxtQkFBbUJuVyxRQUFXeUssSUFBTTdFLEVBQUFBLE9BQU82USxlQUFlaFAsVUFBQUE7O0VBRW5FO0VBS0F1UCxVQUFVOUksU0FBUzlELFFBQU9LLE1BQU05RSxRQUFRO0FBQ3RDdUksWUFBUXZJLFNBQVNBO0FBQ2pCLFVBQU0rQixXQUFVLEtBQUswTixTQUFTaEwsUUFBT3pFLE1BQUFBO0FBQ3JDLFNBQUt3USxtQkFBbUIvTCxRQUFPSyxNQUFNOUUsTUFBUUMsRUFBQUEsT0FBT3NJLFNBQVM7TUFHM0R4RyxTQUFTLENBQUUvQixVQUFVLEtBQUs0USxpQkFBaUI3TyxRQUFhQSxLQUFBQTtJQUMxRCxDQUFBO0VBQ0Y7RUFFQXVQLGlCQUFpQi9JLFNBQVN4RCxjQUFjTixRQUFPO0FBQzdDLFNBQUs0TSxVQUFVOUksU0FBUzlELFFBQU8sVUFBVSxLQUFLO0VBQ2hEO0VBRUE4TSxjQUFjaEosU0FBU3hELGNBQWNOLFFBQU87QUFDMUMsU0FBSzRNLFVBQVU5SSxTQUFTOUQsUUFBTyxVQUFVLElBQUk7RUFDL0M7RUFLQStNLDJCQUEyQjtBQUN6QixVQUFNakosVUFBVSxLQUFLbEIsWUFBWWdCO0FBRWpDLFFBQUlFLFNBQVM7QUFDWCxXQUFLOEksVUFBVTlJLFNBQVNsTyxRQUFXLFVBQVUsS0FBSzs7RUFFdEQ7RUFLQW9YLHdCQUF3QjtBQUN0QixVQUFNbEosVUFBVSxLQUFLbEIsWUFBWWdCO0FBRWpDLFFBQUlFLFNBQVM7QUFDWCxXQUFLOEksVUFBVTlJLFNBQVNsTyxRQUFXLFVBQVUsSUFBSTs7RUFFckQ7RUFLQXVTLGdCQUFnQkgsa0JBQWtCO0FBQ2hDLFVBQU1wSCxPQUFPLEtBQUtzRTtBQUNsQixVQUFNMEYsWUFBVyxLQUFLaEksWUFBWWhDO0FBR2xDLGVBQVcsQ0FBQzNFLFFBQVFnUixNQUFNQyxJQUFBQSxLQUFTLEtBQUt4SCxXQUFXO0FBQ2pELFdBQUt6SixNQUFPLEVBQUNnUixNQUFNQyxJQUFBQTtJQUNyQjtBQUNBLFNBQUt4SCxZQUFZLENBQUE7QUFFakIsVUFBTXlILFVBQVV2QyxVQUFTclQ7QUFDekIsVUFBTTZWLFVBQVV4TSxLQUFLcko7QUFDckIsVUFBTXFSLFFBQVFsUyxLQUFLQyxJQUFJeVcsU0FBU0QsT0FBQUE7QUFFaEMsUUFBSXZFLE9BQU87QUFLVCxXQUFLRCxNQUFNLEdBQUdDLEtBQUFBOztBQUdoQixRQUFJd0UsVUFBVUQsU0FBUztBQUNyQixXQUFLRSxnQkFBZ0JGLFNBQVNDLFVBQVVELFNBQVNuRixnQkFBQUE7ZUFDeENvRixVQUFVRCxTQUFTO0FBQzVCLFdBQUtHLGdCQUFnQkYsU0FBU0QsVUFBVUMsT0FBQUE7O0VBRTVDO0VBS0FDLGdCQUFnQnpXLE9BQU9nUyxPQUFPWixtQkFBbUIsTUFBTTtBQUNyRCxVQUFNbkgsT0FBTyxLQUFLK0I7QUFDbEIsVUFBTWhDLE9BQU9DLEtBQUtEO0FBQ2xCLFVBQU1qQyxNQUFNL0gsUUFBUWdTO0FBQ3BCLFFBQUlwUjtBQUVKLFVBQU0rVixPQUFPLENBQUNDLFFBQVE7QUFDcEJBLFVBQUlqVyxVQUFVcVI7QUFDZCxXQUFLcFIsSUFBSWdXLElBQUlqVyxTQUFTLEdBQUdDLEtBQUttSCxLQUFLbkgsS0FBSztBQUN0Q2dXLFlBQUloVyxDQUFFLElBQUdnVyxJQUFJaFcsSUFBSW9SLEtBQU07TUFDekI7SUFDRjtBQUNBMkUsU0FBSzNNLElBQUFBO0FBRUwsU0FBS3BKLElBQUlaLE9BQU9ZLElBQUltSCxLQUFLLEVBQUVuSCxHQUFHO0FBQzVCb0osV0FBS3BKLENBQUUsSUFBRyxJQUFJLEtBQUtvTyxnQkFBZTtJQUNwQztBQUVBLFFBQUksS0FBS1gsVUFBVTtBQUNqQnNJLFdBQUsxTSxLQUFLcUQsT0FBTzs7QUFFbkIsU0FBS3lFLE1BQU0vUixPQUFPZ1MsS0FBQUE7QUFFbEIsUUFBSVosa0JBQWtCO0FBQ3BCLFdBQUt5RixlQUFlN00sTUFBTWhLLE9BQU9nUyxPQUFPLE9BQUE7O0VBRTVDO0VBRUE2RSxlQUFlM0osU0FBU2xOLE9BQU9nUyxPQUFPdkksTUFBTTtFQUFBO0VBSzVDaU4sZ0JBQWdCMVcsT0FBT2dTLE9BQU87QUFDNUIsVUFBTS9ILE9BQU8sS0FBSytCO0FBQ2xCLFFBQUksS0FBS3FDLFVBQVU7QUFDakIsWUFBTXlJLFVBQVU3TSxLQUFLcUQsUUFBUXlKLE9BQU8vVyxPQUFPZ1MsS0FBQUE7QUFDM0MsVUFBSS9ILEtBQUs2RCxVQUFVO0FBQ2pCVCxvQkFBWXBELE1BQU02TSxPQUFBQTs7O0FBR3RCN00sU0FBS0QsS0FBSytNLE9BQU8vVyxPQUFPZ1MsS0FBQUE7RUFDMUI7RUFLQWdGLE1BQU1DLE1BQU07QUFDVixRQUFJLEtBQUs1SSxVQUFVO0FBQ2pCLFdBQUtTLFVBQVVsTixLQUFLcVYsSUFBQUE7V0FDZjtBQUNMLFlBQU0sQ0FBQzVSLFFBQVFnUixNQUFNQyxJQUFBQSxJQUFRVztBQUM3QixXQUFLNVIsTUFBTyxFQUFDZ1IsTUFBTUMsSUFBQUE7O0FBRXJCLFNBQUtwWCxNQUFNZ1ksYUFBYXRWLEtBQUs7TUFBQyxLQUFLd0g7TUFBVTZOLEdBQUFBO0lBQUssQ0FBQTtFQUNwRDtFQUVBRSxjQUFjO0FBQ1osVUFBTW5GLFFBQVFvRixVQUFVelc7QUFDeEIsU0FBS3FXLE1BQU07TUFBQztNQUFtQixLQUFLdkgsV0FBVSxFQUFHekYsS0FBS3JKLFNBQVNxUjtNQUFPQTtJQUFNLENBQUE7RUFDOUU7RUFFQXFGLGFBQWE7QUFDWCxTQUFLTCxNQUFNO01BQUM7TUFBbUIsS0FBS2hMLFlBQVloQyxLQUFLckosU0FBUztNQUFHO0lBQUUsQ0FBQTtFQUNyRTtFQUVBMlcsZUFBZTtBQUNiLFNBQUtOLE1BQU07TUFBQztNQUFtQjtNQUFHO0lBQUUsQ0FBQTtFQUN0QztFQUVBTyxjQUFjdlgsT0FBT2dTLE9BQU87QUFDMUIsUUFBSUEsT0FBTztBQUNULFdBQUtnRixNQUFNO1FBQUM7UUFBbUJoWDtRQUFPZ1M7TUFBTSxDQUFBOztBQUU5QyxVQUFNd0YsV0FBV0osVUFBVXpXLFNBQVM7QUFDcEMsUUFBSTZXLFVBQVU7QUFDWixXQUFLUixNQUFNO1FBQUM7UUFBbUJoWDtRQUFPd1g7TUFBUyxDQUFBOztFQUVuRDtFQUVBQyxpQkFBaUI7QUFDZixTQUFLVCxNQUFNO01BQUM7TUFBbUI7TUFBR0ksVUFBVXpXO0lBQU8sQ0FBQTtFQUNyRDtBQUNGO0FBdDBCRSxjQUxtQm9OLG1CQUtaaEksWUFBVyxDQUFBO0FBS2xCLGNBVm1CZ0ksbUJBVVpnQixzQkFBcUI7QUFLNUIsY0FmbUJoQixtQkFlWmlCLG1CQUFrQjtBQ2xQM0IsU0FBUzBJLGtCQUFrQi9QLE9BQU90SSxNQUFNO0FBQ3RDLE1BQUksQ0FBQ3NJLE1BQU1nUSxPQUFPQyxNQUFNO0FBQ3RCLFVBQU1DLGVBQWVsUSxNQUFNaUUsd0JBQXdCdk0sSUFBQUE7QUFDbkQsUUFBSW1ILFNBQVMsQ0FBQTtBQUViLGFBQVM1RixJQUFJLEdBQUd1SSxPQUFPME8sYUFBYWxYLFFBQVFDLElBQUl1SSxNQUFNdkksS0FBSztBQUN6RDRGLGVBQVNBLE9BQU9zUixPQUFPRCxhQUFhalgsQ0FBQUEsRUFBR2tMLFdBQVcySCxtQkFBbUI5TCxLQUFBQSxDQUFBQTtJQUN2RTtBQUNBQSxVQUFNZ1EsT0FBT0MsT0FBT0csYUFBYXZSLE9BQU93UixLQUFLLENBQUNDLEdBQUdyUCxNQUFNcVAsSUFBSXJQLENBQUFBLENBQUFBOztBQUU3RCxTQUFPakIsTUFBTWdRLE9BQU9DO0FBQ3RCO0FBTUEsU0FBU00scUJBQXFCak8sTUFBTTtBQUNsQyxRQUFNdEMsUUFBUXNDLEtBQUtDO0FBQ25CLFFBQU0xRCxTQUFTa1Isa0JBQWtCL1AsT0FBT3NDLEtBQUs1SyxJQUFJO0FBQ2pELE1BQUlVLE1BQU00SCxNQUFNd1E7QUFDaEIsTUFBSXZYLEdBQUd1SSxNQUFNaVAsTUFBTWpHO0FBQ25CLFFBQU1rRyxtQkFBbUIsTUFBTTtBQUM3QixRQUFJRCxTQUFTLFNBQVNBLFNBQVMsUUFBUTtBQUVyQzs7QUFFRixRQUFJdkQsUUFBUTFDLElBQU8sR0FBQTtBQUVqQnBTLFlBQU1ELEtBQUtDLElBQUlBLEtBQUtELEtBQUt3WSxJQUFJRixPQUFPakcsSUFBU3BTLEtBQUFBLEdBQUFBOztBQUUvQ29TLFdBQU9pRztFQUNUO0FBRUEsT0FBS3hYLElBQUksR0FBR3VJLE9BQU8zQyxPQUFPN0YsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDL0N3WCxXQUFPelEsTUFBTTRRLGlCQUFpQi9SLE9BQU81RixDQUFFLENBQUE7QUFDdkN5WCxxQkFBQUE7RUFDRjtBQUVBbEcsU0FBT25UO0FBQ1AsT0FBSzRCLElBQUksR0FBR3VJLE9BQU94QixNQUFNNlEsTUFBTTdYLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ3BEd1gsV0FBT3pRLE1BQU04USxnQkFBZ0I3WCxDQUFBQTtBQUM3QnlYLHFCQUFBQTtFQUNGO0FBRUEsU0FBT3RZO0FBQ1Q7QUFRQSxTQUFTMlkseUJBQXlCdFAsUUFBT3VQLE9BQU9qUyxVQUFTa1MsWUFBWTtBQUNuRSxRQUFNQyxZQUFZblMsU0FBUW9TO0FBQzFCLE1BQUl6UixNQUFNMFI7QUFFVixNQUFJQyxjQUFjSCxTQUFZLEdBQUE7QUFDNUJ4UixXQUFPc1IsTUFBTTVZLE1BQU0yRyxTQUFRdVM7QUFDM0JGLFlBQVFyUyxTQUFRd1M7U0FDWDtBQUlMN1IsV0FBT3dSLFlBQVlEO0FBQ25CRyxZQUFROztBQUdWLFNBQU87SUFDTEksT0FBTzlSLE9BQU91UjtJQUNkRztJQUNBL1ksT0FBTzJZLE1BQU1TLE9BQU9oUSxNQUFBQSxJQUFVL0IsT0FBTztFQUN2QztBQUNGO0FBUUEsU0FBU2dTLDBCQUEwQmpRLFFBQU91UCxPQUFPalMsVUFBU2tTLFlBQVk7QUFDcEUsUUFBTVEsU0FBU1QsTUFBTVM7QUFDckIsUUFBTWhCLE9BQU9nQixPQUFPaFEsTUFBTTtBQUMxQixNQUFJK0ksT0FBTy9JLFNBQVEsSUFBSWdRLE9BQU9oUSxTQUFRLENBQUEsSUFBSztBQUMzQyxNQUFJa1EsT0FBT2xRLFNBQVFnUSxPQUFPelksU0FBUyxJQUFJeVksT0FBT2hRLFNBQVEsQ0FBRSxJQUFHO0FBQzNELFFBQU1tUSxVQUFVN1MsU0FBUXVTO0FBRXhCLE1BQUk5RyxTQUFTLE1BQU07QUFHakJBLFdBQU9pRyxRQUFRa0IsU0FBUyxPQUFPWCxNQUFNNVEsTUFBTTRRLE1BQU0zWSxRQUFRc1osT0FBT2xCOztBQUdsRSxNQUFJa0IsU0FBUyxNQUFNO0FBRWpCQSxXQUFPbEIsT0FBT0EsT0FBT2pHOztBQUd2QixRQUFNblMsUUFBUW9ZLFFBQVFBLE9BQU90WSxLQUFLQyxJQUFJb1MsTUFBTW1ILElBQUksS0FBSyxJQUFJQztBQUN6RCxRQUFNbFMsT0FBT3ZILEtBQUt3WSxJQUFJZ0IsT0FBT25ILElBQUFBLElBQVEsSUFBSW9IO0FBRXpDLFNBQU87SUFDTEosT0FBTzlSLE9BQU91UjtJQUNkRyxPQUFPclMsU0FBUXdTO0lBQ2ZsWjtFQUNGO0FBQ0Y7QUFFQSxTQUFTd1osY0FBY0MsT0FBTzNZLE1BQU1xSixRQUFRdkosR0FBRztBQUM3QyxRQUFNOFksYUFBYXZQLE9BQU80SCxNQUFNMEgsTUFBTSxDQUFBLEdBQUk3WSxDQUFBQTtBQUMxQyxRQUFNK1ksV0FBV3hQLE9BQU80SCxNQUFNMEgsTUFBTSxDQUFBLEdBQUk3WSxDQUFBQTtBQUN4QyxRQUFNYixNQUFNRCxLQUFLQyxJQUFJMlosWUFBWUMsUUFBQUE7QUFDakMsUUFBTXpYLE1BQU1wQyxLQUFLb0MsSUFBSXdYLFlBQVlDLFFBQUFBO0FBQ2pDLE1BQUlDLFdBQVc3WjtBQUNmLE1BQUk4WixTQUFTM1g7QUFFYixNQUFJcEMsS0FBS3dZLElBQUl2WSxHQUFBQSxJQUFPRCxLQUFLd1ksSUFBSXBXLEdBQU0sR0FBQTtBQUNqQzBYLGVBQVcxWDtBQUNYMlgsYUFBUzlaOztBQUtYZSxPQUFLcUosT0FBT0UsSUFBSSxJQUFJd1A7QUFFcEIvWSxPQUFLZ1osVUFBVTtJQUNiRjtJQUNBQztJQUNBN1osT0FBTzBaO0lBQ1AzUixLQUFLNFI7SUFDTDVaO0lBQ0FtQztFQUNGO0FBQ0Y7QUFFQSxTQUFTNlgsV0FBV04sT0FBTzNZLE1BQU1xSixRQUFRdkosR0FBRztBQUMxQyxNQUFJeUYsUUFBUW9ULEtBQVEsR0FBQTtBQUNsQkQsa0JBQWNDLE9BQU8zWSxNQUFNcUosUUFBUXZKLENBQUFBO1NBQzlCO0FBQ0xFLFNBQUtxSixPQUFPRSxJQUFJLElBQUlGLE9BQU80SCxNQUFNMEgsT0FBTzdZLENBQUFBOztBQUUxQyxTQUFPRTtBQUNUO0FBRUEsU0FBU2taLHNCQUFzQi9QLE1BQU1ELE1BQU1oSyxPQUFPZ1MsT0FBTztBQUN2RCxRQUFNOUgsU0FBU0QsS0FBS0M7QUFDcEIsUUFBTUMsU0FBU0YsS0FBS0U7QUFDcEIsUUFBTXFJLFNBQVN0SSxPQUFPdUksVUFBUztBQUMvQixRQUFNQyxjQUFjeEksV0FBV0M7QUFDL0IsUUFBTTRCLFNBQVMsQ0FBQTtBQUNmLE1BQUluTCxHQUFHdUksTUFBTXJJLE1BQU0yWTtBQUVuQixPQUFLN1ksSUFBSVosT0FBT21KLE9BQU9uSixRQUFRZ1MsT0FBT3BSLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ25ENlksWUFBUXpQLEtBQUtwSixDQUFFO0FBQ2ZFLFdBQU8sQ0FBQTtBQUNQQSxTQUFLb0osT0FBT0csSUFBSSxJQUFJcUksZUFBZXhJLE9BQU82SCxNQUFNUyxPQUFPNVIsQ0FBQUEsR0FBSUEsQ0FBQUE7QUFDM0RtTCxXQUFPbkssS0FBS21ZLFdBQVdOLE9BQU8zWSxNQUFNcUosUUFBUXZKLENBQUFBLENBQUFBO0VBQzlDO0FBQ0EsU0FBT21MO0FBQ1Q7QUFFQSxTQUFTa08sV0FBV0MsU0FBUTtBQUMxQixTQUFPQSxXQUFVQSxRQUFPTixhQUFhNWEsVUFBYWtiLFFBQU9MLFdBQVc3YTtBQUN0RTtBQUVBLFNBQVNtYixRQUFROVMsTUFBTThDLFFBQVFpUSxZQUFZO0FBQ3pDLE1BQUkvUyxTQUFTLEdBQUc7QUFDZCxXQUFPeUMsS0FBS3pDLElBQUFBOztBQUVkLFVBQVE4QyxPQUFPa1EsYUFBWSxJQUFLLElBQUksT0FBT2xRLE9BQU9wSyxPQUFPcWEsYUFBYSxJQUFJO0FBQzVFO0FBRUEsU0FBU0UsWUFBWWhVLFlBQVk7QUFDL0IsTUFBSXdCLFNBQVM5SCxPQUFPK0gsS0FBS00sS0FBS0U7QUFDOUIsTUFBSWpDLFdBQVdpVSxZQUFZO0FBQ3pCelMsY0FBVXhCLFdBQVdrVSxPQUFPbFUsV0FBVzZCO0FBQ3ZDbkksWUFBUTtBQUNSK0gsVUFBTTtTQUNEO0FBQ0xELGNBQVV4QixXQUFXa1UsT0FBT2xVLFdBQVc4QjtBQUN2Q3BJLFlBQVE7QUFDUitILFVBQU07O0FBRVIsTUFBSUQsU0FBUztBQUNYTyxVQUFNO0FBQ05FLGFBQVM7U0FDSjtBQUNMRixVQUFNO0FBQ05FLGFBQVM7O0FBRVgsU0FBTztJQUFDdkk7SUFBTytIO0lBQUtEO0lBQVNPO0lBQUtFO0VBQU07QUFDMUM7QUFFQSxTQUFTa1MsaUJBQWlCblUsWUFBWUksVUFBUzRDLE9BQU9GLFFBQU87QUFDM0QsTUFBSXNSLE9BQU9oVSxTQUFRaVU7QUFDbkIsUUFBTXpWLE1BQU0sQ0FBQTtBQUVaLE1BQUksQ0FBQ3dWLE1BQU07QUFDVHBVLGVBQVdxVSxnQkFBZ0J6VjtBQUMzQjs7QUFHRixNQUFJd1YsU0FBUyxNQUFNO0FBQ2pCcFUsZUFBV3FVLGdCQUFnQjtNQUFDdFMsS0FBSztNQUFNQyxPQUFPO01BQU1DLFFBQVE7TUFBTUMsTUFBTTtJQUFJO0FBQzVFOztBQUdGLFFBQU0sRUFBQ3hJLE9BQU8rSCxLQUFLRCxTQUFTTyxLQUFLRSxPQUFBQSxJQUFVK1IsWUFBWWhVLFVBQUFBO0FBRXZELE1BQUlvVSxTQUFTLFlBQVlwUixPQUFPO0FBQzlCaEQsZUFBV3NVLHFCQUFxQjtBQUNoQyxTQUFLdFIsTUFBTStDLFFBQVEsT0FBT2pELFFBQU87QUFDL0JzUixhQUFPclM7Z0JBQ0dpQixNQUFNZ0QsV0FBVyxPQUFPbEQsUUFBTztBQUN6Q3NSLGFBQU9uUztXQUNGO0FBQ0xyRCxVQUFJMlYsVUFBVXRTLFFBQVF2SSxPQUFPK0gsS0FBS0QsT0FBQUEsQ0FBQUEsSUFBWTtBQUM5QzRTLGFBQU9yUzs7O0FBSVhuRCxNQUFJMlYsVUFBVUgsTUFBTTFhLE9BQU8rSCxLQUFLRCxPQUFBQSxDQUFBQSxJQUFZO0FBQzVDeEIsYUFBV3FVLGdCQUFnQnpWO0FBQzdCO0FBRUEsU0FBUzJWLFVBQVVILE1BQU16QyxHQUFHclAsR0FBR2QsU0FBUztBQUN0QyxNQUFJQSxTQUFTO0FBQ1g0UyxXQUFPSSxLQUFLSixNQUFNekMsR0FBR3JQLENBQUFBO0FBQ3JCOFIsV0FBT0ssU0FBU0wsTUFBTTlSLEdBQUdxUCxDQUFBQTtTQUNwQjtBQUNMeUMsV0FBT0ssU0FBU0wsTUFBTXpDLEdBQUdyUCxDQUFBQTs7QUFFM0IsU0FBTzhSO0FBQ1Q7QUFFQSxTQUFTSSxLQUFLRSxNQUFNQyxJQUFJQyxJQUFJO0FBQzFCLFNBQU9GLFNBQVNDLEtBQUtDLEtBQUtGLFNBQVNFLEtBQUtELEtBQUtEO0FBQy9DO0FBRUEsU0FBU0QsU0FBU0ksR0FBR25iLE9BQU8rSCxLQUFLO0FBQy9CLFNBQU9vVCxNQUFNLFVBQVVuYixRQUFRbWIsTUFBTSxRQUFRcFQsTUFBTW9UO0FBQ3JEO0FBRUEsU0FBU0MsaUJBQWlCOVUsWUFBWSxFQUFDK1UsY0FBQUEsR0FBZ0J0QyxPQUFPO0FBQzVEelMsYUFBVytVLGdCQUFnQkEsa0JBQWtCLFNBQ3pDdEMsVUFBVSxJQUFJLE9BQU8sSUFDckJzQztBQUNOO0FBRWUsSUFBTUMsZ0JBQU4sY0FBNEJ2TixrQkFBQUE7RUFnRHpDdUUsbUJBQW1CckksTUFBTUQsTUFBTWhLLE9BQU9nUyxPQUFPO0FBQzNDLFdBQU9nSSxzQkFBc0IvUCxNQUFNRCxNQUFNaEssT0FBT2dTLEtBQUFBO0VBQ2xEO0VBT0FJLGVBQWVuSSxNQUFNRCxNQUFNaEssT0FBT2dTLE9BQU87QUFDdkMsV0FBT2dJLHNCQUFzQi9QLE1BQU1ELE1BQU1oSyxPQUFPZ1MsS0FBQUE7RUFDbEQ7RUFPQUssZ0JBQWdCcEksTUFBTUQsTUFBTWhLLE9BQU9nUyxPQUFPO0FBQ3hDLFVBQU0sRUFBQzlILFFBQVFDLE9BQUFBLElBQVVGO0FBQ3pCLFVBQU0sRUFBQzBJLFdBQVcsS0FBS0MsV0FBVyxJQUFBLElBQU8sS0FBS3ZFO0FBQzlDLFVBQU1qRSxXQUFXRixPQUFPRyxTQUFTLE1BQU1zSSxXQUFXQztBQUNsRCxVQUFNdEksV0FBV0gsT0FBT0UsU0FBUyxNQUFNc0ksV0FBV0M7QUFDbEQsVUFBTTdHLFNBQVMsQ0FBQTtBQUNmLFFBQUluTCxHQUFHdUksTUFBTXJJLE1BQU15YTtBQUNuQixTQUFLM2EsSUFBSVosT0FBT21KLE9BQU9uSixRQUFRZ1MsT0FBT3BSLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ25EMmEsWUFBTXZSLEtBQUtwSixDQUFFO0FBQ2JFLGFBQU8sQ0FBQTtBQUNQQSxXQUFLb0osT0FBT0csSUFBSSxJQUFJSCxPQUFPNkgsTUFBTWMsaUJBQWlCMEksS0FBS25SLFFBQVd4SixHQUFBQSxDQUFBQTtBQUNsRW1MLGFBQU9uSyxLQUFLbVksV0FBV2xILGlCQUFpQjBJLEtBQUtqUixRQUFBQSxHQUFXeEosTUFBTXFKLFFBQVF2SixDQUFBQSxDQUFBQTtJQUN4RTtBQUNBLFdBQU9tTDtFQUNUO0VBS0FpSCxzQkFBc0JDLE9BQU90TCxPQUFPb0UsUUFBUXpDLE9BQU87QUFDakQsVUFBTTBKLHNCQUFzQkMsT0FBT3RMLE9BQU9vRSxRQUFRekMsS0FBQUE7QUFDbEQsVUFBTTRRLFVBQVNuTyxPQUFPK047QUFDdEIsUUFBSUksV0FBVXZTLFVBQVUsS0FBS3FFLFlBQVk3QixRQUFRO0FBRS9DOEksWUFBTWxULE1BQU1ELEtBQUtDLElBQUlrVCxNQUFNbFQsS0FBS21hLFFBQU9uYSxHQUFHO0FBQzFDa1QsWUFBTS9RLE1BQU1wQyxLQUFLb0MsSUFBSStRLE1BQU0vUSxLQUFLZ1ksUUFBT2hZLEdBQUc7O0VBRTlDO0VBTUF3UixpQkFBaUI7QUFDZixXQUFPO0VBQ1Q7RUFLQUMsaUJBQWlCdkssUUFBTztBQUN0QixVQUFNYSxPQUFPLEtBQUsrQjtBQUNsQixVQUFNLEVBQUM5QixRQUFRQyxPQUFBQSxJQUFVRjtBQUN6QixVQUFNOEIsU0FBUyxLQUFLK0csVUFBVTFKLE1BQUFBO0FBQzlCLFVBQU04USxVQUFTbk8sT0FBTytOO0FBQ3RCLFVBQU0xUyxRQUFRNlMsV0FBV0MsT0FDckIsSUFBQSxNQUFNQSxRQUFPbGEsUUFBUSxPQUFPa2EsUUFBT25TLE1BQU0sTUFDekMsS0FBS29DLE9BQU8wSixpQkFBaUI5SCxPQUFPNUIsT0FBT0UsSUFBSSxDQUFDO0FBRXBELFdBQU87TUFDTHVKLE9BQU8sS0FBSzFKLE9BQU8ySixpQkFBaUI5SCxPQUFPN0IsT0FBT0csSUFBSSxDQUFDO01BQ3ZEakQ7SUFDRjtFQUNGO0VBRUE2SCxhQUFhO0FBQ1gsU0FBS04sc0JBQXNCO0FBRTNCLFVBQU1NLFdBQVU7QUFFaEIsVUFBTWhGLE9BQU8sS0FBSytCO0FBQ2xCL0IsU0FBS1gsUUFBUSxLQUFLbUcsV0FBVSxFQUFHbkc7RUFDakM7RUFFQTFFLE9BQU82RSxNQUFNO0FBQ1gsVUFBTVEsT0FBTyxLQUFLK0I7QUFDbEIsU0FBSzZLLGVBQWU1TSxLQUFLRCxNQUFNLEdBQUdDLEtBQUtELEtBQUtySixRQUFROEksSUFBQUE7RUFDdEQ7RUFFQW9OLGVBQWUyRSxNQUFNeGIsT0FBT2dTLE9BQU92SSxNQUFNO0FBQ3ZDLFVBQU1vSCxRQUFRcEgsU0FBUztBQUN2QixVQUFNLEVBQUNMLE9BQUFBLFFBQU80QyxhQUFhLEVBQUM3QixPQUFBQSxFQUFPLElBQUk7QUFDdkMsVUFBTXFRLE9BQU9yUSxPQUFPc1IsYUFBWTtBQUNoQyxVQUFNbEIsYUFBYXBRLE9BQU9rUSxhQUFZO0FBQ3RDLFVBQU0xQixRQUFRLEtBQUsrQyxVQUFTO0FBQzVCLFVBQU0sRUFBQ2pHLGVBQWVELGVBQWMsSUFBSSxLQUFLRyxrQkFBa0IzVixPQUFPeUosSUFBQUE7QUFFdEUsYUFBUzdJLElBQUlaLE9BQU9ZLElBQUlaLFFBQVFnUyxPQUFPcFIsS0FBSztBQUMxQyxZQUFNbUwsU0FBUyxLQUFLK0csVUFBVWxTLENBQUFBO0FBQzlCLFlBQU0rYSxVQUFVOUssU0FBU21JLGNBQWNqTixPQUFPNUIsT0FBT0UsSUFBSSxDQUFDLElBQUk7UUFBQ21RO1FBQU1vQixNQUFNcEI7TUFBSSxJQUFJLEtBQUtxQix5QkFBeUJqYixDQUFFO0FBQ25ILFlBQU1rYixVQUFVLEtBQUtDLHlCQUF5Qm5iLEdBQUcrWCxLQUFBQTtBQUNqRCxZQUFNclAsU0FBU3lDLE9BQU9FLFdBQVcsQ0FBQSxHQUFJOUIsT0FBT0UsSUFBSTtBQUVoRCxZQUFNL0QsYUFBYTtRQUNqQmlVO1FBQ0FDLE1BQU1tQixRQUFRbkI7UUFDZEksb0JBQW9CLENBQUN0UixTQUFTMlEsV0FBV2xPLE9BQU8rTixPQUFPLEtBQU0xUSxXQUFVRSxNQUFNK0MsUUFBUWpELFdBQVVFLE1BQU1nRDtRQUNyR25FLEdBQUdvUyxhQUFhb0IsUUFBUUMsT0FBT0UsUUFBUUU7UUFDdkM1VCxHQUFHbVMsYUFBYXVCLFFBQVFFLFNBQVNMLFFBQVFDO1FBQ3pDSyxRQUFRMUIsYUFBYXVCLFFBQVF6VSxPQUFPdkgsS0FBS3dZLElBQUlxRCxRQUFRdFUsSUFBSTtRQUN6RDZVLE9BQU8zQixhQUFhemEsS0FBS3dZLElBQUlxRCxRQUFRdFUsSUFBSSxJQUFJeVUsUUFBUXpVO01BQ3ZEO0FBRUEsVUFBSW1PLGdCQUFnQjtBQUNsQmxQLG1CQUFXSSxVQUFVK08saUJBQWlCLEtBQUtuQiwwQkFBMEIxVCxHQUFHNGEsS0FBSzVhLENBQUUsRUFBQytELFNBQVMsV0FBVzhFLElBQUk7O0FBRTFHLFlBQU0vQyxXQUFVSixXQUFXSSxXQUFXOFUsS0FBSzVhLENBQUFBLEVBQUc4RjtBQUM5QytULHVCQUFpQm5VLFlBQVlJLFVBQVM0QyxPQUFPRixNQUFBQTtBQUM3Q2dTLHVCQUFpQjlVLFlBQVlJLFVBQVNpUyxNQUFNSSxLQUFLO0FBQ2pELFdBQUtoRCxjQUFjeUYsS0FBSzVhLENBQUUsR0FBRUEsR0FBRzBGLFlBQVltRCxJQUFBQTtJQUM3QztFQUNGO0VBU0EwUyxXQUFXQyxNQUFNalAsV0FBVztBQUMxQixVQUFNLEVBQUNqRCxPQUFNLElBQUksS0FBSzhCO0FBQ3RCLFVBQU0vQyxXQUFXaUIsT0FBTzBCLHdCQUF3QixLQUFLd0MsS0FBSyxFQUN2RHpCLE9BQU8xQyxDQUFBQSxTQUFRQSxLQUFLNkIsV0FBV3BGLFFBQVEyVixPQUFPO0FBQ2pELFVBQU0zUixVQUFVUixPQUFPeEQsUUFBUWdFO0FBQy9CLFVBQU1ZLFNBQVMsQ0FBQTtBQUNmLFVBQU1nUixnQkFBZ0IsS0FBS3RRLFlBQVlGLFdBQVdnSCxVQUFVM0YsU0FBQUE7QUFDNUQsVUFBTW9QLGNBQWNELGlCQUFpQkEsY0FBY3BTLE9BQU9HLElBQUk7QUFFOUQsVUFBTW1TLFdBQVcsQ0FBQ3ZTLFNBQVM7QUFDekIsWUFBTThCLFNBQVM5QixLQUFLcUQsUUFBUW1QLEtBQUszYixDQUFBQSxTQUFRQSxLQUFLb0osT0FBT0csSUFBSSxNQUFNa1MsV0FBQUE7QUFDL0QsWUFBTUcsTUFBTTNRLFVBQVVBLE9BQU85QixLQUFLRSxPQUFPRSxJQUFJO0FBRTdDLFVBQUkyTyxjQUFjMEQsR0FBUUMsS0FBQUEsTUFBTUQsR0FBTSxHQUFBO0FBQ3BDLGVBQU87O0lBRVg7QUFFQSxlQUFXelMsUUFBUWhCLFVBQVU7QUFDM0IsVUFBSWtFLGNBQWNuTyxVQUFhd2QsU0FBU3ZTLElBQU8sR0FBQTtBQUM3Qzs7QUFRRixVQUFJUyxZQUFZLFNBQVNZLE9BQU9zUixRQUFRM1MsS0FBS1gsS0FBSyxNQUFNLE1BQ3pEb0IsWUFBWTFMLFVBQWFpTCxLQUFLWCxVQUFVdEssUUFBWTtBQUNqRHNNLGVBQU8xSixLQUFLcUksS0FBS1gsS0FBSzs7QUFFeEIsVUFBSVcsS0FBS2IsVUFBVWdULE1BQU07QUFDdkI7O0lBRUo7QUFLQSxRQUFJLENBQUM5USxPQUFPM0ssUUFBUTtBQUNsQjJLLGFBQU8xSixLQUFLNUMsTUFBQUE7O0FBR2QsV0FBT3NNO0VBQ1Q7RUFNQXVSLGVBQWV6VCxRQUFPO0FBQ3BCLFdBQU8sS0FBSytTLFdBQVduZCxRQUFXb0ssTUFBQUEsRUFBT3pJO0VBQzNDO0VBRUFtYyxnQkFBZ0I7QUFDZCxXQUFPLEtBQUtDLFNBQVEsRUFBR3BjO0VBQ3pCO0VBRUFxYyw4QkFBOEI7QUFDNUIsVUFBTXRRLFVBQVMsS0FBS3hOLE1BQU13TjtBQUMxQixVQUFNdVEsZUFBZSxLQUFLL2QsTUFBTXdILFFBQVF3SjtBQUN4QyxXQUFPckssT0FBT0MsS0FBSzRHLE9BQUFBLEVBQVFDLE9BQU94RyxDQUFBQSxRQUFPdUcsUUFBT3ZHLEdBQUksRUFBQ2tFLFNBQVM0UyxZQUFBQSxFQUFjclEsTUFBSztFQUNuRjtFQUVBbVEsV0FBVztBQUNULFVBQU0xUyxPQUFPLENBQUE7QUFDYixVQUFNNlMsbUJBQW1CLEtBQUtGLDRCQUEyQjtBQUN6RCxlQUFXaFEsV0FBVyxLQUFLOU4sTUFBTThLLEtBQUt5RyxVQUFVO0FBQzlDcEcsV0FBS3dGLGVBQ0gsS0FBSzNRLE1BQU13SCxRQUFRd0osY0FBYyxNQUFNbEQsUUFBUTRDLFVBQVU1QyxRQUFRK0MsU0FBU21OLGdCQUFBQSxDQUFBQSxJQUN2RTtJQUNQO0FBQ0EsV0FBT3JYLE9BQU9DLEtBQUt1RSxJQUFBQTtFQUNyQjtFQVVBOFMsZUFBZXpULGNBQWMwVCxNQUFNalEsV0FBVztBQUM1QyxVQUFNN0IsU0FBUyxLQUFLNlEsV0FBV3pTLGNBQWN5RCxTQUFBQTtBQUM3QyxVQUFNL0QsU0FBUSxTQUFVcEssU0FDcEJzTSxPQUFPc1IsUUFBUVEsSUFDZixJQUFBO0FBRUosV0FBUWhVLFdBQVUsS0FDZGtDLE9BQU8zSyxTQUFTLElBQ2hCeUk7RUFDTjtFQUtBc1MsWUFBWTtBQUNWLFVBQU03VCxPQUFPLEtBQUtuQjtBQUNsQixVQUFNdUQsT0FBTyxLQUFLK0I7QUFDbEIsVUFBTTlCLFNBQVNELEtBQUtDO0FBQ3BCLFVBQU1rUCxTQUFTLENBQUE7QUFDZixRQUFJeFksR0FBR3VJO0FBRVAsU0FBS3ZJLElBQUksR0FBR3VJLE9BQU9jLEtBQUtELEtBQUtySixRQUFRQyxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUNsRHdZLGFBQU94WCxLQUFLc0ksT0FBT3FPLGlCQUFpQixLQUFLekYsVUFBVWxTLENBQUUsRUFBQ3NKLE9BQU9HLElBQUksR0FBR3pKLENBQUFBLENBQUFBO0lBQ3RFO0FBRUEsVUFBTWtZLGVBQWVqUixLQUFLaVI7QUFDMUIsVUFBTS9ZLE1BQU0rWSxnQkFBZ0JaLHFCQUFxQmpPLElBQUFBO0FBRWpELFdBQU87TUFDTGxLO01BQ0FxWjtNQUNBcFosT0FBT2tLLE9BQU9tVDtNQUNkdFYsS0FBS21DLE9BQU9vVDtNQUNaMUUsWUFBWSxLQUFLaUUsZUFBYztNQUMvQmxWLE9BQU91QztNQUNQbVMsU0FBU3hVLEtBQUt3VTtNQUVkdEQsT0FBT0QsZUFBZSxJQUFJalIsS0FBS29SLHFCQUFxQnBSLEtBQUtxUjtJQUMzRDtFQUNGO0VBTUEyQyx5QkFBeUJ6UyxRQUFPO0FBQzlCLFVBQU0sRUFBQzRDLGFBQWEsRUFBQzdCLFFBQVEyRCxVQUFVMUUsT0FBT00sYUFBQUEsR0FBZWhELFNBQVMsRUFBQzhULE1BQU0rQyxXQUFXQyxhQUFBQSxFQUFhLElBQUk7QUFDekcsVUFBTXBELGFBQWFtRCxhQUFhO0FBQ2hDLFVBQU14UixTQUFTLEtBQUsrRyxVQUFVMUosTUFBQUE7QUFDOUIsVUFBTThRLFVBQVNuTyxPQUFPK047QUFDdEIsVUFBTTJELFdBQVd4RCxXQUFXQyxPQUFBQTtBQUM1QixRQUFJOVMsUUFBUTJFLE9BQU81QixPQUFPRSxJQUFJO0FBQzlCLFFBQUlySyxRQUFRO0FBQ1osUUFBSVcsU0FBU21OLFdBQVcsS0FBS3pFLFdBQVdjLFFBQVE0QixRQUFRK0IsUUFBQUEsSUFBWTFHO0FBQ3BFLFFBQUl3VSxNQUFNdlU7QUFFVixRQUFJMUcsV0FBV3lHLE9BQU87QUFDcEJwSCxjQUFRVyxTQUFTeUc7QUFDakJ6RyxlQUFTeUc7O0FBR1gsUUFBSXFXLFVBQVU7QUFDWnJXLGNBQVE4UyxRQUFPTjtBQUNmalosZUFBU3VaLFFBQU9MLFNBQVNLLFFBQU9OO0FBRWhDLFVBQUl4UyxVQUFVLEtBQUswQyxLQUFLMUMsS0FBQUEsTUFBVzBDLEtBQUtvUSxRQUFPTCxNQUFNLEdBQUc7QUFDdEQ3WixnQkFBUTs7QUFFVkEsZUFBU29IOztBQUdYLFVBQU1zUyxhQUFhLENBQUNWLGNBQWN1RSxTQUFBQSxLQUFjLENBQUNFLFdBQVdGLFlBQVl2ZDtBQUN4RSxRQUFJd2EsT0FBT3JRLE9BQU9vTyxpQkFBaUJtQixVQUFBQTtBQUVuQyxRQUFJLEtBQUt4YSxNQUFNd2Usa0JBQWtCdFUsTUFBUSxHQUFBO0FBQ3ZDd1MsYUFBT3pSLE9BQU9vTyxpQkFBaUJ2WSxRQUFRVyxNQUFBQTtXQUNsQztBQUVMaWIsYUFBT3BCOztBQUdUblQsV0FBT3VVLE9BQU9wQjtBQUVkLFFBQUkxYSxLQUFLd1ksSUFBSWpSLElBQUFBLElBQVFtVyxjQUFjO0FBQ2pDblcsYUFBTzhTLFFBQVE5UyxNQUFNOEMsUUFBUWlRLFVBQWNvRCxJQUFBQTtBQUMzQyxVQUFJcFcsVUFBVWdULFlBQVk7QUFDeEJJLGdCQUFRblQsT0FBTzs7QUFFakIsWUFBTXNXLGFBQWF4VCxPQUFPeVQsbUJBQW1CLENBQUE7QUFDN0MsWUFBTUMsV0FBVzFULE9BQU95VCxtQkFBbUIsQ0FBQTtBQUMzQyxZQUFNN2QsTUFBTUQsS0FBS0MsSUFBSTRkLFlBQVlFLFFBQUFBO0FBQ2pDLFlBQU0zYixNQUFNcEMsS0FBS29DLElBQUl5YixZQUFZRSxRQUFBQTtBQUNqQ3JELGFBQU8xYSxLQUFLb0MsSUFBSXBDLEtBQUtDLElBQUl5YSxNQUFNdFksR0FBTW5DLEdBQUFBLEdBQUFBO0FBQ3JDNmIsYUFBT3BCLE9BQU9uVDtBQUVkLFVBQUl5RyxZQUFZLENBQUMyUCxVQUFVO0FBRXpCMVIsZUFBT0UsUUFBUTlCLE9BQU9FLElBQUksRUFBRW1DLGNBQWM5QyxZQUFhLElBQUdTLE9BQU8yVCxpQkFBaUJsQyxJQUFRelIsSUFBQUEsT0FBTzJULGlCQUFpQnRELElBQUFBOzs7QUFJdEgsUUFBSUEsU0FBU3JRLE9BQU9vTyxpQkFBaUI2QixVQUFhLEdBQUE7QUFDaEQsWUFBTTJELFdBQVdqVSxLQUFLekMsSUFBQUEsSUFBUThDLE9BQU82VCxxQkFBcUI1RCxVQUFjLElBQUE7QUFDeEVJLGNBQVF1RDtBQUNSMVcsY0FBUTBXOztBQUdWLFdBQU87TUFDTDFXO01BQ0FtVDtNQUNBb0I7TUFDQUksUUFBUUosT0FBT3ZVLE9BQU87SUFDeEI7RUFDRjtFQUtBMFUseUJBQXlCM1MsUUFBT3VQLE9BQU87QUFDckMsVUFBTWhSLFFBQVFnUixNQUFNaFI7QUFDcEIsVUFBTWpCLFdBQVUsS0FBS0E7QUFDckIsVUFBTThWLFdBQVc5VixTQUFROFY7QUFDekIsVUFBTXlCLGtCQUFrQnBPLGVBQWVuSixTQUFRdVgsaUJBQWlCQyxRQUFBQTtBQUNoRSxRQUFJbEMsUUFBUTNVO0FBQ1osVUFBTThXLFlBQVksS0FBS3JCLGNBQWE7QUFDcEMsUUFBSW5FLE1BQU0wRCxTQUFTO0FBQ2pCLFlBQU16RCxhQUFhNEQsV0FBVyxLQUFLSyxlQUFlelQsTUFBQUEsSUFBU3VQLE1BQU1DO0FBQ2pFLFlBQU0zRixRQUFRdk0sU0FBUW9TLGlCQUFpQixTQUNuQ08sMEJBQTBCalEsUUFBT3VQLE9BQU9qUyxVQUFTa1MsYUFBYXVGLFNBQUFBLElBQzlEekYseUJBQXlCdFAsUUFBT3VQLE9BQU9qUyxVQUFTa1MsYUFBYXVGLFNBQVU7QUFDM0UsWUFBTUMsU0FBUyxLQUFLbGYsTUFBTXdILFFBQVF3SixjQUFjLE1BQU0sS0FBS1QsV0FBVSxFQUFHRyxVQUFVLEtBQUtILFdBQVUsRUFBR007QUFDcEcsWUFBTXNPLGFBQWEsS0FBS3RCLFNBQVEsRUFBR0gsUUFBUS9NLGVBQWV1TyxRQUFRLEtBQUtwQiw0QkFBMkIsQ0FBQSxDQUFBO0FBQ2xHLFlBQU1zQixhQUFhLEtBQUtuQixlQUFlLEtBQUsvVCxPQUFPLEtBQUs0QyxZQUFZMUMsT0FBT2tULFdBQVdwVCxTQUFRcEssTUFBUyxJQUFJcWY7QUFDM0dyQyxlQUFTL0ksTUFBTWpULFFBQVNpVCxNQUFNa0csUUFBUW1GLGFBQWVyTCxNQUFNa0csUUFBUTtBQUNuRTlSLGFBQU92SCxLQUFLQyxJQUFJa2UsaUJBQWlCaEwsTUFBTWtHLFFBQVFsRyxNQUFNOEYsS0FBSztXQUNyRDtBQUVMaUQsZUFBU3JVLE1BQU00USxpQkFBaUIsS0FBS3pGLFVBQVUxSixNQUFBQSxFQUFPekIsTUFBTTBDLElBQUksR0FBR2pCLE1BQUFBO0FBQ25FL0IsYUFBT3ZILEtBQUtDLElBQUlrZSxpQkFBaUJ0RixNQUFNNVksTUFBTTRZLE1BQU1JLEtBQUs7O0FBSTFELFdBQU87TUFDTHlCLE1BQU13QixTQUFTM1UsT0FBTztNQUN0QnVVLE1BQU1JLFNBQVMzVSxPQUFPO01BQ3RCMlU7TUFDQTNVO0lBQ0Y7RUFDRjtFQUVBeEcsT0FBTztBQUNMLFVBQU1vSixPQUFPLEtBQUsrQjtBQUNsQixVQUFNN0IsU0FBU0YsS0FBS0U7QUFDcEIsVUFBTW9VLFFBQVF0VSxLQUFLRDtBQUNuQixVQUFNYixPQUFPb1YsTUFBTTVkO0FBQ25CLFFBQUlDLElBQUk7QUFFUixXQUFPQSxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUNwQixVQUFJLEtBQUtrUyxVQUFVbFMsQ0FBRSxFQUFDdUosT0FBT0UsSUFBSSxNQUFNLFFBQVEsQ0FBQ2tVLE1BQU0zZCxDQUFFLEVBQUNpTixRQUFRO0FBQy9EMFEsY0FBTTNkLENBQUUsRUFBQ0MsS0FBSyxLQUFLbU4sSUFBSTs7SUFFM0I7RUFDRjtBQUVGO0FBdGFFLGNBRm1Cc04sZUFFWnhRLE1BQUs7QUFLWixjQVBtQndRLGVBT1p2VixZQUFXO0VBQ2hCZ0osb0JBQW9CO0VBQ3BCQyxpQkFBaUI7RUFFakJpSyxvQkFBb0I7RUFDcEJDLGVBQWU7RUFDZm1ELFNBQVM7RUFFVHpWLFlBQVk7SUFDVjRYLFNBQVM7TUFDUG5mLE1BQU07TUFDTmlILFlBQVk7UUFBQztRQUFLO1FBQUs7UUFBUTtRQUFTO01BQVM7SUFDbkQ7RUFDRjs7QUFNRixjQTFCbUJnVixlQTBCWm1ELGFBQVk7RUFDakIvUixRQUFRO0lBQ05nUyxTQUFTO01BQ1ByZixNQUFNO01BQ05zZixRQUFRO01BQ1JDLE1BQU07UUFDSkQsUUFBUTtNQUNWO0lBQ0Y7SUFDQUUsU0FBUztNQUNQeGYsTUFBTTtNQUNOeWYsYUFBYTtJQUNmO0VBQ0Y7O0FDclNXLElBQU1DLG1CQUFOLGNBQStCaFIsa0JBQUFBO0VBaUM1Q2tCLGFBQWE7QUFDWCxTQUFLTixzQkFBc0I7QUFDM0IsVUFBTU0sV0FBVTtFQUNsQjtFQU1BcUQsbUJBQW1CckksTUFBTUQsTUFBTWhLLE9BQU9nUyxPQUFPO0FBQzNDLFVBQU1qRyxTQUFTLE1BQU11RyxtQkFBbUJySSxNQUFNRCxNQUFNaEssT0FBT2dTLEtBQUFBO0FBQzNELGFBQVNwUixJQUFJLEdBQUdBLElBQUltTCxPQUFPcEwsUUFBUUMsS0FBSztBQUN0Q21MLGFBQU9uTCxDQUFFLEVBQUNrWixVQUFVLEtBQUt4RiwwQkFBMEIxVCxJQUFJWixLQUFBQSxFQUFPZ2Y7SUFDaEU7QUFDQSxXQUFPalQ7RUFDVDtFQU1BcUcsZUFBZW5JLE1BQU1ELE1BQU1oSyxPQUFPZ1MsT0FBTztBQUN2QyxVQUFNakcsU0FBUyxNQUFNcUcsZUFBZW5JLE1BQU1ELE1BQU1oSyxPQUFPZ1MsS0FBQUE7QUFDdkQsYUFBU3BSLElBQUksR0FBR0EsSUFBSW1MLE9BQU9wTCxRQUFRQyxLQUFLO0FBQ3RDLFlBQU1FLE9BQU9rSixLQUFLaEssUUFBUVksQ0FBRTtBQUM1Qm1MLGFBQU9uTCxDQUFFLEVBQUNrWixVQUFVakssZUFBZS9PLEtBQUssQ0FBRSxHQUFFLEtBQUt3VCwwQkFBMEIxVCxJQUFJWixLQUFBQSxFQUFPZ2YsTUFBTTtJQUM5RjtBQUNBLFdBQU9qVDtFQUNUO0VBTUFzRyxnQkFBZ0JwSSxNQUFNRCxNQUFNaEssT0FBT2dTLE9BQU87QUFDeEMsVUFBTWpHLFNBQVMsTUFBTXNHLGdCQUFnQnBJLE1BQU1ELE1BQU1oSyxPQUFPZ1MsS0FBQUE7QUFDeEQsYUFBU3BSLElBQUksR0FBR0EsSUFBSW1MLE9BQU9wTCxRQUFRQyxLQUFLO0FBQ3RDLFlBQU1FLE9BQU9rSixLQUFLaEssUUFBUVksQ0FBRTtBQUM1Qm1MLGFBQU9uTCxDQUFBQSxFQUFHa1osVUFBVWpLLGVBQWUvTyxRQUFRQSxLQUFLNkgsS0FBSyxDQUFDN0gsS0FBSzZILEdBQUcsS0FBSzJMLDBCQUEwQjFULElBQUlaLEtBQUFBLEVBQU9nZixNQUFNO0lBQ2hIO0FBQ0EsV0FBT2pUO0VBQ1Q7RUFLQTJILGlCQUFpQjtBQUNmLFVBQU0xSixPQUFPLEtBQUtnQyxZQUFZaEM7QUFFOUIsUUFBSTlILE1BQU07QUFDVixhQUFTdEIsSUFBSW9KLEtBQUtySixTQUFTLEdBQUdDLEtBQUssR0FBRyxFQUFFQSxHQUFHO0FBQ3pDc0IsWUFBTXBDLEtBQUtvQyxJQUFJQSxLQUFLOEgsS0FBS3BKLENBQUFBLEVBQUd5RyxLQUFLLEtBQUtpTiwwQkFBMEIxVCxDQUFNLENBQUEsSUFBQSxDQUFBO0lBQ3hFO0FBQ0EsV0FBT3NCLE1BQU0sS0FBS0E7RUFDcEI7RUFLQXlSLGlCQUFpQnZLLFFBQU87QUFDdEIsVUFBTWEsT0FBTyxLQUFLK0I7QUFDbEIsVUFBTXdHLFNBQVMsS0FBS3RULE1BQU04SyxLQUFLd0ksVUFBVSxDQUFBO0FBQ3pDLFVBQU0sRUFBQ3ZLLFFBQVFDLE9BQUFBLElBQVUrQjtBQUN6QixVQUFNOEIsU0FBUyxLQUFLK0csVUFBVTFKLE1BQUFBO0FBQzlCLFVBQU1qQixJQUFJRixPQUFPNEwsaUJBQWlCOUgsT0FBTzVELENBQUM7QUFDMUMsVUFBTUMsSUFBSUYsT0FBTzJMLGlCQUFpQjlILE9BQU8zRCxDQUFDO0FBQzFDLFVBQU1PLElBQUlvRCxPQUFPK047QUFFakIsV0FBTztNQUNMbEcsT0FBT3BCLE9BQU9wSixNQUFBQSxLQUFVO01BQ3hCaEMsT0FBTyxNQUFNZSxJQUFJLE9BQU9DLEtBQUtPLElBQUksT0FBT0EsSUFBSSxNQUFNO0lBQ3BEO0VBQ0Y7RUFFQS9ELE9BQU82RSxNQUFNO0FBQ1gsVUFBTXdWLFNBQVMsS0FBS2pULFlBQVloQztBQUdoQyxTQUFLNk0sZUFBZW9JLFFBQVEsR0FBR0EsT0FBT3RlLFFBQVE4SSxJQUFBQTtFQUNoRDtFQUVBb04sZUFBZW9JLFFBQVFqZixPQUFPZ1MsT0FBT3ZJLE1BQU07QUFDekMsVUFBTW9ILFFBQVFwSCxTQUFTO0FBQ3ZCLFVBQU0sRUFBQ1MsUUFBUUMsT0FBQUEsSUFBVSxLQUFLNkI7QUFDOUIsVUFBTSxFQUFDeUosZUFBZUQsZUFBYyxJQUFJLEtBQUtHLGtCQUFrQjNWLE9BQU95SixJQUFBQTtBQUN0RSxVQUFNeUMsUUFBUWhDLE9BQU9HO0FBQ3JCLFVBQU04QixRQUFRaEMsT0FBT0U7QUFFckIsYUFBU3pKLElBQUlaLE9BQU9ZLElBQUlaLFFBQVFnUyxPQUFPcFIsS0FBSztBQUMxQyxZQUFNc2UsUUFBUUQsT0FBT3JlLENBQUU7QUFDdkIsWUFBTW1MLFNBQVMsQ0FBQzhFLFNBQVMsS0FBS2lDLFVBQVVsUyxDQUFBQTtBQUN4QyxZQUFNMEYsYUFBYSxDQUFBO0FBQ25CLFlBQU02WSxTQUFTN1ksV0FBVzRGLEtBQU0sSUFBRzJFLFFBQVEzRyxPQUFPMFQsbUJBQW1CLEdBQUEsSUFBTzFULE9BQU9xTyxpQkFBaUJ4TSxPQUFPRyxLQUFBQSxDQUFNO0FBQ2pILFlBQU1rVCxTQUFTOVksV0FBVzZGLEtBQUFBLElBQVMwRSxRQUFRMUcsT0FBT3NSLGFBQVksSUFBS3RSLE9BQU9vTyxpQkFBaUJ4TSxPQUFPSSxLQUFBQSxDQUFNO0FBRXhHN0YsaUJBQVcrWSxPQUFPMUMsTUFBTXdDLE1BQUFBLEtBQVd4QyxNQUFNeUMsTUFBQUE7QUFFekMsVUFBSTVKLGdCQUFnQjtBQUNsQmxQLG1CQUFXSSxVQUFVK08saUJBQWlCLEtBQUtuQiwwQkFBMEIxVCxHQUFHc2UsTUFBTXZhLFNBQVMsV0FBVzhFLElBQUk7QUFFdEcsWUFBSW9ILE9BQU87QUFDVHZLLHFCQUFXSSxRQUFRc1ksU0FBUzs7O0FBSWhDLFdBQUtqSixjQUFjbUosT0FBT3RlLEdBQUcwRixZQUFZbUQsSUFBQUE7SUFDM0M7RUFDRjtFQU9BNkssMEJBQTBCbEwsUUFBT0ssTUFBTTtBQUNyQyxVQUFNc0MsU0FBUyxLQUFLK0csVUFBVTFKLE1BQUFBO0FBQzlCLFFBQUk1QyxTQUFTLE1BQU04TiwwQkFBMEJsTCxRQUFPSyxJQUFBQTtBQUdwRCxRQUFJakQsT0FBT00sU0FBUztBQUNsQk4sZUFBU1gsT0FBT3lCLE9BQU8sQ0FBQSxHQUFJZCxRQUFRO1FBQUNNLFNBQVM7TUFBSyxDQUFBOztBQUlwRCxVQUFNa1ksU0FBU3hZLE9BQU93WTtBQUN0QixRQUFJdlYsU0FBUyxVQUFVO0FBQ3JCakQsYUFBT3dZLFNBQVM7O0FBRWxCeFksV0FBT3dZLFVBQVVuUCxlQUFlOUQsVUFBVUEsT0FBTytOLFNBQVNrRixNQUFBQTtBQUUxRCxXQUFPeFk7RUFDVDtBQUNGO0FBbktFLGNBRm1CdVksa0JBRVpqVSxNQUFLO0FBS1osY0FQbUJpVSxrQkFPWmhaLFlBQVc7RUFDaEJnSixvQkFBb0I7RUFDcEJDLGlCQUFpQjtFQUVqQnBJLFlBQVk7SUFDVjRYLFNBQVM7TUFDUG5mLE1BQU07TUFDTmlILFlBQVk7UUFBQztRQUFLO1FBQUs7UUFBZTtNQUFTO0lBQ2pEO0VBQ0Y7O0FBTUYsY0F0Qm1CeVksa0JBc0JaTixhQUFZO0VBQ2pCL1IsUUFBUTtJQUNOdkUsR0FBRztNQUNEOUksTUFBTTtJQUNSO0lBQ0ErSSxHQUFHO01BQ0QvSSxNQUFNO0lBQ1I7RUFDRjs7QUN4QkosU0FBU2lnQixrQkFBa0JDLFVBQVVDLGVBQWVDLFFBQVE7QUFDMUQsTUFBSUMsU0FBUztBQUNiLE1BQUlDLFNBQVM7QUFDYixNQUFJQyxVQUFVO0FBQ2QsTUFBSUMsVUFBVTtBQUVkLE1BQUlMLGdCQUFnQk0sS0FBSztBQUN2QixVQUFNQyxhQUFhUjtBQUNuQixVQUFNUyxXQUFXRCxhQUFhUDtBQUM5QixVQUFNUyxTQUFTbmdCLEtBQUtvZ0IsSUFBSUgsVUFBQUE7QUFDeEIsVUFBTUksU0FBU3JnQixLQUFLc2dCLElBQUlMLFVBQUFBO0FBQ3hCLFVBQU1NLE9BQU92Z0IsS0FBS29nQixJQUFJRixRQUFBQTtBQUN0QixVQUFNTSxPQUFPeGdCLEtBQUtzZ0IsSUFBSUosUUFBQUE7QUFDdEIsVUFBTU8sVUFBVSxDQUFDQyxPQUFPdkksR0FBR3JQLE1BQU02WCxjQUFjRCxPQUFPVCxZQUFZQyxVQUFVLElBQUksSUFBSSxJQUFJbGdCLEtBQUtvQyxJQUFJK1YsR0FBR0EsSUFBSXdILFFBQVE3VyxHQUFHQSxJQUFJNlcsTUFBTztBQUM5SCxVQUFNaUIsVUFBVSxDQUFDRixPQUFPdkksR0FBR3JQLE1BQU02WCxjQUFjRCxPQUFPVCxZQUFZQyxVQUFVLElBQUksSUFBSSxLQUFLbGdCLEtBQUtDLElBQUlrWSxHQUFHQSxJQUFJd0gsUUFBUTdXLEdBQUdBLElBQUk2VyxNQUFPO0FBQy9ILFVBQU1rQixPQUFPSixRQUFRLEdBQUdOLFFBQVFJLElBQUFBO0FBQ2hDLFVBQU1PLE9BQU9MLFFBQVFNLFNBQVNWLFFBQVFHLElBQUFBO0FBQ3RDLFVBQU1RLE9BQU9KLFFBQVFLLElBQUlkLFFBQVFJLElBQUFBO0FBQ2pDLFVBQU1XLE9BQU9OLFFBQVFLLEtBQUtGLFNBQVNWLFFBQVFHLElBQUFBO0FBQzNDWixjQUFVaUIsT0FBT0csUUFBUTtBQUN6Qm5CLGNBQVVpQixPQUFPSSxRQUFRO0FBQ3pCcEIsY0FBVSxFQUFFZSxPQUFPRyxRQUFRO0FBQzNCakIsY0FBVSxFQUFFZSxPQUFPSSxRQUFROztBQUU3QixTQUFPO0lBQUN0QjtJQUFRQztJQUFRQztJQUFTQztFQUFPO0FBQzFDO0FBRWUsSUFBTW9CLHFCQUFOLGNBQWlDbFQsa0JBQUFBO0VBMEY5Q3JQLFlBQVlRLE9BQU93SyxjQUFjO0FBQy9CLFVBQU14SyxPQUFPd0ssWUFBQUE7QUFFYixTQUFLaUYsc0JBQXNCO0FBQzNCLFNBQUt1UyxjQUFjbGlCO0FBQ25CLFNBQUttaUIsY0FBY25pQjtBQUNuQixTQUFLNGdCLFVBQVU1Z0I7QUFDZixTQUFLNmdCLFVBQVU3Z0I7RUFDakI7RUFFQWtRLGFBQWE7RUFBQTtFQUtiNkMsTUFBTS9SLE9BQU9nUyxPQUFPO0FBQ2xCLFVBQU1oSSxPQUFPLEtBQUt5RixXQUFVLEVBQUd6RjtBQUMvQixVQUFNQyxPQUFPLEtBQUsrQjtBQUVsQixRQUFJLEtBQUtxQyxhQUFhLE9BQU87QUFDM0JwRSxXQUFLcUQsVUFBVXREO1dBQ1Y7QUFDTCxVQUFJb1gsU0FBUyxDQUFDeGdCLE9BQU0sQ0FBQ29KLEtBQUtwSixFQUFFO0FBRTVCLFVBQUkrRSxTQUFTcUUsS0FBS2hLLEtBQUFBLENBQU0sR0FBRztBQUN6QixjQUFNLEVBQUNtRyxNQUFNLFFBQUEsSUFBVyxLQUFLa0k7QUFDN0IrUyxpQkFBUyxDQUFDeGdCLE9BQU0sQ0FBQ2lTLGlCQUFpQjdJLEtBQUtwSixFQUFBQSxHQUFJdUYsR0FBQUE7O0FBRzdDLFVBQUl2RixHQUFHdUk7QUFDUCxXQUFLdkksSUFBSVosT0FBT21KLE9BQU9uSixRQUFRZ1MsT0FBT3BSLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ25EcUosYUFBS3FELFFBQVExTSxDQUFFLElBQUd3Z0IsT0FBT3hnQixDQUFBQTtNQUMzQjs7RUFFSjtFQUtBeWdCLGVBQWU7QUFDYixXQUFPQyxVQUFVLEtBQUs1YSxRQUFRNlksV0FBVyxFQUFBO0VBQzNDO0VBS0FnQyxvQkFBb0I7QUFDbEIsV0FBT0QsVUFBVSxLQUFLNWEsUUFBUThZLGFBQWE7RUFDN0M7RUFNQWdDLHNCQUFzQjtBQUNwQixRQUFJemhCLE1BQU0rZjtBQUNWLFFBQUk1ZCxNQUFNLENBQUM0ZDtBQUVYLGFBQVNsZixJQUFJLEdBQUdBLElBQUksS0FBSzFCLE1BQU04SyxLQUFLeUcsU0FBUzlQLFFBQVEsRUFBRUMsR0FBRztBQUN4RCxVQUFJLEtBQUsxQixNQUFNdWlCLGlCQUFpQjdnQixDQUFBQSxLQUFNLEtBQUsxQixNQUFNd1IsZUFBZTlQLENBQUd2QixFQUFBQSxTQUFTLEtBQUsrTyxPQUFPO0FBQ3RGLGNBQU10QyxhQUFhLEtBQUs1TSxNQUFNd1IsZUFBZTlQLENBQUFBLEVBQUdrTDtBQUNoRCxjQUFNeVQsV0FBV3pULFdBQVd1VixhQUFZO0FBQ3hDLGNBQU03QixnQkFBZ0IxVCxXQUFXeVYsa0JBQWlCO0FBRWxEeGhCLGNBQU1ELEtBQUtDLElBQUlBLEtBQUt3ZixRQUFBQTtBQUNwQnJkLGNBQU1wQyxLQUFLb0MsSUFBSUEsS0FBS3FkLFdBQVdDLGFBQUFBOztJQUVuQztBQUVBLFdBQU87TUFDTEQsVUFBVXhmO01BQ1Z5ZixlQUFldGQsTUFBTW5DO0lBQ3ZCO0VBQ0Y7RUFLQTZFLE9BQU82RSxNQUFNO0FBQ1gsVUFBTXZLLFFBQVEsS0FBS0E7QUFDbkIsVUFBTSxFQUFDZ1YsVUFBUyxJQUFJaFY7QUFDcEIsVUFBTStLLE9BQU8sS0FBSytCO0FBQ2xCLFVBQU0wVixPQUFPelgsS0FBS0Q7QUFDbEIsVUFBTTJYLFVBQVUsS0FBS0Msa0JBQWlCLElBQUssS0FBS0MsYUFBYUgsSUFBUSxJQUFBLEtBQUtoYixRQUFRaWI7QUFDbEYsVUFBTUcsVUFBVWhpQixLQUFLb0MsS0FBS3BDLEtBQUtDLElBQUltVSxVQUFVZ0ksT0FBT2hJLFVBQVUrSCxNQUFNLElBQUkwRixXQUFXLEdBQUcsQ0FBQTtBQUN0RixVQUFNbEMsU0FBUzNmLEtBQUtDLElBQUlnaUIsYUFBYSxLQUFLcmIsUUFBUStZLFFBQVFxQyxPQUFVLEdBQUEsQ0FBQTtBQUNwRSxVQUFNRSxjQUFjLEtBQUtDLGVBQWUsS0FBSzdZLEtBQUs7QUFLbEQsVUFBTSxFQUFDb1csZUFBZUQsU0FBQUEsSUFBWSxLQUFLaUMsb0JBQW1CO0FBQzFELFVBQU0sRUFBQzlCLFFBQVFDLFFBQVFDLFNBQVNDLFFBQUFBLElBQVdQLGtCQUFrQkMsVUFBVUMsZUFBZUMsTUFBQUE7QUFDdEYsVUFBTXlDLFlBQVloTyxVQUFVZ0ksUUFBUXlGLFdBQVdqQztBQUMvQyxVQUFNeUMsYUFBYWpPLFVBQVUrSCxTQUFTMEYsV0FBV2hDO0FBQ2pELFVBQU15QyxZQUFZdGlCLEtBQUtvQyxJQUFJcEMsS0FBS0MsSUFBSW1pQixVQUFVQyxTQUFBQSxJQUFhLEdBQUcsQ0FBQTtBQUM5RCxVQUFNaEIsY0FBY2tCLFlBQVksS0FBSzNiLFFBQVFzWSxRQUFRb0QsU0FBQUE7QUFDckQsVUFBTWxCLGNBQWNwaEIsS0FBS29DLElBQUlpZixjQUFjMUIsUUFBUSxDQUFBO0FBQ25ELFVBQU02QyxnQkFBZ0JuQixjQUFjRCxlQUFlLEtBQUtxQiw4QkFBNkI7QUFDckYsU0FBSzNDLFVBQVVBLFVBQVV1QjtBQUN6QixTQUFLdEIsVUFBVUEsVUFBVXNCO0FBRXpCbFgsU0FBS3VZLFFBQVEsS0FBS0MsZUFBYztBQUVoQyxTQUFLdEIsY0FBY0EsY0FBY21CLGVBQWUsS0FBS0kscUJBQXFCLEtBQUt0WixLQUFLO0FBQ3BGLFNBQUs4WCxjQUFjcGhCLEtBQUtvQyxJQUFJLEtBQUtpZixjQUFjbUIsZUFBZU4sYUFBYSxDQUFBO0FBRTNFLFNBQUtuTCxlQUFlNkssTUFBTSxHQUFHQSxLQUFLL2dCLFFBQVE4SSxJQUFBQTtFQUM1QztFQUtBa1osZUFBZS9oQixHQUFHaVEsT0FBTztBQUN2QixVQUFNaEosT0FBTyxLQUFLbkI7QUFDbEIsVUFBTXVELE9BQU8sS0FBSytCO0FBQ2xCLFVBQU13VCxnQkFBZ0IsS0FBSytCLGtCQUFpQjtBQUM1QyxRQUFJLFNBQVUxWixLQUFLN0IsVUFBVTRjLGlCQUFrQixDQUFDLEtBQUsxakIsTUFBTXdlLGtCQUFrQjljLENBQU1xSixLQUFBQSxLQUFLcUQsUUFBUTFNLENBQUUsTUFBSyxRQUFRcUosS0FBS0QsS0FBS3BKLENBQUFBLEVBQUdpTixRQUFRO0FBQ2xJLGFBQU87O0FBRVQsV0FBTyxLQUFLZ1YsdUJBQXVCNVksS0FBS3FELFFBQVExTSxDQUFFLElBQUc0ZSxnQkFBZ0JNLEdBQUFBO0VBQ3ZFO0VBRUFqSixlQUFlNkssTUFBTTFoQixPQUFPZ1MsT0FBT3ZJLE1BQU07QUFDdkMsVUFBTW9ILFFBQVFwSCxTQUFTO0FBQ3ZCLFVBQU12SyxRQUFRLEtBQUtBO0FBQ25CLFVBQU1nVixZQUFZaFYsTUFBTWdWO0FBQ3hCLFVBQU1yTSxPQUFPM0ksTUFBTXdIO0FBQ25CLFVBQU1vYyxnQkFBZ0JqYixLQUFLN0I7QUFDM0IsVUFBTStjLFdBQVc3TyxVQUFVMUwsT0FBTzBMLFVBQVU1TCxTQUFTO0FBQ3JELFVBQU0wYSxXQUFXOU8sVUFBVTdMLE1BQU02TCxVQUFVM0wsVUFBVTtBQUNyRCxVQUFNMGEsZUFBZXBTLFNBQVNpUyxjQUFjRztBQUM1QyxVQUFNL0IsY0FBYytCLGVBQWUsSUFBSSxLQUFLL0I7QUFDNUMsVUFBTUMsY0FBYzhCLGVBQWUsSUFBSSxLQUFLOUI7QUFDNUMsVUFBTSxFQUFDMUwsZUFBZUQsZUFBYyxJQUFJLEtBQUtHLGtCQUFrQjNWLE9BQU95SixJQUFBQTtBQUN0RSxRQUFJc1csYUFBYSxLQUFLc0IsYUFBWTtBQUNsQyxRQUFJemdCO0FBRUosU0FBS0EsSUFBSSxHQUFHQSxJQUFJWixPQUFPLEVBQUVZLEdBQUc7QUFDMUJtZixvQkFBYyxLQUFLNEMsZUFBZS9oQixHQUFHaVEsS0FBQUE7SUFDdkM7QUFFQSxTQUFLalEsSUFBSVosT0FBT1ksSUFBSVosUUFBUWdTLE9BQU8sRUFBRXBSLEdBQUc7QUFDdEMsWUFBTTRlLGdCQUFnQixLQUFLbUQsZUFBZS9oQixHQUFHaVEsS0FBQUE7QUFDN0MsWUFBTXFTLE1BQU14QixLQUFLOWdCLENBQUU7QUFDbkIsWUFBTTBGLGFBQWE7UUFDakI2QixHQUFHNGEsVUFBVSxLQUFLbkQ7UUFDbEJ4WCxHQUFHNGEsVUFBVSxLQUFLbkQ7UUFDbEJFO1FBQ0FDLFVBQVVELGFBQWFQO1FBQ3ZCQTtRQUNBMkI7UUFDQUQ7TUFDRjtBQUNBLFVBQUkxTCxnQkFBZ0I7QUFDbEJsUCxtQkFBV0ksVUFBVStPLGlCQUFpQixLQUFLbkIsMEJBQTBCMVQsR0FBR3NpQixJQUFJdmUsU0FBUyxXQUFXOEUsSUFBSTs7QUFFdEdzVyxvQkFBY1A7QUFFZCxXQUFLekosY0FBY21OLEtBQUt0aUIsR0FBRzBGLFlBQVltRCxJQUFBQTtJQUN6QztFQUNGO0VBRUFnWixpQkFBaUI7QUFDZixVQUFNeFksT0FBTyxLQUFLK0I7QUFDbEIsVUFBTW1YLFdBQVdsWixLQUFLRDtBQUN0QixRQUFJd1ksUUFBUTtBQUNaLFFBQUk1aEI7QUFFSixTQUFLQSxJQUFJLEdBQUdBLElBQUl1aUIsU0FBU3hpQixRQUFRQyxLQUFLO0FBQ3BDLFlBQU13RyxRQUFRNkMsS0FBS3FELFFBQVExTSxDQUFFO0FBQzdCLFVBQUl3RyxVQUFVLFFBQVEsQ0FBQ3VWLE1BQU12VixLQUFBQSxLQUFVLEtBQUtsSSxNQUFNd2Usa0JBQWtCOWMsQ0FBQUEsS0FBTSxDQUFDdWlCLFNBQVN2aUIsQ0FBRSxFQUFDaU4sUUFBUTtBQUM3RjJVLGlCQUFTMWlCLEtBQUt3WSxJQUFJbFIsS0FBQUE7O0lBRXRCO0FBRUEsV0FBT29iO0VBQ1Q7RUFFQUssdUJBQXVCemIsT0FBTztBQUM1QixVQUFNb2IsUUFBUSxLQUFLeFcsWUFBWXdXO0FBQy9CLFFBQUlBLFFBQVEsS0FBSyxDQUFDN0YsTUFBTXZWLEtBQVEsR0FBQTtBQUM5QixhQUFPMFksT0FBT2hnQixLQUFLd1ksSUFBSWxSLEtBQUFBLElBQVNvYjs7QUFFbEMsV0FBTztFQUNUO0VBRUE3TyxpQkFBaUJ2SyxRQUFPO0FBQ3RCLFVBQU1hLE9BQU8sS0FBSytCO0FBQ2xCLFVBQU05TSxRQUFRLEtBQUtBO0FBQ25CLFVBQU1zVCxTQUFTdFQsTUFBTThLLEtBQUt3SSxVQUFVLENBQUE7QUFDcEMsVUFBTXBMLFFBQVFnYyxhQUFhblosS0FBS3FELFFBQVFsRSxNQUFBQSxHQUFRbEssTUFBTXdILFFBQVEyYyxNQUFNO0FBRXBFLFdBQU87TUFDTHpQLE9BQU9wQixPQUFPcEosTUFBQUEsS0FBVTtNQUN4QmhDO0lBQ0Y7RUFDRjtFQUVBd2Esa0JBQWtCRixNQUFNO0FBQ3RCLFFBQUl4ZixNQUFNO0FBQ1YsVUFBTWhELFFBQVEsS0FBS0E7QUFDbkIsUUFBSTBCLEdBQUd1SSxNQUFNYyxNQUFNNkIsWUFBWXBGO0FBRS9CLFFBQUksQ0FBQ2diLE1BQU07QUFFVCxXQUFLOWdCLElBQUksR0FBR3VJLE9BQU9qSyxNQUFNOEssS0FBS3lHLFNBQVM5UCxRQUFRQyxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUM1RCxZQUFJMUIsTUFBTXVpQixpQkFBaUI3Z0IsQ0FBSSxHQUFBO0FBQzdCcUosaUJBQU8vSyxNQUFNd1IsZUFBZTlQLENBQUFBO0FBQzVCOGdCLGlCQUFPelgsS0FBS0Q7QUFDWjhCLHVCQUFhN0IsS0FBSzZCO0FBQ2xCOztNQUVKOztBQUdGLFFBQUksQ0FBQzRWLE1BQU07QUFDVCxhQUFPOztBQUdULFNBQUs5Z0IsSUFBSSxHQUFHdUksT0FBT3VZLEtBQUsvZ0IsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDN0M4RixNQUFBQSxXQUFVb0YsV0FBV3dJLDBCQUEwQjFULENBQUFBO0FBQy9DLFVBQUk4RixTQUFRNGMsZ0JBQWdCLFNBQVM7QUFDbkNwaEIsY0FBTXBDLEtBQUtvQyxJQUFJQSxLQUFLd0UsU0FBUTZjLGVBQWUsR0FBRzdjLFNBQVE4YyxvQkFBb0IsQ0FBQTs7SUFFOUU7QUFDQSxXQUFPdGhCO0VBQ1Q7RUFFQTJmLGFBQWFILE1BQU07QUFDakIsUUFBSXhmLE1BQU07QUFFVixhQUFTdEIsSUFBSSxHQUFHdUksT0FBT3VZLEtBQUsvZ0IsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDakQsWUFBTThGLFdBQVUsS0FBSzROLDBCQUEwQjFULENBQUFBO0FBQy9Dc0IsWUFBTXBDLEtBQUtvQyxJQUFJQSxLQUFLd0UsU0FBUWlZLFVBQVUsR0FBR2pZLFNBQVErYyxlQUFlLENBQUE7SUFDbEU7QUFDQSxXQUFPdmhCO0VBQ1Q7RUFNQXdnQixxQkFBcUJoWixjQUFjO0FBQ2pDLFFBQUlnYSxtQkFBbUI7QUFFdkIsYUFBUzlpQixJQUFJLEdBQUdBLElBQUk4SSxjQUFjLEVBQUU5SSxHQUFHO0FBQ3JDLFVBQUksS0FBSzFCLE1BQU11aUIsaUJBQWlCN2dCLENBQUksR0FBQTtBQUNsQzhpQiw0QkFBb0IsS0FBS3pCLGVBQWVyaEIsQ0FBQUE7O0lBRTVDO0FBRUEsV0FBTzhpQjtFQUNUO0VBS0F6QixlQUFldlksY0FBYztBQUMzQixXQUFPNUosS0FBS29DLElBQUkyTixlQUFlLEtBQUszUSxNQUFNOEssS0FBS3lHLFNBQVMvRyxZQUFBQSxFQUFjaWEsUUFBUSxDQUFJLEdBQUEsQ0FBQTtFQUNwRjtFQU1BcEIsZ0NBQWdDO0FBQzlCLFdBQU8sS0FBS0cscUJBQXFCLEtBQUt4akIsTUFBTThLLEtBQUt5RyxTQUFTOVAsTUFBTSxLQUFLO0VBQ3ZFO0FBQ0Y7QUFyV0UsY0FGbUJzZ0Isb0JBRVpuVyxNQUFLO0FBS1osY0FQbUJtVyxvQkFPWmxiLFlBQVc7RUFDaEJnSixvQkFBb0I7RUFDcEJDLGlCQUFpQjtFQUNqQmhKLFdBQVc7SUFFVDRjLGVBQWU7SUFFZkssY0FBYztFQUNoQjtFQUNBcmMsWUFBWTtJQUNWNFgsU0FBUztNQUNQbmYsTUFBTTtNQUNOaUgsWUFBWTtRQUFDO1FBQWlCO1FBQVk7UUFBZTtRQUFlO1FBQWM7UUFBSztRQUFLO1FBQVU7UUFBZTtNQUFVO0lBQ3JJO0VBQ0Y7RUFFQW1aLFFBQVE7RUFHUkYsVUFBVTtFQUdWQyxlQUFlO0VBR2ZSLFFBQVE7RUFHUjJDLFNBQVM7RUFFVHpSLFdBQVc7O0FBR2IsY0F4Q21CK1Esb0JBd0NaMkMsZUFBYztFQUNuQkMsYUFBYSxDQUFDekcsU0FBU0EsU0FBUztFQUNoQzBHLFlBQVksQ0FBQzFHLFNBQVNBLFNBQVMsYUFBYSxDQUFDQSxLQUFLMkcsV0FBVyxZQUFpQixLQUFBLENBQUMzRyxLQUFLMkcsV0FBVyxpQkFBQTs7QUFNakcsY0FoRG1COUMsb0JBZ0RaeEMsYUFBWTtFQUNqQnVGLGFBQWE7RUFHYkMsU0FBUztJQUNQQyxRQUFRO01BQ04xUixRQUFRO1FBQ04yUixlQUFlamxCLE9BQU87QUFDcEIsZ0JBQU04SyxPQUFPOUssTUFBTThLO0FBQ25CLGNBQUlBLEtBQUt3SSxPQUFPN1IsVUFBVXFKLEtBQUt5RyxTQUFTOVAsUUFBUTtBQUM5QyxrQkFBTSxFQUFDNlIsUUFBUSxFQUFDNFIsWUFBWXRoQixPQUFBQSxPQUFBQSxFQUFNLElBQUk1RCxNQUFNZ2xCLE9BQU94ZDtBQUVuRCxtQkFBT3NELEtBQUt3SSxPQUFPNlIsSUFBSSxDQUFDelEsT0FBT2hULE1BQU07QUFDbkMsb0JBQU1xSixPQUFPL0ssTUFBTXdSLGVBQWUsQ0FBQTtBQUNsQyxvQkFBTTRULFFBQVFyYSxLQUFLNkIsV0FBV3NJLFNBQVN4VCxDQUFBQTtBQUV2QyxxQkFBTztnQkFDTDJqQixNQUFNM1E7Z0JBQ040USxXQUFXRixNQUFNRztnQkFDakJDLGFBQWFKLE1BQU1LO2dCQUNuQkMsV0FBVzloQjtnQkFDWCtoQixXQUFXUCxNQUFNZjtnQkFDakJhO2dCQUNBdlcsUUFBUSxDQUFDM08sTUFBTXdlLGtCQUFrQjljLENBQUFBO2dCQUdqQ3dJLE9BQU94STtjQUNUO1lBQ0YsQ0FBQTs7QUFFRixpQkFBTyxDQUFBO1FBQ1Q7TUFDRjtNQUVBa2tCLFFBQVFDLEdBQUdDLFlBQVlkLFFBQVE7QUFDN0JBLGVBQU9obEIsTUFBTStsQixxQkFBcUJELFdBQVc1YixLQUFLO0FBQ2xEOGEsZUFBT2hsQixNQUFNMEYsT0FBTTtNQUNyQjtJQUNGO0VBQ0Y7O0FDdEhXLElBQU1zZ0IsaUJBQU4sY0FBNkJuWCxrQkFBQUE7RUE2QjFDa0IsYUFBYTtBQUNYLFNBQUtOLHNCQUFzQjtBQUMzQixTQUFLQyxxQkFBcUI7QUFDMUIsVUFBTUssV0FBVTtFQUNsQjtFQUVBckssT0FBTzZFLE1BQU07QUFDWCxVQUFNUSxPQUFPLEtBQUsrQjtBQUNsQixVQUFNLEVBQUNnQixTQUFTbVksTUFBTW5iLE1BQU1pVixTQUFTLENBQUEsR0FBSW1HLFNBQVEsSUFBSW5iO0FBRXJELFVBQU1vYixxQkFBcUIsS0FBS25tQixNQUFNd1c7QUFDdEMsUUFBSSxFQUFDMVYsT0FBT2dTLE1BQUFBLElBQVNzVCxpQ0FBaUNyYixNQUFNZ1YsUUFBUW9HLGtCQUFBQTtBQUVwRSxTQUFLNVcsYUFBYXpPO0FBQ2xCLFNBQUswTyxhQUFhc0Q7QUFFbEIsUUFBSXVULG9CQUFvQnRiLElBQU8sR0FBQTtBQUM3QmpLLGNBQVE7QUFDUmdTLGNBQVFpTixPQUFPdGU7O0FBSWpCd2tCLFNBQUszZixTQUFTLEtBQUt0RztBQUNuQmltQixTQUFLSyxnQkFBZ0IsS0FBS3BjO0FBQzFCK2IsU0FBS00sYUFBYSxDQUFDLENBQUNMLFNBQVNLO0FBQzdCTixTQUFLbEcsU0FBU0E7QUFFZCxVQUFNdlksV0FBVSxLQUFLMk4sNkJBQTZCNUssSUFBQUE7QUFDbEQsUUFBSSxDQUFDLEtBQUsvQyxRQUFRZ2YsVUFBVTtBQUMxQmhmLE1BQUFBLFNBQVE2YyxjQUFjOztBQUV4QjdjLElBQUFBLFNBQVFpZixVQUFVLEtBQUtqZixRQUFRaWY7QUFDL0IsU0FBSzVQLGNBQWNvUCxNQUFNbm1CLFFBQVc7TUFDbEM0bUIsVUFBVSxDQUFDUDtNQUNYM2UsU0FBQUE7T0FDQytDLElBQUFBO0FBR0gsU0FBS29OLGVBQWVvSSxRQUFRamYsT0FBT2dTLE9BQU92SSxJQUFBQTtFQUM1QztFQUVBb04sZUFBZW9JLFFBQVFqZixPQUFPZ1MsT0FBT3ZJLE1BQU07QUFDekMsVUFBTW9ILFFBQVFwSCxTQUFTO0FBQ3ZCLFVBQU0sRUFBQ1MsUUFBUUMsUUFBUTJELFVBQVVzWCxTQUFBQSxJQUFZLEtBQUtwWjtBQUNsRCxVQUFNLEVBQUN5SixlQUFlRCxlQUFjLElBQUksS0FBS0csa0JBQWtCM1YsT0FBT3lKLElBQUFBO0FBQ3RFLFVBQU15QyxRQUFRaEMsT0FBT0c7QUFDckIsVUFBTThCLFFBQVFoQyxPQUFPRTtBQUNyQixVQUFNLEVBQUN3YixVQUFVRixRQUFBQSxJQUFXLEtBQUtqZjtBQUNqQyxVQUFNb2YsZUFBZUMsU0FBU0YsUUFBWUEsSUFBQUEsV0FBVzNhLE9BQU9FO0FBQzVELFVBQU00YSxlQUFlLEtBQUs5bUIsTUFBTXdXLHVCQUF1QjdFLFNBQVNwSCxTQUFTO0FBQ3pFLFVBQU0xQixNQUFNL0gsUUFBUWdTO0FBQ3BCLFVBQU1pVSxjQUFjaEgsT0FBT3RlO0FBQzNCLFFBQUl1bEIsYUFBYWxtQixRQUFRLEtBQUssS0FBSzhTLFVBQVU5UyxRQUFRLENBQUE7QUFFckQsYUFBU1ksSUFBSSxHQUFHQSxJQUFJcWxCLGFBQWEsRUFBRXJsQixHQUFHO0FBQ3BDLFlBQU1zZSxRQUFRRCxPQUFPcmUsQ0FBRTtBQUN2QixZQUFNMEYsYUFBYTBmLGVBQWU5RyxRQUFRLENBQUE7QUFFMUMsVUFBSXRlLElBQUlaLFNBQVNZLEtBQUttSCxLQUFLO0FBQ3pCekIsbUJBQVcrWSxPQUFPO0FBQ2xCOztBQUdGLFlBQU10VCxTQUFTLEtBQUsrRyxVQUFVbFMsQ0FBQUE7QUFDOUIsWUFBTXVsQixXQUFXbk4sY0FBY2pOLE9BQU9JLEtBQU0sQ0FBQTtBQUM1QyxZQUFNZ1QsU0FBUzdZLFdBQVc0RixLQUFNLElBQUdoQyxPQUFPcU8saUJBQWlCeE0sT0FBT0csS0FBQUEsR0FBUXRMLENBQUFBO0FBQzFFLFlBQU13ZSxTQUFTOVksV0FBVzZGLEtBQU0sSUFBRzBFLFNBQVNzVixXQUFXaGMsT0FBT3NSLGFBQVksSUFBS3RSLE9BQU9vTyxpQkFBaUJ6SyxXQUFXLEtBQUt6RSxXQUFXYyxRQUFRNEIsUUFBUStCLFFBQUFBLElBQVkvQixPQUFPSSxLQUFNLEdBQUV2TCxDQUFFO0FBRS9LMEYsaUJBQVcrWSxPQUFPMUMsTUFBTXdDLE1BQUFBLEtBQVd4QyxNQUFNeUMsTUFBVytHLEtBQUFBO0FBQ3BEN2YsaUJBQVdsRSxPQUFPeEIsSUFBSSxLQUFLLEtBQU0wWCxJQUFJdk0sT0FBT0csS0FBTSxJQUFHZ2EsV0FBV2hhLEtBQUFBLENBQU0sSUFBSzRaO0FBQzNFLFVBQUlILFNBQVM7QUFDWHJmLG1CQUFXeUYsU0FBU0E7QUFDcEJ6RixtQkFBVzhHLE1BQU1nWSxTQUFTcGIsS0FBS3BKLENBQUU7O0FBR25DLFVBQUk0VSxnQkFBZ0I7QUFDbEJsUCxtQkFBV0ksVUFBVStPLGlCQUFpQixLQUFLbkIsMEJBQTBCMVQsR0FBR3NlLE1BQU12YSxTQUFTLFdBQVc4RSxJQUFJOztBQUd4RyxVQUFJLENBQUN1YyxjQUFjO0FBQ2pCLGFBQUtqUSxjQUFjbUosT0FBT3RlLEdBQUcwRixZQUFZbUQsSUFBQUE7O0FBRzNDeWMsbUJBQWFuYTtJQUNmO0VBQ0Y7RUFLQTJILGlCQUFpQjtBQUNmLFVBQU16SixPQUFPLEtBQUsrQjtBQUNsQixVQUFNZ0IsVUFBVS9DLEtBQUsrQztBQUNyQixVQUFNb1osU0FBU3BaLFFBQVF0RyxXQUFXc0csUUFBUXRHLFFBQVE2YyxlQUFlO0FBQ2pFLFVBQU12WixPQUFPQyxLQUFLRCxRQUFRLENBQUE7QUFDMUIsUUFBSSxDQUFDQSxLQUFLckosUUFBUTtBQUNoQixhQUFPeWxCOztBQUVULFVBQU1DLGFBQWFyYyxLQUFLLENBQUUsRUFBQzNDLEtBQUssS0FBS2lOLDBCQUEwQixDQUFBLENBQUE7QUFDL0QsVUFBTWdTLFlBQVl0YyxLQUFLQSxLQUFLckosU0FBUyxDQUFFLEVBQUMwRyxLQUFLLEtBQUtpTiwwQkFBMEJ0SyxLQUFLckosU0FBUyxDQUFBLENBQUE7QUFDMUYsV0FBT2IsS0FBS29DLElBQUlra0IsUUFBUUMsWUFBWUMsU0FBYSxJQUFBO0VBQ25EO0VBRUF6bEIsT0FBTztBQUNMLFVBQU1vSixPQUFPLEtBQUsrQjtBQUNsQi9CLFNBQUsrQyxRQUFRdVosb0JBQW9CLEtBQUtybkIsTUFBTWdWLFdBQVdqSyxLQUFLQyxPQUFPRyxJQUFJO0FBQ3ZFLFVBQU14SixLQUFJO0VBQ1o7QUFDRjtBQXZJRSxjQUZtQnFrQixnQkFFWnBhLE1BQUs7QUFLWixjQVBtQm9hLGdCQU9abmYsWUFBVztFQUNoQmdKLG9CQUFvQjtFQUNwQkMsaUJBQWlCO0VBRWpCMFcsVUFBVTtFQUNWRyxVQUFVOztBQU1aLGNBbEJtQlgsZ0JBa0JaekcsYUFBWTtFQUNqQi9SLFFBQVE7SUFDTmdTLFNBQVM7TUFDUHJmLE1BQU07SUFDUjtJQUNBd2YsU0FBUztNQUNQeGYsTUFBTTtJQUNSO0VBQ0Y7O0FDNUJXLElBQU1tbkIsc0JBQU4sY0FBa0N6WSxrQkFBQUE7RUFvRi9DclAsWUFBWVEsT0FBT3dLLGNBQWM7QUFDL0IsVUFBTXhLLE9BQU93SyxZQUFBQTtBQUViLFNBQUt3WCxjQUFjbGlCO0FBQ25CLFNBQUttaUIsY0FBY25pQjtFQUNyQjtFQUVBMlUsaUJBQWlCdkssUUFBTztBQUN0QixVQUFNYSxPQUFPLEtBQUsrQjtBQUNsQixVQUFNOU0sUUFBUSxLQUFLQTtBQUNuQixVQUFNc1QsU0FBU3RULE1BQU04SyxLQUFLd0ksVUFBVSxDQUFBO0FBQ3BDLFVBQU1wTCxRQUFRZ2MsYUFBYW5aLEtBQUtxRCxRQUFRbEUsTUFBQUEsRUFBT1QsR0FBR3pKLE1BQU13SCxRQUFRMmMsTUFBTTtBQUV0RSxXQUFPO01BQ0x6UCxPQUFPcEIsT0FBT3BKLE1BQUFBLEtBQVU7TUFDeEJoQztJQUNGO0VBQ0Y7RUFFQWlMLGdCQUFnQnBJLE1BQU1ELE1BQU1oSyxPQUFPZ1MsT0FBTztBQUN4QyxXQUFPeVUsNEJBQTRCQyxLQUFLLElBQUksRUFBRXpjLE1BQU1ELE1BQU1oSyxPQUFPZ1MsS0FBQUE7RUFDbkU7RUFFQXBOLE9BQU82RSxNQUFNO0FBQ1gsVUFBTWlZLE9BQU8sS0FBSzFWLFlBQVloQztBQUU5QixTQUFLMmMsY0FBYTtBQUNsQixTQUFLOVAsZUFBZTZLLE1BQU0sR0FBR0EsS0FBSy9nQixRQUFROEksSUFBQUE7RUFDNUM7RUFLQTJKLFlBQVk7QUFDVixVQUFNbkosT0FBTyxLQUFLK0I7QUFDbEIsVUFBTWlILFFBQVE7TUFBQ2xULEtBQUttTCxPQUFPRTtNQUFtQmxKLEtBQUtnSixPQUFPQztJQUFpQjtBQUUzRWxCLFNBQUtELEtBQUt0SyxRQUFRLENBQUN3TixTQUFTOUQsV0FBVTtBQUNwQyxZQUFNMkMsU0FBUyxLQUFLK0csVUFBVTFKLE1BQUFBLEVBQU9UO0FBRXJDLFVBQUksQ0FBQ2dVLE1BQU01USxNQUFXLEtBQUEsS0FBSzdNLE1BQU13ZSxrQkFBa0J0VSxNQUFRLEdBQUE7QUFDekQsWUFBSTJDLFNBQVNrSCxNQUFNbFQsS0FBSztBQUN0QmtULGdCQUFNbFQsTUFBTWdNOztBQUdkLFlBQUlBLFNBQVNrSCxNQUFNL1EsS0FBSztBQUN0QitRLGdCQUFNL1EsTUFBTTZKOzs7SUFHbEIsQ0FBQTtBQUVBLFdBQU9rSDtFQUNUO0VBS0EwVCxnQkFBZ0I7QUFDZCxVQUFNem5CLFFBQVEsS0FBS0E7QUFDbkIsVUFBTWdWLFlBQVloVixNQUFNZ1Y7QUFDeEIsVUFBTXJNLE9BQU8zSSxNQUFNd0g7QUFDbkIsVUFBTWtnQixVQUFVOW1CLEtBQUtDLElBQUltVSxVQUFVNUwsUUFBUTRMLFVBQVUxTCxNQUFNMEwsVUFBVTNMLFNBQVMyTCxVQUFVN0wsR0FBRztBQUUzRixVQUFNOFksY0FBY3JoQixLQUFLb0MsSUFBSTBrQixVQUFVLEdBQUcsQ0FBQTtBQUMxQyxVQUFNMUYsY0FBY3BoQixLQUFLb0MsSUFBSTJGLEtBQUtnZixtQkFBbUIsY0FBZSxNQUFRaGYsS0FBS2dmLG1CQUFvQixHQUFHLENBQUE7QUFDeEcsVUFBTXZFLGdCQUFnQm5CLGNBQWNELGVBQWVoaUIsTUFBTTRuQix1QkFBc0I7QUFFL0UsU0FBSzNGLGNBQWNBLGNBQWVtQixlQUFlLEtBQUtsWjtBQUN0RCxTQUFLOFgsY0FBYyxLQUFLQyxjQUFjbUI7RUFDeEM7RUFFQXpMLGVBQWU2SyxNQUFNMWhCLE9BQU9nUyxPQUFPdkksTUFBTTtBQUN2QyxVQUFNb0gsUUFBUXBILFNBQVM7QUFDdkIsVUFBTXZLLFFBQVEsS0FBS0E7QUFDbkIsVUFBTTJJLE9BQU8zSSxNQUFNd0g7QUFDbkIsVUFBTW9jLGdCQUFnQmpiLEtBQUs3QjtBQUMzQixVQUFNMkIsUUFBUSxLQUFLcUUsWUFBWXdFO0FBQy9CLFVBQU11UyxVQUFVcGIsTUFBTW9mO0FBQ3RCLFVBQU0vRCxVQUFVcmIsTUFBTXFmO0FBQ3RCLFVBQU1DLG9CQUFvQnRmLE1BQU11ZixjQUFjLENBQUEsSUFBSyxNQUFNbkc7QUFDekQsUUFBSVAsUUFBUXlHO0FBQ1osUUFBSXJtQjtBQUVKLFVBQU11bUIsZUFBZSxNQUFNLEtBQUtDLHFCQUFvQjtBQUVwRCxTQUFLeG1CLElBQUksR0FBR0EsSUFBSVosT0FBTyxFQUFFWSxHQUFHO0FBQzFCNGYsZUFBUyxLQUFLNkcsY0FBY3ptQixHQUFHNkksTUFBTTBkLFlBQUFBO0lBQ3ZDO0FBQ0EsU0FBS3ZtQixJQUFJWixPQUFPWSxJQUFJWixRQUFRZ1MsT0FBT3BSLEtBQUs7QUFDdEMsWUFBTXNpQixNQUFNeEIsS0FBSzlnQixDQUFFO0FBQ25CLFVBQUltZixhQUFhUztBQUNqQixVQUFJUixXQUFXUSxRQUFRLEtBQUs2RyxjQUFjem1CLEdBQUc2SSxNQUFNMGQsWUFBQUE7QUFDbkQsVUFBSWhHLGNBQWNqaUIsTUFBTXdlLGtCQUFrQjljLENBQUFBLElBQUsrRyxNQUFNMmYsOEJBQThCLEtBQUt4VSxVQUFVbFMsQ0FBRytILEVBQUFBLENBQUMsSUFBSTtBQUMxRzZYLGNBQVFSO0FBRVIsVUFBSW5QLE9BQU87QUFDVCxZQUFJaVMsY0FBY0csY0FBYztBQUM5QjlCLHdCQUFjOztBQUVoQixZQUFJMkIsY0FBY0YsZUFBZTtBQUMvQjdDLHVCQUFhQyxXQUFXaUg7OztBQUk1QixZQUFNM2dCLGFBQWE7UUFDakI2QixHQUFHNGE7UUFDSDNhLEdBQUc0YTtRQUNIOUIsYUFBYTtRQUNiQztRQUNBcEI7UUFDQUM7UUFDQXRaLFNBQVMsS0FBSzROLDBCQUEwQjFULEdBQUdzaUIsSUFBSXZlLFNBQVMsV0FBVzhFLElBQUk7TUFDekU7QUFFQSxXQUFLc00sY0FBY21OLEtBQUt0aUIsR0FBRzBGLFlBQVltRCxJQUFBQTtJQUN6QztFQUNGO0VBRUEyZCx1QkFBdUI7QUFDckIsVUFBTW5kLE9BQU8sS0FBSytCO0FBQ2xCLFFBQUlnRyxRQUFRO0FBRVovSCxTQUFLRCxLQUFLdEssUUFBUSxDQUFDd04sU0FBUzlELFdBQVU7QUFDcEMsVUFBSSxDQUFDdVQsTUFBTSxLQUFLN0osVUFBVTFKLE1BQUFBLEVBQU9ULENBQUMsS0FBSyxLQUFLekosTUFBTXdlLGtCQUFrQnRVLE1BQVEsR0FBQTtBQUMxRTRJOztJQUVKLENBQUE7QUFFQSxXQUFPQTtFQUNUO0VBS0FxVixjQUFjamUsUUFBT0ssTUFBTTBkLGNBQWM7QUFDdkMsV0FBTyxLQUFLam9CLE1BQU13ZSxrQkFBa0J0VSxNQUNoQ2tZLElBQUFBLFVBQVUsS0FBS2hOLDBCQUEwQmxMLFFBQU9LLElBQUFBLEVBQU0rVyxTQUFTMkcsWUFBQUEsSUFDL0Q7RUFDTjtBQUNGO0FBN05FLGNBRm1CWCxxQkFFWjFiLE1BQUs7QUFLWixjQVBtQjBiLHFCQU9aemdCLFlBQVc7RUFDaEJpSixpQkFBaUI7RUFDakJoSixXQUFXO0lBQ1Q0YyxlQUFlO0lBQ2ZLLGNBQWM7RUFDaEI7RUFDQXJjLFlBQVk7SUFDVjRYLFNBQVM7TUFDUG5mLE1BQU07TUFDTmlILFlBQVk7UUFBQztRQUFLO1FBQUs7UUFBYztRQUFZO1FBQWU7TUFBYztJQUNoRjtFQUNGO0VBQ0E0SixXQUFXO0VBQ1g2UCxZQUFZOztBQU1kLGNBMUJtQnlHLHFCQTBCWi9ILGFBQVk7RUFDakJ1RixhQUFhO0VBRWJDLFNBQVM7SUFDUEMsUUFBUTtNQUNOMVIsUUFBUTtRQUNOMlIsZUFBZWpsQixPQUFPO0FBQ3BCLGdCQUFNOEssT0FBTzlLLE1BQU04SztBQUNuQixjQUFJQSxLQUFLd0ksT0FBTzdSLFVBQVVxSixLQUFLeUcsU0FBUzlQLFFBQVE7QUFDOUMsa0JBQU0sRUFBQzZSLFFBQVEsRUFBQzRSLFlBQVl0aEIsT0FBQUEsT0FBQUEsRUFBTSxJQUFJNUQsTUFBTWdsQixPQUFPeGQ7QUFFbkQsbUJBQU9zRCxLQUFLd0ksT0FBTzZSLElBQUksQ0FBQ3pRLE9BQU9oVCxNQUFNO0FBQ25DLG9CQUFNcUosT0FBTy9LLE1BQU13UixlQUFlLENBQUE7QUFDbEMsb0JBQU00VCxRQUFRcmEsS0FBSzZCLFdBQVdzSSxTQUFTeFQsQ0FBQUE7QUFFdkMscUJBQU87Z0JBQ0wyakIsTUFBTTNRO2dCQUNONFEsV0FBV0YsTUFBTUc7Z0JBQ2pCQyxhQUFhSixNQUFNSztnQkFDbkJDLFdBQVc5aEI7Z0JBQ1graEIsV0FBV1AsTUFBTWY7Z0JBQ2pCYTtnQkFDQXZXLFFBQVEsQ0FBQzNPLE1BQU13ZSxrQkFBa0I5YyxDQUFBQTtnQkFHakN3SSxPQUFPeEk7Y0FDVDtZQUNGLENBQUE7O0FBRUYsaUJBQU8sQ0FBQTtRQUNUO01BQ0Y7TUFFQWtrQixRQUFRQyxHQUFHQyxZQUFZZCxRQUFRO0FBQzdCQSxlQUFPaGxCLE1BQU0rbEIscUJBQXFCRCxXQUFXNWIsS0FBSztBQUNsRDhhLGVBQU9obEIsTUFBTTBGLE9BQU07TUFDckI7SUFDRjtFQUNGO0VBRUE4SCxRQUFRO0lBQ04vRCxHQUFHO01BQ0R0SixNQUFNO01BQ05rb0IsWUFBWTtRQUNWQyxTQUFTO01BQ1g7TUFDQTFJLGFBQWE7TUFDYkYsTUFBTTtRQUNKNkksVUFBVTtNQUNaO01BQ0FDLGFBQWE7UUFDWEYsU0FBUztNQUNYO01BQ0F6SCxZQUFZO0lBQ2Q7RUFDRjs7QUNqRlcsSUFBTTRILGdCQUFOLGNBQTRCMUcsbUJBQUFBO0FBb0IzQztBQWxCRSxjQUZtQjBHLGVBRVo3YyxNQUFLO0FBS1osY0FQbUI2YyxlQU9aNWhCLFlBQVc7RUFFaEIwWixRQUFRO0VBR1JGLFVBQVU7RUFHVkMsZUFBZTtFQUdmUixRQUFROztBQ2xCRyxJQUFNNEksa0JBQU4sY0FBOEI3WixrQkFBQUE7RUFtQzNDNEYsaUJBQWlCdkssUUFBTztBQUN0QixVQUFNZSxTQUFTLEtBQUs2QixZQUFZN0I7QUFDaEMsVUFBTTRCLFNBQVMsS0FBSytHLFVBQVUxSixNQUFBQTtBQUU5QixXQUFPO01BQ0x3SyxPQUFPekosT0FBT3NJLFVBQVMsRUFBR3JKLE1BQU07TUFDaENoQyxPQUFPLEtBQUsrQyxPQUFPMEosaUJBQWlCOUgsT0FBTzVCLE9BQU9FLElBQUksQ0FBQztJQUN6RDtFQUNGO0VBRUFnSSxnQkFBZ0JwSSxNQUFNRCxNQUFNaEssT0FBT2dTLE9BQU87QUFDeEMsV0FBT3lVLDRCQUE0QkMsS0FBSyxJQUFJLEVBQUV6YyxNQUFNRCxNQUFNaEssT0FBT2dTLEtBQUFBO0VBQ25FO0VBRUFwTixPQUFPNkUsTUFBTTtBQUNYLFVBQU1RLE9BQU8sS0FBSytCO0FBQ2xCLFVBQU1tWixPQUFPbGIsS0FBSytDO0FBQ2xCLFVBQU1pUyxTQUFTaFYsS0FBS0QsUUFBUSxDQUFBO0FBQzVCLFVBQU13SSxTQUFTdkksS0FBS0MsT0FBT3VJLFVBQVM7QUFHcEMwUyxTQUFLbEcsU0FBU0E7QUFFZCxRQUFJeFYsU0FBUyxVQUFVO0FBQ3JCLFlBQU0vQyxXQUFVLEtBQUsyTiw2QkFBNkI1SyxJQUFBQTtBQUNsRCxVQUFJLENBQUMsS0FBSy9DLFFBQVFnZixVQUFVO0FBQzFCaGYsUUFBQUEsU0FBUTZjLGNBQWM7O0FBR3hCLFlBQU1qZCxhQUFhO1FBQ2pCbEMsT0FBTztRQUNQeWpCLFdBQVdyVixPQUFPN1IsV0FBV3NlLE9BQU90ZTtRQUNwQytGLFNBQUFBO01BQ0Y7QUFFQSxXQUFLcVAsY0FBY29QLE1BQU1ubUIsUUFBV3NILFlBQVltRCxJQUFBQTs7QUFJbEQsU0FBS29OLGVBQWVvSSxRQUFRLEdBQUdBLE9BQU90ZSxRQUFROEksSUFBQUE7RUFDaEQ7RUFFQW9OLGVBQWVvSSxRQUFRamYsT0FBT2dTLE9BQU92SSxNQUFNO0FBQ3pDLFVBQU05QixRQUFRLEtBQUtxRSxZQUFZd0U7QUFDL0IsVUFBTUssUUFBUXBILFNBQVM7QUFFdkIsYUFBUzdJLElBQUlaLE9BQU9ZLElBQUlaLFFBQVFnUyxPQUFPcFIsS0FBSztBQUMxQyxZQUFNc2UsUUFBUUQsT0FBT3JlLENBQUU7QUFDdkIsWUFBTThGLFdBQVUsS0FBSzROLDBCQUEwQjFULEdBQUdzZSxNQUFNdmEsU0FBUyxXQUFXOEUsSUFBSTtBQUNoRixZQUFNcWUsZ0JBQWdCbmdCLE1BQU1vZ0IseUJBQXlCbm5CLEdBQUcsS0FBS2tTLFVBQVVsUyxDQUFBQSxFQUFHK0gsQ0FBQztBQUUzRSxZQUFNUixJQUFJMEksUUFBUWxKLE1BQU1vZixVQUFVZSxjQUFjM2Y7QUFDaEQsWUFBTUMsSUFBSXlJLFFBQVFsSixNQUFNcWYsVUFBVWMsY0FBYzFmO0FBRWhELFlBQU05QixhQUFhO1FBQ2pCNkI7UUFDQUM7UUFDQW9ZLE9BQU9zSCxjQUFjdEg7UUFDckJuQixNQUFNMUMsTUFBTXhVLENBQUFBLEtBQU13VSxNQUFNdlUsQ0FBQUE7UUFDeEIxQixTQUFBQTtNQUNGO0FBRUEsV0FBS3FQLGNBQWNtSixPQUFPdGUsR0FBRzBGLFlBQVltRCxJQUFBQTtJQUMzQztFQUNGO0FBQ0Y7QUFsR0UsY0FGbUJtZSxpQkFFWjljLE1BQUs7QUFLWixjQVBtQjhjLGlCQU9aN2hCLFlBQVc7RUFDaEJnSixvQkFBb0I7RUFDcEJDLGlCQUFpQjtFQUNqQmtCLFdBQVc7RUFDWHdWLFVBQVU7RUFDVjFSLFVBQVU7SUFDUm1SLE1BQU07TUFDSi9WLE1BQU07SUFDUjtFQUNGOztBQU1GLGNBdEJtQndZLGlCQXNCWm5KLGFBQVk7RUFDakJ1RixhQUFhO0VBRWJ0WCxRQUFRO0lBQ04vRCxHQUFHO01BQ0R0SixNQUFNO0lBQ1I7RUFDRjs7QUMzQlcsSUFBTTJvQixvQkFBTixjQUFnQ2phLGtCQUFBQTtFQW9DN0M0RixpQkFBaUJ2SyxRQUFPO0FBQ3RCLFVBQU1hLE9BQU8sS0FBSytCO0FBQ2xCLFVBQU13RyxTQUFTLEtBQUt0VCxNQUFNOEssS0FBS3dJLFVBQVUsQ0FBQTtBQUN6QyxVQUFNLEVBQUN2SyxRQUFRQyxPQUFBQSxJQUFVK0I7QUFDekIsVUFBTThCLFNBQVMsS0FBSytHLFVBQVUxSixNQUFBQTtBQUM5QixVQUFNakIsSUFBSUYsT0FBTzRMLGlCQUFpQjlILE9BQU81RCxDQUFDO0FBQzFDLFVBQU1DLElBQUlGLE9BQU8yTCxpQkFBaUI5SCxPQUFPM0QsQ0FBQztBQUUxQyxXQUFPO01BQ0x3TCxPQUFPcEIsT0FBT3BKLE1BQUFBLEtBQVU7TUFDeEJoQyxPQUFPLE1BQU1lLElBQUksT0FBT0MsSUFBSTtJQUM5QjtFQUNGO0VBRUF4RCxPQUFPNkUsTUFBTTtBQUNYLFVBQU1RLE9BQU8sS0FBSytCO0FBQ2xCLFVBQU0sRUFBQ2hDLE1BQU1pVixTQUFTLENBQUEsRUFBRSxJQUFJaFY7QUFFNUIsVUFBTW9iLHFCQUFxQixLQUFLbm1CLE1BQU13VztBQUN0QyxRQUFJLEVBQUMxVixPQUFPZ1MsTUFBQUEsSUFBU3NULGlDQUFpQ3JiLE1BQU1nVixRQUFRb0csa0JBQUFBO0FBRXBFLFNBQUs1VyxhQUFhek87QUFDbEIsU0FBSzBPLGFBQWFzRDtBQUVsQixRQUFJdVQsb0JBQW9CdGIsSUFBTyxHQUFBO0FBQzdCakssY0FBUTtBQUNSZ1MsY0FBUWlOLE9BQU90ZTs7QUFHakIsUUFBSSxLQUFLK0YsUUFBUWdmLFVBQVU7QUFHekIsVUFBSSxDQUFDLEtBQUszVyxvQkFBb0I7QUFDNUIsYUFBS0ksWUFBVzs7QUFFbEIsWUFBTSxFQUFDbkMsU0FBU21ZLE1BQU1DLFNBQUFBLElBQVluYjtBQUdsQ2tiLFdBQUszZixTQUFTLEtBQUt0RztBQUNuQmltQixXQUFLSyxnQkFBZ0IsS0FBS3BjO0FBQzFCK2IsV0FBS00sYUFBYSxDQUFDLENBQUNMLFNBQVNLO0FBQzdCTixXQUFLbEcsU0FBU0E7QUFFZCxZQUFNdlksV0FBVSxLQUFLMk4sNkJBQTZCNUssSUFBQUE7QUFDbEQvQyxNQUFBQSxTQUFRaWYsVUFBVSxLQUFLamYsUUFBUWlmO0FBQy9CLFdBQUs1UCxjQUFjb1AsTUFBTW5tQixRQUFXO1FBQ2xDNG1CLFVBQVUsQ0FBQ1A7UUFDWDNlLFNBQUFBO1NBQ0MrQyxJQUFBQTtJQUNMLFdBQVcsS0FBS3NGLG9CQUFvQjtBQUVsQyxhQUFPOUUsS0FBSytDO0FBQ1osV0FBSytCLHFCQUFxQjs7QUFJNUIsU0FBSzhILGVBQWVvSSxRQUFRamYsT0FBT2dTLE9BQU92SSxJQUFBQTtFQUM1QztFQUVBMEYsY0FBYztBQUNaLFVBQU0sRUFBQ3VXLFNBQVEsSUFBSSxLQUFLaGY7QUFFeEIsUUFBSSxDQUFDLEtBQUtxSSxzQkFBc0IyVyxVQUFVO0FBQ3hDLFdBQUszVyxxQkFBcUIsS0FBSzdQLE1BQU0rb0IsU0FBU0MsV0FBVyxNQUFBOztBQUczRCxVQUFNL1ksWUFBVztFQUNuQjtFQUVBMEgsZUFBZW9JLFFBQVFqZixPQUFPZ1MsT0FBT3ZJLE1BQU07QUFDekMsVUFBTW9ILFFBQVFwSCxTQUFTO0FBQ3ZCLFVBQU0sRUFBQ1MsUUFBUUMsUUFBUTJELFVBQVVzWCxTQUFBQSxJQUFZLEtBQUtwWjtBQUNsRCxVQUFNNEosWUFBWSxLQUFLdEIsMEJBQTBCdFUsT0FBT3lKLElBQUFBO0FBQ3hELFVBQU1nTSxnQkFBZ0IsS0FBS0YsaUJBQWlCSyxTQUFBQTtBQUM1QyxVQUFNSixpQkFBaUIsS0FBS0EsZUFBZS9MLE1BQU1nTSxhQUFBQTtBQUNqRCxVQUFNdkosUUFBUWhDLE9BQU9HO0FBQ3JCLFVBQU04QixRQUFRaEMsT0FBT0U7QUFDckIsVUFBTSxFQUFDd2IsVUFBVUYsUUFBQUEsSUFBVyxLQUFLamY7QUFDakMsVUFBTW9mLGVBQWVDLFNBQVNGLFFBQVlBLElBQUFBLFdBQVczYSxPQUFPRTtBQUM1RCxVQUFNNGEsZUFBZSxLQUFLOW1CLE1BQU13Vyx1QkFBdUI3RSxTQUFTcEgsU0FBUztBQUN6RSxRQUFJeWMsYUFBYWxtQixRQUFRLEtBQUssS0FBSzhTLFVBQVU5UyxRQUFRLENBQUE7QUFFckQsYUFBU1ksSUFBSVosT0FBT1ksSUFBSVosUUFBUWdTLE9BQU8sRUFBRXBSLEdBQUc7QUFDMUMsWUFBTXNlLFFBQVFELE9BQU9yZSxDQUFFO0FBQ3ZCLFlBQU1tTCxTQUFTLEtBQUsrRyxVQUFVbFMsQ0FBQUE7QUFDOUIsWUFBTTBGLGFBQWEwZixlQUFlOUcsUUFBUSxDQUFBO0FBQzFDLFlBQU1pSCxXQUFXbk4sY0FBY2pOLE9BQU9JLEtBQU0sQ0FBQTtBQUM1QyxZQUFNZ1QsU0FBUzdZLFdBQVc0RixLQUFNLElBQUdoQyxPQUFPcU8saUJBQWlCeE0sT0FBT0csS0FBQUEsR0FBUXRMLENBQUFBO0FBQzFFLFlBQU13ZSxTQUFTOVksV0FBVzZGLEtBQU0sSUFBRzBFLFNBQVNzVixXQUFXaGMsT0FBT3NSLGFBQVksSUFBS3RSLE9BQU9vTyxpQkFBaUJ6SyxXQUFXLEtBQUt6RSxXQUFXYyxRQUFRNEIsUUFBUStCLFFBQUFBLElBQVkvQixPQUFPSSxLQUFNLEdBQUV2TCxDQUFFO0FBRS9LMEYsaUJBQVcrWSxPQUFPMUMsTUFBTXdDLE1BQUFBLEtBQVd4QyxNQUFNeUMsTUFBVytHLEtBQUFBO0FBQ3BEN2YsaUJBQVdsRSxPQUFPeEIsSUFBSSxLQUFLLEtBQU0wWCxJQUFJdk0sT0FBT0csS0FBTSxJQUFHZ2EsV0FBV2hhLEtBQUFBLENBQU0sSUFBSzRaO0FBQzNFLFVBQUlILFNBQVM7QUFDWHJmLG1CQUFXeUYsU0FBU0E7QUFDcEJ6RixtQkFBVzhHLE1BQU1nWSxTQUFTcGIsS0FBS3BKLENBQUU7O0FBR25DLFVBQUk0VSxnQkFBZ0I7QUFDbEJsUCxtQkFBV0ksVUFBVStPLGlCQUFpQixLQUFLbkIsMEJBQTBCMVQsR0FBR3NlLE1BQU12YSxTQUFTLFdBQVc4RSxJQUFJOztBQUd4RyxVQUFJLENBQUN1YyxjQUFjO0FBQ2pCLGFBQUtqUSxjQUFjbUosT0FBT3RlLEdBQUcwRixZQUFZbUQsSUFBQUE7O0FBRzNDeWMsbUJBQWFuYTtJQUNmO0FBRUEsU0FBSytKLG9CQUFvQkwsZUFBZWhNLE1BQU1tTSxTQUFBQTtFQUNoRDtFQUtBbEMsaUJBQWlCO0FBQ2YsVUFBTXpKLE9BQU8sS0FBSytCO0FBQ2xCLFVBQU1oQyxPQUFPQyxLQUFLRCxRQUFRLENBQUE7QUFFMUIsUUFBSSxDQUFDLEtBQUt0RCxRQUFRZ2YsVUFBVTtBQUMxQixVQUFJeGpCLE1BQU07QUFDVixlQUFTdEIsSUFBSW9KLEtBQUtySixTQUFTLEdBQUdDLEtBQUssR0FBRyxFQUFFQSxHQUFHO0FBQ3pDc0IsY0FBTXBDLEtBQUtvQyxJQUFJQSxLQUFLOEgsS0FBS3BKLENBQUFBLEVBQUd5RyxLQUFLLEtBQUtpTiwwQkFBMEIxVCxDQUFNLENBQUEsSUFBQSxDQUFBO01BQ3hFO0FBQ0EsYUFBT3NCLE1BQU0sS0FBS0E7O0FBR3BCLFVBQU04SyxVQUFVL0MsS0FBSytDO0FBQ3JCLFVBQU1vWixTQUFTcFosUUFBUXRHLFdBQVdzRyxRQUFRdEcsUUFBUTZjLGVBQWU7QUFFakUsUUFBSSxDQUFDdlosS0FBS3JKLFFBQVE7QUFDaEIsYUFBT3lsQjs7QUFHVCxVQUFNQyxhQUFhcmMsS0FBSyxDQUFFLEVBQUMzQyxLQUFLLEtBQUtpTiwwQkFBMEIsQ0FBQSxDQUFBO0FBQy9ELFVBQU1nUyxZQUFZdGMsS0FBS0EsS0FBS3JKLFNBQVMsQ0FBRSxFQUFDMEcsS0FBSyxLQUFLaU4sMEJBQTBCdEssS0FBS3JKLFNBQVMsQ0FBQSxDQUFBO0FBQzFGLFdBQU9iLEtBQUtvQyxJQUFJa2tCLFFBQVFDLFlBQVlDLFNBQWEsSUFBQTtFQUNuRDtBQUNGO0FBM0tFLGNBRm1CMEIsbUJBRVpsZCxNQUFLO0FBS1osY0FQbUJrZCxtQkFPWmppQixZQUFXO0VBQ2hCZ0osb0JBQW9CO0VBQ3BCQyxpQkFBaUI7RUFDakIwVyxVQUFVO0VBQ1Z0VyxNQUFNOztBQU1SLGNBakJtQjRZLG1CQWlCWnZKLGFBQVk7RUFFakIwSixhQUFhO0lBQ1gxZSxNQUFNO0VBQ1I7RUFFQWlELFFBQVE7SUFDTnZFLEdBQUc7TUFDRDlJLE1BQU07SUFDUjtJQUNBK0ksR0FBRztNQUNEL0ksTUFBTTtJQUNSO0VBQ0Y7Ozs7Ozs7Ozs7Ozs7QUM2QkosU0FBUytvQixXQUF3QjtBQUMvQixRQUFNLElBQUlDLE1BQU0saUZBQW1GO0FBQ3JHO0FBUUEsSUFBTUMsa0JBQU4sTUFBTUEsaUJBQUFBO0VBb0JKNXBCLFlBQVlnSSxVQUFxQjtBQUZ4QkE7QUFHUCxTQUFLQSxVQUFVQSxZQUFXLENBQUE7RUFDNUI7Ozs7Ozs7Ozs7O0VBVkEsT0FBTzZoQixTQUNMQyxTQUNBO0FBQ0EzaUIsV0FBT3lCLE9BQU9naEIsaUJBQWdCRyxXQUFXRCxPQUFBQTtFQUMzQzs7RUFTQUUsT0FBTztFQUFBO0VBRVBDLFVBQWlEO0FBQy9DLFdBQU9QLFNBQUFBO0VBQ1Q7RUFFQXJXLFFBQXVCO0FBQ3JCLFdBQU9xVyxTQUFBQTtFQUNUO0VBRUFRLFNBQWlCO0FBQ2YsV0FBT1IsU0FBQUE7RUFDVDtFQUVBdm1CLE1BQWM7QUFDWixXQUFPdW1CLFNBQUFBO0VBQ1Q7RUFFQVMsT0FBZTtBQUNiLFdBQU9ULFNBQUFBO0VBQ1Q7RUFFQVUsVUFBa0I7QUFDaEIsV0FBT1YsU0FBQUE7RUFDVDtFQUVBVyxRQUFnQjtBQUNkLFdBQU9YLFNBQUFBO0VBQ1Q7QUFDRjtBQUVBLElBQUEsV0FBZTtFQUNiWSxPQUFPVjtBQU1UO0FDcEhBLFNBQVNXLGFBQWFDLFNBQVM3ZSxNQUFNakQsT0FBTytoQixXQUFXO0FBQ3JELFFBQU0sRUFBQ3JkLFlBQVk5QixNQUFNa0ksUUFBQUEsSUFBV2dYO0FBQ3BDLFFBQU1oZixTQUFTNEIsV0FBV0UsWUFBWTlCO0FBQ3RDLFFBQU0yYixXQUFXcUQsUUFBUWxjLFVBQVVrYyxRQUFRbGMsUUFBUXRHLFVBQVV3aUIsUUFBUWxjLFFBQVF0RyxRQUFRbWYsV0FBVyxPQUFPO0FBRXZHLE1BQUkzYixVQUFVRyxTQUFTSCxPQUFPRyxRQUFRQSxTQUFTLE9BQU82SCxXQUFXbEksS0FBS3JKLFFBQVE7QUFDNUUsVUFBTXlvQixlQUFlbGYsT0FBT21mLGlCQUFpQkMsZ0JBQWdCQztBQUM3RCxRQUFJLENBQUNKLFdBQVc7QUFDZCxZQUFNSyxTQUFTSixhQUFhcGYsTUFBTUssTUFBTWpELEtBQUFBO0FBQ3hDLFVBQUl5ZSxVQUFVO0FBQ1osY0FBTSxFQUFDMWIsT0FBQUEsSUFBVTJCLFdBQVdFO0FBQzVCLGNBQU0sRUFBQ3NCLFFBQU8sSUFBSTRiO0FBRWxCLGNBQU1PLHNCQUF1Qm5jLFFBQzFCb2MsTUFBTSxHQUFHRixPQUFPRyxLQUFLLENBQ3JCN2hCLEVBQUFBLFFBQU8sRUFDUDhoQixVQUNDMUssQ0FBQUEsVUFBUyxDQUFDbEcsY0FBY2tHLE1BQU0vVSxPQUFPRSxJQUFJLENBQUMsQ0FBQTtBQUM5Q21mLGVBQU9HLE1BQU03cEIsS0FBS29DLElBQUksR0FBR3VuQixtQkFBQUE7QUFFekIsY0FBTUksc0JBQXVCdmMsUUFDMUJvYyxNQUFNRixPQUFPTSxFQUFFLEVBQ2ZGLFVBQ0MxSyxDQUFBQSxVQUFTLENBQUNsRyxjQUFja0csTUFBTS9VLE9BQU9FLElBQUksQ0FBQyxDQUFBO0FBQzlDbWYsZUFBT00sTUFBTWhxQixLQUFLb0MsSUFBSSxHQUFHMm5CLG1CQUFBQTs7QUFFM0IsYUFBT0w7ZUFDRTFkLFdBQVcwQyxnQkFBZ0I7QUFJcEMsWUFBTXViLEtBQUsvZixLQUFLLENBQUU7QUFDbEIsWUFBTWlKLFFBQVEsT0FBTzhXLEdBQUdDLGFBQWEsY0FBY0QsR0FBR0MsU0FBUzNmLElBQUFBO0FBQy9ELFVBQUk0SSxPQUFPO0FBQ1QsY0FBTWpULFFBQVFvcEIsYUFBYXBmLE1BQU1LLE1BQU1qRCxRQUFRNkwsS0FBQUE7QUFDL0MsY0FBTWxMLE1BQU1xaEIsYUFBYXBmLE1BQU1LLE1BQU1qRCxRQUFRNkwsS0FBQUE7QUFDN0MsZUFBTztVQUFDMFcsSUFBSTNwQixNQUFNMnBCO1VBQUlHLElBQUkvaEIsSUFBSStoQjtRQUFFOzs7O0FBS3RDLFNBQU87SUFBQ0gsSUFBSTtJQUFHRyxJQUFJOWYsS0FBS3JKLFNBQVM7RUFBQztBQUNwQztBQVVBLFNBQVNzcEIseUJBQXlCL3FCLE9BQU9tTCxNQUFNNmYsVUFBVUMsU0FBU2hCLFdBQVc7QUFDM0UsUUFBTWxnQixXQUFXL0osTUFBTWtyQiw2QkFBNEI7QUFDbkQsUUFBTWhqQixRQUFROGlCLFNBQVM3ZixJQUFLO0FBQzVCLFdBQVN6SixJQUFJLEdBQUd1SSxPQUFPRixTQUFTdEksUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDckQsVUFBTSxFQUFDd0ksT0FBQUEsUUFBT1ksS0FBQUEsSUFBUWYsU0FBU3JJLENBQUU7QUFDakMsVUFBTSxFQUFDK29CLElBQUlHLEdBQUFBLElBQU1iLGFBQWFoZ0IsU0FBU3JJLENBQUFBLEdBQUl5SixNQUFNakQsT0FBTytoQixTQUFBQTtBQUN4RCxhQUFTa0IsSUFBSVYsSUFBSVUsS0FBS1AsSUFBSSxFQUFFTyxHQUFHO0FBQzdCLFlBQU1uZCxVQUFVbEQsS0FBS3FnQixDQUFFO0FBQ3ZCLFVBQUksQ0FBQ25kLFFBQVFtUyxNQUFNO0FBQ2pCOEssZ0JBQVFqZCxTQUFTOUQsUUFBT2loQixDQUFBQTs7SUFFNUI7RUFDRjtBQUNGO0FBT0EsU0FBU0MseUJBQXlCamdCLE1BQU07QUFDdEMsUUFBTWtnQixPQUFPbGdCLEtBQUt1UyxRQUFRLEdBQUEsTUFBUztBQUNuQyxRQUFNNE4sT0FBT25nQixLQUFLdVMsUUFBUSxHQUFBLE1BQVM7QUFFbkMsU0FBTyxTQUFTNk4sS0FBS0MsS0FBSztBQUN4QixVQUFNQyxTQUFTSixPQUFPenFCLEtBQUt3WSxJQUFJbVMsSUFBSXRpQixJQUFJdWlCLElBQUl2aUIsQ0FBQyxJQUFJO0FBQ2hELFVBQU15aUIsU0FBU0osT0FBTzFxQixLQUFLd1ksSUFBSW1TLElBQUlyaUIsSUFBSXNpQixJQUFJdGlCLENBQUMsSUFBSTtBQUNoRCxXQUFPdEksS0FBSytxQixLQUFLL3FCLEtBQUtnckIsSUFBSUgsUUFBUSxDQUFLN3FCLElBQUFBLEtBQUtnckIsSUFBSUYsUUFBUSxDQUFBLENBQUE7RUFDMUQ7QUFDRjtBQVdBLFNBQVNHLGtCQUFrQjdyQixPQUFPZ3JCLFVBQVU3ZixNQUFNMmdCLGtCQUFrQkMsa0JBQWtCO0FBQ3BGLFFBQU12cUIsUUFBUSxDQUFBO0FBRWQsTUFBSSxDQUFDdXFCLG9CQUFvQixDQUFDL3JCLE1BQU1nc0IsY0FBY2hCLFFBQVcsR0FBQTtBQUN2RCxXQUFPeHBCOztBQUdULFFBQU15cUIsaUJBQWlCLFNBQVNqZSxTQUFTeEQsY0FBY04sUUFBTztBQUM1RCxRQUFJLENBQUM2aEIsb0JBQW9CLENBQUNHLGVBQWVsZSxTQUFTaE8sTUFBTWdWLFdBQVcsQ0FBSSxHQUFBO0FBQ3JFOztBQUVGLFFBQUloSCxRQUFRbWUsUUFBUW5CLFNBQVMvaEIsR0FBRytoQixTQUFTOWhCLEdBQUc0aUIsZ0JBQW1CLEdBQUE7QUFDN0R0cUIsWUFBTWtCLEtBQUs7UUFBQ3NMO1FBQVN4RDtRQUFjTixPQUFBQTtNQUFLLENBQUE7O0VBRTVDO0FBRUE2Z0IsMkJBQXlCL3FCLE9BQU9tTCxNQUFNNmYsVUFBVWlCLGdCQUFnQixJQUFJO0FBQ3BFLFNBQU96cUI7QUFDVDtBQVVBLFNBQVM0cUIsc0JBQXNCcHNCLE9BQU9nckIsVUFBVTdmLE1BQU0yZ0Isa0JBQWtCO0FBQ3RFLE1BQUl0cUIsUUFBUSxDQUFBO0FBRVosV0FBU3lxQixlQUFlamUsU0FBU3hELGNBQWNOLFFBQU87QUFDcEQsVUFBTSxFQUFDMlcsWUFBWUMsU0FBQUEsSUFBWTlTLFFBQVFxZSxTQUFTO01BQUM7TUFBYztPQUFhUCxnQkFBQUE7QUFDNUUsVUFBTSxFQUFDeEssTUFBQUEsSUFBU2dMLGtCQUFrQnRlLFNBQVM7TUFBQy9FLEdBQUcraEIsU0FBUy9oQjtNQUFHQyxHQUFHOGhCLFNBQVM5aEI7SUFBQyxDQUFBO0FBRXhFLFFBQUlxWSxjQUFjRCxPQUFPVCxZQUFZQyxRQUFXLEdBQUE7QUFDOUN0ZixZQUFNa0IsS0FBSztRQUFDc0w7UUFBU3hEO1FBQWNOLE9BQUFBO01BQUssQ0FBQTs7RUFFNUM7QUFFQTZnQiwyQkFBeUIvcUIsT0FBT21MLE1BQU02ZixVQUFVaUIsY0FBQUE7QUFDaEQsU0FBT3pxQjtBQUNUO0FBWUEsU0FBUytxQix5QkFBeUJ2c0IsT0FBT2dyQixVQUFVN2YsTUFBTThlLFdBQVc2QixrQkFBa0JDLGtCQUFrQjtBQUN0RyxNQUFJdnFCLFFBQVEsQ0FBQTtBQUNaLFFBQU1nckIsaUJBQWlCcEIseUJBQXlCamdCLElBQUFBO0FBQ2hELE1BQUlzaEIsY0FBY3pnQixPQUFPRTtBQUV6QixXQUFTK2YsZUFBZWplLFNBQVN4RCxjQUFjTixRQUFPO0FBQ3BELFVBQU1paUIsV0FBVW5lLFFBQVFtZSxRQUFRbkIsU0FBUy9oQixHQUFHK2hCLFNBQVM5aEIsR0FBRzRpQixnQkFBQUE7QUFDeEQsUUFBSTdCLGFBQWEsQ0FBQ2tDLFVBQVM7QUFDekI7O0FBR0YsVUFBTXJQLFNBQVM5TyxRQUFRMGUsZUFBZVosZ0JBQUFBO0FBQ3RDLFVBQU1hLGNBQWMsQ0FBQyxDQUFDWixvQkFBb0IvckIsTUFBTWdzQixjQUFjbFAsTUFBQUE7QUFDOUQsUUFBSSxDQUFDNlAsZUFBZSxDQUFDUixVQUFTO0FBQzVCOztBQUdGLFVBQU1TLFdBQVdKLGVBQWV4QixVQUFVbE8sTUFBQUE7QUFDMUMsUUFBSThQLFdBQVdILGFBQWE7QUFDMUJqckIsY0FBUTtRQUFDO1VBQUN3TTtVQUFTeEQ7VUFBY04sT0FBQUE7UUFBSztNQUFFO0FBQ3hDdWlCLG9CQUFjRztlQUNMQSxhQUFhSCxhQUFhO0FBRW5DanJCLFlBQU1rQixLQUFLO1FBQUNzTDtRQUFTeEQ7UUFBY04sT0FBQUE7TUFBSyxDQUFBOztFQUU1QztBQUVBNmdCLDJCQUF5Qi9xQixPQUFPbUwsTUFBTTZmLFVBQVVpQixjQUFBQTtBQUNoRCxTQUFPenFCO0FBQ1Q7QUFZQSxTQUFTcXJCLGdCQUFnQjdzQixPQUFPZ3JCLFVBQVU3ZixNQUFNOGUsV0FBVzZCLGtCQUFrQkMsa0JBQWtCO0FBQzdGLE1BQUksQ0FBQ0Esb0JBQW9CLENBQUMvckIsTUFBTWdzQixjQUFjaEIsUUFBVyxHQUFBO0FBQ3ZELFdBQU8sQ0FBQTs7QUFHVCxTQUFPN2YsU0FBUyxPQUFPLENBQUM4ZSxZQUNwQm1DLHNCQUFzQnBzQixPQUFPZ3JCLFVBQVU3ZixNQUFNMmdCLGdCQUFBQSxJQUM3Q1MseUJBQXlCdnNCLE9BQU9nckIsVUFBVTdmLE1BQU04ZSxXQUFXNkIsa0JBQWtCQyxnQkFBaUI7QUFDcEc7QUFXQSxTQUFTZSxhQUFhOXNCLE9BQU9nckIsVUFBVTdmLE1BQU04ZSxXQUFXNkIsa0JBQWtCO0FBQ3hFLFFBQU10cUIsUUFBUSxDQUFBO0FBQ2QsUUFBTXVyQixjQUFjNWhCLFNBQVMsTUFBTSxhQUFhO0FBQ2hELE1BQUk2aEIsaUJBQWlCO0FBRXJCakMsMkJBQXlCL3FCLE9BQU9tTCxNQUFNNmYsVUFBVSxDQUFDaGQsU0FBU3hELGNBQWNOLFdBQVU7QUFDaEYsUUFBSThELFFBQVErZSxXQUFZLEtBQUkvZSxRQUFRK2UsV0FBWSxFQUFDL0IsU0FBUzdmLElBQUssR0FBRTJnQixnQkFBbUIsR0FBQTtBQUNsRnRxQixZQUFNa0IsS0FBSztRQUFDc0w7UUFBU3hEO1FBQWNOLE9BQUFBO01BQUssQ0FBQTtBQUN4QzhpQix1QkFBaUJBLGtCQUFrQmhmLFFBQVFtZSxRQUFRbkIsU0FBUy9oQixHQUFHK2hCLFNBQVM5aEIsR0FBRzRpQixnQkFBQUE7O0VBRS9FLENBQUE7QUFJQSxNQUFJN0IsYUFBYSxDQUFDK0MsZ0JBQWdCO0FBQ2hDLFdBQU8sQ0FBQTs7QUFFVCxTQUFPeHJCO0FBQ1Q7QUFNQSxJQUFBLGNBQWU7RUFFYnVwQjtFQUdBa0MsT0FBTztJQVlML2lCLE1BQU1sSyxPQUFPNmxCLEdBQUdyZSxVQUFTc2tCLGtCQUFrQjtBQUN6QyxZQUFNZCxXQUFXa0Msb0JBQW9CckgsR0FBRzdsQixLQUFBQTtBQUV4QyxZQUFNbUwsT0FBTzNELFNBQVEyRCxRQUFRO0FBQzdCLFlBQU00Z0IsbUJBQW1CdmtCLFNBQVF1a0Isb0JBQW9CO0FBQ3JELFlBQU12cUIsUUFBUWdHLFNBQVF5aUIsWUFDbEI0QixrQkFBa0I3ckIsT0FBT2dyQixVQUFVN2YsTUFBTTJnQixrQkFBa0JDLGdCQUFBQSxJQUMzRGMsZ0JBQWdCN3NCLE9BQU9nckIsVUFBVTdmLE1BQU0sT0FBTzJnQixrQkFBa0JDLGdCQUFpQjtBQUNyRixZQUFNalgsWUFBVyxDQUFBO0FBRWpCLFVBQUksQ0FBQ3RULE1BQU1DLFFBQVE7QUFDakIsZUFBTyxDQUFBOztBQUdUekIsWUFBTWtyQiw2QkFBNEIsRUFBRzFxQixRQUFRLENBQUN1SyxTQUFTO0FBQ3JELGNBQU1iLFNBQVExSSxNQUFNLENBQUEsRUFBRzBJO0FBQ3ZCLGNBQU04RCxVQUFVakQsS0FBS0QsS0FBS1osTUFBTTtBQUdoQyxZQUFJOEQsV0FBVyxDQUFDQSxRQUFRbVMsTUFBTTtBQUM1QnJMLFVBQUFBLFVBQVNwUyxLQUFLO1lBQUNzTDtZQUFTeEQsY0FBY08sS0FBS2I7WUFBT0EsT0FBQUE7VUFBSyxDQUFBOztNQUUzRCxDQUFBO0FBRUEsYUFBTzRLO0lBQ1Q7SUFZQWhILFFBQVE5TixPQUFPNmxCLEdBQUdyZSxVQUFTc2tCLGtCQUFrQjtBQUMzQyxZQUFNZCxXQUFXa0Msb0JBQW9CckgsR0FBRzdsQixLQUFBQTtBQUN4QyxZQUFNbUwsT0FBTzNELFNBQVEyRCxRQUFRO0FBQzdCLFlBQU00Z0IsbUJBQW1CdmtCLFNBQVF1a0Isb0JBQW9CO0FBQ3JELFVBQUl2cUIsUUFBUWdHLFNBQVF5aUIsWUFDaEI0QixrQkFBa0I3ckIsT0FBT2dyQixVQUFVN2YsTUFBTTJnQixrQkFBa0JDLGdCQUFBQSxJQUM3RGMsZ0JBQWdCN3NCLE9BQU9nckIsVUFBVTdmLE1BQU0sT0FBTzJnQixrQkFBa0JDLGdCQUFpQjtBQUVuRixVQUFJdnFCLE1BQU1DLFNBQVMsR0FBRztBQUNwQixjQUFNK0ksZUFBZWhKLE1BQU0sQ0FBQSxFQUFHZ0o7QUFDOUIsY0FBTU0sT0FBTzlLLE1BQU13UixlQUFlaEgsWUFBQUEsRUFBY007QUFDaER0SixnQkFBUSxDQUFBO0FBQ1IsaUJBQVNFLElBQUksR0FBR0EsSUFBSW9KLEtBQUtySixRQUFRLEVBQUVDLEdBQUc7QUFDcENGLGdCQUFNa0IsS0FBSztZQUFDc0wsU0FBU2xELEtBQUtwSixDQUFFO1lBQUU4STtZQUFjTixPQUFPeEk7VUFBQyxDQUFBO1FBQ3REOztBQUdGLGFBQU9GO0lBQ1Q7SUFZQXdlLE1BQU1oZ0IsT0FBTzZsQixHQUFHcmUsVUFBU3NrQixrQkFBa0I7QUFDekMsWUFBTWQsV0FBV2tDLG9CQUFvQnJILEdBQUc3bEIsS0FBQUE7QUFDeEMsWUFBTW1MLE9BQU8zRCxTQUFRMkQsUUFBUTtBQUM3QixZQUFNNGdCLG1CQUFtQnZrQixTQUFRdWtCLG9CQUFvQjtBQUNyRCxhQUFPRixrQkFBa0I3ckIsT0FBT2dyQixVQUFVN2YsTUFBTTJnQixrQkFBa0JDLGdCQUFBQTtJQUNwRTtJQVdBb0IsUUFBUW50QixPQUFPNmxCLEdBQUdyZSxVQUFTc2tCLGtCQUFrQjtBQUMzQyxZQUFNZCxXQUFXa0Msb0JBQW9CckgsR0FBRzdsQixLQUFBQTtBQUN4QyxZQUFNbUwsT0FBTzNELFNBQVEyRCxRQUFRO0FBQzdCLFlBQU00Z0IsbUJBQW1CdmtCLFNBQVF1a0Isb0JBQW9CO0FBQ3JELGFBQU9jLGdCQUFnQjdzQixPQUFPZ3JCLFVBQVU3ZixNQUFNM0QsU0FBUXlpQixXQUFXNkIsa0JBQWtCQyxnQkFBQUE7SUFDckY7SUFXQTlpQixFQUFFakosT0FBTzZsQixHQUFHcmUsVUFBU3NrQixrQkFBa0I7QUFDckMsWUFBTWQsV0FBV2tDLG9CQUFvQnJILEdBQUc3bEIsS0FBQUE7QUFDeEMsYUFBTzhzQixhQUFhOXNCLE9BQU9nckIsVUFBVSxLQUFLeGpCLFNBQVF5aUIsV0FBVzZCLGdCQUFBQTtJQUMvRDtJQVdBNWlCLEVBQUVsSixPQUFPNmxCLEdBQUdyZSxVQUFTc2tCLGtCQUFrQjtBQUNyQyxZQUFNZCxXQUFXa0Msb0JBQW9CckgsR0FBRzdsQixLQUFBQTtBQUN4QyxhQUFPOHNCLGFBQWE5c0IsT0FBT2dyQixVQUFVLEtBQUt4akIsU0FBUXlpQixXQUFXNkIsZ0JBQUFBO0lBQy9EO0VBQ0Y7QUFDRjtBQzNYQSxJQUFNc0IsbUJBQW1CO0VBQUM7RUFBUTtFQUFPO0VBQVM7QUFBUztBQUUzRCxTQUFTQyxpQkFBaUJDLE9BQU90QyxVQUFVO0FBQ3pDLFNBQU9zQyxNQUFNN2YsT0FBT3dPLENBQUFBLE1BQUtBLEVBQUVzUixRQUFRdkMsUUFBQUE7QUFDckM7QUFFQSxTQUFTd0MsNEJBQTRCRixPQUFPbmlCLE1BQU07QUFDaEQsU0FBT21pQixNQUFNN2YsT0FBT3dPLENBQUFBLE1BQUttUixpQkFBaUIxUCxRQUFRekIsRUFBRXNSLEdBQUcsTUFBTSxNQUFNdFIsRUFBRXdSLElBQUl0aUIsU0FBU0EsSUFBQUE7QUFDcEY7QUFFQSxTQUFTdWlCLGFBQWFKLE9BQU8xa0IsU0FBUztBQUNwQyxTQUFPMGtCLE1BQU14VSxLQUFLLENBQUNDLEdBQUdyUCxNQUFNO0FBQzFCLFVBQU1pa0IsS0FBSy9rQixVQUFVYyxJQUFJcVA7QUFDekIsVUFBTWdELEtBQUtuVCxVQUFVbVEsSUFBSXJQO0FBQ3pCLFdBQU9pa0IsR0FBR2xKLFdBQVcxSSxHQUFHMEksU0FDdEJrSixHQUFHempCLFFBQVE2UixHQUFHN1IsUUFDZHlqQixHQUFHbEosU0FBUzFJLEdBQUcwSTtFQUNuQixDQUFBO0FBQ0Y7QUFFQSxTQUFTbUosVUFBVUMsT0FBTztBQUN4QixRQUFNQyxjQUFjLENBQUE7QUFDcEIsTUFBSXBzQixHQUFHdUksTUFBTXdqQixLQUFLRixLQUFLbmpCLE9BQU8yakI7QUFFOUIsT0FBS3JzQixJQUFJLEdBQUd1SSxRQUFRNGpCLFNBQVMsQ0FBQSxHQUFJcHNCLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ3REK3JCLFVBQU1JLE1BQU1uc0IsQ0FBRTtBQUNiLEtBQUEsRUFBQ3NwQixVQUFVdUMsS0FBSy9sQixTQUFTLEVBQUM0QyxPQUFPMmpCLGNBQWMsRUFBQyxFQUFDLElBQUlOO0FBQ3RESyxnQkFBWXByQixLQUFLO01BQ2Z3SCxPQUFPeEk7TUFDUCtyQjtNQUNBRjtNQUNBbFMsWUFBWW9TLElBQUl0UyxhQUFZO01BQzVCc0osUUFBUWdKLElBQUloSjtNQUNacmEsT0FBT0EsU0FBVW1qQixNQUFNbmpCO01BQ3ZCMmpCO0lBQ0YsQ0FBQTtFQUNGO0FBQ0EsU0FBT0Q7QUFDVDtBQUVBLFNBQVNFLFlBQVlDLFVBQVM7QUFDNUIsUUFBTTdoQixTQUFTLENBQUE7QUFDZixhQUFXOGhCLFFBQVFELFVBQVM7QUFDMUIsVUFBTSxFQUFDN2pCLE9BQU9takIsS0FBS1EsWUFBQUEsSUFBZUc7QUFDbEMsUUFBSSxDQUFDOWpCLFNBQVMsQ0FBQ2dqQixpQkFBaUJlLFNBQVNaLEdBQU0sR0FBQTtBQUM3Qzs7QUFFRixVQUFNYSxTQUFTaGlCLE9BQU9oQyxLQUFBQSxNQUFXZ0MsT0FBT2hDLEtBQUFBLElBQVM7TUFBQzBJLE9BQU87TUFBR3ViLFFBQVE7TUFBRzVKLFFBQVE7TUFBR3RjLE1BQU07O0FBQ3hGaW1CLFdBQU90YjtBQUNQc2IsV0FBTzNKLFVBQVVzSjtFQUNuQjtBQUNBLFNBQU8zaEI7QUFDVDtBQUtBLFNBQVNraUIsY0FBY0wsVUFBU00sUUFBUTtBQUN0QyxRQUFNbmlCLFNBQVM0aEIsWUFBWUMsUUFBQUE7QUFDM0IsUUFBTSxFQUFDTyxjQUFjQyxjQUFBQSxJQUFpQkY7QUFDdEMsTUFBSTdzQixHQUFHdUksTUFBTXlrQjtBQUNiLE9BQUtodEIsSUFBSSxHQUFHdUksT0FBT2drQixTQUFReHNCLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ2hEZ3RCLGFBQVNULFNBQVF2c0IsQ0FBRTtBQUNuQixVQUFNLEVBQUNpdEIsU0FBQUEsSUFBWUQsT0FBT2pCO0FBQzFCLFVBQU1yakIsUUFBUWdDLE9BQU9zaUIsT0FBT3RrQixLQUFLO0FBQ2pDLFVBQU16RyxTQUFTeUcsU0FBU3NrQixPQUFPWCxjQUFjM2pCLE1BQU1xYTtBQUNuRCxRQUFJaUssT0FBT3JULFlBQVk7QUFDckJxVCxhQUFPMVIsUUFBUXJaLFNBQVNBLFNBQVM2cUIsZUFBZUcsWUFBWUosT0FBT0s7QUFDbkVGLGFBQU8zUixTQUFTMFI7V0FDWDtBQUNMQyxhQUFPMVIsUUFBUXdSO0FBQ2ZFLGFBQU8zUixTQUFTcFosU0FBU0EsU0FBUzhxQixnQkFBZ0JFLFlBQVlKLE9BQU9NOztFQUV6RTtBQUNBLFNBQU96aUI7QUFDVDtBQUVBLFNBQVMwaUIsaUJBQWlCakIsT0FBTztBQUMvQixRQUFNQyxjQUFjRixVQUFVQyxLQUFBQTtBQUM5QixRQUFNYyxXQUFXakIsYUFBYUksWUFBWXJnQixPQUFPeWdCLENBQUFBLFNBQVFBLEtBQUtULElBQUlrQixRQUFRLEdBQUcsSUFBSTtBQUNqRixRQUFNcmxCLE9BQU9va0IsYUFBYUwsaUJBQWlCUyxhQUFhLE1BQUEsR0FBUyxJQUFJO0FBQ3JFLFFBQU0xa0IsUUFBUXNrQixhQUFhTCxpQkFBaUJTLGFBQWEsT0FBQSxDQUFBO0FBQ3pELFFBQU0za0IsTUFBTXVrQixhQUFhTCxpQkFBaUJTLGFBQWEsS0FBQSxHQUFRLElBQUk7QUFDbkUsUUFBTXprQixTQUFTcWtCLGFBQWFMLGlCQUFpQlMsYUFBYSxRQUFBLENBQUE7QUFDMUQsUUFBTWlCLG1CQUFtQnZCLDRCQUE0Qk0sYUFBYSxHQUFBO0FBQ2xFLFFBQU1rQixpQkFBaUJ4Qiw0QkFBNEJNLGFBQWEsR0FBQTtBQUVoRSxTQUFPO0lBQ0xhO0lBQ0FNLFlBQVkzbEIsS0FBS3NQLE9BQU96UCxHQUFBQTtJQUN4QitsQixnQkFBZ0I5bEIsTUFBTXdQLE9BQU9vVyxjQUFBQSxFQUFnQnBXLE9BQU92UCxNQUFBQSxFQUFRdVAsT0FBT21XLGdCQUFBQTtJQUNuRS9aLFdBQVdxWSxpQkFBaUJTLGFBQWEsV0FBQTtJQUN6Q3FCLFVBQVU3bEIsS0FBS3NQLE9BQU94UCxLQUFBQSxFQUFPd1AsT0FBT29XLGNBQUFBO0lBQ3BDM1QsWUFBWWxTLElBQUl5UCxPQUFPdlAsTUFBQUEsRUFBUXVQLE9BQU9tVyxnQkFBQUE7RUFDeEM7QUFDRjtBQUVBLFNBQVNLLGVBQWVDLFlBQVlyYSxXQUFXK0QsR0FBR3JQLEdBQUc7QUFDbkQsU0FBTzlJLEtBQUtvQyxJQUFJcXNCLFdBQVd0VyxDQUFFLEdBQUUvRCxVQUFVK0QsQ0FBQUEsQ0FBRSxJQUFJblksS0FBS29DLElBQUlxc0IsV0FBVzNsQixDQUFBQSxHQUFJc0wsVUFBVXRMLENBQUUsQ0FBQTtBQUNyRjtBQUVBLFNBQVM0bEIsaUJBQWlCRCxZQUFZRSxZQUFZO0FBQ2hERixhQUFXbG1CLE1BQU12SSxLQUFLb0MsSUFBSXFzQixXQUFXbG1CLEtBQUtvbUIsV0FBV3BtQixHQUFHO0FBQ3hEa21CLGFBQVcvbEIsT0FBTzFJLEtBQUtvQyxJQUFJcXNCLFdBQVcvbEIsTUFBTWltQixXQUFXam1CLElBQUk7QUFDM0QrbEIsYUFBV2htQixTQUFTekksS0FBS29DLElBQUlxc0IsV0FBV2htQixRQUFRa21CLFdBQVdsbUIsTUFBTTtBQUNqRWdtQixhQUFXam1CLFFBQVF4SSxLQUFLb0MsSUFBSXFzQixXQUFXam1CLE9BQU9tbUIsV0FBV25tQixLQUFLO0FBQ2hFO0FBRUEsU0FBU29tQixXQUFXeGEsV0FBV3VaLFFBQVFHLFFBQVF0aUIsUUFBUTtBQUNyRCxRQUFNLEVBQUNtaEIsS0FBS0UsSUFBQUEsSUFBT2lCO0FBQ25CLFFBQU1XLGFBQWFyYSxVQUFVcWE7QUFHN0IsTUFBSSxDQUFDNW9CLFNBQVM4bUIsR0FBTSxHQUFBO0FBQ2xCLFFBQUltQixPQUFPdm1CLE1BQU07QUFFZjZNLGdCQUFVdVksR0FBQUEsS0FBUW1CLE9BQU92bUI7O0FBRTNCLFVBQU1pQyxRQUFRZ0MsT0FBT3NpQixPQUFPdGtCLEtBQUssS0FBSztNQUFDakMsTUFBTTtNQUFHMkssT0FBTztJQUFDO0FBQ3hEMUksVUFBTWpDLE9BQU92SCxLQUFLb0MsSUFBSW9ILE1BQU1qQyxNQUFNdW1CLE9BQU9yVCxhQUFhb1MsSUFBSTFRLFNBQVMwUSxJQUFJelEsS0FBSztBQUM1RTBSLFdBQU92bUIsT0FBT2lDLE1BQU1qQyxPQUFPaUMsTUFBTTBJO0FBQ2pDa0MsY0FBVXVZLEdBQUFBLEtBQVFtQixPQUFPdm1COztBQUczQixNQUFJc2xCLElBQUlnQyxZQUFZO0FBQ2xCSCxxQkFBaUJELFlBQVk1QixJQUFJZ0MsV0FBVSxDQUFBOztBQUc3QyxRQUFNQyxXQUFXOXVCLEtBQUtvQyxJQUFJLEdBQUd1ckIsT0FBT29CLGFBQWFQLGVBQWVDLFlBQVlyYSxXQUFXLFFBQVEsT0FBQSxDQUFBO0FBQy9GLFFBQU00YSxZQUFZaHZCLEtBQUtvQyxJQUFJLEdBQUd1ckIsT0FBT3NCLGNBQWNULGVBQWVDLFlBQVlyYSxXQUFXLE9BQU8sUUFBQSxDQUFBO0FBQ2hHLFFBQU04YSxlQUFlSixhQUFhMWEsVUFBVSthO0FBQzVDLFFBQU1DLGdCQUFnQkosY0FBYzVhLFVBQVVpYjtBQUM5Q2piLFlBQVUrYSxJQUFJTDtBQUNkMWEsWUFBVWliLElBQUlMO0FBR2QsU0FBT2xCLE9BQU9yVCxhQUNWO0lBQUM2VSxNQUFNSjtJQUFjSyxPQUFPSDtNQUM1QjtJQUFDRSxNQUFNRjtJQUFlRyxPQUFPTDs7QUFDbkM7QUFFQSxTQUFTTSxpQkFBaUJwYixXQUFXO0FBQ25DLFFBQU1xYSxhQUFhcmEsVUFBVXFhO0FBRTdCLFdBQVNnQixVQUFVOUMsS0FBSztBQUN0QixVQUFNK0MsU0FBUzF2QixLQUFLb0MsSUFBSXFzQixXQUFXOUIsR0FBQUEsSUFBT3ZZLFVBQVV1WSxHQUFBQSxHQUFNLENBQUE7QUFDMUR2WSxjQUFVdVksR0FBQUEsS0FBUStDO0FBQ2xCLFdBQU9BO0VBQ1Q7QUFDQXRiLFlBQVU5TCxLQUFLbW5CLFVBQVUsS0FBQTtBQUN6QnJiLFlBQVUvTCxLQUFLb25CLFVBQVUsTUFBQTtBQUN6QkEsWUFBVSxPQUFBO0FBQ1ZBLFlBQVUsUUFBQTtBQUNaO0FBRUEsU0FBU0UsV0FBV2xWLFlBQVlyRyxXQUFXO0FBQ3pDLFFBQU1xYSxhQUFhcmEsVUFBVXFhO0FBRTdCLFdBQVNtQixtQkFBbUJDLFlBQVc7QUFDckMsVUFBTUMsU0FBUztNQUFDcG5CLE1BQU07TUFBR0gsS0FBSztNQUFHQyxPQUFPO01BQUdDLFFBQVE7SUFBQztBQUNwRG9uQixJQUFBQSxXQUFVandCLFFBQVEsQ0FBQytzQixRQUFRO0FBQ3pCbUQsYUFBT25ELEdBQUFBLElBQU8zc0IsS0FBS29DLElBQUlnUyxVQUFVdVksR0FBSSxHQUFFOEIsV0FBVzlCLEdBQUksQ0FBQTtJQUN4RCxDQUFBO0FBQ0EsV0FBT21EO0VBQ1Q7QUFFQSxTQUFPclYsYUFDSG1WLG1CQUFtQjtJQUFDO0lBQVE7RUFBUSxDQUFBLElBQ3BDQSxtQkFBbUI7SUFBQztJQUFPO0dBQVM7QUFDMUM7QUFFQSxTQUFTRyxTQUFTOUMsT0FBTzdZLFdBQVd1WixRQUFRbmlCLFFBQVE7QUFDbEQsUUFBTXdrQixhQUFhLENBQUE7QUFDbkIsTUFBSWx2QixHQUFHdUksTUFBTXlrQixRQUFRakIsS0FBS29ELE9BQU9DO0FBRWpDLE9BQUtwdkIsSUFBSSxHQUFHdUksT0FBTzRqQixNQUFNcHNCLFFBQVFvdkIsUUFBUSxHQUFHbnZCLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ3pEZ3RCLGFBQVNiLE1BQU1uc0IsQ0FBRTtBQUNqQityQixVQUFNaUIsT0FBT2pCO0FBRWJBLFFBQUkvbkIsT0FDRmdwQixPQUFPMVIsU0FBU2hJLFVBQVUrYSxHQUMxQnJCLE9BQU8zUixVQUFVL0gsVUFBVWliLEdBQzNCTSxXQUFXN0IsT0FBT3JULFlBQVlyRyxTQUFBQSxDQUFBQTtBQUVoQyxVQUFNLEVBQUNrYixNQUFNQyxNQUFBQSxJQUFTWCxXQUFXeGEsV0FBV3VaLFFBQVFHLFFBQVF0aUIsTUFBQUE7QUFJNUR5a0IsYUFBU1gsUUFBUVUsV0FBV252QjtBQUc1QnF2QixjQUFVQSxXQUFXWDtBQUVyQixRQUFJLENBQUMxQyxJQUFJa0IsVUFBVTtBQUNqQmlDLGlCQUFXbHVCLEtBQUtnc0IsTUFBQUE7O0VBRXBCO0FBRUEsU0FBT21DLFNBQVNGLFNBQVNDLFlBQVk1YixXQUFXdVosUUFBUW5pQixNQUFXMGtCLEtBQUFBO0FBQ3JFO0FBRUEsU0FBU0MsV0FBV3RELEtBQUtua0IsTUFBTUgsS0FBSzZULE9BQU9ELFFBQVE7QUFDakQwUSxNQUFJdGtCLE1BQU1BO0FBQ1Zza0IsTUFBSW5rQixPQUFPQTtBQUNYbWtCLE1BQUlya0IsUUFBUUUsT0FBTzBUO0FBQ25CeVEsTUFBSXBrQixTQUFTRixNQUFNNFQ7QUFDbkIwUSxNQUFJelEsUUFBUUE7QUFDWnlRLE1BQUkxUSxTQUFTQTtBQUNmO0FBRUEsU0FBU2lVLFdBQVduRCxPQUFPN1ksV0FBV3VaLFFBQVFuaUIsUUFBUTtBQUNwRCxRQUFNNmtCLGNBQWMxQyxPQUFPMkM7QUFDM0IsTUFBSSxFQUFDam9CLEdBQUdDLEVBQUFBLElBQUs4TDtBQUViLGFBQVcwWixVQUFVYixPQUFPO0FBQzFCLFVBQU1KLE1BQU1pQixPQUFPakI7QUFDbkIsVUFBTXJqQixRQUFRZ0MsT0FBT3NpQixPQUFPdGtCLEtBQUssS0FBSztNQUFDMEksT0FBTztNQUFHdWIsUUFBUTtNQUFHNUosUUFBUTtJQUFDO0FBQ3JFLFVBQU1BLFNBQVMsT0FBUXNKLGNBQWMzakIsTUFBTXFhLFVBQVc7QUFDdEQsUUFBSWlLLE9BQU9yVCxZQUFZO0FBQ3JCLFlBQU0yQixRQUFRaEksVUFBVSthLElBQUl0TDtBQUM1QixZQUFNMUgsU0FBUzNTLE1BQU1qQyxRQUFRc2xCLElBQUkxUTtBQUNqQyxVQUFJcEgsUUFBUXZMLE1BQU10SixLQUFLLEdBQUc7QUFDeEJvSSxZQUFJa0IsTUFBTXRKOztBQUVaLFVBQUkyc0IsSUFBSWtCLFVBQVU7QUFDaEJvQyxtQkFBV3RELEtBQUt3RCxZQUFZM25CLE1BQU1KLEdBQUdxbEIsT0FBT29CLGFBQWFzQixZQUFZN25CLFFBQVE2bkIsWUFBWTNuQixNQUFNeVQsTUFBQUE7YUFDMUY7QUFDTGdVLG1CQUFXdEQsS0FBS3pZLFVBQVUxTCxPQUFPYyxNQUFNaWtCLFFBQVFubEIsR0FBRzhULE9BQU9ELE1BQUFBOztBQUUzRDNTLFlBQU10SixRQUFRb0k7QUFDZGtCLFlBQU1pa0IsVUFBVXJSO0FBQ2hCOVQsVUFBSXVrQixJQUFJcGtCO1dBQ0g7QUFDTCxZQUFNMFQsU0FBUy9ILFVBQVVpYixJQUFJeEw7QUFDN0IsWUFBTXpILFFBQVE1UyxNQUFNakMsUUFBUXNsQixJQUFJelE7QUFDaEMsVUFBSXJILFFBQVF2TCxNQUFNdEosS0FBSyxHQUFHO0FBQ3hCbUksWUFBSW1CLE1BQU10Sjs7QUFFWixVQUFJMnNCLElBQUlrQixVQUFVO0FBQ2hCb0MsbUJBQVd0RCxLQUFLeGtCLEdBQUdnb0IsWUFBWTluQixLQUFLNlQsT0FBT3VSLE9BQU9zQixjQUFjb0IsWUFBWTVuQixTQUFTNG5CLFlBQVk5bkIsR0FBRzthQUMvRjtBQUNMNG5CLG1CQUFXdEQsS0FBS3hrQixHQUFHK0wsVUFBVTdMLE1BQU1pQixNQUFNaWtCLFFBQVFyUixPQUFPRCxNQUFBQTs7QUFFMUQzUyxZQUFNdEosUUFBUW1JO0FBQ2RtQixZQUFNaWtCLFVBQVV0UjtBQUNoQjlULFVBQUl3a0IsSUFBSXJrQjs7RUFFWjtBQUVBNEwsWUFBVS9MLElBQUlBO0FBQ2QrTCxZQUFVOUwsSUFBSUE7QUFDaEI7QUF3QkEsSUFBQSxVQUFlO0VBUWJpb0IsT0FBT254QixPQUFPNEIsTUFBTTtBQUNsQixRQUFJLENBQUM1QixNQUFNNnRCLE9BQU87QUFDaEI3dEIsWUFBTTZ0QixRQUFRLENBQUE7O0FBSWhCanNCLFNBQUsrc0IsV0FBVy9zQixLQUFLK3NCLFlBQVk7QUFDakMvc0IsU0FBS29wQixXQUFXcHBCLEtBQUtvcEIsWUFBWTtBQUNqQ3BwQixTQUFLNmlCLFNBQVM3aUIsS0FBSzZpQixVQUFVO0FBRTdCN2lCLFNBQUt3dkIsVUFBVXh2QixLQUFLd3ZCLFdBQVcsV0FBVztBQUN4QyxhQUFPO1FBQUM7VUFDTkMsR0FBRztVQUNIMXZCLEtBQUtxVCxXQUFXO0FBQ2RwVCxpQkFBS0QsS0FBS3FULFNBQUFBO1VBQ1o7UUFDRjtNQUFFO0lBQ0o7QUFFQWhWLFVBQU02dEIsTUFBTW5yQixLQUFLZCxJQUFBQTtFQUNuQjtFQU9BMHZCLFVBQVV0eEIsT0FBT3V4QixZQUFZO0FBQzNCLFVBQU1ybkIsU0FBUWxLLE1BQU02dEIsUUFBUTd0QixNQUFNNnRCLE1BQU1uUSxRQUFRNlQsVUFBYyxJQUFBO0FBQzlELFFBQUlybkIsV0FBVSxJQUFJO0FBQ2hCbEssWUFBTTZ0QixNQUFNaFcsT0FBTzNOLFFBQU8sQ0FBQTs7RUFFOUI7RUFRQTFELFVBQVV4RyxPQUFPNEIsTUFBTTRGLFVBQVM7QUFDOUI1RixTQUFLK3NCLFdBQVdubkIsU0FBUW1uQjtBQUN4Qi9zQixTQUFLb3BCLFdBQVd4akIsU0FBUXdqQjtBQUN4QnBwQixTQUFLNmlCLFNBQVNqZCxTQUFRaWQ7RUFDeEI7RUFVQS9lLE9BQU8xRixPQUFPZ2QsT0FBT0QsUUFBUXlVLFlBQVk7QUFDdkMsUUFBSSxDQUFDeHhCLE9BQU87QUFDVjs7QUFHRixVQUFNa3hCLFVBQVVPLFVBQVV6eEIsTUFBTXdILFFBQVFrbkIsT0FBT3dDLE9BQU87QUFDdEQsVUFBTXRDLGlCQUFpQmh1QixLQUFLb0MsSUFBSWdhLFFBQVFrVSxRQUFRbFUsT0FBTyxDQUFBO0FBQ3ZELFVBQU02UixrQkFBa0JqdUIsS0FBS29DLElBQUkrWixTQUFTbVUsUUFBUW5VLFFBQVEsQ0FBQTtBQUMxRCxVQUFNOFEsUUFBUWlCLGlCQUFpQjl1QixNQUFNNnRCLEtBQUs7QUFDMUMsVUFBTTZELGdCQUFnQjdELE1BQU1zQjtBQUM1QixVQUFNd0Msa0JBQWtCOUQsTUFBTXhTO0FBSTlCdVcsU0FBSzV4QixNQUFNNnRCLE9BQU9KLENBQUFBLFFBQU87QUFDdkIsVUFBSSxPQUFPQSxJQUFJb0UsaUJBQWlCLFlBQVk7QUFDMUNwRSxZQUFJb0UsYUFBWTs7SUFFcEIsQ0FBQTtBQTZCQSxVQUFNQywwQkFBMEJKLGNBQWM3dUIsT0FBTyxDQUFDeWdCLE9BQU80SyxTQUMzREEsS0FBS1QsSUFBSWptQixXQUFXMG1CLEtBQUtULElBQUlqbUIsUUFBUThnQixZQUFZLFFBQVFoRixRQUFRQSxRQUFRLEdBQUcsQ0FBTSxLQUFBO0FBRXBGLFVBQU1pTCxTQUFTNW5CLE9BQU9xUCxPQUFPO01BQzNCMlosWUFBWTNTO01BQ1o2UyxhQUFhOVM7TUFDYm1VO01BQ0F0QztNQUNBQztNQUNBTCxjQUFjSSxpQkFBaUIsSUFBSWtEO01BQ25DckQsZUFBZUksa0JBQWtCO0lBQ25DLENBQUE7QUFDQSxVQUFNUSxhQUFhMW9CLE9BQU95QixPQUFPLENBQUEsR0FBSThvQixPQUFBQTtBQUNyQzVCLHFCQUFpQkQsWUFBWW9DLFVBQVVELFVBQUFBLENBQUFBO0FBQ3ZDLFVBQU14YyxZQUFZck8sT0FBT3lCLE9BQU87TUFDOUJpbkI7TUFDQVUsR0FBR25CO01BQ0hxQixHQUFHcEI7TUFDSDVsQixHQUFHaW9CLFFBQVE1bkI7TUFDWEosR0FBR2dvQixRQUFRL25CO09BQ1YrbkIsT0FBQUE7QUFFSCxVQUFNOWtCLFNBQVNraUIsY0FBY29ELGNBQWM5WSxPQUFPK1ksZUFBa0JwRCxHQUFBQSxNQUFBQTtBQUdwRW9DLGFBQVM5QyxNQUFNYyxVQUFVM1osV0FBV3VaLFFBQVFuaUIsTUFBQUE7QUFHNUN1a0IsYUFBU2UsZUFBZTFjLFdBQVd1WixRQUFRbmlCLE1BQUFBO0FBRzNDLFFBQUl1a0IsU0FBU2dCLGlCQUFpQjNjLFdBQVd1WixRQUFRbmlCLE1BQVMsR0FBQTtBQUV4RHVrQixlQUFTZSxlQUFlMWMsV0FBV3VaLFFBQVFuaUIsTUFBQUE7O0FBRzdDZ2tCLHFCQUFpQnBiLFNBQUFBO0FBR2pCZ2MsZUFBV25ELE1BQU1vQixZQUFZamEsV0FBV3VaLFFBQVFuaUIsTUFBQUE7QUFHaEQ0SSxjQUFVL0wsS0FBSytMLFVBQVUrYTtBQUN6Qi9hLGNBQVU5TCxLQUFLOEwsVUFBVWliO0FBRXpCZSxlQUFXbkQsTUFBTXFCLGdCQUFnQmxhLFdBQVd1WixRQUFRbmlCLE1BQUFBO0FBRXBEcE0sVUFBTWdWLFlBQVk7TUFDaEIxTCxNQUFNMEwsVUFBVTFMO01BQ2hCSCxLQUFLNkwsVUFBVTdMO01BQ2ZDLE9BQU80TCxVQUFVMUwsT0FBTzBMLFVBQVUrYTtNQUNsQzFtQixRQUFRMkwsVUFBVTdMLE1BQU02TCxVQUFVaWI7TUFDbENsVCxRQUFRL0gsVUFBVWliO01BQ2xCalQsT0FBT2hJLFVBQVUrYTtJQUNuQjtBQUdBNkIsU0FBSy9ELE1BQU03WSxXQUFXLENBQUMwWixXQUFXO0FBQ2hDLFlBQU1qQixNQUFNaUIsT0FBT2pCO0FBQ25COW1CLGFBQU95QixPQUFPcWxCLEtBQUt6dEIsTUFBTWdWLFNBQVM7QUFDbEN5WSxVQUFJL25CLE9BQU9zUCxVQUFVK2EsR0FBRy9hLFVBQVVpYixHQUFHO1FBQUMzbUIsTUFBTTtRQUFHSCxLQUFLO1FBQUdDLE9BQU87UUFBR0MsUUFBUTtNQUFDLENBQUE7SUFDNUUsQ0FBQTtFQUNGO0FBQ0Y7QUM5YmUsSUFBTTBvQixlQUFOLE1BQU1BO0VBT25CQyxlQUFlQyxRQUFRbk4sYUFBYTtFQUFBO0VBUXBDb04sZUFBZTdjLFNBQVM7QUFDdEIsV0FBTztFQUNUO0VBU0E4YyxpQkFBaUJueUIsT0FBT0csTUFBTWl5QixVQUFVO0VBQUE7RUFReENDLG9CQUFvQnJ5QixPQUFPRyxNQUFNaXlCLFVBQVU7RUFBQTtFQUszQ0Usc0JBQXNCO0FBQ3BCLFdBQU87RUFDVDtFQVNBQyxlQUFldmtCLFNBQVNnUCxPQUFPRCxRQUFRK0gsYUFBYTtBQUNsRDlILFlBQVFwYyxLQUFLb0MsSUFBSSxHQUFHZ2EsU0FBU2hQLFFBQVFnUCxLQUFLO0FBQzFDRCxhQUFTQSxVQUFVL08sUUFBUStPO0FBQzNCLFdBQU87TUFDTEM7TUFDQUQsUUFBUW5jLEtBQUtvQyxJQUFJLEdBQUc4aEIsY0FBY2xrQixLQUFLb0UsTUFBTWdZLFFBQVE4SCxXQUFBQSxJQUFlL0gsTUFBTTtJQUM1RTtFQUNGO0VBTUF5VixXQUFXUCxRQUFRO0FBQ2pCLFdBQU87RUFDVDtFQU1BUSxhQUFhcHNCLFFBQVE7RUFFckI7QUFDRjtBQ3RFZSxJQUFNcXNCLGdCQUFOLGNBQTRCWCxhQUFBQTtFQUN6Q0MsZUFBZXB3QixNQUFNO0FBSW5CLFdBQU9BLFFBQVFBLEtBQUsrUSxjQUFjL1EsS0FBSytRLFdBQVcsSUFBQSxLQUFTO0VBQzdEO0VBQ0E4ZixhQUFhcHNCLFFBQVE7QUFDbkJBLFdBQU9tQixRQUFRVixZQUFZO0VBQzdCO0FBQ0Y7QUNUQSxJQUFNNnJCLGNBQWM7QUFPcEIsSUFBTUMsY0FBYztFQUNsQkMsWUFBWTtFQUNaQyxXQUFXO0VBQ1hDLFVBQVU7RUFDVkMsY0FBYztFQUNkQyxhQUFhO0VBQ2JDLGFBQWE7RUFDYkMsV0FBVztFQUNYQyxjQUFjO0VBQ2RDLFlBQVk7QUFDZDtBQUVBLElBQU1DLGdCQUFnQnByQixDQUFBQSxVQUFTQSxVQUFVLFFBQVFBLFVBQVU7QUFRM0QsU0FBU3FyQixXQUFXdEIsUUFBUW5OLGFBQWE7QUFDdkMsUUFBTU0sUUFBUTZNLE9BQU83TTtBQUlyQixRQUFNb08sZUFBZXZCLE9BQU93QixhQUFhLFFBQUE7QUFDekMsUUFBTUMsY0FBY3pCLE9BQU93QixhQUFhLE9BQUE7QUFHeEN4QixTQUFPVSxXQUFBQSxJQUFlO0lBQ3BCanlCLFNBQVM7TUFDUHFjLFFBQVF5VztNQUNSeFcsT0FBTzBXO01BQ1B0TyxPQUFPO1FBQ0xrRCxTQUFTbEQsTUFBTWtEO1FBQ2Z2TCxRQUFRcUksTUFBTXJJO1FBQ2RDLE9BQU9vSSxNQUFNcEk7TUFDZjtJQUNGO0VBQ0Y7QUFLQW9JLFFBQU1rRCxVQUFVbEQsTUFBTWtELFdBQVc7QUFFakNsRCxRQUFNdU8sWUFBWXZPLE1BQU11TyxhQUFhO0FBRXJDLE1BQUlMLGNBQWNJLFdBQWMsR0FBQTtBQUM5QixVQUFNRSxlQUFlQyxhQUFhNUIsUUFBUSxPQUFBO0FBQzFDLFFBQUkyQixpQkFBaUI5ekIsUUFBVztBQUM5Qm15QixhQUFPalYsUUFBUTRXOzs7QUFJbkIsTUFBSU4sY0FBY0UsWUFBZSxHQUFBO0FBQy9CLFFBQUl2QixPQUFPN00sTUFBTXJJLFdBQVcsSUFBSTtBQUk5QmtWLGFBQU9sVixTQUFTa1YsT0FBT2pWLFNBQVM4SCxlQUFlO1dBQzFDO0FBQ0wsWUFBTWdQLGdCQUFnQkQsYUFBYTVCLFFBQVEsUUFBQTtBQUMzQyxVQUFJNkIsa0JBQWtCaDBCLFFBQVc7QUFDL0JteUIsZUFBT2xWLFNBQVMrVzs7OztBQUt0QixTQUFPN0I7QUFDVDtBQUlBLElBQU04Qix1QkFBdUJDLCtCQUErQjtFQUFDQyxTQUFTO0FBQUksSUFBSTtBQUU5RSxTQUFTQyxZQUFZQyxNQUFNaDBCLE1BQU1peUIsVUFBVTtBQUN6QyxNQUFJK0IsTUFBTTtBQUNSQSxTQUFLaEMsaUJBQWlCaHlCLE1BQU1peUIsVUFBVTJCLG9CQUFBQTs7QUFFMUM7QUFFQSxTQUFTSyxlQUFlcDBCLE9BQU9HLE1BQU1peUIsVUFBVTtBQUM3QyxNQUFJcHlCLFNBQVNBLE1BQU1peUIsUUFBUTtBQUN6Qmp5QixVQUFNaXlCLE9BQU9JLG9CQUFvQmx5QixNQUFNaXlCLFVBQVUyQixvQkFBQUE7O0FBRXJEO0FBRUEsU0FBU00sZ0JBQWdCN3hCLE9BQU94QyxPQUFPO0FBQ3JDLFFBQU1HLE9BQU95eUIsWUFBWXB3QixNQUFNckMsSUFBSSxLQUFLcUMsTUFBTXJDO0FBQzlDLFFBQU0sRUFBQzhJLEdBQUdDLEVBQUFBLElBQUtna0Isb0JBQW9CMXFCLE9BQU94QyxLQUFBQTtBQUMxQyxTQUFPO0lBQ0xHO0lBQ0FIO0lBQ0FzMEIsUUFBUTl4QjtJQUNSeUcsR0FBR0EsTUFBTW5KLFNBQVltSixJQUFJO0lBQ3pCQyxHQUFHQSxNQUFNcEosU0FBWW9KLElBQUk7RUFDM0I7QUFDRjtBQUVBLFNBQVNxckIsaUJBQWlCQyxVQUFVdkMsUUFBUTtBQUMxQyxhQUFXa0MsUUFBUUssVUFBVTtBQUMzQixRQUFJTCxTQUFTbEMsVUFBVWtDLEtBQUtNLFNBQVN4QyxNQUFTLEdBQUE7QUFDNUMsYUFBTzs7RUFFWDtBQUNGO0FBRUEsU0FBU3lDLHFCQUFxQjEwQixPQUFPRyxNQUFNaXlCLFVBQVU7QUFDbkQsUUFBTUgsU0FBU2p5QixNQUFNaXlCO0FBQ3JCLFFBQU0wQyxXQUFXLElBQUlDLGlCQUFpQkMsQ0FBQUEsWUFBVztBQUMvQyxRQUFJQyxVQUFVO0FBQ2QsZUFBV3ZhLFNBQVNzYSxTQUFTO0FBQzNCQyxnQkFBVUEsV0FBV1AsaUJBQWlCaGEsTUFBTXdhLFlBQVk5QyxNQUFBQTtBQUN4RDZDLGdCQUFVQSxXQUFXLENBQUNQLGlCQUFpQmhhLE1BQU15YSxjQUFjL0MsTUFBQUE7SUFDN0Q7QUFDQSxRQUFJNkMsU0FBUztBQUNYMUMsZUFBQUE7O0VBRUosQ0FBQTtBQUNBdUMsV0FBU00sUUFBUUMsVUFBVTtJQUFDQyxXQUFXO0lBQU1DLFNBQVM7RUFBSSxDQUFBO0FBQzFELFNBQU9UO0FBQ1Q7QUFFQSxTQUFTVSxxQkFBcUJyMUIsT0FBT0csTUFBTWl5QixVQUFVO0FBQ25ELFFBQU1ILFNBQVNqeUIsTUFBTWl5QjtBQUNyQixRQUFNMEMsV0FBVyxJQUFJQyxpQkFBaUJDLENBQUFBLFlBQVc7QUFDL0MsUUFBSUMsVUFBVTtBQUNkLGVBQVd2YSxTQUFTc2EsU0FBUztBQUMzQkMsZ0JBQVVBLFdBQVdQLGlCQUFpQmhhLE1BQU15YSxjQUFjL0MsTUFBQUE7QUFDMUQ2QyxnQkFBVUEsV0FBVyxDQUFDUCxpQkFBaUJoYSxNQUFNd2EsWUFBWTlDLE1BQUFBO0lBQzNEO0FBQ0EsUUFBSTZDLFNBQVM7QUFDWDFDLGVBQUFBOztFQUVKLENBQUE7QUFDQXVDLFdBQVNNLFFBQVFDLFVBQVU7SUFBQ0MsV0FBVztJQUFNQyxTQUFTO0VBQUksQ0FBQTtBQUMxRCxTQUFPVDtBQUNUO0FBRUEsSUFBTVcscUJBQXFCLG9CQUFJMzFCLElBQUFBO0FBQy9CLElBQUk0MUIsc0JBQXNCO0FBRTFCLFNBQVNDLGlCQUFpQjtBQUN4QixRQUFNQyxNQUFNdjBCLE9BQU93MEI7QUFDbkIsTUFBSUQsUUFBUUYscUJBQXFCO0FBQy9COztBQUVGQSx3QkFBc0JFO0FBQ3RCSCxxQkFBbUI5MEIsUUFBUSxDQUFDbTFCLFFBQVEzMUIsVUFBVTtBQUM1QyxRQUFJQSxNQUFNNDFCLDRCQUE0QkgsS0FBSztBQUN6Q0UsYUFBQUE7O0VBRUosQ0FBQTtBQUNGO0FBRUEsU0FBU0UsOEJBQThCNzFCLE9BQU8yMUIsUUFBUTtBQUNwRCxNQUFJLENBQUNMLG1CQUFtQm50QixNQUFNO0FBQzVCakgsV0FBT2l4QixpQkFBaUIsVUFBVXFELGNBQUFBOztBQUVwQ0YscUJBQW1CaHpCLElBQUl0QyxPQUFPMjFCLE1BQUFBO0FBQ2hDO0FBRUEsU0FBU0csZ0NBQWdDOTFCLE9BQU87QUFDOUNzMUIscUJBQW1CanlCLE9BQU9yRCxLQUFBQTtBQUMxQixNQUFJLENBQUNzMUIsbUJBQW1CbnRCLE1BQU07QUFDNUJqSCxXQUFPbXhCLG9CQUFvQixVQUFVbUQsY0FBQUE7O0FBRXpDO0FBRUEsU0FBU08scUJBQXFCLzFCLE9BQU9HLE1BQU1peUIsVUFBVTtBQUNuRCxRQUFNSCxTQUFTanlCLE1BQU1peUI7QUFDckIsUUFBTStELFlBQVkvRCxVQUFVZ0UsZUFBZWhFLE1BQUFBO0FBQzNDLE1BQUksQ0FBQytELFdBQVc7QUFDZDs7QUFFRixRQUFNTCxTQUFTTyxVQUFVLENBQUNsWixPQUFPRCxXQUFXO0FBQzFDLFVBQU1nVCxJQUFJaUcsVUFBVUc7QUFDcEIvRCxhQUFTcFYsT0FBT0QsTUFBQUE7QUFDaEIsUUFBSWdULElBQUlpRyxVQUFVRyxhQUFhO0FBUTdCL0QsZUFBQUE7O0tBRURseEIsTUFBQUE7QUFHSCxRQUFNeXpCLFdBQVcsSUFBSXlCLGVBQWV2QixDQUFBQSxZQUFXO0FBQzdDLFVBQU10YSxRQUFRc2EsUUFBUSxDQUFFO0FBQ3hCLFVBQU03WCxRQUFRekMsTUFBTThiLFlBQVlyWjtBQUNoQyxVQUFNRCxTQUFTeEMsTUFBTThiLFlBQVl0WjtBQUlqQyxRQUFJQyxVQUFVLEtBQUtELFdBQVcsR0FBRztBQUMvQjs7QUFFRjRZLFdBQU8zWSxPQUFPRCxNQUFBQTtFQUNoQixDQUFBO0FBQ0E0WCxXQUFTTSxRQUFRZSxTQUFBQTtBQUNqQkgsZ0NBQThCNzFCLE9BQU8yMUIsTUFBQUE7QUFFckMsU0FBT2hCO0FBQ1Q7QUFFQSxTQUFTMkIsZ0JBQWdCdDJCLE9BQU9HLE1BQU13MEIsVUFBVTtBQUM5QyxNQUFJQSxVQUFVO0FBQ1pBLGFBQVM0QixXQUFVOztBQUVyQixNQUFJcDJCLFNBQVMsVUFBVTtBQUNyQjIxQixvQ0FBZ0M5MUIsS0FBQUE7O0FBRXBDO0FBRUEsU0FBU3cyQixxQkFBcUJ4MkIsT0FBT0csTUFBTWl5QixVQUFVO0FBQ25ELFFBQU1ILFNBQVNqeUIsTUFBTWl5QjtBQUNyQixRQUFNd0UsUUFBUVAsVUFBVSxDQUFDMXpCLFVBQVU7QUFJakMsUUFBSXhDLE1BQU0rTyxRQUFRLE1BQU07QUFDdEJxakIsZUFBU2lDLGdCQUFnQjd4QixPQUFPeEMsS0FBQUEsQ0FBQUE7O0tBRWpDQSxLQUFBQTtBQUVIazBCLGNBQVlqQyxRQUFROXhCLE1BQU1zMkIsS0FBQUE7QUFFMUIsU0FBT0E7QUFDVDtBQU1lLElBQU1DLGNBQU4sY0FBMEIzRSxhQUFBQTtFQU92Q0MsZUFBZUMsUUFBUW5OLGFBQWE7QUFJbEMsVUFBTXpQLFVBQVU0YyxVQUFVQSxPQUFPdGYsY0FBY3NmLE9BQU90ZixXQUFXLElBQUE7QUFTakUsUUFBSTBDLFdBQVdBLFFBQVE0YyxXQUFXQSxRQUFRO0FBR3hDc0IsaUJBQVd0QixRQUFRbk4sV0FBQUE7QUFDbkIsYUFBT3pQOztBQUdULFdBQU87RUFDVDtFQUtBNmMsZUFBZTdjLFNBQVM7QUFDdEIsVUFBTTRjLFNBQVM1YyxRQUFRNGM7QUFDdkIsUUFBSSxDQUFDQSxPQUFPVSxXQUFBQSxHQUFjO0FBQ3hCLGFBQU87O0FBR1QsVUFBTWp5QixVQUFVdXhCLE9BQU9VLFdBQUFBLEVBQWFqeUI7QUFDcEM7TUFBQztNQUFVO01BQVNGLFFBQVEsQ0FBQytELFNBQVM7QUFDcEMsWUFBTTJELFFBQVF4SCxRQUFRNkQsSUFBSztBQUMzQixVQUFJdVYsY0FBYzVSLEtBQVEsR0FBQTtBQUN4QitwQixlQUFPMEUsZ0JBQWdCcHlCLElBQUFBO2FBQ2xCO0FBQ0wwdEIsZUFBTzJFLGFBQWFyeUIsTUFBTTJELEtBQUFBOztJQUU5QixDQUFBO0FBRUEsVUFBTWtkLFFBQVExa0IsUUFBUTBrQixTQUFTLENBQUE7QUFDL0J6ZSxXQUFPQyxLQUFLd2UsS0FBQUEsRUFBTzVrQixRQUFRLENBQUN5RyxRQUFRO0FBQ2xDZ3JCLGFBQU83TSxNQUFNbmUsR0FBQUEsSUFBT21lLE1BQU1uZSxHQUFJO0lBQ2hDLENBQUE7QUFPQWdyQixXQUFPalYsUUFBUWlWLE9BQU9qVjtBQUV0QixXQUFPaVYsT0FBT1UsV0FBWTtBQUMxQixXQUFPO0VBQ1Q7RUFRQVIsaUJBQWlCbnlCLE9BQU9HLE1BQU1peUIsVUFBVTtBQUV0QyxTQUFLQyxvQkFBb0JyeUIsT0FBT0csSUFBQUE7QUFFaEMsVUFBTTAyQixVQUFVNzJCLE1BQU04MkIsYUFBYTkyQixNQUFNODJCLFdBQVcsQ0FBQTtBQUNwRCxVQUFNQyxXQUFXO01BQ2ZDLFFBQVF0QztNQUNSdUMsUUFBUTVCO01BQ1JNLFFBQVFJO0lBQ1Y7QUFDQSxVQUFNOUssVUFBVThMLFNBQVM1MkIsSUFBQUEsS0FBU3EyQjtBQUNsQ0ssWUFBUTEyQixJQUFBQSxJQUFROHFCLFFBQVFqckIsT0FBT0csTUFBTWl5QixRQUFBQTtFQUN2QztFQU9BQyxvQkFBb0JyeUIsT0FBT0csTUFBTTtBQUMvQixVQUFNMDJCLFVBQVU3MkIsTUFBTTgyQixhQUFhOTJCLE1BQU04MkIsV0FBVyxDQUFBO0FBQ3BELFVBQU1MLFFBQVFJLFFBQVExMkIsSUFBSztBQUUzQixRQUFJLENBQUNzMkIsT0FBTztBQUNWOztBQUdGLFVBQU1NLFdBQVc7TUFDZkMsUUFBUVY7TUFDUlcsUUFBUVg7TUFDUlgsUUFBUVc7SUFDVjtBQUNBLFVBQU1yTCxVQUFVOEwsU0FBUzUyQixJQUFBQSxLQUFTaTBCO0FBQ2xDbkosWUFBUWpyQixPQUFPRyxNQUFNczJCLEtBQUFBO0FBQ3JCSSxZQUFRMTJCLElBQUFBLElBQVFMO0VBQ2xCO0VBRUF3eUIsc0JBQXNCO0FBQ3BCLFdBQU9weEIsT0FBT3cwQjtFQUNoQjtFQVFBbkQsZUFBZU4sUUFBUWpWLE9BQU9ELFFBQVErSCxhQUFhO0FBQ2pELFdBQU95TixlQUFlTixRQUFRalYsT0FBT0QsUUFBUStILFdBQUFBO0VBQy9DO0VBS0EwTixXQUFXUCxRQUFRO0FBQ2pCLFVBQU0rRCxZQUFZL0QsVUFBVWdFLGVBQWVoRSxNQUFBQTtBQUMzQyxXQUFPLENBQUMsRUFBRStELGFBQWFBLFVBQVVrQjtFQUNuQztBQUNGO0FDL1hPLFNBQVNDLGdCQUFnQmxGLFFBQVE7QUFDdEMsTUFBSSxDQUFDbUYsZ0JBQXNCLEtBQUEsT0FBT0Msb0JBQW9CLGVBQWVwRixrQkFBa0JvRixpQkFBa0I7QUFDdkcsV0FBTzNFOztBQUVULFNBQU9nRTtBQUNUO0FDTGUsSUFBTVksVUFBTixNQUFNQTtFQUFOO0FBS2JydUI7QUFDQUM7QUFDQXpELGtDQUFTO0FBQ1QrQjtBQUNBTTs7RUFFQXl2QixnQkFBZ0J6TCxrQkFBa0M7QUFDaEQsVUFBTSxFQUFDN2lCLEdBQUdDLEVBQUFBLElBQUssS0FBS21qQixTQUFTO01BQUM7TUFBSztPQUFNUCxnQkFBQUE7QUFDekMsV0FBTztNQUFDN2lCO01BQUdDO0lBQUM7RUFDZDtFQUVBc3VCLFdBQVc7QUFDVCxXQUFPM1EsU0FBUyxLQUFLNWQsQ0FBQyxLQUFLNGQsU0FBUyxLQUFLM2QsQ0FBQztFQUM1QztFQVNBbWpCLFNBQVNya0IsT0FBaUJ5dkIsT0FBbUQ7QUFDM0UsVUFBTXgzQixRQUFRLEtBQUs2SDtBQUNuQixRQUFJLENBQUMydkIsU0FBUyxDQUFDeDNCLE9BQU87QUFFcEIsYUFBTzs7QUFFVCxVQUFNeTNCLE1BQStCLENBQUE7QUFDckMxdkIsVUFBTXhILFFBQVEsQ0FBQytELFNBQVM7QUFDdEJtekIsVUFBSW56QixJQUFBQSxJQUFRdEUsTUFBTXNFLElBQUssS0FBSXRFLE1BQU1zRSxJQUFBQSxFQUFNa0IsT0FBTSxJQUFLeEYsTUFBTXNFLElBQUFBLEVBQU1nQixNQUFNLEtBQUtoQixJQUFlO0lBQzFGLENBQUE7QUFDQSxXQUFPbXpCO0VBQ1Q7QUFDRjtBQXJDRSxjQUZtQkosU0FFWnp3QixZQUFXLENBQUE7QUFDbEIsY0FIbUJ5d0IsU0FHWks7QUNRRixTQUFTQyxTQUFTbnZCLE9BQU82USxPQUFPO0FBQ3JDLFFBQU11ZSxXQUFXcHZCLE1BQU1qQixRQUFROFI7QUFDL0IsUUFBTXdlLHFCQUFxQkMsa0JBQWtCdHZCLEtBQUFBO0FBQzdDLFFBQU11dkIsYUFBYXAzQixLQUFLQyxJQUFJZzNCLFNBQVNJLGlCQUFpQkgsb0JBQW9CQSxrQkFBQUE7QUFDMUUsUUFBTUksZUFBZUwsU0FBU00sTUFBTUMsVUFBVUMsZ0JBQWdCL2UsS0FBQUEsSUFBUyxDQUFBO0FBQ3ZFLFFBQU1nZixrQkFBa0JKLGFBQWF6MkI7QUFDckMsUUFBTTgyQixRQUFRTCxhQUFhLENBQUU7QUFDN0IsUUFBTWhiLE9BQU9nYixhQUFhSSxrQkFBa0IsQ0FBRTtBQUM5QyxRQUFNRSxXQUFXLENBQUE7QUFHakIsTUFBSUYsa0JBQWtCTixZQUFZO0FBQ2hDUyxlQUFXbmYsT0FBT2tmLFVBQVVOLGNBQWNJLGtCQUFrQk4sVUFBQUE7QUFDNUQsV0FBT1E7O0FBR1QsUUFBTS9WLFVBQVVpVyxpQkFBaUJSLGNBQWM1ZSxPQUFPMGUsVUFBQUE7QUFFdEQsTUFBSU0sa0JBQWtCLEdBQUc7QUFDdkIsUUFBSTUyQixHQUFHdUk7QUFDUCxVQUFNMHVCLGtCQUFrQkwsa0JBQWtCLElBQUkxM0IsS0FBS2c0QixPQUFPMWIsT0FBT3FiLFVBQVVELGtCQUFrQixFQUFBLElBQU07QUFDbkduWSxTQUFLN0csT0FBT2tmLFVBQVUvVixTQUFTM0ksY0FBYzZlLGVBQUFBLElBQW1CLElBQUlKLFFBQVFJLGlCQUFpQkosS0FBQUE7QUFDN0YsU0FBSzcyQixJQUFJLEdBQUd1SSxPQUFPcXVCLGtCQUFrQixHQUFHNTJCLElBQUl1SSxNQUFNdkksS0FBSztBQUNyRHllLFdBQUs3RyxPQUFPa2YsVUFBVS9WLFNBQVN5VixhQUFheDJCLENBQUFBLEdBQUl3MkIsYUFBYXgyQixJQUFJLENBQUUsQ0FBQTtJQUNyRTtBQUNBeWUsU0FBSzdHLE9BQU9rZixVQUFVL1YsU0FBU3ZGLE1BQU1wRCxjQUFjNmUsZUFBQUEsSUFBbUJyZixNQUFNN1gsU0FBU3liLE9BQU95YixlQUFlO0FBQzNHLFdBQU9IOztBQUVUclksT0FBSzdHLE9BQU9rZixVQUFVL1YsT0FBQUE7QUFDdEIsU0FBTytWO0FBQ1Q7QUFFQSxTQUFTVCxrQkFBa0J0dkIsT0FBTztBQUNoQyxRQUFNZ1gsU0FBU2hYLE1BQU1qQixRQUFRaVk7QUFDN0IsUUFBTW9aLGFBQWFwd0IsTUFBTXF3QixVQUFTO0FBQ2xDLFFBQU1DLFdBQVd0d0IsTUFBTXdRLFVBQVU0ZixjQUFjcFosU0FBUyxJQUFJO0FBQzVELFFBQU11WixXQUFXdndCLE1BQU13d0IsYUFBYUo7QUFDcEMsU0FBT2o0QixLQUFLb0UsTUFBTXBFLEtBQUtDLElBQUlrNEIsVUFBVUMsUUFBQUEsQ0FBQUE7QUFDdkM7QUFPQSxTQUFTTixpQkFBaUJSLGNBQWM1ZSxPQUFPMGUsWUFBWTtBQUN6RCxRQUFNa0IsbUJBQW1CQyxlQUFlakIsWUFBQUE7QUFDeEMsUUFBTXpWLFVBQVVuSixNQUFNN1gsU0FBU3UyQjtBQUkvQixNQUFJLENBQUNrQixrQkFBa0I7QUFDckIsV0FBT3Q0QixLQUFLb0MsSUFBSXlmLFNBQVMsQ0FBQTs7QUFHM0IsUUFBTTJXLFVBQVVDLFdBQVdILGdCQUFBQTtBQUMzQixXQUFTeDNCLElBQUksR0FBR3VJLE9BQU9tdkIsUUFBUTMzQixTQUFTLEdBQUdDLElBQUl1SSxNQUFNdkksS0FBSztBQUN4RCxVQUFNaUMsU0FBU3kxQixRQUFRMTNCLENBQUU7QUFDekIsUUFBSWlDLFNBQVM4ZSxTQUFTO0FBQ3BCLGFBQU85ZTs7RUFFWDtBQUNBLFNBQU8vQyxLQUFLb0MsSUFBSXlmLFNBQVMsQ0FBQTtBQUMzQjtBQUtBLFNBQVM0VixnQkFBZ0IvZSxPQUFPO0FBQzlCLFFBQU1nUixTQUFTLENBQUE7QUFDZixNQUFJNW9CLEdBQUd1STtBQUNQLE9BQUt2SSxJQUFJLEdBQUd1SSxPQUFPcVAsTUFBTTdYLFFBQVFDLElBQUl1SSxNQUFNdkksS0FBSztBQUM5QyxRQUFJNFgsTUFBTTVYLENBQUUsRUFBQ3kyQixPQUFPO0FBQ2xCN04sYUFBTzVuQixLQUFLaEIsQ0FBQUE7O0VBRWhCO0FBQ0EsU0FBTzRvQjtBQUNUO0FBUUEsU0FBU21PLFdBQVduZixPQUFPa2YsVUFBVU4sY0FBY3pWLFNBQVM7QUFDMUQsTUFBSTNQLFFBQVE7QUFDWixNQUFJc0gsT0FBTzhkLGFBQWEsQ0FBRTtBQUMxQixNQUFJeDJCO0FBRUorZ0IsWUFBVTdoQixLQUFLMDRCLEtBQUs3VyxPQUFBQTtBQUNwQixPQUFLL2dCLElBQUksR0FBR0EsSUFBSTRYLE1BQU03WCxRQUFRQyxLQUFLO0FBQ2pDLFFBQUlBLE1BQU0wWSxNQUFNO0FBQ2RvZSxlQUFTOTFCLEtBQUs0VyxNQUFNNVgsQ0FBRSxDQUFBO0FBQ3RCb1I7QUFDQXNILGFBQU84ZCxhQUFhcGxCLFFBQVEyUCxPQUFROztFQUV4QztBQUNGO0FBU0EsU0FBU3RDLEtBQUs3RyxPQUFPa2YsVUFBVS9WLFNBQVM4VyxZQUFZQyxVQUFVO0FBQzVELFFBQU0xNEIsUUFBUTZQLGVBQWU0b0IsWUFBWSxDQUFBO0FBQ3pDLFFBQU0xd0IsTUFBTWpJLEtBQUtDLElBQUk4UCxlQUFlNm9CLFVBQVVsZ0IsTUFBTTdYLE1BQU0sR0FBRzZYLE1BQU03WCxNQUFNO0FBQ3pFLE1BQUlxUixRQUFRO0FBQ1osTUFBSXJSLFFBQVFDLEdBQUcwWTtBQUVmcUksWUFBVTdoQixLQUFLMDRCLEtBQUs3VyxPQUFBQTtBQUNwQixNQUFJK1csVUFBVTtBQUNaLzNCLGFBQVMrM0IsV0FBV0Q7QUFDcEI5VyxjQUFVaGhCLFNBQVNiLEtBQUtvRSxNQUFNdkQsU0FBU2doQixPQUFBQTs7QUFHekNySSxTQUFPdFo7QUFFUCxTQUFPc1osT0FBTyxHQUFHO0FBQ2Z0SDtBQUNBc0gsV0FBT3haLEtBQUtnNEIsTUFBTTkzQixRQUFRZ1MsUUFBUTJQLE9BQUFBO0VBQ3BDO0FBRUEsT0FBSy9nQixJQUFJZCxLQUFLb0MsSUFBSWxDLE9BQU8sQ0FBSVksR0FBQUEsSUFBSW1ILEtBQUtuSCxLQUFLO0FBQ3pDLFFBQUlBLE1BQU0wWSxNQUFNO0FBQ2RvZSxlQUFTOTFCLEtBQUs0VyxNQUFNNVgsQ0FBRSxDQUFBO0FBQ3RCb1I7QUFDQXNILGFBQU94WixLQUFLZzRCLE1BQU05M0IsUUFBUWdTLFFBQVEyUCxPQUFBQTs7RUFFdEM7QUFDRjtBQU1BLFNBQVMwVyxlQUFlemhCLEtBQUs7QUFDM0IsUUFBTStoQixNQUFNL2hCLElBQUlqVztBQUNoQixNQUFJQyxHQUFHaW9CO0FBRVAsTUFBSThQLE1BQU0sR0FBRztBQUNYLFdBQU87O0FBR1QsT0FBSzlQLE9BQU9qUyxJQUFJLENBQUUsR0FBRWhXLElBQUksR0FBR0EsSUFBSSszQixLQUFLLEVBQUUvM0IsR0FBRztBQUN2QyxRQUFJZ1csSUFBSWhXLENBQUUsSUFBR2dXLElBQUloVyxJQUFJLENBQUUsTUFBS2lvQixNQUFNO0FBQ2hDLGFBQU87O0VBRVg7QUFDQSxTQUFPQTtBQUNUO0FDaktBLElBQU0rUCxlQUFlLENBQUNDLFVBQVVBLFVBQVUsU0FBUyxVQUFVQSxVQUFVLFVBQVUsU0FBU0E7QUFDMUYsSUFBTUMsaUJBQWlCLENBQUNueEIsT0FBTytTLE1BQU1pRSxXQUFXakUsU0FBUyxTQUFTQSxTQUFTLFNBQVMvUyxNQUFNK1MsSUFBQUEsSUFBUWlFLFNBQVNoWCxNQUFNK1MsSUFBQUEsSUFBUWlFO0FBQ3pILElBQU1vYSxnQkFBZ0IsQ0FBQ0MsYUFBYTdCLGtCQUFrQnIzQixLQUFLQyxJQUFJbzNCLGlCQUFpQjZCLGFBQWFBLFdBQUFBO0FBWTdGLFNBQVNDLE9BQU9yaUIsS0FBS3NpQixVQUFVO0FBQzdCLFFBQU0xUCxTQUFTLENBQUE7QUFDZixRQUFNMlAsWUFBWXZpQixJQUFJalcsU0FBU3U0QjtBQUMvQixRQUFNUCxNQUFNL2hCLElBQUlqVztBQUNoQixNQUFJQyxJQUFJO0FBRVIsU0FBT0EsSUFBSSszQixLQUFLLzNCLEtBQUt1NEIsV0FBVztBQUM5QjNQLFdBQU81bkIsS0FBS2dWLElBQUk5VyxLQUFLb0UsTUFBTXRELENBQUcsQ0FBQSxDQUFBO0VBQ2hDO0FBQ0EsU0FBTzRvQjtBQUNUO0FBT0EsU0FBUzRQLG9CQUFvQnp4QixPQUFPeUIsUUFBT2l3QixpQkFBaUI7QUFDMUQsUUFBTTE0QixTQUFTZ0gsTUFBTTZRLE1BQU03WDtBQUMzQixRQUFNMjRCLGNBQWF4NUIsS0FBS0MsSUFBSXFKLFFBQU96SSxTQUFTLENBQUE7QUFDNUMsUUFBTVgsUUFBUTJILE1BQU0wVjtBQUNwQixRQUFNdFYsTUFBTUosTUFBTTJWO0FBQ2xCLFFBQU1pYyxVQUFVO0FBQ2hCLE1BQUlDLFlBQVk3eEIsTUFBTThRLGdCQUFnQjZnQixXQUFBQTtBQUN0QyxNQUFJM2E7QUFFSixNQUFJMGEsaUJBQWlCO0FBQ25CLFFBQUkxNEIsV0FBVyxHQUFHO0FBQ2hCZ2UsZUFBUzdlLEtBQUtvQyxJQUFJczNCLFlBQVl4NUIsT0FBTytILE1BQU15eEIsU0FBQUE7ZUFDbENwd0IsV0FBVSxHQUFHO0FBQ3RCdVYsZ0JBQVVoWCxNQUFNOFEsZ0JBQWdCLENBQUEsSUFBSytnQixhQUFhO1dBQzdDO0FBQ0w3YSxnQkFBVTZhLFlBQVk3eEIsTUFBTThRLGdCQUFnQjZnQixjQUFhLENBQUEsS0FBTTs7QUFFakVFLGlCQUFhRixjQUFhbHdCLFNBQVF1VixTQUFTLENBQUNBO0FBRzVDLFFBQUk2YSxZQUFZeDVCLFFBQVF1NUIsV0FBV0MsWUFBWXp4QixNQUFNd3hCLFNBQVM7QUFDNUQ7OztBQUdKLFNBQU9DO0FBQ1Q7QUFNQSxTQUFTQyxlQUFlQyxRQUFRLzRCLFFBQVE7QUFDdENtd0IsT0FBSzRJLFFBQVEsQ0FBQ2hsQixVQUFVO0FBQ3RCLFVBQU1pbEIsS0FBS2psQixNQUFNaWxCO0FBQ2pCLFVBQU1DLFFBQVFELEdBQUdoNUIsU0FBUztBQUMxQixRQUFJQztBQUNKLFFBQUlnNUIsUUFBUWo1QixRQUFRO0FBQ2xCLFdBQUtDLElBQUksR0FBR0EsSUFBSWc1QixPQUFPLEVBQUVoNUIsR0FBRztBQUMxQixlQUFPOFQsTUFBTTFLLEtBQUsydkIsR0FBRy80QixDQUFBQSxDQUFFO01BQ3pCO0FBQ0ErNEIsU0FBRzVpQixPQUFPLEdBQUc2aUIsS0FBQUE7O0VBRWpCLENBQUE7QUFDRjtBQUtBLFNBQVNDLGtCQUFrQm56QixVQUFTO0FBQ2xDLFNBQU9BLFNBQVFvekIsWUFBWXB6QixTQUFRcXhCLGFBQWE7QUFDbEQ7QUFLQSxTQUFTZ0MsZUFBZXJ6QixVQUFTc3pCLFVBQVU7QUFDekMsTUFBSSxDQUFDdHpCLFNBQVE4Z0IsU0FBUztBQUNwQixXQUFPOztBQUdULFFBQU15UyxPQUFPQyxPQUFPeHpCLFNBQVF1ekIsTUFBTUQsUUFBQUE7QUFDbEMsUUFBTTVKLFVBQVVPLFVBQVVqcUIsU0FBUTBwQixPQUFPO0FBQ3pDLFFBQU0rSixRQUFROXpCLFFBQVFLLFNBQVE2ZCxJQUFJLElBQUk3ZCxTQUFRNmQsS0FBSzVqQixTQUFTO0FBRTVELFNBQU8sUUFBU3M1QixLQUFLRyxhQUFjaEssUUFBUW5VO0FBQzdDO0FBRUEsU0FBU29lLG1CQUFtQnZ0QixRQUFRbkYsT0FBTztBQUN6QyxTQUFPb0YsY0FBY0QsUUFBUTtJQUMzQm5GO0lBQ0F0SSxNQUFNO0VBQ1IsQ0FBQTtBQUNGO0FBRUEsU0FBU2k3QixrQkFBa0J4dEIsUUFBUTFELFFBQU9uSSxNQUFNO0FBQzlDLFNBQU84TCxjQUFjRCxRQUFRO0lBQzNCN0w7SUFDQW1JLE9BQUFBO0lBQ0EvSixNQUFNO0VBQ1IsQ0FBQTtBQUNGO0FBRUEsU0FBU2s3QixXQUFXMUIsT0FBTzNPLFVBQVVwaUIsU0FBUztBQUU1QyxNQUFJOHVCLE1BQU00RCxtQkFBbUIzQixLQUFBQTtBQUM3QixNQUFJLFdBQVkzTyxhQUFhLFdBQWEsQ0FBQ3BpQixXQUFXb2lCLGFBQWEsU0FBVTtBQUMzRTBNLFVBQU1nQyxhQUFhaEMsR0FBQUE7O0FBRXJCLFNBQU9BO0FBQ1Q7QUFFQSxTQUFTNkQsVUFBVTl5QixPQUFPZ1gsUUFBUXVMLFVBQVUyTyxPQUFPO0FBQ2pELFFBQU0sRUFBQ3h3QixLQUFLRyxNQUFNRCxRQUFRRCxPQUFPcEosTUFBSyxJQUFJeUk7QUFDMUMsUUFBTSxFQUFDdU0sV0FBV3hILFFBQUFBLFFBQUFBLElBQVV4TjtBQUM1QixNQUFJcWdCLFdBQVc7QUFDZixNQUFJMkMsVUFBVXdZLFFBQVFDO0FBQ3RCLFFBQU0xZSxTQUFTMVQsU0FBU0Y7QUFDeEIsUUFBTTZULFFBQVE1VCxRQUFRRTtBQUV0QixNQUFJYixNQUFNMFMsYUFBWSxHQUFJO0FBQ3hCcWdCLGFBQVNFLGVBQWUvQixPQUFPcndCLE1BQU1GLEtBQUFBO0FBRXJDLFFBQUkzQyxTQUFTdWtCLFFBQVcsR0FBQTtBQUN0QixZQUFNMlEsaUJBQWlCaDFCLE9BQU9DLEtBQUtva0IsUUFBQUEsRUFBVSxDQUFFO0FBQy9DLFlBQU05aUIsUUFBUThpQixTQUFTMlEsY0FBZTtBQUN0Q0YsZUFBU2p1QixRQUFPbXVCLGNBQUFBLEVBQWdCdGlCLGlCQUFpQm5SLEtBQUFBLElBQVM2VSxTQUFTMEM7ZUFDMUR1TCxhQUFhLFVBQVU7QUFDaEN5USxnQkFBVXptQixVQUFVM0wsU0FBUzJMLFVBQVU3TCxPQUFPLElBQUk0VCxTQUFTMEM7V0FDdEQ7QUFDTGdjLGVBQVM3QixlQUFlbnhCLE9BQU91aUIsVUFBVXZMLE1BQUFBOztBQUUzQ3VELGVBQVc1WixRQUFRRTtTQUNkO0FBQ0wsUUFBSTdDLFNBQVN1a0IsUUFBVyxHQUFBO0FBQ3RCLFlBQU0yUSxpQkFBaUJoMUIsT0FBT0MsS0FBS29rQixRQUFBQSxFQUFVLENBQUU7QUFDL0MsWUFBTTlpQixRQUFROGlCLFNBQVMyUSxjQUFlO0FBQ3RDSCxlQUFTaHVCLFFBQU9tdUIsY0FBQUEsRUFBZ0J0aUIsaUJBQWlCblIsS0FBQUEsSUFBUzhVLFFBQVF5QztlQUN6RHVMLGFBQWEsVUFBVTtBQUNoQ3dRLGdCQUFVeG1CLFVBQVUxTCxPQUFPMEwsVUFBVTVMLFNBQVMsSUFBSTRULFFBQVF5QztXQUNyRDtBQUNMK2IsZUFBUzVCLGVBQWVueEIsT0FBT3VpQixVQUFVdkwsTUFBQUE7O0FBRTNDZ2MsYUFBU0MsZUFBZS9CLE9BQU90d0IsUUFBUUYsR0FBQUE7QUFDdkNrWCxlQUFXMkssYUFBYSxTQUFTLENBQUNySixVQUFVQTs7QUFFOUMsU0FBTztJQUFDNlo7SUFBUUM7SUFBUXpZO0lBQVUzQztFQUFRO0FBQzVDO0FBRWUsSUFBTXViLFFBQU4sTUFBTUEsZUFBY3RFLFFBQUFBO0VBR2pDOTNCLFlBQVk2RSxLQUFLO0FBQ2YsVUFBSztBQUdMLFNBQUt1SCxLQUFLdkgsSUFBSXVIO0FBRWQsU0FBS3pMLE9BQU9rRSxJQUFJbEU7QUFFaEIsU0FBS3FILFVBQVUxSDtBQUVmLFNBQUtpUCxNQUFNMUssSUFBSTBLO0FBRWYsU0FBSy9PLFFBQVFxRSxJQUFJckU7QUFJakIsU0FBS21KLE1BQU1ySjtBQUVYLFNBQUt1SixTQUFTdko7QUFFZCxTQUFLd0osT0FBT3hKO0FBRVosU0FBS3NKLFFBQVF0SjtBQUViLFNBQUtrZCxRQUFRbGQ7QUFFYixTQUFLaWQsU0FBU2pkO0FBQ2QsU0FBSys3QixXQUFXO01BQ2R2eUIsTUFBTTtNQUNORixPQUFPO01BQ1BELEtBQUs7TUFDTEUsUUFBUTtJQUNWO0FBRUEsU0FBSzJaLFdBQVdsakI7QUFFaEIsU0FBS21qQixZQUFZbmpCO0FBRWpCLFNBQUtnOEIsYUFBYWg4QjtBQUVsQixTQUFLaThCLGdCQUFnQmo4QjtBQUVyQixTQUFLazhCLGNBQWNsOEI7QUFFbkIsU0FBS204QixlQUFlbjhCO0FBSXBCLFNBQUtxTCxPQUFPckw7QUFFWixTQUFLbzhCLGdCQUFnQnA4QjtBQUNyQixTQUFLZSxNQUFNZjtBQUNYLFNBQUtrRCxNQUFNbEQ7QUFDWCxTQUFLcThCLFNBQVNyOEI7QUFFZCxTQUFLd1osUUFBUSxDQUFBO0FBRWIsU0FBSzhpQixpQkFBaUI7QUFFdEIsU0FBS0MsY0FBYztBQUVuQixTQUFLQyxjQUFjO0FBQ25CLFNBQUtyakIsVUFBVTtBQUNmLFNBQUtnZ0IsYUFBYTtBQUNsQixTQUFLc0Qsb0JBQW9CLENBQUE7QUFFekIsU0FBS3BlLGNBQWNyZTtBQUVuQixTQUFLc2UsWUFBWXRlO0FBQ2pCLFNBQUtxcUIsaUJBQWlCO0FBQ3RCLFNBQUtxUyxXQUFXMThCO0FBQ2hCLFNBQUsyOEIsV0FBVzM4QjtBQUNoQixTQUFLNDhCLGdCQUFnQjU4QjtBQUNyQixTQUFLNjhCLGdCQUFnQjc4QjtBQUNyQixTQUFLODhCLGVBQWU7QUFDcEIsU0FBS0MsZUFBZTtBQUNwQixTQUFLcGtCLFNBQVMsQ0FBQTtBQUNkLFNBQUtxa0Isb0JBQW9CO0FBQ3pCLFNBQUtudEIsV0FBVzdQO0VBQ2xCO0VBTUEwcEIsS0FBS2hpQixVQUFTO0FBQ1osU0FBS0EsVUFBVUEsU0FBUXUxQixXQUFXLEtBQUtwcUIsV0FBVSxDQUFBO0FBRWpELFNBQUt4SCxPQUFPM0QsU0FBUTJEO0FBR3BCLFNBQUtzeEIsV0FBVyxLQUFLNXBCLE1BQU1yTCxTQUFRM0csR0FBRztBQUN0QyxTQUFLMjdCLFdBQVcsS0FBSzNwQixNQUFNckwsU0FBUXhFLEdBQUc7QUFDdEMsU0FBSzI1QixnQkFBZ0IsS0FBSzlwQixNQUFNckwsU0FBUXcxQixZQUFZO0FBQ3BELFNBQUtOLGdCQUFnQixLQUFLN3BCLE1BQU1yTCxTQUFReTFCLFlBQVk7RUFDdEQ7RUFRQXBxQixNQUFNM0UsS0FBS2hFLFFBQU87QUFDaEIsV0FBT2dFO0VBQ1Q7RUFPQXJDLGdCQUFnQjtBQUNkLFFBQUksRUFBQzR3QixVQUFVRCxVQUFVRyxlQUFlRCxjQUFBQSxJQUFpQjtBQUN6REQsZUFBV1MsZ0JBQWdCVCxVQUFVendCLE9BQU9FLGlCQUFpQjtBQUM3RHN3QixlQUFXVSxnQkFBZ0JWLFVBQVV4d0IsT0FBT0MsaUJBQWlCO0FBQzdEMHdCLG9CQUFnQk8sZ0JBQWdCUCxlQUFlM3dCLE9BQU9FLGlCQUFpQjtBQUN2RXd3QixvQkFBZ0JRLGdCQUFnQlIsZUFBZTF3QixPQUFPQyxpQkFBaUI7QUFDdkUsV0FBTztNQUNMcEwsS0FBS3E4QixnQkFBZ0JULFVBQVVFLGFBQUFBO01BQy9CMzVCLEtBQUtrNkIsZ0JBQWdCVixVQUFVRSxhQUFBQTtNQUMvQjV3QixZQUFZbkIsZUFBUzh4QixRQUFBQTtNQUNyQjF3QixZQUFZcEIsZUFBUzZ4QixRQUFBQTtJQUN2QjtFQUNGO0VBUUF0b0IsVUFBVXhGLFVBQVU7QUFDbEIsUUFBSSxFQUFDN04sS0FBS21DLEtBQUs4SSxZQUFZQyxXQUFBQSxJQUFjLEtBQUtGLGNBQWE7QUFDM0QsUUFBSWtJO0FBRUosUUFBSWpJLGNBQWNDLFlBQVk7QUFDNUIsYUFBTztRQUFDbEw7UUFBS21DO01BQUc7O0FBR2xCLFVBQU1tNkIsUUFBUSxLQUFLendCLHdCQUF1QjtBQUMxQyxhQUFTaEwsSUFBSSxHQUFHdUksT0FBT2t6QixNQUFNMTdCLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ2xEcVMsY0FBUW9wQixNQUFNejdCLENBQUUsRUFBQ2tMLFdBQVdzSCxVQUFVLE1BQU14RixRQUFBQTtBQUM1QyxVQUFJLENBQUM1QyxZQUFZO0FBQ2ZqTCxjQUFNRCxLQUFLQyxJQUFJQSxLQUFLa1QsTUFBTWxULEdBQUc7O0FBRS9CLFVBQUksQ0FBQ2tMLFlBQVk7QUFDZi9JLGNBQU1wQyxLQUFLb0MsSUFBSUEsS0FBSytRLE1BQU0vUSxHQUFHOztJQUVqQztBQUdBbkMsVUFBTWtMLGNBQWNsTCxNQUFNbUMsTUFBTUEsTUFBTW5DO0FBQ3RDbUMsVUFBTThJLGNBQWNqTCxNQUFNbUMsTUFBTW5DLE1BQU1tQztBQUV0QyxXQUFPO01BQ0xuQyxLQUFLcThCLGdCQUFnQnI4QixLQUFLcThCLGdCQUFnQmw2QixLQUFLbkMsR0FBQUEsQ0FBQUE7TUFDL0NtQyxLQUFLazZCLGdCQUFnQmw2QixLQUFLazZCLGdCQUFnQnI4QixLQUFLbUMsR0FBQUEsQ0FBQUE7SUFDakQ7RUFDRjtFQU9BeXNCLGFBQWE7QUFDWCxXQUFPO01BQ0xubUIsTUFBTSxLQUFLMHlCLGVBQWU7TUFDMUI3eUIsS0FBSyxLQUFLMnlCLGNBQWM7TUFDeEIxeUIsT0FBTyxLQUFLNnlCLGdCQUFnQjtNQUM1QjV5QixRQUFRLEtBQUsweUIsaUJBQWlCO0lBQ2hDO0VBQ0Y7RUFPQXFCLFdBQVc7QUFDVCxXQUFPLEtBQUs5akI7RUFDZDtFQUtBL0YsWUFBWTtBQUNWLFVBQU16SSxPQUFPLEtBQUs5SyxNQUFNOEs7QUFDeEIsV0FBTyxLQUFLdEQsUUFBUThMLFdBQVcsS0FBSzZILGFBQVksSUFBS3JRLEtBQUt1eUIsVUFBVXZ5QixLQUFLd3lCLFlBQVl4eUIsS0FBS3dJLFVBQVUsQ0FBQTtFQUN0RztFQUtBaXFCLGNBQWN2b0IsWUFBWSxLQUFLaFYsTUFBTWdWLFdBQVc7QUFDOUMsVUFBTXhULFFBQVEsS0FBSzY2QixnQkFBZ0IsS0FBS0EsY0FBYyxLQUFLbUIsbUJBQW1CeG9CLFNBQVM7QUFDdkYsV0FBT3hUO0VBQ1Q7RUFHQXF3QixlQUFlO0FBQ2IsU0FBS3BaLFNBQVMsQ0FBQTtBQUNkLFNBQUtxa0Isb0JBQW9CO0VBQzNCO0VBTUFXLGVBQWU7QUFDYng4QixhQUFLLEtBQUt1RyxRQUFRaTJCLGNBQWM7TUFBQztJQUFLLENBQUE7RUFDeEM7RUFVQS8zQixPQUFPc2QsVUFBVUMsV0FBV3lhLFNBQVM7QUFDbkMsVUFBTSxFQUFDOWQsYUFBYStkLE9BQU9ya0IsT0FBT3VlLFNBQUFBLElBQVksS0FBS3J3QjtBQUNuRCxVQUFNbzJCLGFBQWEvRixTQUFTK0Y7QUFHNUIsU0FBS0gsYUFBWTtBQUdqQixTQUFLemEsV0FBV0E7QUFDaEIsU0FBS0MsWUFBWUE7QUFDakIsU0FBSzRZLFdBQVc2QixVQUFVLzJCLE9BQU95QixPQUFPO01BQ3RDa0IsTUFBTTtNQUNORixPQUFPO01BQ1BELEtBQUs7TUFDTEUsUUFBUTtPQUNQcTBCLE9BQUFBO0FBRUgsU0FBS3BrQixRQUFRO0FBQ2IsU0FBS2dqQixjQUFjO0FBQ25CLFNBQUtGLGlCQUFpQjtBQUN0QixTQUFLQyxjQUFjO0FBR25CLFNBQUt3QixvQkFBbUI7QUFDeEIsU0FBS0MsY0FBYTtBQUNsQixTQUFLQyxtQkFBa0I7QUFFdkIsU0FBSzlFLGFBQWEsS0FBSzlkLGFBQVksSUFDL0IsS0FBSzZCLFFBQVEwZ0IsUUFBUXAwQixPQUFPbzBCLFFBQVF0MEIsUUFDcEMsS0FBSzJULFNBQVMyZ0IsUUFBUXYwQixNQUFNdTBCLFFBQVFyMEI7QUFHeEMsUUFBSSxDQUFDLEtBQUt5ekIsbUJBQW1CO0FBQzNCLFdBQUtrQixpQkFBZ0I7QUFDckIsV0FBS0Msb0JBQW1CO0FBQ3hCLFdBQUtDLGdCQUFlO0FBQ3BCLFdBQUsvQixTQUFTZ0MsVUFBVSxNQUFNUixPQUFPL2QsV0FBQUE7QUFDckMsV0FBS2tkLG9CQUFvQjs7QUFHM0IsU0FBS3NCLGlCQUFnQjtBQUVyQixTQUFLOWtCLFFBQVEsS0FBSytrQixXQUFVLEtBQU0sQ0FBQTtBQUdsQyxTQUFLQyxnQkFBZTtBQUlwQixVQUFNQyxrQkFBa0JYLGFBQWEsS0FBS3RrQixNQUFNN1g7QUFDaEQsU0FBSys4QixzQkFBc0JELGtCQUFrQnhFLE9BQU8sS0FBS3pnQixPQUFPc2tCLFVBQUFBLElBQWMsS0FBS3RrQixLQUFLO0FBTXhGLFNBQUs5UyxVQUFTO0FBR2QsU0FBS2k0Qiw2QkFBNEI7QUFDakMsU0FBS0MsdUJBQXNCO0FBQzNCLFNBQUtDLDRCQUEyQjtBQUdoQyxRQUFJOUcsU0FBU3ZQLFlBQVl1UCxTQUFTRCxZQUFZQyxTQUFTK0csV0FBVyxTQUFTO0FBQ3pFLFdBQUt0bEIsUUFBUXNlLFNBQVMsTUFBTSxLQUFLdGUsS0FBSztBQUN0QyxXQUFLZ2pCLGNBQWM7QUFDbkIsV0FBS3VDLGNBQWE7O0FBR3BCLFFBQUlOLGlCQUFpQjtBQUVuQixXQUFLQyxzQkFBc0IsS0FBS2xsQixLQUFLOztBQUd2QyxTQUFLd2xCLFVBQVM7QUFDZCxTQUFLQyxJQUFHO0FBQ1IsU0FBS0MsU0FBUTtBQUliLFNBQUtDLFlBQVc7RUFDbEI7RUFLQXo0QixZQUFZO0FBQ1YsUUFBSTA0QixnQkFBZ0IsS0FBSzEzQixRQUFRb0I7QUFDakMsUUFBSTZWLFlBQVlFO0FBRWhCLFFBQUksS0FBS3hELGFBQVksR0FBSTtBQUN2QnNELG1CQUFhLEtBQUtuVjtBQUNsQnFWLGlCQUFXLEtBQUt2VjtXQUNYO0FBQ0xxVixtQkFBYSxLQUFLdFY7QUFDbEJ3VixpQkFBVyxLQUFLdFY7QUFFaEI2MUIsc0JBQWdCLENBQUNBOztBQUVuQixTQUFLL2dCLGNBQWNNO0FBQ25CLFNBQUtMLFlBQVlPO0FBQ2pCLFNBQUt3TCxpQkFBaUIrVTtBQUN0QixTQUFLam1CLFVBQVUwRixXQUFXRjtBQUMxQixTQUFLMGdCLGlCQUFpQixLQUFLMzNCLFFBQVE0M0I7RUFDckM7RUFFQUgsY0FBYztBQUNaaCtCLGFBQUssS0FBS3VHLFFBQVF5M0IsYUFBYTtNQUFDO0lBQUssQ0FBQTtFQUN2QztFQUlBcEIsc0JBQXNCO0FBQ3BCNThCLGFBQUssS0FBS3VHLFFBQVFxMkIscUJBQXFCO01BQUM7SUFBSyxDQUFBO0VBQy9DO0VBQ0FDLGdCQUFnQjtBQUVkLFFBQUksS0FBSzNpQixhQUFZLEdBQUk7QUFFdkIsV0FBSzZCLFFBQVEsS0FBS2dHO0FBQ2xCLFdBQUsxWixPQUFPO0FBQ1osV0FBS0YsUUFBUSxLQUFLNFQ7V0FDYjtBQUNMLFdBQUtELFNBQVMsS0FBS2tHO0FBR25CLFdBQUs5WixNQUFNO0FBQ1gsV0FBS0UsU0FBUyxLQUFLMFQ7O0FBSXJCLFNBQUtpZixjQUFjO0FBQ25CLFNBQUtGLGFBQWE7QUFDbEIsU0FBS0csZUFBZTtBQUNwQixTQUFLRixnQkFBZ0I7RUFDdkI7RUFDQWdDLHFCQUFxQjtBQUNuQjk4QixhQUFLLEtBQUt1RyxRQUFRdTJCLG9CQUFvQjtNQUFDO0lBQUssQ0FBQTtFQUM5QztFQUVBc0IsV0FBV25oQixNQUFNO0FBQ2YsU0FBS2xlLE1BQU1zL0IsY0FBY3BoQixNQUFNLEtBQUt2TCxXQUFVLENBQUE7QUFDOUMxUixhQUFLLEtBQUt1RyxRQUFRMFcsSUFBQUEsR0FBTztNQUFDO0lBQUssQ0FBQTtFQUNqQztFQUdBOGYsbUJBQW1CO0FBQ2pCLFNBQUtxQixXQUFXLGtCQUFBO0VBQ2xCO0VBQ0FwQixzQkFBc0I7RUFBQTtFQUN0QkMsa0JBQWtCO0FBQ2hCLFNBQUttQixXQUFXLGlCQUFBO0VBQ2xCO0VBR0FqQixtQkFBbUI7QUFDakIsU0FBS2lCLFdBQVcsa0JBQUE7RUFDbEI7RUFJQWhCLGFBQWE7QUFDWCxXQUFPLENBQUE7RUFDVDtFQUNBQyxrQkFBa0I7QUFDaEIsU0FBS2UsV0FBVyxpQkFBQTtFQUNsQjtFQUVBRSw4QkFBOEI7QUFDNUJ0K0IsYUFBSyxLQUFLdUcsUUFBUSszQiw2QkFBNkI7TUFBQztJQUFLLENBQUE7RUFDdkQ7RUFLQUMsbUJBQW1CbG1CLE9BQU87QUFDeEIsVUFBTXVlLFdBQVcsS0FBS3J3QixRQUFROFI7QUFDOUIsUUFBSTVYLEdBQUd1SSxNQUFNbEk7QUFDYixTQUFLTCxJQUFJLEdBQUd1SSxPQUFPcVAsTUFBTTdYLFFBQVFDLElBQUl1SSxNQUFNdkksS0FBSztBQUM5Q0ssYUFBT3VYLE1BQU01WCxDQUFFO0FBQ2ZLLFdBQUsyUyxRQUFRelQsU0FBSzQyQixTQUFTNEgsVUFBVTtRQUFDMTlCLEtBQUttRztRQUFPeEc7UUFBRzRYO01BQU0sR0FBRSxJQUFJO0lBQ25FO0VBQ0Y7RUFDQW9tQiw2QkFBNkI7QUFDM0J6K0IsYUFBSyxLQUFLdUcsUUFBUWs0Qiw0QkFBNEI7TUFBQztJQUFLLENBQUE7RUFDdEQ7RUFJQWpCLCtCQUErQjtBQUM3Qng5QixhQUFLLEtBQUt1RyxRQUFRaTNCLDhCQUE4QjtNQUFDO0lBQUssQ0FBQTtFQUN4RDtFQUNBQyx5QkFBeUI7QUFDdkIsVUFBTWwzQixXQUFVLEtBQUtBO0FBQ3JCLFVBQU1xd0IsV0FBV3J3QixTQUFROFI7QUFDekIsVUFBTXFtQixXQUFXOUYsY0FBYyxLQUFLdmdCLE1BQU03WCxRQUFRK0YsU0FBUThSLE1BQU0yZSxhQUFhO0FBQzdFLFVBQU0ySCxjQUFjL0gsU0FBUytILGVBQWU7QUFDNUMsVUFBTUMsY0FBY2hJLFNBQVNnSTtBQUM3QixRQUFJM0QsZ0JBQWdCMEQ7QUFDcEIsUUFBSUUsV0FBVzdjLFdBQVc4YztBQUUxQixRQUFJLENBQUMsS0FBS0MsV0FBVSxLQUFNLENBQUNuSSxTQUFTdlAsV0FBV3NYLGVBQWVDLGVBQWVGLFlBQVksS0FBSyxDQUFDLEtBQUt4a0IsYUFBWSxHQUFJO0FBQ2xILFdBQUsrZ0IsZ0JBQWdCMEQ7QUFDckI7O0FBR0YsVUFBTUssYUFBYSxLQUFLQyxlQUFjO0FBQ3RDLFVBQU1DLGdCQUFnQkYsV0FBV0csT0FBT3BqQjtBQUN4QyxVQUFNcWpCLGlCQUFpQkosV0FBV0ssUUFBUXZqQjtBQUkxQyxVQUFNaUcsV0FBV3VkLFlBQVksS0FBS3ZnQyxNQUFNZ2QsUUFBUW1qQixlQUFlLEdBQUcsS0FBS25kLFFBQVE7QUFDL0U4YyxnQkFBWXQ0QixTQUFRaVksU0FBUyxLQUFLdUQsV0FBVzJjLFdBQVczYyxZQUFZMmMsV0FBVztBQUcvRSxRQUFJUSxnQkFBZ0IsSUFBSUwsV0FBVztBQUNqQ0Esa0JBQVk5YyxZQUFZMmMsWUFBWW40QixTQUFRaVksU0FBUyxNQUFNO0FBQzNEd0Qsa0JBQVksS0FBS0EsWUFBWTBYLGtCQUFrQm56QixTQUFRa1ksSUFBSSxJQUMzRG1ZLFNBQVMzRyxVQUFVMkosZUFBZXJ6QixTQUFRZzVCLE9BQU8sS0FBS3hnQyxNQUFNd0gsUUFBUXV6QixJQUFJO0FBQ3hFZ0YseUJBQW1Cbi9CLEtBQUsrcUIsS0FBS3dVLGdCQUFnQkEsZ0JBQWdCRSxpQkFBaUJBLGNBQUFBO0FBQzlFbkUsc0JBQWdCdUUsVUFBVTcvQixLQUFLQyxJQUM3QkQsS0FBSzgvQixLQUFLSCxhQUFhTixXQUFXSyxRQUFRdmpCLFNBQVMsS0FBSytpQixXQUFXLElBQUksQ0FBQSxDQUFBLEdBQ3ZFbC9CLEtBQUs4L0IsS0FBS0gsWUFBWXRkLFlBQVk4YyxrQkFBa0IsSUFBSSxDQUFBLENBQUEsSUFBTW4vQixLQUFLOC9CLEtBQUtILFlBQVlGLGlCQUFpQk4sa0JBQWtCLElBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQTtBQUU3SDdELHNCQUFnQnQ3QixLQUFLb0MsSUFBSTQ4QixhQUFhaC9CLEtBQUtDLElBQUlnL0IsYUFBYTNELGFBQUFBLENBQUFBOztBQUc5RCxTQUFLQSxnQkFBZ0JBO0VBQ3ZCO0VBQ0F5Qyw4QkFBOEI7QUFDNUIxOUIsYUFBSyxLQUFLdUcsUUFBUW0zQiw2QkFBNkI7TUFBQztJQUFLLENBQUE7RUFDdkQ7RUFDQUUsZ0JBQWdCO0VBQUE7RUFJaEJDLFlBQVk7QUFDVjc5QixhQUFLLEtBQUt1RyxRQUFRczNCLFdBQVc7TUFBQztJQUFLLENBQUE7RUFDckM7RUFDQUMsTUFBTTtBQUVKLFVBQU1yWCxVQUFVO01BQ2QxSyxPQUFPO01BQ1BELFFBQVE7SUFDVjtBQUVBLFVBQU0sRUFBQy9jLE9BQU93SCxTQUFTLEVBQUM4UixPQUFPdWUsVUFBVTJJLE9BQU9HLFdBQVdqaEIsTUFBTWtoQixTQUFBQSxFQUFTLElBQUk7QUFDOUUsVUFBTXRZLFVBQVUsS0FBSzBYLFdBQVU7QUFDL0IsVUFBTTdrQixlQUFlLEtBQUtBLGFBQVk7QUFFdEMsUUFBSW1OLFNBQVM7QUFDWCxZQUFNdVksY0FBY2hHLGVBQWU4RixXQUFXM2dDLE1BQU13SCxRQUFRdXpCLElBQUk7QUFDaEUsVUFBSTVmLGNBQWM7QUFDaEJ1TSxnQkFBUTFLLFFBQVEsS0FBS2dHO0FBQ3JCMEUsZ0JBQVEzSyxTQUFTNGQsa0JBQWtCaUcsUUFBWUMsSUFBQUE7YUFDMUM7QUFDTG5aLGdCQUFRM0ssU0FBUyxLQUFLa0c7QUFDdEJ5RSxnQkFBUTFLLFFBQVEyZCxrQkFBa0JpRyxRQUFZQyxJQUFBQTs7QUFJaEQsVUFBSWhKLFNBQVN2UCxXQUFXLEtBQUtoUCxNQUFNN1gsUUFBUTtBQUN6QyxjQUFNLEVBQUM4MkIsT0FBT3JiLE1BQU1rakIsUUFBUUUsUUFBQUEsSUFBVyxLQUFLSixlQUFjO0FBQzFELGNBQU1ZLGNBQWNqSixTQUFTM0csVUFBVTtBQUN2QyxjQUFNNlAsZUFBZTNlLFVBQVUsS0FBSzhaLGFBQWE7QUFDakQsY0FBTWxiLE1BQU1wZ0IsS0FBS29nQixJQUFJK2YsWUFBQUE7QUFDckIsY0FBTTdmLE1BQU10Z0IsS0FBS3NnQixJQUFJNmYsWUFBQUE7QUFFckIsWUFBSTVsQixjQUFjO0FBRWhCLGdCQUFNNmxCLGNBQWNuSixTQUFTb0osU0FBUyxJQUFJL2YsTUFBTWtmLE9BQU9wakIsUUFBUWdFLE1BQU1zZixRQUFRdmpCO0FBQzdFMkssa0JBQVEzSyxTQUFTbmMsS0FBS0MsSUFBSSxLQUFLb2lCLFdBQVd5RSxRQUFRM0ssU0FBU2lrQixjQUFjRixXQUFBQTtlQUNwRTtBQUdMLGdCQUFNSSxhQUFhckosU0FBU29KLFNBQVMsSUFBSWpnQixNQUFNb2YsT0FBT3BqQixRQUFRa0UsTUFBTW9mLFFBQVF2akI7QUFFNUUySyxrQkFBUTFLLFFBQVFwYyxLQUFLQyxJQUFJLEtBQUttaUIsVUFBVTBFLFFBQVExSyxRQUFRa2tCLGFBQWFKLFdBQUFBOztBQUV2RSxhQUFLSyxrQkFBa0I1SSxPQUFPcmIsTUFBTWdFLEtBQUtGLEdBQUFBOzs7QUFJN0MsU0FBS29nQixlQUFjO0FBRW5CLFFBQUlqbUIsY0FBYztBQUNoQixXQUFLNkIsUUFBUSxLQUFLL0QsVUFBVWpaLE1BQU1nZCxRQUFRLEtBQUs2ZSxTQUFTdnlCLE9BQU8sS0FBS3V5QixTQUFTenlCO0FBQzdFLFdBQUsyVCxTQUFTMkssUUFBUTNLO1dBQ2pCO0FBQ0wsV0FBS0MsUUFBUTBLLFFBQVExSztBQUNyQixXQUFLRCxTQUFTLEtBQUs5RCxVQUFValosTUFBTStjLFNBQVMsS0FBSzhlLFNBQVMxeUIsTUFBTSxLQUFLMHlCLFNBQVN4eUI7O0VBRWxGO0VBRUE4M0Isa0JBQWtCNUksT0FBT3JiLE1BQU1nRSxLQUFLRixLQUFLO0FBQ3ZDLFVBQU0sRUFBQzFILE9BQU8sRUFBQ3FnQixPQUFPekksUUFBTyxHQUFHbEcsU0FBUSxJQUFJLEtBQUt4akI7QUFDakQsVUFBTTY1QixZQUFZLEtBQUtuRixrQkFBa0I7QUFDekMsVUFBTW9GLG1CQUFtQnRXLGFBQWEsU0FBUyxLQUFLN2YsU0FBUztBQUU3RCxRQUFJLEtBQUtnUSxhQUFZLEdBQUk7QUFDdkIsWUFBTW9tQixhQUFhLEtBQUtob0IsZ0JBQWdCLENBQUssSUFBQSxLQUFLalE7QUFDbEQsWUFBTWs0QixjQUFjLEtBQUtwNEIsUUFBUSxLQUFLbVEsZ0JBQWdCLEtBQUtELE1BQU03WCxTQUFTLENBQUE7QUFDMUUsVUFBSXU2QixjQUFjO0FBQ2xCLFVBQUlDLGVBQWU7QUFJbkIsVUFBSW9GLFdBQVc7QUFDYixZQUFJQyxrQkFBa0I7QUFDcEJ0Rix3QkFBY2hiLE1BQU11WCxNQUFNdmI7QUFDMUJpZix5QkFBZS9hLE1BQU1oRSxLQUFLSDtlQUNyQjtBQUNMaWYsd0JBQWM5YSxNQUFNcVgsTUFBTXhiO0FBQzFCa2YseUJBQWVqYixNQUFNOUQsS0FBS0Y7O2lCQUVuQjJjLFVBQVUsU0FBUztBQUM1QnNDLHVCQUFlL2UsS0FBS0Y7aUJBQ1gyYyxVQUFVLE9BQU87QUFDMUJxQyxzQkFBY3pELE1BQU12YjtpQkFDWDJjLFVBQVUsU0FBUztBQUM1QnFDLHNCQUFjekQsTUFBTXZiLFFBQVE7QUFDNUJpZix1QkFBZS9lLEtBQUtGLFFBQVE7O0FBSTlCLFdBQUtnZixjQUFjcDdCLEtBQUtvQyxLQUFLZzVCLGNBQWN1RixhQUFhclEsV0FBVyxLQUFLbFUsU0FBUyxLQUFLQSxRQUFRdWtCLGFBQWEsQ0FBQTtBQUMzRyxXQUFLdEYsZUFBZXI3QixLQUFLb0MsS0FBS2k1QixlQUFldUYsY0FBY3RRLFdBQVcsS0FBS2xVLFNBQVMsS0FBS0EsUUFBUXdrQixjQUFjLENBQUE7V0FDMUc7QUFDTCxVQUFJMUYsYUFBYTVlLEtBQUtILFNBQVM7QUFDL0IsVUFBSWdmLGdCQUFnQnhELE1BQU14YixTQUFTO0FBRW5DLFVBQUk0YyxVQUFVLFNBQVM7QUFDckJtQyxxQkFBYTtBQUNiQyx3QkFBZ0J4RCxNQUFNeGI7aUJBQ2I0YyxVQUFVLE9BQU87QUFDMUJtQyxxQkFBYTVlLEtBQUtIO0FBQ2xCZ2Ysd0JBQWdCOztBQUdsQixXQUFLRCxhQUFhQSxhQUFhNUs7QUFDL0IsV0FBSzZLLGdCQUFnQkEsZ0JBQWdCN0s7O0VBRXpDO0VBTUFrUSxpQkFBaUI7QUFDZixRQUFJLEtBQUt2RixVQUFVO0FBQ2pCLFdBQUtBLFNBQVN2eUIsT0FBTzFJLEtBQUtvQyxJQUFJLEtBQUtnNUIsYUFBYSxLQUFLSCxTQUFTdnlCLElBQUk7QUFDbEUsV0FBS3V5QixTQUFTMXlCLE1BQU12SSxLQUFLb0MsSUFBSSxLQUFLODRCLFlBQVksS0FBS0QsU0FBUzF5QixHQUFHO0FBQy9ELFdBQUsweUIsU0FBU3p5QixRQUFReEksS0FBS29DLElBQUksS0FBS2k1QixjQUFjLEtBQUtKLFNBQVN6eUIsS0FBSztBQUNyRSxXQUFLeXlCLFNBQVN4eUIsU0FBU3pJLEtBQUtvQyxJQUFJLEtBQUsrNEIsZUFBZSxLQUFLRixTQUFTeHlCLE1BQU07O0VBRTVFO0VBRUEyMUIsV0FBVztBQUNULzlCLGFBQUssS0FBS3VHLFFBQVF3M0IsVUFBVTtNQUFDO0lBQUssQ0FBQTtFQUNwQztFQU1BN2pCLGVBQWU7QUFDYixVQUFNLEVBQUNoUSxNQUFNNmYsU0FBQUEsSUFBWSxLQUFLeGpCO0FBQzlCLFdBQU93akIsYUFBYSxTQUFTQSxhQUFhLFlBQVk3ZixTQUFTO0VBQ2pFO0VBSUFzMkIsYUFBYTtBQUNYLFdBQU8sS0FBS2o2QixRQUFRbW5CO0VBQ3RCO0VBTUE2UCxzQkFBc0JsbEIsT0FBTztBQUMzQixTQUFLaW1CLDRCQUEyQjtBQUVoQyxTQUFLQyxtQkFBbUJsbUIsS0FBQUE7QUFHeEIsUUFBSTVYLEdBQUd1STtBQUNQLFNBQUt2SSxJQUFJLEdBQUd1SSxPQUFPcVAsTUFBTTdYLFFBQVFDLElBQUl1SSxNQUFNdkksS0FBSztBQUM5QyxVQUFJb1ksY0FBY1IsTUFBTTVYLENBQUUsRUFBQ2dULEtBQUssR0FBRztBQUNqQzRFLGNBQU16QixPQUFPblcsR0FBRyxDQUFBO0FBQ2hCdUk7QUFDQXZJOztJQUVKO0FBRUEsU0FBS2crQiwyQkFBMEI7RUFDakM7RUFNQVEsaUJBQWlCO0FBQ2YsUUFBSUQsYUFBYSxLQUFLM0Q7QUFFdEIsUUFBSSxDQUFDMkQsWUFBWTtBQUNmLFlBQU1yQyxhQUFhLEtBQUtwMkIsUUFBUThSLE1BQU1za0I7QUFDdEMsVUFBSXRrQixRQUFRLEtBQUtBO0FBQ2pCLFVBQUlza0IsYUFBYXRrQixNQUFNN1gsUUFBUTtBQUM3QjZYLGdCQUFReWdCLE9BQU96Z0IsT0FBT3NrQixVQUFBQTs7QUFHeEIsV0FBS3RCLGNBQWMyRCxhQUFhLEtBQUt5QixtQkFBbUJwb0IsT0FBT0EsTUFBTTdYLFFBQVEsS0FBSytGLFFBQVE4UixNQUFNMmUsYUFBYTs7QUFHL0csV0FBT2dJO0VBQ1Q7RUFRQXlCLG1CQUFtQnBvQixPQUFPN1gsUUFBUXcyQixlQUFlO0FBQy9DLFVBQU0sRUFBQ2xwQixLQUFLd3RCLG1CQUFtQi9CLE9BQU0sSUFBSTtBQUN6QyxVQUFNbUgsU0FBUyxDQUFBO0FBQ2YsVUFBTUMsVUFBVSxDQUFBO0FBQ2hCLFVBQU0zSCxZQUFZcjVCLEtBQUtvRSxNQUFNdkQsU0FBU280QixjQUFjcDRCLFFBQVF3MkIsYUFBQUEsQ0FBQUE7QUFDNUQsUUFBSTRKLGtCQUFrQjtBQUN0QixRQUFJQyxtQkFBbUI7QUFDdkIsUUFBSXBnQyxHQUFHeXBCLEdBQUc0VyxNQUFNcnRCLE9BQU9zdEIsVUFBVUMsWUFBWXpzQixPQUFPMGxCLFlBQVlsZSxPQUFPRCxRQUFRbWxCO0FBRS9FLFNBQUt4Z0MsSUFBSSxHQUFHQSxJQUFJRCxRQUFRQyxLQUFLdTRCLFdBQVc7QUFDdEN2bEIsY0FBUTRFLE1BQU01WCxDQUFFLEVBQUNnVDtBQUNqQnN0QixpQkFBVyxLQUFLRyx3QkFBd0J6Z0MsQ0FBQUE7QUFDeENxTixVQUFJZ3NCLE9BQU9rSCxhQUFhRCxTQUFTSTtBQUNqQzVzQixjQUFRZ2xCLE9BQU95SCxVQUFBQSxJQUFjekgsT0FBT3lILFVBQUFBLEtBQWU7UUFBQ24zQixNQUFNLENBQUE7UUFBSTJ2QixJQUFJLENBQUE7TUFBRTtBQUNwRVMsbUJBQWE4RyxTQUFTOUc7QUFDdEJsZSxjQUFRRCxTQUFTO0FBRWpCLFVBQUksQ0FBQ2pELGNBQWNwRixLQUFVLEtBQUEsQ0FBQ3ZOLFFBQVF1TixLQUFRLEdBQUE7QUFDNUNzSSxnQkFBUXFsQixhQUFhdHpCLEtBQUt5RyxNQUFNMUssTUFBTTBLLE1BQU1pbEIsSUFBSXpkLE9BQU90SSxLQUFBQTtBQUN2RHFJLGlCQUFTbWU7aUJBQ0EvekIsUUFBUXVOLEtBQVEsR0FBQTtBQUV6QixhQUFLeVcsSUFBSSxHQUFHNFcsT0FBT3J0QixNQUFNalQsUUFBUTBwQixJQUFJNFcsTUFBTSxFQUFFNVcsR0FBRztBQUM5QytXLHdCQUFxQ3h0QixNQUFNeVcsQ0FBRTtBQUU3QyxjQUFJLENBQUNyUixjQUFjb29CLFdBQWdCLEtBQUEsQ0FBQy82QixRQUFRKzZCLFdBQWMsR0FBQTtBQUN4RGxsQixvQkFBUXFsQixhQUFhdHpCLEtBQUt5RyxNQUFNMUssTUFBTTBLLE1BQU1pbEIsSUFBSXpkLE9BQU9rbEIsV0FBQUE7QUFDdkRubEIsc0JBQVVtZTs7UUFFZDs7QUFFRnlHLGFBQU9qL0IsS0FBS3NhLEtBQUFBO0FBQ1o0a0IsY0FBUWwvQixLQUFLcWEsTUFBQUE7QUFDYjhrQix3QkFBa0JqaEMsS0FBS29DLElBQUlnYSxPQUFPNmtCLGVBQUFBO0FBQ2xDQyx5QkFBbUJsaEMsS0FBS29DLElBQUkrWixRQUFRK2tCLGdCQUFBQTtJQUN0QztBQUNBdkgsbUJBQWVDLFFBQVEvNEIsTUFBQUE7QUFFdkIsVUFBTTIrQixTQUFTdUIsT0FBT2prQixRQUFRbWtCLGVBQUFBO0FBQzlCLFVBQU12QixVQUFVc0IsUUFBUWxrQixRQUFRb2tCLGdCQUFBQTtBQUVoQyxVQUFNUSxVQUFVLENBQUNDLFNBQVM7TUFBQ3ZsQixPQUFPMmtCLE9BQU9ZLEdBQUFBLEtBQVE7TUFBR3hsQixRQUFRNmtCLFFBQVFXLEdBQUFBLEtBQVE7O0FBRTVFLFdBQU87TUFDTGhLLE9BQU8rSixRQUFRLENBQUE7TUFDZnBsQixNQUFNb2xCLFFBQVE3Z0MsU0FBUyxDQUFBO01BQ3ZCMitCLFFBQVFrQyxRQUFRbEMsTUFBQUE7TUFDaEJFLFNBQVNnQyxRQUFRaEMsT0FBQUE7TUFDakJxQjtNQUNBQztJQUNGO0VBQ0Y7RUFPQWp0QixpQkFBaUJ6TSxPQUFPO0FBQ3RCLFdBQU9BO0VBQ1Q7RUFTQW1SLGlCQUFpQm5SLE9BQU9nQyxRQUFPO0FBQzdCLFdBQU8rSjtFQUNUO0VBUUEySyxpQkFBaUI0akIsT0FBTztFQUFBO0VBUXhCanBCLGdCQUFnQnJQLFFBQU87QUFDckIsVUFBTW9QLFFBQVEsS0FBS0E7QUFDbkIsUUFBSXBQLFNBQVEsS0FBS0EsU0FBUW9QLE1BQU03WCxTQUFTLEdBQUc7QUFDekMsYUFBTzs7QUFFVCxXQUFPLEtBQUs0WCxpQkFBaUJDLE1BQU1wUCxNQUFBQSxFQUFPaEMsS0FBSztFQUNqRDtFQVFBd1csbUJBQW1CK2pCLFNBQVM7QUFDMUIsUUFBSSxLQUFLdFksZ0JBQWdCO0FBQ3ZCc1ksZ0JBQVUsSUFBSUE7O0FBR2hCLFVBQU1ELFFBQVEsS0FBS3JrQixjQUFjc2tCLFVBQVUsS0FBS3hwQjtBQUNoRCxXQUFPeXBCLFlBQVksS0FBS3ZELGlCQUFpQndELFlBQVksS0FBSzNpQyxPQUFPd2lDLE9BQU8sQ0FBQSxJQUFLQSxLQUFLO0VBQ3BGO0VBTUFJLG1CQUFtQkosT0FBTztBQUN4QixVQUFNQyxXQUFXRCxRQUFRLEtBQUtya0IsZUFBZSxLQUFLbEY7QUFDbEQsV0FBTyxLQUFLa1IsaUJBQWlCLElBQUlzWSxVQUFVQTtFQUM3QztFQU9BbG1CLGVBQWU7QUFDYixXQUFPLEtBQUtsRCxpQkFBaUIsS0FBS3dwQixhQUFZLENBQUE7RUFDaEQ7RUFLQUEsZUFBZTtBQUNiLFVBQU0sRUFBQ2hpQyxLQUFLbUMsSUFBRyxJQUFJO0FBRW5CLFdBQU9uQyxNQUFNLEtBQUttQyxNQUFNLElBQUlBLE1BQzFCbkMsTUFBTSxLQUFLbUMsTUFBTSxJQUFJbkMsTUFDckI7RUFDSjtFQUtBOFIsV0FBV3pJLFFBQU87QUFDaEIsVUFBTW9QLFFBQVEsS0FBS0EsU0FBUyxDQUFBO0FBRTVCLFFBQUlwUCxVQUFTLEtBQUtBLFNBQVFvUCxNQUFNN1gsUUFBUTtBQUN0QyxZQUFNTSxPQUFPdVgsTUFBTXBQLE1BQU07QUFDekIsYUFBT25JLEtBQUs0TixhQUNiNU4sS0FBSzROLFdBQVd5ckIsa0JBQWtCLEtBQUt6b0IsV0FBVSxHQUFJekksUUFBT25JLElBQUk7O0FBRWpFLFdBQU8sS0FBSzROLGFBQ1osS0FBS0EsV0FBV3dyQixtQkFBbUIsS0FBS243QixNQUFNMlMsV0FBVSxHQUFJLElBQUk7RUFDbEU7RUFNQW1tQixZQUFZO0FBQ1YsVUFBTWdLLGNBQWMsS0FBS3Q3QixRQUFROFI7QUFHakMsVUFBTXlwQixNQUFNM2dCLFVBQVUsS0FBSzhaLGFBQWE7QUFDeEMsVUFBTWxiLE1BQU1wZ0IsS0FBS3dZLElBQUl4WSxLQUFLb2dCLElBQUkraEIsR0FBQUEsQ0FBQUE7QUFDOUIsVUFBTTdoQixNQUFNdGdCLEtBQUt3WSxJQUFJeFksS0FBS3NnQixJQUFJNmhCLEdBQUFBLENBQUFBO0FBRTlCLFVBQU05QyxhQUFhLEtBQUtDLGVBQWM7QUFDdEMsVUFBTWhQLFVBQVU0UixZQUFZRSxtQkFBbUI7QUFDL0MsVUFBTWpULElBQUlrUSxhQUFhQSxXQUFXRyxPQUFPcGpCLFFBQVFrVSxVQUFVO0FBQzNELFVBQU1qQixJQUFJZ1EsYUFBYUEsV0FBV0ssUUFBUXZqQixTQUFTbVUsVUFBVTtBQUc3RCxXQUFPLEtBQUsvVixhQUFZLElBQ3BCOFUsSUFBSWpQLE1BQU0rTyxJQUFJN08sTUFBTTZPLElBQUkvTyxNQUFNaVAsSUFBSS9PLE1BQ2xDK08sSUFBSS9PLE1BQU02TyxJQUFJL08sTUFBTWlQLElBQUlqUCxNQUFNK08sSUFBSTdPO0VBQ3hDO0VBTUE4ZSxhQUFhO0FBQ1gsVUFBTTFYLFVBQVUsS0FBSzlnQixRQUFROGdCO0FBRTdCLFFBQUlBLFlBQVksUUFBUTtBQUN0QixhQUFPLENBQUMsQ0FBQ0E7O0FBR1gsV0FBTyxLQUFLNWIsd0JBQXVCLEVBQUdqTCxTQUFTO0VBQ2pEO0VBS0F3aEMsc0JBQXNCanVCLFdBQVc7QUFDL0IsVUFBTTdKLE9BQU8sS0FBS0E7QUFDbEIsVUFBTW5MLFFBQVEsS0FBS0E7QUFDbkIsVUFBTXdILFdBQVUsS0FBS0E7QUFDckIsVUFBTSxFQUFDa1ksTUFBTXNMLFVBQVU5RCxPQUFBQSxJQUFVMWY7QUFDakMsVUFBTWlZLFNBQVNDLEtBQUtEO0FBQ3BCLFVBQU10RSxlQUFlLEtBQUtBLGFBQVk7QUFDdEMsVUFBTTdCLFFBQVEsS0FBS0E7QUFDbkIsVUFBTXdnQixjQUFjeGdCLE1BQU03WCxVQUFVZ2UsU0FBUyxJQUFJO0FBQ2pELFVBQU15akIsS0FBS3ZJLGtCQUFrQmpiLElBQUFBO0FBQzdCLFVBQU1sZSxRQUFRLENBQUE7QUFFZCxVQUFNMmhDLGFBQWFqYyxPQUFPNlYsV0FBVyxLQUFLcHFCLFdBQVUsQ0FBQTtBQUNwRCxVQUFNeXdCLFlBQVlELFdBQVc3YSxVQUFVNmEsV0FBV25tQixRQUFRO0FBQzFELFVBQU1xbUIsZ0JBQWdCRCxZQUFZO0FBQ2xDLFVBQU1FLG1CQUFtQixTQUFTZCxPQUFPO0FBQ3ZDLGFBQU9HLFlBQVkzaUMsT0FBT3dpQyxPQUFPWSxTQUFBQTtJQUNuQztBQUNBLFFBQUlHLGFBQWE3aEMsR0FBRzQ0QixXQUFXa0o7QUFDL0IsUUFBSUMsS0FBS0MsS0FBS0MsS0FBS0MsS0FBS0MsSUFBSUMsSUFBSUMsSUFBSUM7QUFFcEMsUUFBSWhaLGFBQWEsT0FBTztBQUN0QnVZLG9CQUFjRCxpQkFBaUIsS0FBS2o2QixNQUFNO0FBQzFDcTZCLFlBQU0sS0FBS3I2QixTQUFTNjVCO0FBQ3BCVSxZQUFNTCxjQUFjRjtBQUNwQlMsV0FBS1IsaUJBQWlCdHVCLFVBQVU3TCxHQUFHLElBQUlrNkI7QUFDdkNXLFdBQUtodkIsVUFBVTNMO2VBQ04yaEIsYUFBYSxVQUFVO0FBQ2hDdVksb0JBQWNELGlCQUFpQixLQUFLbjZCLEdBQUc7QUFDdkMyNkIsV0FBSzl1QixVQUFVN0w7QUFDZjY2QixXQUFLVixpQkFBaUJ0dUIsVUFBVTNMLE1BQU0sSUFBSWc2QjtBQUMxQ0ssWUFBTUgsY0FBY0Y7QUFDcEJPLFlBQU0sS0FBS3o2QixNQUFNKzVCO2VBQ1JsWSxhQUFhLFFBQVE7QUFDOUJ1WSxvQkFBY0QsaUJBQWlCLEtBQUtsNkIsS0FBSztBQUN6Q3E2QixZQUFNLEtBQUtyNkIsUUFBUTg1QjtBQUNuQlMsWUFBTUosY0FBY0Y7QUFDcEJRLFdBQUtQLGlCQUFpQnR1QixVQUFVMUwsSUFBSSxJQUFJKzVCO0FBQ3hDVSxXQUFLL3VCLFVBQVU1TDtlQUNONGhCLGFBQWEsU0FBUztBQUMvQnVZLG9CQUFjRCxpQkFBaUIsS0FBS2g2QixJQUFJO0FBQ3hDdTZCLFdBQUs3dUIsVUFBVTFMO0FBQ2Z5NkIsV0FBS1QsaUJBQWlCdHVCLFVBQVU1TCxLQUFLLElBQUlpNkI7QUFDekNJLFlBQU1GLGNBQWNGO0FBQ3BCTSxZQUFNLEtBQUtyNkIsT0FBTzQ1QjtlQUNULzNCLFNBQVMsS0FBSztBQUN2QixVQUFJNmYsYUFBYSxVQUFVO0FBQ3pCdVksc0JBQWNELGtCQUFrQnR1QixVQUFVN0wsTUFBTTZMLFVBQVUzTCxVQUFVLElBQUksR0FBQTtpQkFDL0Q1QyxTQUFTdWtCLFFBQVcsR0FBQTtBQUM3QixjQUFNMlEsaUJBQWlCaDFCLE9BQU9DLEtBQUtva0IsUUFBQUEsRUFBVSxDQUFFO0FBQy9DLGNBQU05aUIsUUFBUThpQixTQUFTMlEsY0FBZTtBQUN0QzRILHNCQUFjRCxpQkFBaUIsS0FBS3RqQyxNQUFNd04sT0FBT211QixjQUFBQSxFQUFnQnRpQixpQkFBaUJuUixLQUFBQSxDQUFBQTs7QUFHcEY0N0IsV0FBSzl1QixVQUFVN0w7QUFDZjY2QixXQUFLaHZCLFVBQVUzTDtBQUNmcTZCLFlBQU1ILGNBQWNGO0FBQ3BCTyxZQUFNRixNQUFNUjtlQUNILzNCLFNBQVMsS0FBSztBQUN2QixVQUFJNmYsYUFBYSxVQUFVO0FBQ3pCdVksc0JBQWNELGtCQUFrQnR1QixVQUFVMUwsT0FBTzBMLFVBQVU1TCxTQUFTLENBQUE7aUJBQzNEM0MsU0FBU3VrQixRQUFXLEdBQUE7QUFDN0IsY0FBTTJRLGlCQUFpQmgxQixPQUFPQyxLQUFLb2tCLFFBQUFBLEVBQVUsQ0FBRTtBQUMvQyxjQUFNOWlCLFFBQVE4aUIsU0FBUzJRLGNBQWU7QUFDdEM0SCxzQkFBY0QsaUJBQWlCLEtBQUt0akMsTUFBTXdOLE9BQU9tdUIsY0FBQUEsRUFBZ0J0aUIsaUJBQWlCblIsS0FBQUEsQ0FBQUE7O0FBR3BGdTdCLFlBQU1GLGNBQWNGO0FBQ3BCTSxZQUFNRixNQUFNUDtBQUNaVyxXQUFLN3VCLFVBQVUxTDtBQUNmeTZCLFdBQUsvdUIsVUFBVTVMOztBQUdqQixVQUFNNjZCLFFBQVF0ekIsZUFBZW5KLFNBQVE4UixNQUFNMmUsZUFBZTZCLFdBQUFBO0FBQzFELFVBQU1vSyxPQUFPdGpDLEtBQUtvQyxJQUFJLEdBQUdwQyxLQUFLMDRCLEtBQUtRLGNBQWNtSyxLQUFBQSxDQUFBQTtBQUNqRCxTQUFLdmlDLElBQUksR0FBR0EsSUFBSW80QixhQUFhcDRCLEtBQUt3aUMsTUFBTTtBQUN0QyxZQUFNN3VCLFVBQVUsS0FBSzFDLFdBQVdqUixDQUFBQTtBQUNoQyxZQUFNeWlDLGNBQWN6a0IsS0FBS3FkLFdBQVcxbkIsT0FBQUE7QUFDcEMsWUFBTSt1QixvQkFBb0JsZCxPQUFPNlYsV0FBVzFuQixPQUFBQTtBQUU1QyxZQUFNc1EsWUFBWXdlLFlBQVl4ZTtBQUM5QixZQUFNMGUsWUFBWUYsWUFBWXZnQztBQUM5QixZQUFNMGdDLGFBQWFGLGtCQUFrQkcsUUFBUSxDQUFBO0FBQzdDLFlBQU1DLG1CQUFtQkosa0JBQWtCSztBQUUzQyxZQUFNM0UsWUFBWXFFLFlBQVlyRTtBQUM5QixZQUFNNEUsWUFBWVAsWUFBWU87QUFDOUIsWUFBTUMsaUJBQWlCUixZQUFZUSxrQkFBa0IsQ0FBQTtBQUNyRCxZQUFNQyx1QkFBdUJULFlBQVlTO0FBRXpDdEssa0JBQVlKLG9CQUFvQixNQUFNeDRCLEdBQUcrZCxNQUFBQTtBQUd6QyxVQUFJNmEsY0FBY3g2QixRQUFXO0FBQzNCOztBQUdGMGpDLHlCQUFtQmIsWUFBWTNpQyxPQUFPczZCLFdBQVczVSxTQUFBQTtBQUVqRCxVQUFJeEssY0FBYztBQUNoQnNvQixjQUFNRSxNQUFNRSxLQUFLRSxLQUFLUDthQUNqQjtBQUNMRSxjQUFNRSxNQUFNRSxLQUFLRSxLQUFLUjs7QUFHeEJoaUMsWUFBTWtCLEtBQUs7UUFDVCtnQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBQztRQUNBaG5CLE9BQU8ySTtRQUNQL2hCLE9BQU95Z0M7UUFDUEM7UUFDQUU7UUFDQTFFO1FBQ0E0RTtRQUNBQztRQUNBQztNQUNGLENBQUE7SUFDRjtBQUVBLFNBQUtoSSxlQUFlOUM7QUFDcEIsU0FBSytDLGVBQWUwRztBQUVwQixXQUFPL2hDO0VBQ1Q7RUFLQWc4QixtQkFBbUJ4b0IsV0FBVztBQUM1QixVQUFNN0osT0FBTyxLQUFLQTtBQUNsQixVQUFNM0QsV0FBVSxLQUFLQTtBQUNyQixVQUFNLEVBQUN3akIsVUFBVTFSLE9BQU93cEIsWUFBQUEsSUFBZXQ3QjtBQUN2QyxVQUFNMlQsZUFBZSxLQUFLQSxhQUFZO0FBQ3RDLFVBQU03QixRQUFRLEtBQUtBO0FBQ25CLFVBQU0sRUFBQ3FnQixPQUFPa0wsWUFBWTNULFNBQVMrUCxPQUFNLElBQUk2QjtBQUM3QyxVQUFNSSxLQUFLdkksa0JBQWtCbnpCLFNBQVFrWSxJQUFJO0FBQ3pDLFVBQU1vbEIsaUJBQWlCNUIsS0FBS2hTO0FBQzVCLFVBQU02VCxrQkFBa0I5RCxTQUFTLENBQUMvUCxVQUFVNFQ7QUFDNUMsVUFBTXprQixXQUFXLENBQUMrQixVQUFVLEtBQUs4WixhQUFhO0FBQzlDLFVBQU0xNkIsUUFBUSxDQUFBO0FBQ2QsUUFBSUUsR0FBR3VJLE1BQU1sSSxNQUFNMlMsT0FBT3pMLEdBQUdDLEdBQUc4N0IsV0FBV3hDLE9BQU96SCxNQUFNRyxZQUFZK0osV0FBV0M7QUFDL0UsUUFBSUMsZUFBZTtBQUVuQixRQUFJbmEsYUFBYSxPQUFPO0FBQ3RCOWhCLFVBQUksS0FBS0csU0FBUzA3QjtBQUNsQkMsa0JBQVksS0FBS0ksd0JBQXVCO2VBQy9CcGEsYUFBYSxVQUFVO0FBQ2hDOWhCLFVBQUksS0FBS0MsTUFBTTQ3QjtBQUNmQyxrQkFBWSxLQUFLSSx3QkFBdUI7ZUFDL0JwYSxhQUFhLFFBQVE7QUFDOUIsWUFBTTBNLE1BQU0sS0FBSzJOLHdCQUF3Qm5DLEVBQUFBO0FBQ3pDOEIsa0JBQVl0TixJQUFJc047QUFDaEIvN0IsVUFBSXl1QixJQUFJenVCO2VBQ0MraEIsYUFBYSxTQUFTO0FBQy9CLFlBQU0wTSxNQUFNLEtBQUsyTix3QkFBd0JuQyxFQUFBQTtBQUN6QzhCLGtCQUFZdE4sSUFBSXNOO0FBQ2hCLzdCLFVBQUl5dUIsSUFBSXp1QjtlQUNDa0MsU0FBUyxLQUFLO0FBQ3ZCLFVBQUk2ZixhQUFhLFVBQVU7QUFDekI5aEIsYUFBTThMLFVBQVU3TCxNQUFNNkwsVUFBVTNMLFVBQVUsSUFBS3k3QjtpQkFDdENyK0IsU0FBU3VrQixRQUFXLEdBQUE7QUFDN0IsY0FBTTJRLGlCQUFpQmgxQixPQUFPQyxLQUFLb2tCLFFBQUFBLEVBQVUsQ0FBRTtBQUMvQyxjQUFNOWlCLFFBQVE4aUIsU0FBUzJRLGNBQWU7QUFDdEN6eUIsWUFBSSxLQUFLbEosTUFBTXdOLE9BQU9tdUIsY0FBZSxFQUFDdGlCLGlCQUFpQm5SLEtBQVM0OEIsSUFBQUE7O0FBRWxFRSxrQkFBWSxLQUFLSSx3QkFBdUI7ZUFDL0JqNkIsU0FBUyxLQUFLO0FBQ3ZCLFVBQUk2ZixhQUFhLFVBQVU7QUFDekIvaEIsYUFBTStMLFVBQVUxTCxPQUFPMEwsVUFBVTVMLFNBQVMsSUFBSzA3QjtpQkFDdENyK0IsU0FBU3VrQixRQUFXLEdBQUE7QUFDN0IsY0FBTTJRLGlCQUFpQmgxQixPQUFPQyxLQUFLb2tCLFFBQUFBLEVBQVUsQ0FBRTtBQUMvQyxjQUFNOWlCLFFBQVE4aUIsU0FBUzJRLGNBQWU7QUFDdEMxeUIsWUFBSSxLQUFLakosTUFBTXdOLE9BQU9tdUIsY0FBQUEsRUFBZ0J0aUIsaUJBQWlCblIsS0FBQUE7O0FBRXpEODhCLGtCQUFZLEtBQUtLLHdCQUF3Qm5DLEVBQUFBLEVBQUk4Qjs7QUFHL0MsUUFBSTc1QixTQUFTLEtBQUs7QUFDaEIsVUFBSXd1QixVQUFVLFNBQVM7QUFDckJ3TCx1QkFBZTtpQkFDTnhMLFVBQVUsT0FBTztBQUMxQndMLHVCQUFlOzs7QUFJbkIsVUFBTWxGLGFBQWEsS0FBS0MsZUFBYztBQUN0QyxTQUFLeCtCLElBQUksR0FBR3VJLE9BQU9xUCxNQUFNN1gsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDOUNLLGFBQU91WCxNQUFNNVgsQ0FBRTtBQUNmZ1QsY0FBUTNTLEtBQUsyUztBQUViLFlBQU15dkIsY0FBY3JCLFlBQVkvRixXQUFXLEtBQUtwcUIsV0FBV2pSLENBQUFBLENBQUFBO0FBQzNEOGdDLGNBQVEsS0FBS2pwQixnQkFBZ0I3WCxDQUFBQSxJQUFLb2hDLFlBQVl3QztBQUM5Q3ZLLGFBQU8sS0FBS29ILHdCQUF3QnpnQyxDQUFBQTtBQUNwQ3c1QixtQkFBYUgsS0FBS0c7QUFDbEIrSixrQkFBWTk5QixRQUFRdU4sS0FBQUEsSUFBU0EsTUFBTWpULFNBQVM7QUFDNUMsWUFBTThqQyxZQUFZTixZQUFZO0FBQzlCLFlBQU1yaEMsU0FBUXVnQyxZQUFZdmdDO0FBQzFCLFlBQU00aEMsY0FBY3JCLFlBQVlzQjtBQUNoQyxZQUFNQyxjQUFjdkIsWUFBWXdCO0FBQ2hDLFVBQUlDLGdCQUFnQlo7QUFFcEIsVUFBSTdwQixjQUFjO0FBQ2hCbFMsWUFBSXU1QjtBQUVKLFlBQUl3QyxjQUFjLFNBQVM7QUFDekIsY0FBSXRqQyxNQUFNdUksT0FBTyxHQUFHO0FBQ2xCMjdCLDRCQUFnQixDQUFDLEtBQUtwK0IsUUFBUW9CLFVBQVUsVUFBVTtxQkFDekNsSCxNQUFNLEdBQUc7QUFDbEJra0MsNEJBQWdCLENBQUMsS0FBS3ArQixRQUFRb0IsVUFBVSxTQUFTO2lCQUM1QztBQUNMZzlCLDRCQUFnQjs7O0FBSXBCLFlBQUk1YSxhQUFhLE9BQU87QUFDdEIsY0FBSTZaLGVBQWUsVUFBVXhrQixhQUFhLEdBQUc7QUFDM0M2a0IseUJBQWEsQ0FBQ0QsWUFBWS9KLGFBQWFBLGFBQWE7cUJBQzNDMkosZUFBZSxVQUFVO0FBQ2xDSyx5QkFBYSxDQUFDakYsV0FBV0ssUUFBUXZqQixTQUFTLElBQUl3b0IsWUFBWXJLLGFBQWFBO2lCQUNsRTtBQUNMZ0sseUJBQWEsQ0FBQ2pGLFdBQVdLLFFBQVF2akIsU0FBU21lLGFBQWE7O2VBRXBEO0FBRUwsY0FBSTJKLGVBQWUsVUFBVXhrQixhQUFhLEdBQUc7QUFDM0M2a0IseUJBQWFoSyxhQUFhO3FCQUNqQjJKLGVBQWUsVUFBVTtBQUNsQ0sseUJBQWFqRixXQUFXSyxRQUFRdmpCLFNBQVMsSUFBSXdvQixZQUFZcks7aUJBQ3BEO0FBQ0xnSyx5QkFBYWpGLFdBQVdLLFFBQVF2akIsU0FBU2tvQixZQUFZL0o7OztBQUd6RCxZQUFJK0YsUUFBUTtBQUNWaUUsd0JBQWM7O0FBRWhCLFlBQUk3a0IsYUFBYSxLQUFLLENBQUM4akIsWUFBWTBCLG1CQUFtQjtBQUNwRDU4QixlQUFLLGFBQWMsSUFBS3JJLEtBQUtzZ0IsSUFBSWIsUUFBQUE7O2FBRTlCO0FBQ0xuWCxZQUFJczVCO0FBQ0owQyxzQkFBYyxJQUFJRCxhQUFhL0osYUFBYTs7QUFHOUMsVUFBSTRLO0FBRUosVUFBSTNCLFlBQVkwQixtQkFBbUI7QUFDakMsY0FBTUUsZUFBZXRVLFVBQVUwUyxZQUFZNkIsZUFBZTtBQUMxRCxjQUFNanBCLFNBQVNrakIsV0FBVzJCLFFBQVFsZ0MsQ0FBRTtBQUNwQyxjQUFNc2IsUUFBUWlqQixXQUFXMEIsT0FBT2pnQyxDQUFFO0FBRWxDLFlBQUl5SCxNQUFNKzdCLGFBQWFhLGFBQWE1OEI7QUFDcEMsWUFBSUcsT0FBTyxJQUFJeThCLGFBQWF6OEI7QUFFNUIsZ0JBQVE2N0IsY0FBQUE7VUFDUixLQUFLO0FBQ0hoOEIsbUJBQU80VCxTQUFTO0FBQ2hCO1VBQ0YsS0FBSztBQUNINVQsbUJBQU80VDtBQUNQO1FBR0Y7QUFFQSxnQkFBUWlvQixXQUFBQTtVQUNSLEtBQUs7QUFDSDE3QixvQkFBUTBULFFBQVE7QUFDaEI7VUFDRixLQUFLO0FBQ0gxVCxvQkFBUTBUO0FBQ1I7VUFDRixLQUFLO0FBQ0gsZ0JBQUl0YixNQUFNdUksT0FBTyxHQUFHO0FBQ2xCWCxzQkFBUTBUO3VCQUNDdGIsSUFBSSxHQUFHO0FBQ2hCNEgsc0JBQVEwVCxRQUFROztBQUVsQjtRQUdGO0FBRUE4b0IsbUJBQVc7VUFDVHg4QjtVQUNBSDtVQUNBNlQsT0FBT0EsUUFBUStvQixhQUFhL29CO1VBQzVCRCxRQUFRQSxTQUFTZ3BCLGFBQWFocEI7VUFFOUJuWixPQUFPdWdDLFlBQVk4QjtRQUNyQjs7QUFHRnprQyxZQUFNa0IsS0FBSztRQUNUZ1M7UUFDQXFtQjtRQUNBbUs7UUFDQTE5QixTQUFTO1VBQ1A2WTtVQUNBemMsT0FBQUE7VUFDQTRoQztVQUNBRTtVQUNBVixXQUFXWTtVQUNYVDtVQUNBZSxhQUFhO1lBQUNqOUI7WUFBR0M7VUFBRTtVQUNuQjQ4QjtRQUNGO01BQ0YsQ0FBQTtJQUNGO0FBRUEsV0FBT3RrQztFQUNUO0VBRUE0akMsMEJBQTBCO0FBQ3hCLFVBQU0sRUFBQ3BhLFVBQVUxUixNQUFBQSxJQUFTLEtBQUs5UjtBQUMvQixVQUFNNlksV0FBVyxDQUFDK0IsVUFBVSxLQUFLOFosYUFBYTtBQUU5QyxRQUFJN2IsVUFBVTtBQUNaLGFBQU8ySyxhQUFhLFFBQVEsU0FBUzs7QUFHdkMsUUFBSTJPLFFBQVE7QUFFWixRQUFJcmdCLE1BQU1xZ0IsVUFBVSxTQUFTO0FBQzNCQSxjQUFRO0lBQ1YsV0FBV3JnQixNQUFNcWdCLFVBQVUsT0FBTztBQUNoQ0EsY0FBUTtJQUNWLFdBQVdyZ0IsTUFBTXFnQixVQUFVLFNBQVM7QUFDbENBLGNBQVE7O0FBR1YsV0FBT0E7RUFDVDtFQUVBMEwsd0JBQXdCbkMsSUFBSTtBQUMxQixVQUFNLEVBQUNsWSxVQUFVMVIsT0FBTyxFQUFDdXJCLFlBQVk1RCxRQUFRL1AsUUFBQUEsRUFBUSxJQUFJLEtBQUsxcEI7QUFDOUQsVUFBTXk0QixhQUFhLEtBQUtDLGVBQWM7QUFDdEMsVUFBTTRFLGlCQUFpQjVCLEtBQUtoUztBQUM1QixVQUFNa1AsU0FBU0gsV0FBV0csT0FBT3BqQjtBQUVqQyxRQUFJZ29CO0FBQ0osUUFBSS83QjtBQUVKLFFBQUkraEIsYUFBYSxRQUFRO0FBQ3ZCLFVBQUlpVyxRQUFRO0FBQ1ZoNEIsWUFBSSxLQUFLRyxRQUFROG5CO0FBRWpCLFlBQUkyVCxlQUFlLFFBQVE7QUFDekJHLHNCQUFZO21CQUNISCxlQUFlLFVBQVU7QUFDbENHLHNCQUFZO0FBQ1ovN0IsZUFBTW0zQixTQUFTO2VBQ1Y7QUFDTDRFLHNCQUFZO0FBQ1ovN0IsZUFBS20zQjs7YUFFRjtBQUNMbjNCLFlBQUksS0FBS0csUUFBUTA3QjtBQUVqQixZQUFJRCxlQUFlLFFBQVE7QUFDekJHLHNCQUFZO21CQUNISCxlQUFlLFVBQVU7QUFDbENHLHNCQUFZO0FBQ1ovN0IsZUFBTW0zQixTQUFTO2VBQ1Y7QUFDTDRFLHNCQUFZO0FBQ1ovN0IsY0FBSSxLQUFLSzs7O2VBR0owaEIsYUFBYSxTQUFTO0FBQy9CLFVBQUlpVyxRQUFRO0FBQ1ZoNEIsWUFBSSxLQUFLSyxPQUFPNG5CO0FBRWhCLFlBQUkyVCxlQUFlLFFBQVE7QUFDekJHLHNCQUFZO21CQUNISCxlQUFlLFVBQVU7QUFDbENHLHNCQUFZO0FBQ1ovN0IsZUFBTW0zQixTQUFTO2VBQ1Y7QUFDTDRFLHNCQUFZO0FBQ1ovN0IsZUFBS20zQjs7YUFFRjtBQUNMbjNCLFlBQUksS0FBS0ssT0FBT3c3QjtBQUVoQixZQUFJRCxlQUFlLFFBQVE7QUFDekJHLHNCQUFZO21CQUNISCxlQUFlLFVBQVU7QUFDbENHLHNCQUFZO0FBQ1ovN0IsZUFBS20zQixTQUFTO2VBQ1Q7QUFDTDRFLHNCQUFZO0FBQ1ovN0IsY0FBSSxLQUFLRzs7O1dBR1I7QUFDTDQ3QixrQkFBWTs7QUFHZCxXQUFPO01BQUNBO01BQVcvN0I7SUFBQztFQUN0QjtFQUtBazlCLG9CQUFvQjtBQUNsQixRQUFJLEtBQUszK0IsUUFBUThSLE1BQU0ybkIsUUFBUTtBQUM3Qjs7QUFHRixVQUFNamhDLFFBQVEsS0FBS0E7QUFDbkIsVUFBTWdyQixXQUFXLEtBQUt4akIsUUFBUXdqQjtBQUU5QixRQUFJQSxhQUFhLFVBQVVBLGFBQWEsU0FBUztBQUMvQyxhQUFPO1FBQUM3aEIsS0FBSztRQUFHRyxNQUFNLEtBQUtBO1FBQU1ELFFBQVFySixNQUFNK2M7UUFBUTNULE9BQU8sS0FBS0E7TUFBSzs7QUFDeEUsUUFBSTRoQixhQUFhLFNBQVNBLGFBQWEsVUFBVTtBQUNqRCxhQUFPO1FBQUM3aEIsS0FBSyxLQUFLQTtRQUFLRyxNQUFNO1FBQUdELFFBQVEsS0FBS0E7UUFBUUQsT0FBT3BKLE1BQU1nZDtNQUFLOztFQUUzRTtFQUtBb3BCLGlCQUFpQjtBQUNmLFVBQU0sRUFBQ3IzQixLQUFLdkgsU0FBUyxFQUFDK2QsZ0JBQUFBLEdBQWtCamMsTUFBTUgsS0FBSzZULE9BQU9ELE9BQU0sSUFBSTtBQUNwRSxRQUFJd0ksaUJBQWlCO0FBQ25CeFcsVUFBSXMzQixLQUFJO0FBQ1J0M0IsVUFBSXVXLFlBQVlDO0FBQ2hCeFcsVUFBSXUzQixTQUFTaDlCLE1BQU1ILEtBQUs2VCxPQUFPRCxNQUFBQTtBQUMvQmhPLFVBQUl3M0IsUUFBTzs7RUFFZjtFQUVBem5CLHFCQUFxQjVXLE9BQU87QUFDMUIsVUFBTXdYLE9BQU8sS0FBS2xZLFFBQVFrWTtBQUMxQixRQUFJLENBQUMsS0FBS3NnQixXQUFVLEtBQU0sQ0FBQ3RnQixLQUFLNEksU0FBUztBQUN2QyxhQUFPOztBQUVULFVBQU1oUCxRQUFRLEtBQUtBO0FBQ25CLFVBQU1wUCxTQUFRb1AsTUFBTW9SLFVBQVVsaEIsQ0FBQUEsTUFBS0EsRUFBRXRCLFVBQVVBLEtBQUFBO0FBQy9DLFFBQUlnQyxVQUFTLEdBQUc7QUFDZCxZQUFNdkIsT0FBTytXLEtBQUtxZCxXQUFXLEtBQUtwcUIsV0FBV3pJLE1BQUFBLENBQUFBO0FBQzdDLGFBQU92QixLQUFLZ2Q7O0FBRWQsV0FBTztFQUNUO0VBS0E2Z0IsU0FBU3h4QixXQUFXO0FBQ2xCLFVBQU0wSyxPQUFPLEtBQUtsWSxRQUFRa1k7QUFDMUIsVUFBTTNRLE1BQU0sS0FBS0E7QUFDakIsVUFBTXZOLFFBQVEsS0FBSzQ2QixtQkFBbUIsS0FBS0EsaUJBQWlCLEtBQUs2RyxzQkFBc0JqdUIsU0FBUztBQUNoRyxRQUFJdFQsR0FBR3VJO0FBRVAsVUFBTXc4QixXQUFXLENBQUNDLElBQUlDLElBQUl2aEIsVUFBVTtBQUNsQyxVQUFJLENBQUNBLE1BQU1wSSxTQUFTLENBQUNvSSxNQUFNeGhCLE9BQU87QUFDaEM7O0FBRUZtTCxVQUFJczNCLEtBQUk7QUFDUnQzQixVQUFJNFcsWUFBWVAsTUFBTXBJO0FBQ3RCak8sVUFBSXlXLGNBQWNKLE1BQU14aEI7QUFDeEJtTCxVQUFJNjNCLFlBQVl4aEIsTUFBTWtmLGNBQWMsQ0FBQSxDQUFFO0FBQ3RDdjFCLFVBQUk4M0IsaUJBQWlCemhCLE1BQU1vZjtBQUUzQnoxQixVQUFJKzNCLFVBQVM7QUFDYi8zQixVQUFJZzRCLE9BQU9MLEdBQUd6OUIsR0FBR3k5QixHQUFHeDlCLENBQUM7QUFDckI2RixVQUFJaTRCLE9BQU9MLEdBQUcxOUIsR0FBRzA5QixHQUFHejlCLENBQUM7QUFDckI2RixVQUFJazRCLE9BQU07QUFDVmw0QixVQUFJdzNCLFFBQU87SUFDYjtBQUVBLFFBQUk3bUIsS0FBSzRJLFNBQVM7QUFDaEIsV0FBSzVtQixJQUFJLEdBQUd1SSxPQUFPekksTUFBTUMsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDOUMsY0FBTUUsT0FBT0osTUFBTUUsQ0FBRTtBQUVyQixZQUFJZ2UsS0FBS3duQixpQkFBaUI7QUFDeEJULG1CQUNFO1lBQUN4OUIsR0FBR3JILEtBQUtpaUM7WUFBSTM2QixHQUFHdEgsS0FBS2tpQzthQUNyQjtZQUFDNzZCLEdBQUdySCxLQUFLbWlDO1lBQUk3NkIsR0FBR3RILEtBQUtvaUM7YUFDckJwaUMsSUFBQUE7O0FBSUosWUFBSThkLEtBQUtrYixXQUFXO0FBQ2xCNkwsbUJBQ0U7WUFBQ3g5QixHQUFHckgsS0FBSzZoQztZQUFLdjZCLEdBQUd0SCxLQUFLOGhDO2FBQ3RCO1lBQUN6NkIsR0FBR3JILEtBQUsraEM7WUFBS3o2QixHQUFHdEgsS0FBS2dpQzthQUN0QjtZQUNFaGdDLE9BQU9oQyxLQUFLOGlDO1lBQ1oxbkIsT0FBT3BiLEtBQUtrK0I7WUFDWndFLFlBQVkxaUMsS0FBSytpQztZQUNqQkgsa0JBQWtCNWlDLEtBQUtnakM7VUFDekIsQ0FBQTs7TUFHTjs7RUFFSjtFQUtBdUMsYUFBYTtBQUNYLFVBQU0sRUFBQ25uQyxPQUFPK08sS0FBS3ZILFNBQVMsRUFBQzBmLFFBQVF4SCxLQUFJLEVBQUMsSUFBSTtBQUM5QyxVQUFNeWpCLGFBQWFqYyxPQUFPNlYsV0FBVyxLQUFLcHFCLFdBQVUsQ0FBQTtBQUNwRCxVQUFNeXdCLFlBQVlsYyxPQUFPb0IsVUFBVTZhLFdBQVdubUIsUUFBUTtBQUN0RCxRQUFJLENBQUNvbUIsV0FBVztBQUNkOztBQUVGLFVBQU1nRSxnQkFBZ0IxbkIsS0FBS3FkLFdBQVcsS0FBS3BxQixXQUFXLENBQUEsQ0FBQSxFQUFJZ1Q7QUFDMUQsVUFBTTRkLGNBQWMsS0FBSzFHO0FBQ3pCLFFBQUlnSCxJQUFJRSxJQUFJRCxJQUFJRTtBQUVoQixRQUFJLEtBQUs3b0IsYUFBWSxHQUFJO0FBQ3ZCMG9CLFdBQUtsQixZQUFZM2lDLE9BQU8sS0FBS3NKLE1BQU04NUIsU0FBQUEsSUFBYUEsWUFBWTtBQUM1RFcsV0FBS3BCLFlBQVkzaUMsT0FBTyxLQUFLb0osT0FBT2crQixhQUFBQSxJQUFpQkEsZ0JBQWdCO0FBQ3JFdEQsV0FBS0UsS0FBS1Q7V0FDTDtBQUNMTyxXQUFLbkIsWUFBWTNpQyxPQUFPLEtBQUttSixLQUFLaTZCLFNBQUFBLElBQWFBLFlBQVk7QUFDM0RZLFdBQUtyQixZQUFZM2lDLE9BQU8sS0FBS3FKLFFBQVErOUIsYUFBQUEsSUFBaUJBLGdCQUFnQjtBQUN0RXZELFdBQUtFLEtBQUtSOztBQUVaeDBCLFFBQUlzM0IsS0FBSTtBQUNSdDNCLFFBQUk0VyxZQUFZd2QsV0FBV25tQjtBQUMzQmpPLFFBQUl5VyxjQUFjMmQsV0FBV3YvQjtBQUU3Qm1MLFFBQUkrM0IsVUFBUztBQUNiLzNCLFFBQUlnNEIsT0FBT2xELElBQUlDLEVBQUFBO0FBQ2YvMEIsUUFBSWk0QixPQUFPakQsSUFBSUMsRUFBQUE7QUFDZmoxQixRQUFJazRCLE9BQU07QUFFVmw0QixRQUFJdzNCLFFBQU87RUFDYjtFQUtBYyxXQUFXcnlCLFdBQVc7QUFDcEIsVUFBTTh0QixjQUFjLEtBQUt0N0IsUUFBUThSO0FBRWpDLFFBQUksQ0FBQ3dwQixZQUFZeGEsU0FBUztBQUN4Qjs7QUFHRixVQUFNdlosTUFBTSxLQUFLQTtBQUVqQixVQUFNZ0csT0FBTyxLQUFLb3hCLGtCQUFpQjtBQUNuQyxRQUFJcHhCLE1BQU07QUFDUnV5QixlQUFTdjRCLEtBQUtnRyxJQUFBQTs7QUFHaEIsVUFBTXZULFFBQVEsS0FBSys3QixjQUFjdm9CLFNBQUFBO0FBQ2pDLGVBQVdwVCxRQUFRSixPQUFPO0FBQ3hCLFlBQU0rbEMsb0JBQW9CM2xDLEtBQUs0RjtBQUMvQixZQUFNdzZCLFdBQVdwZ0MsS0FBS201QjtBQUN0QixZQUFNcm1CLFFBQVE5UyxLQUFLOFM7QUFDbkIsWUFBTXhMLElBQUl0SCxLQUFLc2pDO0FBQ2ZzQyxpQkFBV3o0QixLQUFLMkYsT0FBTyxHQUFHeEwsR0FBRzg0QixVQUFVdUYsaUJBQUFBO0lBQ3pDO0FBRUEsUUFBSXh5QixNQUFNO0FBQ1IweUIsaUJBQVcxNEIsR0FBQUE7O0VBRWY7RUFLQTI0QixZQUFZO0FBQ1YsVUFBTSxFQUFDMzRCLEtBQUt2SCxTQUFTLEVBQUN3akIsVUFBVXdWLE9BQU81M0IsUUFBTyxFQUFDLElBQUk7QUFFbkQsUUFBSSxDQUFDNDNCLE1BQU1sWSxTQUFTO0FBQ2xCOztBQUdGLFVBQU15UyxPQUFPQyxPQUFPd0YsTUFBTXpGLElBQUk7QUFDOUIsVUFBTTdKLFVBQVVPLFVBQVUrTyxNQUFNdFAsT0FBTztBQUN2QyxVQUFNeUksUUFBUTZHLE1BQU03RztBQUNwQixRQUFJbGEsU0FBU3NiLEtBQUtHLGFBQWE7QUFFL0IsUUFBSWxRLGFBQWEsWUFBWUEsYUFBYSxZQUFZdmtCLFNBQVN1a0IsUUFBVyxHQUFBO0FBQ3hFdkwsZ0JBQVV5UixRQUFRN25CO0FBQ2xCLFVBQUlsQyxRQUFRcTVCLE1BQU1uYixJQUFJLEdBQUc7QUFDdkI1RixrQkFBVXNiLEtBQUtHLGNBQWNzRixNQUFNbmIsS0FBSzVqQixTQUFTOztXQUU5QztBQUNMZ2UsZ0JBQVV5UixRQUFRL25COztBQUdwQixVQUFNLEVBQUNxeUIsUUFBUUMsUUFBUXpZLFVBQVUzQyxTQUFRLElBQUlrYixVQUFVLE1BQU05YixRQUFRdUwsVUFBVTJPLEtBQUFBO0FBRS9FNk4sZUFBV3o0QixLQUFLeXhCLE1BQU1uYixNQUFNLEdBQUcsR0FBRzBWLE1BQU07TUFDdENuM0IsT0FBTzQ4QixNQUFNNThCO01BQ2JvZjtNQUNBM0M7TUFDQTJrQixXQUFXM0osV0FBVzFCLE9BQU8zTyxVQUFVcGlCLE9BQUFBO01BQ3ZDdThCLGNBQWM7TUFDZGUsYUFBYTtRQUFDMUs7UUFBUUM7TUFBTztJQUMvQixDQUFBO0VBQ0Y7RUFFQTk1QixLQUFLcVQsV0FBVztBQUNkLFFBQUksQ0FBQyxLQUFLZ3JCLFdBQVUsR0FBSTtBQUN0Qjs7QUFHRixTQUFLb0csZUFBYztBQUNuQixTQUFLSSxTQUFTeHhCLFNBQUFBO0FBQ2QsU0FBS215QixXQUFVO0FBQ2YsU0FBS08sVUFBUztBQUNkLFNBQUtMLFdBQVdyeUIsU0FBQUE7RUFDbEI7RUFNQW9jLFVBQVU7QUFDUixVQUFNem9CLE9BQU8sS0FBS25CO0FBQ2xCLFVBQU1tZ0MsS0FBS2gvQixLQUFLMlEsU0FBUzNRLEtBQUsyUSxNQUFNK1gsS0FBSztBQUN6QyxVQUFNdVcsS0FBS2ozQixlQUFlaEksS0FBSytXLFFBQVEvVyxLQUFLK1csS0FBSzJSLEdBQUcsRUFBQztBQUNyRCxVQUFNd1csS0FBS2wzQixlQUFlaEksS0FBS3VlLFVBQVV2ZSxLQUFLdWUsT0FBT21LLEdBQUcsQ0FBQTtBQUV4RCxRQUFJLENBQUMsS0FBSzJPLFdBQVUsS0FBTSxLQUFLcitCLFNBQVNpNkIsT0FBTXJTLFVBQVU1bkIsTUFBTTtBQUU1RCxhQUFPO1FBQUM7VUFDTjB2QixHQUFHc1c7VUFDSGhtQyxNQUFNLENBQUNxVCxjQUFjO0FBQ25CLGlCQUFLclQsS0FBS3FULFNBQUFBO1VBQ1o7UUFDRjtNQUFFOztBQUdKLFdBQU87TUFBQztRQUNOcWMsR0FBR3VXO1FBQ0hqbUMsTUFBTSxDQUFDcVQsY0FBYztBQUNuQixlQUFLb3hCLGVBQWM7QUFDbkIsZUFBS0ksU0FBU3h4QixTQUFBQTtBQUNkLGVBQUsweUIsVUFBUztRQUNoQjtNQUNGO01BQUc7UUFDRHJXLEdBQUd3VztRQUNIbG1DLE1BQU0sTUFBTTtBQUNWLGVBQUt3bEMsV0FBVTtRQUNqQjtNQUNGO01BQUc7UUFDRDlWLEdBQUdzVztRQUNIaG1DLE1BQU0sQ0FBQ3FULGNBQWM7QUFDbkIsZUFBS3F5QixXQUFXcnlCLFNBQUFBO1FBQ2xCO01BQ0Y7SUFBRTtFQUNKO0VBT0F0SSx3QkFBd0J2TSxNQUFNO0FBQzVCLFVBQU1nOUIsUUFBUSxLQUFLbjlCLE1BQU1rckIsNkJBQTRCO0FBQ3JELFVBQU1oTSxTQUFTLEtBQUsvVCxPQUFPO0FBQzNCLFVBQU1tZixTQUFTLENBQUE7QUFDZixRQUFJNW9CLEdBQUd1STtBQUVQLFNBQUt2SSxJQUFJLEdBQUd1SSxPQUFPa3pCLE1BQU0xN0IsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDOUMsWUFBTXFKLE9BQU9veUIsTUFBTXo3QixDQUFFO0FBQ3JCLFVBQUlxSixLQUFLbVUsTUFBTyxNQUFLLEtBQUt0VCxPQUFPLENBQUN6TCxRQUFRNEssS0FBSzVLLFNBQVNBLE9BQU87QUFDN0RtcUIsZUFBTzVuQixLQUFLcUksSUFBQUE7O0lBRWhCO0FBQ0EsV0FBT3VmO0VBQ1Q7RUFPQTZYLHdCQUF3Qmo0QixRQUFPO0FBQzdCLFVBQU12QixPQUFPLEtBQUtuQixRQUFROFIsTUFBTXlqQixXQUFXLEtBQUtwcUIsV0FBV3pJLE1BQUFBLENBQUFBO0FBQzNELFdBQU84d0IsT0FBT3J5QixLQUFLb3lCLElBQUk7RUFDekI7RUFLQStNLGFBQWE7QUFDWCxVQUFNQyxXQUFXLEtBQUs1Rix3QkFBd0IsQ0FBQSxFQUFHakg7QUFDakQsWUFBUSxLQUFLL2YsYUFBWSxJQUFLLEtBQUs2QixRQUFRLEtBQUtELFVBQVVnckI7RUFDNUQ7QUFDRjtBQ3RxRGUsSUFBTUMsZ0JBQU4sTUFBTUE7RUFDbkJ4b0MsWUFBWVcsTUFBTThuQyxPQUFPNWUsVUFBVTtBQUNqQyxTQUFLbHBCLE9BQU9BO0FBQ1osU0FBSzhuQyxRQUFRQTtBQUNiLFNBQUs1ZSxXQUFXQTtBQUNoQixTQUFLN25CLFFBQVFtRix1QkFBT3VoQyxPQUFPLElBQUk7RUFDakM7RUFFQUMsVUFBVWhvQyxNQUFNO0FBQ2QsV0FBT3dHLE9BQU80aUIsVUFBVTZlLGNBQWNubkMsS0FBSyxLQUFLZCxLQUFLb3BCLFdBQVdwcEIsS0FBS29wQixTQUFTO0VBQ2hGO0VBTUE4ZSxTQUFTem1DLE1BQU07QUFDYixVQUFNMG1DLFFBQVEzaEMsT0FBTzRoQyxlQUFlM21DLElBQUFBO0FBQ3BDLFFBQUk0bUM7QUFFSixRQUFJQyxrQkFBa0JILEtBQVEsR0FBQTtBQUU1QkUsb0JBQWMsS0FBS0gsU0FBU0MsS0FBQUE7O0FBRzlCLFVBQU05bUMsUUFBUSxLQUFLQTtBQUNuQixVQUFNb0ssS0FBS2hLLEtBQUtnSztBQUNoQixVQUFNcThCLFFBQVEsS0FBS0EsUUFBUSxNQUFNcjhCO0FBRWpDLFFBQUksQ0FBQ0EsSUFBSTtBQUNQLFlBQU0sSUFBSXVkLE1BQU0sNkJBQTZCdm5CLElBQU07O0FBR3JELFFBQUlnSyxNQUFNcEssT0FBTztBQUVmLGFBQU95bUM7O0FBR1R6bUMsVUFBTW9LLEVBQUFBLElBQU1oSztBQUNaOG1DLHFCQUFpQjltQyxNQUFNcW1DLE9BQU9PLFdBQUFBO0FBQzlCLFFBQUksS0FBS25mLFVBQVU7QUFDakJ4aUIsZUFBU3dpQixTQUFTem5CLEtBQUtnSyxJQUFJaEssS0FBSzJkLFNBQVM7O0FBRzNDLFdBQU8wb0I7RUFDVDtFQU1BOWxDLElBQUl5SixJQUFJO0FBQ04sV0FBTyxLQUFLcEssTUFBTW9LLEVBQUc7RUFDdkI7RUFLQSs4QixXQUFXL21DLE1BQU07QUFDZixVQUFNSixRQUFRLEtBQUtBO0FBQ25CLFVBQU1vSyxLQUFLaEssS0FBS2dLO0FBQ2hCLFVBQU1xOEIsUUFBUSxLQUFLQTtBQUVuQixRQUFJcjhCLE1BQU1wSyxPQUFPO0FBQ2YsYUFBT0EsTUFBTW9LLEVBQUc7O0FBR2xCLFFBQUlxOEIsU0FBU3I4QixNQUFNL0UsU0FBU29oQyxLQUFBQSxHQUFRO0FBQ2xDLGFBQU9waEMsU0FBU29oQyxLQUFNLEVBQUNyOEIsRUFBRztBQUMxQixVQUFJLEtBQUt5ZCxVQUFVO0FBQ2pCLGVBQU85SixVQUFVM1QsRUFBRzs7O0VBRzFCO0FBQ0Y7QUFFQSxTQUFTODhCLGlCQUFpQjltQyxNQUFNcW1DLE9BQU9PLGFBQWE7QUFFbEQsUUFBTUksZUFBZUMsTUFBTWxpQyx1QkFBT3VoQyxPQUFPLElBQUksR0FBRztJQUM5Q00sY0FBYzNoQyxTQUFTMUUsSUFBSXFtQyxXQUFBQSxJQUFlLENBQUE7SUFDMUMzaEMsU0FBUzFFLElBQUk4bEMsS0FBQUE7SUFDYnJtQyxLQUFLaUY7RUFDTixDQUFBO0FBRURBLFdBQVN2RSxJQUFJMmxDLE9BQU9XLFlBQUFBO0FBRXBCLE1BQUlobkMsS0FBSysxQixlQUFlO0FBQ3RCbVIsa0JBQWNiLE9BQU9ybUMsS0FBSysxQixhQUFhOztBQUd6QyxNQUFJLzFCLEtBQUs4aUIsYUFBYTtBQUNwQjdkLGFBQVNraUMsU0FBU2QsT0FBT3JtQyxLQUFLOGlCLFdBQVc7O0FBRTdDO0FBRUEsU0FBU29rQixjQUFjYixPQUFPZSxRQUFRO0FBQ3BDcmlDLFNBQU9DLEtBQUtvaUMsTUFBQUEsRUFBUXhvQyxRQUFReW9DLENBQUFBLGFBQVk7QUFDdEMsVUFBTUMsZ0JBQWdCRCxTQUFTRSxNQUFNLEdBQUE7QUFDckMsVUFBTUMsYUFBYUYsY0FBY2xuQyxJQUFHO0FBQ3BDLFVBQU1xbkMsY0FBYztNQUFDcEI7SUFBTSxFQUFDcnZCLE9BQU9zd0IsYUFBZUksRUFBQUEsS0FBSyxHQUFBO0FBQ3ZELFVBQU1DLFFBQVFQLE9BQU9DLFFBQVMsRUFBQ0UsTUFBTSxHQUFBO0FBQ3JDLFVBQU1LLGFBQWFELE1BQU12bkMsSUFBRztBQUM1QixVQUFNeW5DLGNBQWNGLE1BQU1ELEtBQUssR0FBQTtBQUMvQnppQyxhQUFTNmlDLE1BQU1MLGFBQWFELFlBQVlLLGFBQWFELFVBQUFBO0VBQ3ZELENBQUE7QUFDRjtBQUVBLFNBQVNmLGtCQUFrQkgsT0FBTztBQUNoQyxTQUFPLFFBQVFBLFNBQVMsY0FBY0E7QUFDeEM7QUMxR08sSUFBTXFCLFdBQU4sTUFBTUE7RUFDWG5xQyxjQUFjO0FBQ1osU0FBS29xQyxjQUFjLElBQUk1QixjQUFjbjVCLG1CQUFtQixZQUFZLElBQUk7QUFDeEUsU0FBS2lHLFdBQVcsSUFBSWt6QixjQUFjMVEsU0FBUyxVQUFBO0FBQzNDLFNBQUt2UyxVQUFVLElBQUlpakIsY0FBY3JoQyxRQUFRLFNBQUE7QUFDekMsU0FBSzZHLFNBQVMsSUFBSXc2QixjQUFjcE0sT0FBTyxRQUFBO0FBR3ZDLFNBQUtpTyxtQkFBbUI7TUFBQyxLQUFLRDtNQUFhLEtBQUtwOEI7TUFBUSxLQUFLc0g7SUFBUztFQUN4RTtFQUtBblMsT0FBT29WLE1BQU07QUFDWCxTQUFLK3hCLE1BQU0sWUFBWS94QixJQUFBQTtFQUN6QjtFQUVBM1UsVUFBVTJVLE1BQU07QUFDZCxTQUFLK3hCLE1BQU0sY0FBYy94QixJQUFBQTtFQUMzQjtFQUtBZ3lCLGtCQUFrQmh5QixNQUFNO0FBQ3RCLFNBQUsreEIsTUFBTSxZQUFZL3hCLE1BQU0sS0FBSzZ4QixXQUFXO0VBQy9DO0VBS0EzNUIsZUFBZThILE1BQU07QUFDbkIsU0FBSyt4QixNQUFNLFlBQVkveEIsTUFBTSxLQUFLakQsUUFBUTtFQUM1QztFQUtBazFCLGNBQWNqeUIsTUFBTTtBQUNsQixTQUFLK3hCLE1BQU0sWUFBWS94QixNQUFNLEtBQUtnTixPQUFPO0VBQzNDO0VBS0FrbEIsYUFBYWx5QixNQUFNO0FBQ2pCLFNBQUsreEIsTUFBTSxZQUFZL3hCLE1BQU0sS0FBS3ZLLE1BQU07RUFDMUM7RUFNQTA4QixjQUFjdCtCLElBQUk7QUFDaEIsV0FBTyxLQUFLdStCLEtBQUt2K0IsSUFBSSxLQUFLZytCLGFBQWEsWUFBQTtFQUN6QztFQU1BNWdCLFdBQVdwZCxJQUFJO0FBQ2IsV0FBTyxLQUFLdStCLEtBQUt2K0IsSUFBSSxLQUFLa0osVUFBVSxTQUFBO0VBQ3RDO0VBTUFzMUIsVUFBVXgrQixJQUFJO0FBQ1osV0FBTyxLQUFLdStCLEtBQUt2K0IsSUFBSSxLQUFLbVosU0FBUyxRQUFBO0VBQ3JDO0VBTUFzbEIsU0FBU3orQixJQUFJO0FBQ1gsV0FBTyxLQUFLdStCLEtBQUt2K0IsSUFBSSxLQUFLNEIsUUFBUSxPQUFBO0VBQ3BDO0VBS0E4OEIscUJBQXFCdnlCLE1BQU07QUFDekIsU0FBSyt4QixNQUFNLGNBQWMveEIsTUFBTSxLQUFLNnhCLFdBQVc7RUFDakQ7RUFLQVcsa0JBQWtCeHlCLE1BQU07QUFDdEIsU0FBSyt4QixNQUFNLGNBQWMveEIsTUFBTSxLQUFLakQsUUFBUTtFQUM5QztFQUtBMDFCLGlCQUFpQnp5QixNQUFNO0FBQ3JCLFNBQUsreEIsTUFBTSxjQUFjL3hCLE1BQU0sS0FBS2dOLE9BQU87RUFDN0M7RUFLQTBsQixnQkFBZ0IxeUIsTUFBTTtBQUNwQixTQUFLK3hCLE1BQU0sY0FBYy94QixNQUFNLEtBQUt2SyxNQUFNO0VBQzVDO0VBS0FzOEIsTUFBTTNqQyxRQUFRNFIsTUFBTTJ5QixlQUFlO0FBQ2pDO01BQUkzeUIsR0FBQUE7TUFBTXZYLFFBQVFtcUMsQ0FBQUEsUUFBTztBQUN2QixZQUFNQyxNQUFNRixpQkFBaUIsS0FBS0csb0JBQW9CRixHQUFBQTtBQUN0RCxVQUFJRCxpQkFBaUJFLElBQUl6QyxVQUFVd0MsR0FBU0MsS0FBQUEsUUFBUSxLQUFLN2xCLFdBQVc0bEIsSUFBSS8rQixJQUFLO0FBQzNFLGFBQUtrL0IsTUFBTTNrQyxRQUFReWtDLEtBQUtELEdBQUFBO2FBQ25CO0FBS0wvWSxhQUFLK1ksS0FBSy9vQyxDQUFBQSxTQUFRO0FBT2hCLGdCQUFNbXBDLFVBQVVMLGlCQUFpQixLQUFLRyxvQkFBb0JqcEMsSUFBQUE7QUFDMUQsZUFBS2twQyxNQUFNM2tDLFFBQVE0a0MsU0FBU25wQyxJQUFBQTtRQUM5QixDQUFBOztJQUVKLENBQUE7RUFDRjtFQUtBa3BDLE1BQU0za0MsUUFBUTRpQixXQUFVaWlCLFdBQVc7QUFDakMsVUFBTUMsY0FBY0MsWUFBWS9rQyxNQUFBQTtBQUNoQ2xGLGFBQUsrcEMsVUFBVSxXQUFXQyxXQUFBQSxHQUFjLENBQUEsR0FBSUQsU0FBQUE7QUFDNUNqaUIsSUFBQUEsVUFBUzVpQixNQUFBQSxFQUFRNmtDLFNBQUFBO0FBQ2pCL3BDLGFBQUsrcEMsVUFBVSxVQUFVQyxXQUFBQSxHQUFjLENBQUEsR0FBSUQsU0FBQUE7RUFDN0M7RUFLQUgsb0JBQW9CMXFDLE1BQU07QUFDeEIsYUFBU3VCLElBQUksR0FBR0EsSUFBSSxLQUFLbW9DLGlCQUFpQnBvQyxRQUFRQyxLQUFLO0FBQ3JELFlBQU1rcEMsTUFBTSxLQUFLZixpQkFBaUJub0MsQ0FBRTtBQUNwQyxVQUFJa3BDLElBQUl6QyxVQUFVaG9DLElBQU8sR0FBQTtBQUN2QixlQUFPeXFDOztJQUVYO0FBRUEsV0FBTyxLQUFLN2xCO0VBQ2Q7RUFLQW9sQixLQUFLditCLElBQUk4K0IsZUFBZXZxQyxNQUFNO0FBQzVCLFVBQU15QixPQUFPOG9DLGNBQWN2b0MsSUFBSXlKLEVBQUFBO0FBQy9CLFFBQUloSyxTQUFTOUIsUUFBVztBQUN0QixZQUFNLElBQUlxcEIsTUFBTSxNQUFNdmQsS0FBSywyQkFBMkJ6TCxPQUFPLEdBQUs7O0FBRXBFLFdBQU95QjtFQUNUO0FBRUY7QUFHQSxJQUFBLFdBQStCLG9CQUFJK25DLFNBQVc7QUN0Sy9CLElBQU13QixnQkFBTixNQUFNQTtFQUNuQjNyQyxjQUFjO0FBQ1osU0FBSzRyQyxRQUFRLENBQUE7RUFDZjtFQVlBQyxPQUFPcnJDLE9BQU9zckMsTUFBTXZ6QixNQUFNdEssUUFBUTtBQUNoQyxRQUFJNjlCLFNBQVMsY0FBYztBQUN6QixXQUFLRixRQUFRLEtBQUtHLG1CQUFtQnZyQyxPQUFPLElBQUk7QUFDaEQsV0FBS0QsUUFBUSxLQUFLcXJDLE9BQU9wckMsT0FBTyxTQUFBOztBQUdsQyxVQUFNMGtCLGVBQWNqWCxTQUFTLEtBQUsrOUIsYUFBYXhyQyxLQUFBQSxFQUFPeU4sT0FBT0EsTUFBVSxJQUFBLEtBQUsrOUIsYUFBYXhyQyxLQUFNO0FBQy9GLFVBQU1zcUIsU0FBUyxLQUFLdnFCLFFBQVEya0IsY0FBYTFrQixPQUFPc3JDLE1BQU12ekIsSUFBQUE7QUFFdEQsUUFBSXV6QixTQUFTLGdCQUFnQjtBQUMzQixXQUFLdnJDLFFBQVEya0IsY0FBYTFrQixPQUFPLE1BQUE7QUFDakMsV0FBS0QsUUFBUSxLQUFLcXJDLE9BQU9wckMsT0FBTyxXQUFBOztBQUVsQyxXQUFPc3FCO0VBQ1Q7RUFLQXZxQixRQUFRMmtCLGNBQWExa0IsT0FBT3NyQyxNQUFNdnpCLE1BQU07QUFDdENBLFdBQU9BLFFBQVEsQ0FBQTtBQUNmLGVBQVcwekIsY0FBYy9tQixjQUFhO0FBQ3BDLFlBQU1nbkIsU0FBU0QsV0FBV0M7QUFDMUIsWUFBTXZsQyxTQUFTdWxDLE9BQU9KLElBQUs7QUFDM0IsWUFBTS9jLFNBQVM7UUFBQ3Z1QjtRQUFPK1g7UUFBTTB6QixXQUFXamtDO01BQVE7QUFDaEQsVUFBSW1rQyxTQUFheGxDLFFBQVFvb0IsUUFBUW1kLE1BQUFBLE1BQVksU0FBUzN6QixLQUFLNnpCLFlBQVk7QUFDckUsZUFBTzs7SUFFWDtBQUVBLFdBQU87RUFDVDtFQUVBQyxhQUFhO0FBTVgsUUFBSSxDQUFDL3hCLGNBQWMsS0FBS3JCLE1BQU0sR0FBRztBQUMvQixXQUFLcXpCLFlBQVksS0FBS3J6QjtBQUN0QixXQUFLQSxTQUFTM1k7O0VBRWxCO0VBTUEwckMsYUFBYXhyQyxPQUFPO0FBQ2xCLFFBQUksS0FBS3lZLFFBQVE7QUFDZixhQUFPLEtBQUtBOztBQUdkLFVBQU1pTSxlQUFjLEtBQUtqTSxTQUFTLEtBQUs4eUIsbUJBQW1CdnJDLEtBQUFBO0FBRTFELFNBQUsrckMsb0JBQW9CL3JDLEtBQUFBO0FBRXpCLFdBQU8wa0I7RUFDVDtFQUVBNm1CLG1CQUFtQnZyQyxPQUFPdUksS0FBSztBQUM3QixVQUFNbEMsU0FBU3JHLFNBQVNBLE1BQU1xRztBQUM5QixVQUFNbUIsV0FBVW1KLGVBQWV0SyxPQUFPbUIsV0FBV25CLE9BQU9tQixRQUFRdWQsU0FBUyxDQUFBLENBQUM7QUFDMUUsVUFBTUEsV0FBVWluQixXQUFXM2xDLE1BQUFBO0FBRTNCLFdBQU9tQixhQUFZLFNBQVMsQ0FBQ2UsTUFBTSxDQUFBLElBQUswakMsa0JBQWtCanNDLE9BQU8ra0IsVUFBU3ZkLFVBQVNlLEdBQUk7RUFDekY7RUFNQXdqQyxvQkFBb0IvckMsT0FBTztBQUN6QixVQUFNa3NDLHNCQUFzQixLQUFLSixhQUFhLENBQUE7QUFDOUMsVUFBTXBuQixlQUFjLEtBQUtqTTtBQUN6QixVQUFNa1IsT0FBTyxDQUFDNVEsR0FBR3JQLE1BQU1xUCxFQUFFdEwsT0FBT3hFLENBQUFBLE1BQUssQ0FBQ1MsRUFBRXlpQyxLQUFLampDLENBQUFBLE1BQUtELEVBQUV5aUMsT0FBTzkvQixPQUFPMUMsRUFBRXdpQyxPQUFPOS9CLEVBQUUsQ0FBQTtBQUM3RSxTQUFLN0wsUUFBUTRwQixLQUFLdWlCLHFCQUFxQnhuQixZQUFBQSxHQUFjMWtCLE9BQU8sTUFBQTtBQUM1RCxTQUFLRCxRQUFRNHBCLEtBQUtqRixjQUFhd25CLG1CQUFBQSxHQUFzQmxzQyxPQUFPLE9BQUE7RUFDOUQ7QUFDRjtBQUtBLFNBQVNnc0MsV0FBVzNsQyxRQUFRO0FBQzFCLFFBQU0rbEMsV0FBVyxDQUFBO0FBQ2pCLFFBQU1ybkIsV0FBVSxDQUFBO0FBQ2hCLFFBQU1uZSxPQUFPRCxPQUFPQyxLQUFLbWlCLFNBQVNoRSxRQUFRdmpCLEtBQUs7QUFDL0MsV0FBU0UsSUFBSSxHQUFHQSxJQUFJa0YsS0FBS25GLFFBQVFDLEtBQUs7QUFDcENxakIsSUFBQUEsU0FBUXJpQixLQUFLcW1CLFNBQVNxaEIsVUFBVXhqQyxLQUFLbEYsQ0FBRSxDQUFBLENBQUE7RUFDekM7QUFFQSxRQUFNMnFDLFFBQVFobUMsT0FBTzBlLFdBQVcsQ0FBQTtBQUNoQyxXQUFTcmpCLElBQUksR0FBR0EsSUFBSTJxQyxNQUFNNXFDLFFBQVFDLEtBQUs7QUFDckMsVUFBTWdxQyxTQUFTVyxNQUFNM3FDLENBQUU7QUFFdkIsUUFBSXFqQixTQUFRckgsUUFBUWd1QixNQUFBQSxNQUFZLElBQUk7QUFDbEMzbUIsTUFBQUEsU0FBUXJpQixLQUFLZ3BDLE1BQUFBO0FBQ2JVLGVBQVNWLE9BQU85L0IsRUFBRSxJQUFJOztFQUUxQjtBQUVBLFNBQU87SUFBQ21aLFNBQUFBO0lBQVNxbkI7RUFBUTtBQUMzQjtBQUVBLFNBQVNFLFFBQVE5a0MsVUFBU2UsS0FBSztBQUM3QixNQUFJLENBQUNBLE9BQU9mLGFBQVksT0FBTztBQUM3QixXQUFPOztBQUVULE1BQUlBLGFBQVksTUFBTTtBQUNwQixXQUFPLENBQUE7O0FBRVQsU0FBT0E7QUFDVDtBQUVBLFNBQVN5a0Msa0JBQWtCanNDLE9BQU8sRUFBQytrQixTQUFBQSxVQUFTcW5CLFNBQVEsR0FBRzVrQyxVQUFTZSxLQUFLO0FBQ25FLFFBQU0raEIsU0FBUyxDQUFBO0FBQ2YsUUFBTWpWLFVBQVVyVixNQUFNMlMsV0FBVTtBQUVoQyxhQUFXKzRCLFVBQVUzbUIsVUFBUztBQUM1QixVQUFNblosS0FBSzgvQixPQUFPOS9CO0FBQ2xCLFVBQU1qRCxPQUFPMmpDLFFBQVE5a0MsU0FBUW9FLEVBQUFBLEdBQUtyRCxHQUFBQTtBQUNsQyxRQUFJSSxTQUFTLE1BQU07QUFDakI7O0FBRUYyaEIsV0FBTzVuQixLQUFLO01BQ1ZncEM7TUFDQWxrQyxTQUFTK2tDLFdBQVd2c0MsTUFBTXFHLFFBQVE7UUFBQ3FsQztRQUFRVyxPQUFPRCxTQUFTeGdDLEVBQUc7TUFBQSxHQUFHakQsTUFBTTBNLE9BQUFBO0lBQ3pFLENBQUE7RUFDRjtBQUVBLFNBQU9pVjtBQUNUO0FBRUEsU0FBU2lpQixXQUFXbG1DLFFBQVEsRUFBQ3FsQyxRQUFRVyxNQUFLLEdBQUcxakMsTUFBTTBNLFNBQVM7QUFDMUQsUUFBTXpPLE9BQU9QLE9BQU9tbUMsZ0JBQWdCZCxNQUFBQTtBQUNwQyxRQUFNbDVCLFNBQVNuTSxPQUFPb00sZ0JBQWdCOUosTUFBTS9CLElBQUFBO0FBQzVDLE1BQUl5bEMsU0FBU1gsT0FBTzdrQyxVQUFVO0FBRTVCMkwsV0FBTzlQLEtBQUtncEMsT0FBTzdrQyxRQUFROztBQUU3QixTQUFPUixPQUFPcU0sZUFBZUYsUUFBUTZDLFNBQVM7SUFBQztLQUFLO0lBRWxEbzNCLFlBQVk7SUFDWkMsV0FBVztJQUNYQyxTQUFTO0VBQ1gsQ0FBQTtBQUNGO0FDbExPLFNBQVNDLGFBQWF6c0MsTUFBTXFILFVBQVM7QUFDMUMsUUFBTXFsQyxrQkFBa0JobUMsU0FBUzBLLFNBQVNwUixJQUFBQSxLQUFTLENBQUE7QUFDbkQsUUFBTTJzQyxrQkFBa0J0bEMsU0FBUStKLFlBQVksQ0FBQSxHQUFJcFIsSUFBSyxLQUFJLENBQUE7QUFDekQsU0FBTzJzQyxlQUFlOTdCLGFBQWF4SixTQUFRd0osYUFBYTY3QixnQkFBZ0I3N0IsYUFBYTtBQUN2RjtBQUVBLFNBQVMrN0IsMEJBQTBCbmhDLElBQUlvRixXQUFXO0FBQ2hELE1BQUk3RixPQUFPUztBQUNYLE1BQUlBLE9BQU8sV0FBVztBQUNwQlQsV0FBTzZGO2FBQ0VwRixPQUFPLFdBQVc7QUFDM0JULFdBQU82RixjQUFjLE1BQU0sTUFBTTs7QUFFbkMsU0FBTzdGO0FBQ1Q7QUFFQSxTQUFTNmhDLDBCQUEwQjdoQyxNQUFNNkYsV0FBVztBQUNsRCxTQUFPN0YsU0FBUzZGLFlBQVksWUFBWTtBQUMxQztBQUVBLFNBQVNpOEIsY0FBY3JoQyxJQUFJO0FBQ3pCLE1BQUlBLE9BQU8sT0FBT0EsT0FBTyxPQUFPQSxPQUFPLEtBQUs7QUFDMUMsV0FBT0E7O0FBRVg7QUFFQSxTQUFTc2hDLGlCQUFpQmxpQixVQUFVO0FBQ2xDLE1BQUlBLGFBQWEsU0FBU0EsYUFBYSxVQUFVO0FBQy9DLFdBQU87O0FBRVQsTUFBSUEsYUFBYSxVQUFVQSxhQUFhLFNBQVM7QUFDL0MsV0FBTzs7QUFFWDtBQUVPLFNBQVNtaUIsY0FBY3ZoQyxPQUFPd2hDLGNBQWM7QUFDakQsTUFBSUgsY0FBY3JoQyxFQUFLLEdBQUE7QUFDckIsV0FBT0E7O0FBRVQsYUFBV2pELFFBQVF5a0MsY0FBYztBQUMvQixVQUFNamlDLE9BQU94QyxLQUFLd0MsUUFDYitoQyxpQkFBaUJ2a0MsS0FBS3FpQixRQUFRLEtBQzlCcGYsR0FBR25LLFNBQVMsS0FBS3dyQyxjQUFjcmhDLEdBQUcsQ0FBQSxFQUFHeWhDLFlBQVcsQ0FBQTtBQUNyRCxRQUFJbGlDLE1BQU07QUFDUixhQUFPQTs7RUFFWDtBQUNBLFFBQU0sSUFBSWdlLE1BQU0sNkJBQTZCdmQsRUFBRyxxREFBb0Q7QUFDdEc7QUFFQSxTQUFTMGhDLG1CQUFtQjFoQyxJQUFJVCxNQUFNMkMsU0FBUztBQUM3QyxNQUFJQSxRQUFRM0MsT0FBTyxRQUFBLE1BQWNTLElBQUk7QUFDbkMsV0FBTztNQUFDVDtJQUFJOztBQUVoQjtBQUVBLFNBQVNvaUMseUJBQXlCM2hDLElBQUl2RixRQUFRO0FBQzVDLE1BQUlBLE9BQU95RSxRQUFRekUsT0FBT3lFLEtBQUt5RyxVQUFVO0FBQ3ZDLFVBQU1pOEIsVUFBVW5uQyxPQUFPeUUsS0FBS3lHLFNBQVM5RCxPQUFPLENBQUNnZ0MsTUFBTUEsRUFBRS84QixZQUFZOUUsTUFBTTZoQyxFQUFFNThCLFlBQVlqRixFQUFBQTtBQUNyRixRQUFJNGhDLFFBQVEvckMsUUFBUTtBQUNsQixhQUFPNnJDLG1CQUFtQjFoQyxJQUFJLEtBQUs0aEMsUUFBUSxDQUFBLENBQUUsS0FBS0YsbUJBQW1CMWhDLElBQUksS0FBSzRoQyxRQUFRLENBQUUsQ0FBQTs7O0FBRzVGLFNBQU8sQ0FBQTtBQUNUO0FBRUEsU0FBU0UsaUJBQWlCcm5DLFFBQVFtQixVQUFTO0FBQ3pDLFFBQU1tbUMsZ0JBQWdCcHVCLFVBQVVsWixPQUFPbEcsSUFBSSxLQUFLO0lBQUNxTixRQUFRLENBQUE7RUFBRTtBQUMzRCxRQUFNb2dDLGVBQWVwbUMsU0FBUWdHLFVBQVUsQ0FBQTtBQUN2QyxRQUFNcWdDLGlCQUFpQmpCLGFBQWF2bUMsT0FBT2xHLE1BQU1xSCxRQUFBQTtBQUNqRCxRQUFNZ0csVUFBUzdHLHVCQUFPdWhDLE9BQU8sSUFBSTtBQUdqQ3ZoQyxTQUFPQyxLQUFLZ25DLFlBQUFBLEVBQWNwdEMsUUFBUW9MLENBQUFBLE9BQU07QUFDdEMsVUFBTWtpQyxZQUFZRixhQUFhaGlDLEVBQUc7QUFDbEMsUUFBSSxDQUFDbkYsU0FBU3FuQyxTQUFZLEdBQUE7QUFDeEIsYUFBTzE5QixRQUFRMjlCLE1BQU0sMENBQTBDbmlDLEVBQUFBLEVBQUk7O0FBRXJFLFFBQUlraUMsVUFBVUUsUUFBUTtBQUNwQixhQUFPNTlCLFFBQVFDLEtBQUssa0RBQWtEekUsRUFBQUEsRUFBSTs7QUFFNUUsVUFBTVQsT0FBT2dpQyxjQUFjdmhDLElBQUlraUMsV0FBV1AseUJBQXlCM2hDLElBQUl2RixNQUFTUSxHQUFBQSxTQUFTMkcsT0FBT3NnQyxVQUFVM3RDLElBQUksQ0FBQztBQUMvRyxVQUFNOHRDLFlBQVlqQiwwQkFBMEI3aEMsTUFBTTBpQyxjQUFBQTtBQUNsRCxVQUFNSyxzQkFBc0JQLGNBQWNuZ0MsVUFBVSxDQUFBO0FBQ3BEQSxJQUFBQSxRQUFPNUIsRUFBQUEsSUFBTXVpQyxRQUFReG5DLHVCQUFPdWhDLE9BQU8sSUFBSSxHQUFHO01BQUM7UUFBQy84QjtNQUFJO01BQUcyaUM7TUFBV0ksb0JBQW9CL2lDLElBQUs7TUFBRStpQyxvQkFBb0JELFNBQVU7SUFBQyxDQUFBO0VBQzFILENBQUE7QUFHQTVuQyxTQUFPeUUsS0FBS3lHLFNBQVMvUSxRQUFRc04sQ0FBQUEsWUFBVztBQUN0QyxVQUFNM04sT0FBTzJOLFFBQVEzTixRQUFRa0csT0FBT2xHO0FBQ3BDLFVBQU02USxZQUFZbEQsUUFBUWtELGFBQWE0N0IsYUFBYXpzQyxNQUFNcUgsUUFBQUE7QUFDMUQsVUFBTXFsQyxrQkFBa0J0dEIsVUFBVXBmLElBQUFBLEtBQVMsQ0FBQTtBQUMzQyxVQUFNK3RDLHNCQUFzQnJCLGdCQUFnQnIvQixVQUFVLENBQUE7QUFDdEQ3RyxXQUFPQyxLQUFLc25DLG1CQUFBQSxFQUFxQjF0QyxRQUFRNHRDLENBQUFBLGNBQWE7QUFDcEQsWUFBTWpqQyxPQUFPNGhDLDBCQUEwQnFCLFdBQVdwOUIsU0FBQUE7QUFDbEQsWUFBTXBGLEtBQUtrQyxRQUFRM0MsT0FBTyxRQUFBLEtBQWFBO0FBQ3ZDcUMsTUFBQUEsUUFBTzVCLEVBQUcsSUFBRzRCLFFBQU81QixFQUFBQSxLQUFPakYsdUJBQU91aEMsT0FBTyxJQUFJO0FBQzdDaUcsY0FBUTNnQyxRQUFPNUIsRUFBQUEsR0FBSztRQUFDO1VBQUNUO1FBQUk7UUFBR3lpQyxhQUFhaGlDLEVBQUc7UUFBRXNpQyxvQkFBb0JFLFNBQVU7TUFBQyxDQUFBO0lBQ2hGLENBQUE7RUFDRixDQUFBO0FBR0F6bkMsU0FBT0MsS0FBSzRHLE9BQUFBLEVBQVFoTixRQUFReUcsQ0FBQUEsUUFBTztBQUNqQyxVQUFNd0IsUUFBUStFLFFBQU92RyxHQUFJO0FBQ3pCa25DLFlBQVExbEMsT0FBTztNQUFDNUIsU0FBUzJHLE9BQU8vRSxNQUFNdEksSUFBSTtNQUFHMEcsU0FBUzRCO0lBQU0sQ0FBQTtFQUM5RCxDQUFBO0FBRUEsU0FBTytFO0FBQ1Q7QUFFQSxTQUFTNmdDLFlBQVlob0MsUUFBUTtBQUMzQixRQUFNbUIsV0FBVW5CLE9BQU9tQixZQUFZbkIsT0FBT21CLFVBQVUsQ0FBQTtBQUVwREEsRUFBQUEsU0FBUXVkLFVBQVVwVSxlQUFlbkosU0FBUXVkLFNBQVMsQ0FBQSxDQUFDO0FBQ25EdmQsRUFBQUEsU0FBUWdHLFNBQVNrZ0MsaUJBQWlCcm5DLFFBQVFtQixRQUFBQTtBQUM1QztBQUVBLFNBQVM4bUMsU0FBU3hqQyxNQUFNO0FBQ3RCQSxTQUFPQSxRQUFRLENBQUE7QUFDZkEsT0FBS3lHLFdBQVd6RyxLQUFLeUcsWUFBWSxDQUFBO0FBQ2pDekcsT0FBS3dJLFNBQVN4SSxLQUFLd0ksVUFBVSxDQUFBO0FBQzdCLFNBQU94STtBQUNUO0FBRUEsU0FBU3lqQyxXQUFXbG9DLFFBQVE7QUFDMUJBLFdBQVNBLFVBQVUsQ0FBQTtBQUNuQkEsU0FBT3lFLE9BQU93akMsU0FBU2pvQyxPQUFPeUUsSUFBSTtBQUVsQ3VqQyxjQUFZaG9DLE1BQUFBO0FBRVosU0FBT0E7QUFDVDtBQUVBLElBQU1tb0MsV0FBVyxvQkFBSTd1QyxJQUFBQTtBQUNyQixJQUFNOHVDLGFBQWEsb0JBQUlDLElBQUFBO0FBRXZCLFNBQVNDLFdBQVdsNUIsVUFBVW01QixVQUFVO0FBQ3RDLE1BQUlob0MsT0FBTzRuQyxTQUFTcnNDLElBQUlzVCxRQUFBQTtBQUN4QixNQUFJLENBQUM3TyxNQUFNO0FBQ1RBLFdBQU9nb0MsU0FBQUE7QUFDUEosYUFBU2xzQyxJQUFJbVQsVUFBVTdPLElBQUFBO0FBQ3ZCNm5DLGVBQVc5ckMsSUFBSWlFLElBQUFBOztBQUVqQixTQUFPQTtBQUNUO0FBRUEsSUFBTWlvQyxhQUFhLENBQUN2c0MsTUFBSytaLEtBQUtwVixRQUFRO0FBQ3BDLFFBQU0wQixPQUFPZ0wsaUJBQWlCMEksS0FBS3BWLEdBQUFBO0FBQ25DLE1BQUkwQixTQUFTN0ksUUFBVztBQUN0QndDLElBQUFBLEtBQUlLLElBQUlnRyxJQUFBQTs7QUFFWjtBQUVlLElBQU1tbUMsU0FBTixNQUFNQTtFQUNuQnR2QyxZQUFZNkcsUUFBUTtBQUNsQixTQUFLMG9DLFVBQVVSLFdBQVdsb0MsTUFBQUE7QUFDMUIsU0FBSzJvQyxjQUFjLG9CQUFJcnZDLElBQUFBO0FBQ3ZCLFNBQUtzdkMsaUJBQWlCLG9CQUFJdHZDLElBQUFBO0VBQzVCO0VBRUEsSUFBSXV2QyxXQUFXO0FBQ2IsV0FBTyxLQUFLSCxRQUFRRztFQUN0QjtFQUVBLElBQUkvdUMsT0FBTztBQUNULFdBQU8sS0FBSzR1QyxRQUFRNXVDO0VBQ3RCO0VBRUEsSUFBSUEsS0FBS0EsTUFBTTtBQUNiLFNBQUs0dUMsUUFBUTV1QyxPQUFPQTtFQUN0QjtFQUVBLElBQUkySyxPQUFPO0FBQ1QsV0FBTyxLQUFLaWtDLFFBQVFqa0M7RUFDdEI7RUFFQSxJQUFJQSxLQUFLQSxNQUFNO0FBQ2IsU0FBS2lrQyxRQUFRamtDLE9BQU93akMsU0FBU3hqQyxJQUFBQTtFQUMvQjtFQUVBLElBQUl0RCxVQUFVO0FBQ1osV0FBTyxLQUFLdW5DLFFBQVF2bkM7RUFDdEI7RUFFQSxJQUFJQSxRQUFRQSxVQUFTO0FBQ25CLFNBQUt1bkMsUUFBUXZuQyxVQUFVQTtFQUN6QjtFQUVBLElBQUl1ZCxVQUFVO0FBQ1osV0FBTyxLQUFLZ3FCLFFBQVFocUI7RUFDdEI7RUFFQXJmLFNBQVM7QUFDUCxVQUFNVyxTQUFTLEtBQUswb0M7QUFDcEIsU0FBS0ksV0FBVTtBQUNmZCxnQkFBWWhvQyxNQUFBQTtFQUNkO0VBRUE4b0MsYUFBYTtBQUNYLFNBQUtILFlBQVlJLE1BQUs7QUFDdEIsU0FBS0gsZUFBZUcsTUFBSztFQUMzQjtFQVFBNzhCLGlCQUFpQjg4QixhQUFhO0FBQzVCLFdBQU9WLFdBQVdVLGFBQ2hCLE1BQU07TUFBQztRQUNMLFlBQVlBLFdBQUFBO1FBQ1o7TUFDRDtJQUFDLENBQUE7RUFDTjtFQVNBbDVCLDBCQUEwQms1QixhQUFhbjVCLFlBQVk7QUFDakQsV0FBT3k0QixXQUFXLEdBQUdVLFdBQUFBLGVBQTBCbjVCLFVBQUFBLElBQzdDLE1BQU07TUFDSjtRQUNFLFlBQVltNUIsV0FBQUEsZ0JBQTJCbjVCLFVBQUFBO1FBQ3ZDLGVBQWVBLFVBQUFBO01BQ2hCO01BRUQ7UUFDRSxZQUFZbTVCLFdBQUFBO1FBQ1o7TUFDRDtJQUNGLENBQUE7RUFDTDtFQVVBejVCLHdCQUF3Qnk1QixhQUFhOTVCLGFBQWE7QUFDaEQsV0FBT281QixXQUFXLEdBQUdVLFdBQUFBLElBQWU5NUIsV0FBQUEsSUFDbEMsTUFBTTtNQUFDO1FBQ0wsWUFBWTg1QixXQUFBQSxhQUF3Qjk1QixXQUFBQTtRQUNwQyxZQUFZODVCLFdBQUFBO1FBQ1osWUFBWTk1QixXQUFBQTtRQUNaO01BQ0Q7SUFBQyxDQUFBO0VBQ047RUFPQWkzQixnQkFBZ0JkLFFBQVE7QUFDdEIsVUFBTTkvQixLQUFLOC9CLE9BQU85L0I7QUFDbEIsVUFBTXpMLE9BQU8sS0FBS0E7QUFDbEIsV0FBT3d1QyxXQUFXLEdBQUd4dUMsSUFBQUEsV0FBZXlMLEVBQUFBLElBQ2xDLE1BQU07TUFBQztRQUNMLFdBQVdBLEVBQUFBO1dBQ1I4L0IsT0FBTzRELDBCQUEwQixDQUFBO01BQ3JDO0lBQUMsQ0FBQTtFQUNOO0VBS0FDLGNBQWNDLFdBQVdDLFlBQVk7QUFDbkMsVUFBTVQsY0FBYyxLQUFLQTtBQUN6QixRQUFJeDVCLFFBQVF3NUIsWUFBWTdzQyxJQUFJcXRDLFNBQUFBO0FBQzVCLFFBQUksQ0FBQ2g2QixTQUFTaTZCLFlBQVk7QUFDeEJqNkIsY0FBUSxvQkFBSTdWLElBQUFBO0FBQ1pxdkMsa0JBQVkxc0MsSUFBSWt0QyxXQUFXaDZCLEtBQUFBOztBQUU3QixXQUFPQTtFQUNUO0VBUUEvQyxnQkFBZ0IrOEIsV0FBV0UsVUFBVUQsWUFBWTtBQUMvQyxVQUFNLEVBQUNqb0MsU0FBQUEsVUFBU3JILEtBQUksSUFBSTtBQUN4QixVQUFNcVYsUUFBUSxLQUFLKzVCLGNBQWNDLFdBQVdDLFVBQUFBO0FBQzVDLFVBQU1saEMsU0FBU2lILE1BQU1yVCxJQUFJdXRDLFFBQUFBO0FBQ3pCLFFBQUluaEMsUUFBUTtBQUNWLGFBQU9BOztBQUdULFVBQU1pRSxTQUFTLG9CQUFJazhCLElBQUFBO0FBRW5CZ0IsYUFBU2x2QyxRQUFRb0csQ0FBQUEsU0FBUTtBQUN2QixVQUFJNG9DLFdBQVc7QUFDYmg5QixlQUFPN1AsSUFBSTZzQyxTQUFBQTtBQUNYNW9DLGFBQUtwRyxRQUFReUcsQ0FBQUEsUUFBTzRuQyxXQUFXcjhCLFFBQVFnOUIsV0FBV3ZvQyxHQUFBQSxDQUFBQTs7QUFFcERMLFdBQUtwRyxRQUFReUcsQ0FBQUEsUUFBTzRuQyxXQUFXcjhCLFFBQVFoTCxVQUFTUCxHQUFBQSxDQUFBQTtBQUNoREwsV0FBS3BHLFFBQVF5RyxDQUFBQSxRQUFPNG5DLFdBQVdyOEIsUUFBUStNLFVBQVVwZixJQUFBQSxLQUFTLENBQUEsR0FBSThHLEdBQUFBLENBQUFBO0FBQzlETCxXQUFLcEcsUUFBUXlHLENBQUFBLFFBQU80bkMsV0FBV3I4QixRQUFRM0wsVUFBVUksR0FBQUEsQ0FBQUE7QUFDakRMLFdBQUtwRyxRQUFReUcsQ0FBQUEsUUFBTzRuQyxXQUFXcjhCLFFBQVFrUyxhQUFhemQsR0FBQUEsQ0FBQUE7SUFDdEQsQ0FBQTtBQUVBLFVBQU1xbUIsUUFBUWhpQixNQUFNN0gsS0FBSytPLE1BQUFBO0FBQ3pCLFFBQUk4YSxNQUFNN3JCLFdBQVcsR0FBRztBQUN0QjZyQixZQUFNNXFCLEtBQUtpRSx1QkFBT3VoQyxPQUFPLElBQUksQ0FBQTs7QUFFL0IsUUFBSXVHLFdBQVc3ckMsSUFBSThzQyxRQUFXLEdBQUE7QUFDNUJsNkIsWUFBTWxULElBQUlvdEMsVUFBVXBpQixLQUFBQTs7QUFFdEIsV0FBT0E7RUFDVDtFQU1BcWlCLG9CQUFvQjtBQUNsQixVQUFNLEVBQUNub0MsU0FBQUEsVUFBU3JILEtBQUksSUFBSTtBQUV4QixXQUFPO01BQ0xxSDtNQUNBK1gsVUFBVXBmLElBQUssS0FBSSxDQUFBO01BQ25CMEcsU0FBUzBLLFNBQVNwUixJQUFLLEtBQUksQ0FBQTtNQUMzQjtRQUFDQTtNQUFJO01BQ0wwRztNQUNBNmQ7SUFDRDtFQUNIO0VBU0EzTyxvQkFBb0J2RCxRQUFRc0QsUUFBT1QsU0FBU1EsV0FBVztJQUFDO0tBQUs7QUFDM0QsVUFBTXlVLFNBQVM7TUFBQzFpQixTQUFTO0lBQUk7QUFDN0IsVUFBTSxFQUFDZ29DLFVBQVVDLFlBQVcsSUFBSUMsWUFBWSxLQUFLYixnQkFBZ0J6OEIsUUFBUXFELFFBQUFBO0FBQ3pFLFFBQUlyTyxXQUFVb29DO0FBQ2QsUUFBSUcsWUFBWUgsVUFBVTk1QixNQUFRLEdBQUE7QUFDaEN3VSxhQUFPMWlCLFVBQVU7QUFDakJ5TixnQkFBVTI2QixXQUFXMzZCLE9BQVdBLElBQUFBLFFBQUFBLElBQVlBO0FBRTVDLFlBQU00NkIsY0FBYyxLQUFLdjlCLGVBQWVGLFFBQVE2QyxTQUFTdzZCLFdBQUFBO0FBQ3pEcm9DLE1BQUFBLFdBQVUwb0MsZUFBZU4sVUFBVXY2QixTQUFTNDZCLFdBQUFBOztBQUc5QyxlQUFXMXJDLFFBQVF1UixRQUFPO0FBQ3hCd1UsYUFBTy9sQixJQUFBQSxJQUFRaUQsU0FBUWpELElBQUs7SUFDOUI7QUFDQSxXQUFPK2xCO0VBQ1Q7RUFRQTVYLGVBQWVGLFFBQVE2QyxTQUFTUSxXQUFXO0lBQUM7RUFBRyxHQUFFczZCLG9CQUFvQjtBQUNuRSxVQUFNLEVBQUNQLFNBQUFBLElBQVlFLFlBQVksS0FBS2IsZ0JBQWdCejhCLFFBQVFxRCxRQUFBQTtBQUM1RCxXQUFPcFAsU0FBUzRPLE9BQ1o2NkIsSUFBQUEsZUFBZU4sVUFBVXY2QixTQUFTdlYsUUFBV3F3QyxrQkFBQUEsSUFDN0NQO0VBQ047QUFDRjtBQUVBLFNBQVNFLFlBQVlNLGVBQWU1OUIsUUFBUXFELFVBQVU7QUFDcEQsTUFBSUwsUUFBUTQ2QixjQUFjanVDLElBQUlxUSxNQUFBQTtBQUM5QixNQUFJLENBQUNnRCxPQUFPO0FBQ1ZBLFlBQVEsb0JBQUk3VixJQUFBQTtBQUNaeXdDLGtCQUFjOXRDLElBQUlrUSxRQUFRZ0QsS0FBQUE7O0FBRTVCLFFBQU1DLFdBQVdJLFNBQVN5ekIsS0FBSTtBQUM5QixNQUFJLzZCLFNBQVNpSCxNQUFNclQsSUFBSXNULFFBQUFBO0FBQ3ZCLE1BQUksQ0FBQ2xILFFBQVE7QUFDWCxVQUFNcWhDLFdBQVdTLGdCQUFnQjc5QixRQUFRcUQsUUFBQUE7QUFDekN0SCxhQUFTO01BQ1BxaEM7TUFDQUMsYUFBYWg2QixTQUFTcEksT0FBTzZpQyxDQUFBQSxNQUFLLENBQUNBLEVBQUVqRCxZQUFXLEVBQUdsZixTQUFTLE9BQUEsQ0FBQTtJQUM5RDtBQUNBM1ksVUFBTWxULElBQUltVCxVQUFVbEgsTUFBQUE7O0FBRXRCLFNBQU9BO0FBQ1Q7QUFFQSxJQUFNZ2lDLGNBQWNyb0MsQ0FBQUEsVUFBU3pCLFNBQVN5QixLQUFBQSxLQUNqQ3ZCLE9BQU9LLG9CQUFvQmtCLEtBQU9pa0MsRUFBQUEsS0FBSyxDQUFDbGxDLFFBQVErb0MsV0FBVzluQyxNQUFNakIsR0FBSSxDQUFBLENBQUE7QUFFMUUsU0FBUzhvQyxZQUFZdFosT0FBTzNnQixRQUFPO0FBQ2pDLFFBQU0sRUFBQzA2QixjQUFjQyxZQUFXLElBQUlqRixhQUFhL1UsS0FBQUE7QUFFakQsYUFBV2x5QixRQUFRdVIsUUFBTztBQUN4QixVQUFNMjJCLGFBQWErRCxhQUFhanNDLElBQUFBO0FBQ2hDLFVBQU1tb0MsWUFBWStELFlBQVlsc0MsSUFBQUE7QUFDOUIsVUFBTTJELFNBQVN3a0MsYUFBYUQsZUFBZWhXLE1BQU1seUIsSUFBSztBQUN0RCxRQUFLa29DLGVBQWV1RCxXQUFXOW5DLEtBQUFBLEtBQVVxb0MsWUFBWXJvQyxLQUFLLE1BQ3BEd2tDLGFBQWF2bEMsUUFBUWUsS0FBUyxHQUFBO0FBQ2xDLGFBQU87O0VBRVg7QUFDQSxTQUFPO0FBQ1Q7O0FDOVlBLElBQU13b0Msa0JBQWtCO0VBQUM7RUFBTztFQUFVO0VBQVE7RUFBUztBQUFZO0FBQ3ZFLFNBQVNDLHFCQUFxQjNsQixVQUFVN2YsTUFBTTtBQUM1QyxTQUFPNmYsYUFBYSxTQUFTQSxhQUFhLFlBQWEwbEIsZ0JBQWdCaHpCLFFBQVFzTixRQUFBQSxNQUFjLE1BQU03ZixTQUFTO0FBQzlHO0FBRUEsU0FBU3lsQyxjQUFjQyxJQUFJQyxJQUFJO0FBQzdCLFNBQU8sU0FBUy8zQixHQUFHclAsR0FBRztBQUNwQixXQUFPcVAsRUFBRTgzQixFQUFHLE1BQUtubkMsRUFBRW1uQyxFQUFBQSxJQUNmOTNCLEVBQUUrM0IsRUFBQUEsSUFBTXBuQyxFQUFFb25DLEVBQUFBLElBQ1YvM0IsRUFBRTgzQixFQUFHLElBQUdubkMsRUFBRW1uQyxFQUFHO0VBQ25CO0FBQ0Y7QUFFQSxTQUFTRSxxQkFBcUIxN0IsU0FBUztBQUNyQyxRQUFNclYsUUFBUXFWLFFBQVFyVjtBQUN0QixRQUFNMEcsbUJBQW1CMUcsTUFBTXdILFFBQVFWO0FBRXZDOUcsUUFBTXMvQixjQUFjLGFBQUE7QUFDcEJxTSxXQUFhamxDLG9CQUFvQkEsaUJBQWlCc3FDLFlBQVk7SUFBQzM3QjtLQUFVclYsS0FBQUE7QUFDM0U7QUFFQSxTQUFTaXhDLG9CQUFvQjU3QixTQUFTO0FBQ3BDLFFBQU1yVixRQUFRcVYsUUFBUXJWO0FBQ3RCLFFBQU0wRyxtQkFBbUIxRyxNQUFNd0gsUUFBUVY7QUFDdkM2a0MsV0FBYWpsQyxvQkFBb0JBLGlCQUFpQndxQyxZQUFZO0lBQUM3N0I7S0FBVXJWLEtBQUFBO0FBQzNFO0FBTUEsU0FBU214QyxVQUFVdnZDLE1BQU07QUFDdkIsTUFBSXcxQixnQkFBQUEsS0FBcUIsT0FBT3gxQixTQUFTLFVBQVU7QUFDakRBLFdBQU9zekIsU0FBU2tjLGVBQWV4dkMsSUFBQUE7RUFDakMsV0FBV0EsUUFBUUEsS0FBS0gsUUFBUTtBQUU5QkcsV0FBT0EsS0FBSyxDQUFFOztBQUdoQixNQUFJQSxRQUFRQSxLQUFLcXdCLFFBQVE7QUFFdkJyd0IsV0FBT0EsS0FBS3F3Qjs7QUFFZCxTQUFPcndCO0FBQ1Q7QUFFQSxJQUFNeXZDLFlBQVksQ0FBQTtBQUNsQixJQUFNQyxXQUFXLENBQUNycUMsUUFBUTtBQUN4QixRQUFNZ3JCLFNBQVNrZixVQUFVbHFDLEdBQUFBO0FBQ3pCLFNBQU9OLE9BQU9XLE9BQU8rcEMsU0FBQUEsRUFBVzVqQyxPQUFPLENBQUM4akMsTUFBTUEsRUFBRXRmLFdBQVdBLE1BQUFBLEVBQVFqd0IsSUFBRztBQUN4RTtBQUVBLFNBQVN3dkMsZ0JBQWdCbjFCLEtBQUt2YixPQUFPMlcsTUFBTTtBQUN6QyxRQUFNN1EsT0FBT0QsT0FBT0MsS0FBS3lWLEdBQUFBO0FBQ3pCLGFBQVdwVixPQUFPTCxNQUFNO0FBQ3RCLFVBQU02cUMsU0FBUyxDQUFDeHFDO0FBQ2hCLFFBQUl3cUMsVUFBVTN3QyxPQUFPO0FBQ25CLFlBQU1vSCxRQUFRbVUsSUFBSXBWLEdBQUk7QUFDdEIsYUFBT29WLElBQUlwVixHQUFJO0FBQ2YsVUFBSXdRLE9BQU8sS0FBS2c2QixTQUFTM3dDLE9BQU87QUFDOUJ1YixZQUFJbzFCLFNBQVNoNkIsSUFBQUEsSUFBUXZQOzs7RUFHM0I7QUFDRjtBQVNBLFNBQVN3cEMsbUJBQW1CN3JCLEdBQUc4ckIsV0FBV0MsYUFBYUMsU0FBUztBQUM5RCxNQUFJLENBQUNELGVBQWUvckIsRUFBRTFsQixTQUFTLFlBQVk7QUFDekMsV0FBTzs7QUFFVCxNQUFJMHhDLFNBQVM7QUFDWCxXQUFPRjs7QUFFVCxTQUFPOXJCO0FBQ1Q7QUFFQSxJQUFNaXNCLFFBQU4sTUFBTUE7RUFTSixPQUFPekosWUFBWTdtQyxPQUFPO0FBQ3hCdW5CLGFBQVNwbUIsSUFBT25CLEdBQUFBLEtBQUFBO0FBQ2hCdXdDLHNCQUFBQTtFQUNGO0VBRUEsT0FBT3BKLGNBQWNubkMsT0FBTztBQUMxQnVuQixhQUFTM2xCLE9BQVU1QixHQUFBQSxLQUFBQTtBQUNuQnV3QyxzQkFBQUE7RUFDRjtFQUdBdnlDLFlBQVlvQyxNQUFNb3dDLFlBQVk7QUFDNUIsVUFBTTNyQyxTQUFTLEtBQUtBLFNBQVMsSUFBSXlvQyxPQUFPa0QsVUFBQUE7QUFDeEMsVUFBTUMsZ0JBQWdCZCxVQUFVdnZDLElBQUFBO0FBQ2hDLFVBQU1zd0MsZ0JBQWdCWixTQUFTVyxhQUFBQTtBQUMvQixRQUFJQyxlQUFlO0FBQ2pCLFlBQU0sSUFBSS9vQixNQUNSLDhDQUErQytvQixjQUFjdG1DLEtBQUssb0RBQ2xCc21DLGNBQWNqZ0IsT0FBT3JtQixLQUFLLGtCQUMxRTs7QUFHSixVQUFNcEUsV0FBVW5CLE9BQU9xTSxlQUFlck0sT0FBT3NwQyxrQkFBaUIsR0FBSSxLQUFLaDlCLFdBQVUsQ0FBQTtBQUVqRixTQUFLdThCLFdBQVcsS0FBSzdvQyxPQUFPNm9DLFlBQVkvWCxnQkFBZ0I4YSxhQUFhLEdBQUE7QUFDckUsU0FBSy9DLFNBQVN6YyxhQUFhcHNCLE1BQUFBO0FBRTNCLFVBQU1nUCxVQUFVLEtBQUs2NUIsU0FBU2xkLGVBQWVpZ0IsZUFBZXpxQyxTQUFRc2QsV0FBVztBQUMvRSxVQUFNbU4sU0FBUzVjLFdBQVdBLFFBQVE0YztBQUNsQyxVQUFNbFYsU0FBU2tWLFVBQVVBLE9BQU9sVjtBQUNoQyxVQUFNQyxRQUFRaVYsVUFBVUEsT0FBT2pWO0FBRS9CLFNBQUtwUixLQUFLdW1DLElBQUFBO0FBQ1YsU0FBS3BqQyxNQUFNc0c7QUFDWCxTQUFLNGMsU0FBU0E7QUFDZCxTQUFLalYsUUFBUUE7QUFDYixTQUFLRCxTQUFTQTtBQUNkLFNBQUtxMUIsV0FBVzVxQztBQUloQixTQUFLNnFDLGVBQWUsS0FBS3Z0QjtBQUN6QixTQUFLc00sVUFBVSxDQUFBO0FBQ2YsU0FBS2toQixZQUFZLENBQUE7QUFDakIsU0FBS3ZsQyxVQUFVak47QUFDZixTQUFLK3RCLFFBQVEsQ0FBQTtBQUNiLFNBQUsrSCwwQkFBMEI5MUI7QUFDL0IsU0FBS2tWLFlBQVlsVjtBQUNqQixTQUFLK0IsVUFBVSxDQUFBO0FBQ2YsU0FBSzB3QyxhQUFhenlDO0FBQ2xCLFNBQUsweUMsYUFBYSxDQUFBO0FBRWxCLFNBQUtDLHVCQUF1QjN5QztBQUM1QixTQUFLNHlDLGtCQUFrQixDQUFBO0FBQ3ZCLFNBQUtsbEMsU0FBUyxDQUFBO0FBQ2QsU0FBS21sQyxXQUFXLElBQUl4SCxjQUFBQTtBQUNwQixTQUFLclUsV0FBVyxDQUFBO0FBQ2hCLFNBQUs4YixpQkFBaUIsQ0FBQTtBQUN0QixTQUFLQyxXQUFXO0FBQ2hCLFNBQUtyOEIsc0JBQXNCMVc7QUFDM0IsU0FBSzZQLFdBQVc3UDtBQUNoQixTQUFLZ3pDLFlBQVlDLFNBQVN4b0MsQ0FBQUEsU0FBUSxLQUFLN0UsT0FBTzZFLElBQU8vQyxHQUFBQSxTQUFRd3JDLGVBQWUsQ0FBQTtBQUM1RSxTQUFLaDdCLGVBQWUsQ0FBQTtBQUdwQnE1QixjQUFVLEtBQUt6bEMsRUFBRSxJQUFJO0FBRXJCLFFBQUksQ0FBQ3lKLFdBQVcsQ0FBQzRjLFFBQVE7QUFLdkI3aEIsY0FBUTI5QixNQUFNLG1FQUFBO0FBQ2Q7O0FBR0YxbEMsYUFBUzlGLE9BQU8sTUFBTSxZQUFZd3VDLG9CQUFBQTtBQUNsQzFvQyxhQUFTOUYsT0FBTyxNQUFNLFlBQVkwdUMsbUJBQUFBO0FBRWxDLFNBQUtnQyxZQUFXO0FBQ2hCLFFBQUksS0FBS0osVUFBVTtBQUNqQixXQUFLbnRDLE9BQU07O0VBRWY7RUFFQSxJQUFJb2YsY0FBYztBQUNoQixVQUFNLEVBQUN0ZCxTQUFTLEVBQUNzZCxhQUFhb3VCLG9CQUFBQSxHQUFzQmwyQixPQUFPRCxRQUFRczFCLGFBQVksSUFBSTtBQUNuRixRQUFJLENBQUN2NEIsY0FBY2dMLFdBQWMsR0FBQTtBQUUvQixhQUFPQTs7QUFHVCxRQUFJb3VCLHVCQUF1QmIsY0FBYztBQUV2QyxhQUFPQTs7QUFJVCxXQUFPdDFCLFNBQVNDLFFBQVFELFNBQVM7RUFDbkM7RUFFQSxJQUFJalMsT0FBTztBQUNULFdBQU8sS0FBS3pFLE9BQU95RTtFQUNyQjtFQUVBLElBQUlBLEtBQUtBLE1BQU07QUFDYixTQUFLekUsT0FBT3lFLE9BQU9BO0VBQ3JCO0VBRUEsSUFBSXRELFVBQVU7QUFDWixXQUFPLEtBQUs0cUM7RUFDZDtFQUVBLElBQUk1cUMsUUFBUUEsVUFBUztBQUNuQixTQUFLbkIsT0FBT21CLFVBQVVBO0VBQ3hCO0VBRUEsSUFBSXVoQixXQUFXO0FBQ2IsV0FBT0E7RUFDVDtFQUtBa3FCLGNBQWM7QUFFWixTQUFLM1QsY0FBYyxZQUFBO0FBRW5CLFFBQUksS0FBSzkzQixRQUFRMnJDLFlBQVk7QUFDM0IsV0FBS3hkLE9BQU07V0FDTjtBQUNMeWQsa0JBQVksTUFBTSxLQUFLNXJDLFFBQVFrdUIsZ0JBQWdCOztBQUdqRCxTQUFLMmQsV0FBVTtBQUdmLFNBQUsvVCxjQUFjLFdBQUE7QUFFbkIsV0FBTztFQUNUO0VBRUE4UCxRQUFRO0FBQ05rRSxnQkFBWSxLQUFLcmhCLFFBQVEsS0FBS2xqQixHQUFHO0FBQ2pDLFdBQU87RUFDVDtFQUVBN0wsT0FBTztBQUNMbUYsYUFBU25GLEtBQUssSUFBSTtBQUNsQixXQUFPO0VBQ1Q7RUFPQXl5QixPQUFPM1ksT0FBT0QsUUFBUTtBQUNwQixRQUFJLENBQUMxVSxTQUFTOUcsUUFBUSxJQUFJLEdBQUc7QUFDM0IsV0FBS2d5QyxRQUFRdjJCLE9BQU9ELE1BQUFBO1dBQ2Y7QUFDTCxXQUFLeTJCLG9CQUFvQjtRQUFDeDJCO1FBQU9EO01BQU07O0VBRTNDO0VBRUF3MkIsUUFBUXYyQixPQUFPRCxRQUFRO0FBQ3JCLFVBQU12VixXQUFVLEtBQUtBO0FBQ3JCLFVBQU15cUIsU0FBUyxLQUFLQTtBQUNwQixVQUFNbk4sY0FBY3RkLFNBQVEwckMsdUJBQXVCLEtBQUtwdUI7QUFDeEQsVUFBTTJ1QixVQUFVLEtBQUt2RSxTQUFTM2MsZUFBZU4sUUFBUWpWLE9BQU9ELFFBQVErSCxXQUFBQTtBQUNwRSxVQUFNNHVCLFdBQVdsc0MsU0FBUWt1QixvQkFBb0IsS0FBS3daLFNBQVM1YyxvQkFBbUI7QUFDOUUsVUFBTS9uQixPQUFPLEtBQUt5UyxRQUFRLFdBQVc7QUFFckMsU0FBS0EsUUFBUXkyQixRQUFRejJCO0FBQ3JCLFNBQUtELFNBQVMwMkIsUUFBUTEyQjtBQUN0QixTQUFLczFCLGVBQWUsS0FBS3Z0QjtBQUN6QixRQUFJLENBQUNzdUIsWUFBWSxNQUFNTSxVQUFVLElBQUksR0FBRztBQUN0Qzs7QUFHRixTQUFLcFUsY0FBYyxVQUFVO01BQUNuM0IsTUFBTXNyQztJQUFPLENBQUE7QUFFM0M5SCxhQUFhbmtDLFNBQVFtc0MsVUFBVTtNQUFDO01BQU1GO0lBQVEsR0FBRSxJQUFJO0FBRXBELFFBQUksS0FBS1osVUFBVTtBQUNqQixVQUFJLEtBQUtDLFVBQVV2b0MsSUFBTyxHQUFBO0FBRXhCLGFBQUtxcEMsT0FBTTs7O0VBR2pCO0VBRUFDLHNCQUFzQjtBQUNwQixVQUFNcnNDLFdBQVUsS0FBS0E7QUFDckIsVUFBTXNzQyxnQkFBZ0J0c0MsU0FBUWdHLFVBQVUsQ0FBQTtBQUV4Q29rQixTQUFLa2lCLGVBQWUsQ0FBQ0MsYUFBYTcwQixXQUFXO0FBQzNDNjBCLGtCQUFZbm9DLEtBQUtzVDtJQUNuQixDQUFBO0VBQ0Y7RUFLQTgwQixzQkFBc0I7QUFDcEIsVUFBTXhzQyxXQUFVLEtBQUtBO0FBQ3JCLFVBQU15c0MsWUFBWXpzQyxTQUFRZ0c7QUFDMUIsVUFBTUEsVUFBUyxLQUFLQTtBQUNwQixVQUFNMG1DLFVBQVV2dEMsT0FBT0MsS0FBSzRHLE9BQUFBLEVBQVEzSyxPQUFPLENBQUN3WixLQUFLelEsT0FBTztBQUN0RHlRLFVBQUl6USxFQUFHLElBQUc7QUFDVixhQUFPeVE7SUFDVCxHQUFHLENBQUEsQ0FBQztBQUNKLFFBQUk3YSxRQUFRLENBQUE7QUFFWixRQUFJeXlDLFdBQVc7QUFDYnp5QyxjQUFRQSxNQUFNb1gsT0FDWmpTLE9BQU9DLEtBQUtxdEMsU0FBVzl1QixFQUFBQSxJQUFJLENBQUN2WixPQUFPO0FBQ2pDLGNBQU13aEMsZUFBZTZHLFVBQVVyb0MsRUFBRztBQUNsQyxjQUFNVCxPQUFPZ2lDLGNBQWN2aEMsSUFBSXdoQyxZQUFBQTtBQUMvQixjQUFNK0csV0FBV2hwQyxTQUFTO0FBQzFCLGNBQU1nUSxlQUFlaFEsU0FBUztBQUM5QixlQUFPO1VBQ0wzRCxTQUFTNGxDO1VBQ1RnSCxXQUFXRCxXQUFXLGNBQWNoNUIsZUFBZSxXQUFXO1VBQzlEazVCLE9BQU9GLFdBQVcsaUJBQWlCaDVCLGVBQWUsYUFBYTtRQUNqRTtNQUNGLENBQUEsQ0FBQTs7QUFJSnlXLFNBQUtwd0IsT0FBTyxDQUFDSSxTQUFTO0FBQ3BCLFlBQU13ckMsZUFBZXhyQyxLQUFLNEY7QUFDMUIsWUFBTW9FLEtBQUt3aEMsYUFBYXhoQztBQUN4QixZQUFNVCxPQUFPZ2lDLGNBQWN2aEMsSUFBSXdoQyxZQUFBQTtBQUMvQixZQUFNa0gsWUFBWTNqQyxlQUFleThCLGFBQWFqdEMsTUFBTXlCLEtBQUt5eUMsS0FBSztBQUU5RCxVQUFJakgsYUFBYXBpQixhQUFhbHJCLFVBQWE2d0MscUJBQXFCdkQsYUFBYXBpQixVQUFVN2YsSUFBVXdsQyxNQUFBQSxxQkFBcUIvdUMsS0FBS3d5QyxTQUFTLEdBQUc7QUFDckloSCxxQkFBYXBpQixXQUFXcHBCLEtBQUt3eUM7O0FBRy9CRixjQUFRdG9DLEVBQUcsSUFBRztBQUNkLFVBQUluRCxRQUFRO0FBQ1osVUFBSW1ELE1BQU00QixXQUFVQSxRQUFPNUIsRUFBQUEsRUFBSXpMLFNBQVNtMEMsV0FBVztBQUNqRDdyQyxnQkFBUStFLFFBQU81QixFQUFHO2FBQ2I7QUFDTCxjQUFNMm9DLGFBQWF4ckIsU0FBU3NoQixTQUFTaUssU0FBQUE7QUFDckM3ckMsZ0JBQVEsSUFBSThyQyxXQUFXO1VBQ3JCM29DO1VBQ0F6TCxNQUFNbTBDO1VBQ052bEMsS0FBSyxLQUFLQTtVQUNWL08sT0FBTztRQUNULENBQUE7QUFDQXdOLFFBQUFBLFFBQU8vRSxNQUFNbUQsRUFBRSxJQUFJbkQ7O0FBR3JCQSxZQUFNK2dCLEtBQUs0akIsY0FBYzVsQyxRQUFBQTtJQUMzQixDQUFBO0FBRUFvcUIsU0FBS3NpQixTQUFTLENBQUNNLFlBQVk1b0MsT0FBTztBQUNoQyxVQUFJLENBQUM0b0MsWUFBWTtBQUNmLGVBQU9obkMsUUFBTzVCLEVBQUc7O0lBRXJCLENBQUE7QUFFQWdtQixTQUFLcGtCLFNBQVEsQ0FBQy9FLFVBQVU7QUFDdEJ3bEIsY0FBUXpuQixVQUFVLE1BQU1pQyxPQUFPQSxNQUFNakIsT0FBTztBQUM1Q3ltQixjQUFRa0QsT0FBTyxNQUFNMW9CLEtBQUFBO0lBQ3ZCLENBQUE7RUFDRjtFQUtBZ3NDLGtCQUFrQjtBQUNoQixVQUFNMXFDLFdBQVcsS0FBS3VvQztBQUN0QixVQUFNaDdCLFVBQVUsS0FBS3hNLEtBQUt5RyxTQUFTOVA7QUFDbkMsVUFBTTRWLFVBQVV0TixTQUFTdEk7QUFFekJzSSxhQUFTK08sS0FBSyxDQUFDQyxHQUFHclAsTUFBTXFQLEVBQUU3TyxRQUFRUixFQUFFUSxLQUFLO0FBQ3pDLFFBQUltTixVQUFVQyxTQUFTO0FBQ3JCLGVBQVM1VixJQUFJNFYsU0FBUzVWLElBQUkyVixTQUFTLEVBQUUzVixHQUFHO0FBQ3RDLGFBQUtnekMsb0JBQW9CaHpDLENBQUFBO01BQzNCO0FBQ0FxSSxlQUFTOE4sT0FBT1AsU0FBU0QsVUFBVUMsT0FBQUE7O0FBRXJDLFNBQUtvN0Isa0JBQWtCM29DLFNBQVN5Z0IsTUFBTSxDQUFHMVIsRUFBQUEsS0FBSzgzQixjQUFjLFNBQVMsT0FBQSxDQUFBO0VBQ3ZFO0VBS0ErRCw4QkFBOEI7QUFDNUIsVUFBTSxFQUFDckMsV0FBV3ZvQyxVQUFVZSxNQUFNLEVBQUN5RyxTQUFBQSxFQUFTLElBQUk7QUFDaEQsUUFBSXhILFNBQVN0SSxTQUFTOFAsU0FBUzlQLFFBQVE7QUFDckMsYUFBTyxLQUFLc0w7O0FBRWRoRCxhQUFTdkosUUFBUSxDQUFDdUssTUFBTWIsV0FBVTtBQUNoQyxVQUFJcUgsU0FBUzlELE9BQU94RSxDQUFBQSxNQUFLQSxNQUFNOEIsS0FBS21iLFFBQVEsRUFBRXprQixXQUFXLEdBQUc7QUFDMUQsYUFBS2l6QyxvQkFBb0J4cUMsTUFBQUE7O0lBRTdCLENBQUE7RUFDRjtFQUVBMHFDLDJCQUEyQjtBQUN6QixVQUFNQyxpQkFBaUIsQ0FBQTtBQUN2QixVQUFNdGpDLFdBQVcsS0FBS3pHLEtBQUt5RztBQUMzQixRQUFJN1AsR0FBR3VJO0FBRVAsU0FBSzBxQyw0QkFBMkI7QUFFaEMsU0FBS2p6QyxJQUFJLEdBQUd1SSxPQUFPc0gsU0FBUzlQLFFBQVFDLElBQUl1SSxNQUFNdkksS0FBSztBQUNqRCxZQUFNb00sVUFBVXlELFNBQVM3UCxDQUFFO0FBQzNCLFVBQUlxSixPQUFPLEtBQUt5RyxlQUFlOVAsQ0FBQUE7QUFDL0IsWUFBTXZCLE9BQU8yTixRQUFRM04sUUFBUSxLQUFLa0csT0FBT2xHO0FBRXpDLFVBQUk0SyxLQUFLNUssUUFBUTRLLEtBQUs1SyxTQUFTQSxNQUFNO0FBQ25DLGFBQUt1MEMsb0JBQW9CaHpDLENBQUFBO0FBQ3pCcUosZUFBTyxLQUFLeUcsZUFBZTlQLENBQUFBOztBQUU3QnFKLFdBQUs1SyxPQUFPQTtBQUNaNEssV0FBS2lHLFlBQVlsRCxRQUFRa0QsYUFBYTQ3QixhQUFhenNDLE1BQU0sS0FBS3FILE9BQU87QUFDckV1RCxXQUFLK3BDLFFBQVFobkMsUUFBUWduQyxTQUFTO0FBQzlCL3BDLFdBQUtiLFFBQVF4STtBQUNicUosV0FBSzJKLFFBQVEsS0FBSzVHLFFBQVE0RztBQUMxQjNKLFdBQUtncUMsVUFBVSxLQUFLeHlCLGlCQUFpQjdnQixDQUFBQTtBQUVyQyxVQUFJcUosS0FBSzZCLFlBQVk7QUFDbkI3QixhQUFLNkIsV0FBVzBELFlBQVk1TyxDQUFBQTtBQUM1QnFKLGFBQUs2QixXQUFXb0QsV0FBVTthQUNyQjtBQUNMLGNBQU1nbEMsa0JBQWtCanNCLFNBQVNtaEIsY0FBYy9wQyxJQUFBQTtBQUMvQyxjQUFNLEVBQUMwUCxvQkFBb0JDLGdCQUFBQSxJQUFtQmpKLFNBQVMwSyxTQUFTcFIsSUFBSztBQUNyRXdHLGVBQU95QixPQUFPNHNDLGlCQUFpQjtVQUM3QmxsQyxpQkFBaUJpWixTQUFTQyxXQUFXbFosZUFBQUE7VUFDckNELG9CQUFvQkEsc0JBQXNCa1osU0FBU0MsV0FBV25aLGtCQUFBQTtRQUNoRSxDQUFBO0FBQ0E5RSxhQUFLNkIsYUFBYSxJQUFJb29DLGdCQUFnQixNQUFNdHpDLENBQUFBO0FBQzVDbXpDLHVCQUFlbnlDLEtBQUtxSSxLQUFLNkIsVUFBVTs7SUFFdkM7QUFFQSxTQUFLNm5DLGdCQUFlO0FBQ3BCLFdBQU9JO0VBQ1Q7RUFNQUksaUJBQWlCO0FBQ2ZyakIsU0FBSyxLQUFLOW1CLEtBQUt5RyxVQUFVLENBQUN6RCxTQUFTdEQsaUJBQWlCO0FBQ2xELFdBQUtnSCxlQUFlaEgsWUFBY29DLEVBQUFBLFdBQVcrRSxNQUFLO0lBQ3BELEdBQUcsSUFBSTtFQUNUO0VBS0FBLFFBQVE7QUFDTixTQUFLc2pDLGVBQWM7QUFDbkIsU0FBSzNWLGNBQWMsT0FBQTtFQUNyQjtFQUVBNTVCLE9BQU82RSxNQUFNO0FBQ1gsVUFBTWxFLFNBQVMsS0FBS0E7QUFFcEJBLFdBQU9YLE9BQU07QUFDYixVQUFNOEIsV0FBVSxLQUFLNHFDLFdBQVcvckMsT0FBT3FNLGVBQWVyTSxPQUFPc3BDLGtCQUFpQixHQUFJLEtBQUtoOUIsV0FBVSxDQUFBO0FBQ2pHLFVBQU11aUMsZ0JBQWdCLEtBQUsxK0Isc0JBQXNCLENBQUNoUCxTQUFRVjtBQUUxRCxTQUFLcXVDLGNBQWE7QUFDbEIsU0FBS0Msb0JBQW1CO0FBQ3hCLFNBQUtDLHFCQUFvQjtBQUl6QixTQUFLMUMsU0FBUzlHLFdBQVU7QUFFeEIsUUFBSSxLQUFLdk0sY0FBYyxnQkFBZ0I7TUFBQy8wQjtNQUFNcWhDLFlBQVk7SUFBSSxDQUFBLE1BQU8sT0FBTztBQUMxRTs7QUFJRixVQUFNaUosaUJBQWlCLEtBQUtELHlCQUF3QjtBQUVwRCxTQUFLdFYsY0FBYyxzQkFBQTtBQUduQixRQUFJOU4sYUFBYTtBQUNqQixhQUFTOXZCLElBQUksR0FBR3VJLE9BQU8sS0FBS2EsS0FBS3lHLFNBQVM5UCxRQUFRQyxJQUFJdUksTUFBTXZJLEtBQUs7QUFDL0QsWUFBTSxFQUFDa0wsV0FBVSxJQUFJLEtBQUs0RSxlQUFlOVAsQ0FBQUE7QUFDekMsWUFBTWlRLFFBQVEsQ0FBQ3VqQyxpQkFBaUJMLGVBQWVuM0IsUUFBUTlRLFVBQUFBLE1BQWdCO0FBR3ZFQSxpQkFBV3FGLHNCQUFzQk4sS0FBQUE7QUFDakM2ZixtQkFBYTV3QixLQUFLb0MsSUFBSSxDQUFDNEosV0FBVzRILGVBQWMsR0FBSWdkLFVBQUFBO0lBQ3REO0FBQ0FBLGlCQUFhLEtBQUs4akIsY0FBYzl0QyxTQUFRa25CLE9BQU82bUIsY0FBYy9qQixhQUFhO0FBQzFFLFNBQUtna0IsY0FBY2hrQixVQUFBQTtBQUduQixRQUFJLENBQUMwakIsZUFBZTtBQUdsQnRqQixXQUFLaWpCLGdCQUFnQixDQUFDam9DLGVBQWU7QUFDbkNBLG1CQUFXK0UsTUFBSztNQUNsQixDQUFBOztBQUdGLFNBQUs4akMsZ0JBQWdCbHJDLElBQUFBO0FBR3JCLFNBQUsrMEIsY0FBYyxlQUFlO01BQUMvMEI7SUFBSSxDQUFBO0FBRXZDLFNBQUs2bUIsUUFBUXRZLEtBQUs4M0IsY0FBYyxLQUFLLE1BQUEsQ0FBQTtBQUdyQyxVQUFNLEVBQUMvdUMsU0FBUzB3QyxXQUFVLElBQUk7QUFDOUIsUUFBSUEsWUFBWTtBQUNkLFdBQUttRCxjQUFjbkQsWUFBWSxJQUFJO2VBQzFCMXdDLFFBQVFKLFFBQVE7QUFDekIsV0FBS2swQyxtQkFBbUI5ekMsU0FBU0EsU0FBUyxJQUFJOztBQUdoRCxTQUFLK3hDLE9BQU07RUFDYjtFQUtBdUIsZ0JBQWdCO0FBQ2R2akIsU0FBSyxLQUFLcGtCLFFBQVEsQ0FBQy9FLFVBQVU7QUFDM0J3bEIsY0FBUXFELFVBQVUsTUFBTTdvQixLQUFBQTtJQUMxQixDQUFBO0FBRUEsU0FBS29yQyxvQkFBbUI7QUFDeEIsU0FBS0csb0JBQW1CO0VBQzFCO0VBS0FvQixzQkFBc0I7QUFDcEIsVUFBTTV0QyxXQUFVLEtBQUtBO0FBQ3JCLFVBQU1vdUMsaUJBQWlCLElBQUlsSCxJQUFJL25DLE9BQU9DLEtBQUssS0FBSzRyQyxVQUFVLENBQUE7QUFDMUQsVUFBTXFELFlBQVksSUFBSW5ILElBQUlsbkMsU0FBUXN1QyxNQUFNO0FBRXhDLFFBQUksQ0FBQ0MsVUFBVUgsZ0JBQWdCQyxTQUFBQSxLQUFjLENBQUMsQ0FBQyxLQUFLcEQseUJBQXlCanJDLFNBQVEyckMsWUFBWTtBQUUvRixXQUFLNkMsYUFBWTtBQUNqQixXQUFLM0MsV0FBVTs7RUFFbkI7RUFLQWdDLHVCQUF1QjtBQUNyQixVQUFNLEVBQUN6QyxlQUFBQSxJQUFrQjtBQUN6QixVQUFNcUQsVUFBVSxLQUFLQyx1QkFBc0IsS0FBTSxDQUFBO0FBQ2pELGVBQVcsRUFBQy92QyxRQUFRckYsT0FBT2dTLE1BQUFBLEtBQVVtakMsU0FBUztBQUM1QyxZQUFNeCtCLE9BQU90UixXQUFXLG9CQUFvQixDQUFDMk0sUUFBUUE7QUFDckQwK0Isc0JBQWdCb0IsZ0JBQWdCOXhDLE9BQU8yVyxJQUFBQTtJQUN6QztFQUNGO0VBS0F5K0IseUJBQXlCO0FBQ3ZCLFVBQU1sK0IsZUFBZSxLQUFLQTtBQUMxQixRQUFJLENBQUNBLGdCQUFnQixDQUFDQSxhQUFhdlcsUUFBUTtBQUN6Qzs7QUFHRixTQUFLdVcsZUFBZSxDQUFBO0FBQ3BCLFVBQU1tK0IsZUFBZSxLQUFLcnJDLEtBQUt5RyxTQUFTOVA7QUFDeEMsVUFBTTIwQyxVQUFVLENBQUM3VCxRQUFRLElBQUltTSxJQUMzQjEyQixhQUNHdkssT0FBTzhqQyxDQUFBQSxNQUFLQSxFQUFFLENBQUEsTUFBT2hQLEdBQUFBLEVBQ3JCcGQsSUFBSSxDQUFDb3NCLEdBQUc3dkMsTUFBTUEsSUFBSSxNQUFNNnZDLEVBQUUxNUIsT0FBTyxDQUFHeXhCLEVBQUFBLEtBQUssR0FBQSxDQUFBLENBQUE7QUFHOUMsVUFBTStNLFlBQVlELFFBQVEsQ0FBQTtBQUMxQixhQUFTMTBDLElBQUksR0FBR0EsSUFBSXkwQyxjQUFjejBDLEtBQUs7QUFDckMsVUFBSSxDQUFDcTBDLFVBQVVNLFdBQVdELFFBQVExMEMsQ0FBSyxDQUFBLEdBQUE7QUFDckM7O0lBRUo7QUFDQSxXQUFPNEosTUFBTTdILEtBQUs0eUMsU0FDZmx4QixFQUFBQSxJQUFJb3NCLENBQUFBLE1BQUtBLEVBQUVwSSxNQUFNLEdBQ2pCaGtCLENBQUFBLEVBQUFBLElBQUlwTSxDQUFBQSxPQUFNO01BQUM1UyxRQUFRNFMsRUFBRSxDQUFFO01BQUVqWSxPQUFPLENBQUNpWSxFQUFFLENBQUU7TUFBRWpHLE9BQU8sQ0FBQ2lHLEVBQUUsQ0FBRTtNQUFBO0VBQ3hEO0VBT0F5OEIsY0FBY2hrQixZQUFZO0FBQ3hCLFFBQUksS0FBSzhOLGNBQWMsZ0JBQWdCO01BQUNzTSxZQUFZO0lBQUksQ0FBQSxNQUFPLE9BQU87QUFDcEU7O0FBR0YzZCxZQUFRdm9CLE9BQU8sTUFBTSxLQUFLc1gsT0FBTyxLQUFLRCxRQUFReVUsVUFBQUE7QUFFOUMsVUFBTXpjLE9BQU8sS0FBS0M7QUFDbEIsVUFBTXNoQyxTQUFTdmhDLEtBQUtpSSxTQUFTLEtBQUtqSSxLQUFLZ0ksVUFBVTtBQUVqRCxTQUFLcVUsVUFBVSxDQUFBO0FBQ2ZRLFNBQUssS0FBSy9ELE9BQU8sQ0FBQ0osUUFBUTtBQUN4QixVQUFJNm9CLFVBQVU3b0IsSUFBSXpDLGFBQWEsYUFBYTtBQUUxQzs7QUFLRixVQUFJeUMsSUFBSWpuQixXQUFXO0FBQ2pCaW5CLFlBQUlqbkIsVUFBUzs7QUFFZixXQUFLNHFCLFFBQVExdUIsS0FBSSxHQUFJK3FCLElBQUkyRCxRQUFPLENBQUE7SUFDbEMsR0FBRyxJQUFJO0FBRVAsU0FBS0EsUUFBUTV3QixRQUFRLENBQUNvQixNQUFNc0ksV0FBVTtBQUNwQ3RJLFdBQUsyMEMsT0FBT3JzQztJQUNkLENBQUE7QUFFQSxTQUFLbzFCLGNBQWMsYUFBQTtFQUNyQjtFQU9BbVcsZ0JBQWdCbHJDLE1BQU07QUFDcEIsUUFBSSxLQUFLKzBCLGNBQWMsd0JBQXdCO01BQUMvMEI7TUFBTXFoQyxZQUFZO0lBQUksQ0FBQSxNQUFPLE9BQU87QUFDbEY7O0FBR0YsYUFBU2xxQyxJQUFJLEdBQUd1SSxPQUFPLEtBQUthLEtBQUt5RyxTQUFTOVAsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDL0QsV0FBSzhQLGVBQWU5UCxDQUFHa0wsRUFBQUEsV0FBV3BHLFVBQVM7SUFDN0M7QUFFQSxhQUFTOUUsSUFBSSxHQUFHdUksT0FBTyxLQUFLYSxLQUFLeUcsU0FBUzlQLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQy9ELFdBQUs4MEMsZUFBZTkwQyxHQUFHc3VDLFdBQVd6bEMsSUFBQUEsSUFBUUEsS0FBSztRQUFDQyxjQUFjOUk7TUFBQyxDQUFBLElBQUs2SSxJQUFJO0lBQzFFO0FBRUEsU0FBSyswQixjQUFjLHVCQUF1QjtNQUFDLzBCO0lBQUksQ0FBQTtFQUNqRDtFQU9BaXNDLGVBQWV0c0MsUUFBT0ssTUFBTTtBQUMxQixVQUFNUSxPQUFPLEtBQUt5RyxlQUFldEgsTUFBQUE7QUFDakMsVUFBTTZOLE9BQU87TUFBQ2hOO01BQU1iLE9BQUFBO01BQU9LO01BQU1xaEMsWUFBWTtJQUFJO0FBRWpELFFBQUksS0FBS3RNLGNBQWMsdUJBQXVCdm5CLElBQUFBLE1BQVUsT0FBTztBQUM3RDs7QUFHRmhOLFNBQUs2QixXQUFXekwsUUFBUW9KLElBQUFBO0FBRXhCd04sU0FBSzZ6QixhQUFhO0FBQ2xCLFNBQUt0TSxjQUFjLHNCQUFzQnZuQixJQUFBQTtFQUMzQztFQUVBNjdCLFNBQVM7QUFDUCxRQUFJLEtBQUt0VSxjQUFjLGdCQUFnQjtNQUFDc00sWUFBWTtJQUFJLENBQUEsTUFBTyxPQUFPO0FBQ3BFOztBQUdGLFFBQUl2akMsU0FBU3pGLElBQUksSUFBSSxHQUFHO0FBQ3RCLFVBQUksS0FBS2l3QyxZQUFZLENBQUN4cUMsU0FBUzlHLFFBQVEsSUFBSSxHQUFHO0FBQzVDOEcsaUJBQVN2SCxNQUFNLElBQUk7O1dBRWhCO0FBQ0wsV0FBS2EsS0FBSTtBQUNUb3ZDLDJCQUFxQjtRQUFDL3dDLE9BQU87TUFBSSxDQUFBOztFQUVyQztFQUVBMkIsT0FBTztBQUNMLFFBQUlEO0FBQ0osUUFBSSxLQUFLOHhDLG1CQUFtQjtBQUMxQixZQUFNLEVBQUN4MkIsT0FBT0QsT0FBQUEsSUFBVSxLQUFLeTJCO0FBRTdCLFdBQUtBLG9CQUFvQjtBQUN6QixXQUFLRCxRQUFRdjJCLE9BQU9ELE1BQUFBOztBQUV0QixTQUFLcXlCLE1BQUs7QUFFVixRQUFJLEtBQUtweUIsU0FBUyxLQUFLLEtBQUtELFVBQVUsR0FBRztBQUN2Qzs7QUFHRixRQUFJLEtBQUt1aUIsY0FBYyxjQUFjO01BQUNzTSxZQUFZO0lBQUksQ0FBQSxNQUFPLE9BQU87QUFDbEU7O0FBTUYsVUFBTTZLLFNBQVMsS0FBS3JsQjtBQUNwQixTQUFLMXZCLElBQUksR0FBR0EsSUFBSSswQyxPQUFPaDFDLFVBQVVnMUMsT0FBTy8wQyxDQUFBQSxFQUFHMnZCLEtBQUssR0FBRyxFQUFFM3ZCLEdBQUc7QUFDdEQrMEMsYUFBTy8wQyxDQUFFLEVBQUNDLEtBQUssS0FBS3FULFNBQVM7SUFDL0I7QUFFQSxTQUFLMGhDLGNBQWE7QUFHbEIsV0FBT2gxQyxJQUFJKzBDLE9BQU9oMUMsUUFBUSxFQUFFQyxHQUFHO0FBQzdCKzBDLGFBQU8vMEMsQ0FBRSxFQUFDQyxLQUFLLEtBQUtxVCxTQUFTO0lBQy9CO0FBRUEsU0FBS3NxQixjQUFjLFdBQUE7RUFDckI7RUFLQXQxQix1QkFBdUJGLGVBQWU7QUFDcEMsVUFBTUMsV0FBVyxLQUFLMm9DO0FBQ3RCLFVBQU1wb0IsU0FBUyxDQUFBO0FBQ2YsUUFBSTVvQixHQUFHdUk7QUFFUCxTQUFLdkksSUFBSSxHQUFHdUksT0FBT0YsU0FBU3RJLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ2pELFlBQU1xSixPQUFPaEIsU0FBU3JJLENBQUU7QUFDeEIsVUFBSSxDQUFDb0ksaUJBQWlCaUIsS0FBS2dxQyxTQUFTO0FBQ2xDenFCLGVBQU81bkIsS0FBS3FJLElBQUFBOztJQUVoQjtBQUVBLFdBQU91ZjtFQUNUO0VBTUFZLCtCQUErQjtBQUM3QixXQUFPLEtBQUtsaEIsdUJBQXVCLElBQUk7RUFDekM7RUFPQTBzQyxnQkFBZ0I7QUFDZCxRQUFJLEtBQUtwWCxjQUFjLHNCQUFzQjtNQUFDc00sWUFBWTtJQUFJLENBQUEsTUFBTyxPQUFPO0FBQzFFOztBQUdGLFVBQU03aEMsV0FBVyxLQUFLbWhCLDZCQUE0QjtBQUNsRCxhQUFTeHBCLElBQUlxSSxTQUFTdEksU0FBUyxHQUFHQyxLQUFLLEdBQUcsRUFBRUEsR0FBRztBQUM3QyxXQUFLaTFDLGFBQWE1c0MsU0FBU3JJLENBQUUsQ0FBQTtJQUMvQjtBQUVBLFNBQUs0OUIsY0FBYyxtQkFBQTtFQUNyQjtFQU9BcVgsYUFBYTVyQyxNQUFNO0FBQ2pCLFVBQU1nRSxNQUFNLEtBQUtBO0FBQ2pCLFVBQU1nSixPQUFPO01BQ1hoTjtNQUNBYixPQUFPYSxLQUFLYjtNQUNaMGhDLFlBQVk7SUFDZDtBQUVBLFVBQU0vMkIsT0FBTytoQyxtQkFBbUIsTUFBTTdyQyxJQUFBQTtBQUV0QyxRQUFJLEtBQUt1MEIsY0FBYyxxQkFBcUJ2bkIsSUFBQUEsTUFBVSxPQUFPO0FBQzNEOztBQUdGLFFBQUlsRCxNQUFNO0FBQ1J5eUIsZUFBU3Y0QixLQUFLOEYsSUFBQUE7O0FBR2hCOUosU0FBSzZCLFdBQVdqTCxLQUFJO0FBRXBCLFFBQUlrVCxNQUFNO0FBQ1I0eUIsaUJBQVcxNEIsR0FBQUE7O0FBR2JnSixTQUFLNnpCLGFBQWE7QUFDbEIsU0FBS3RNLGNBQWMsb0JBQW9Cdm5CLElBQUFBO0VBQ3pDO0VBT0FpVSxjQUFjaE0sT0FBTztBQUNuQixXQUFPa00sZUFBZWxNLE9BQU8sS0FBS2hMLFdBQVcsS0FBS3NnQyxXQUFXO0VBQy9EO0VBRUF1QiwwQkFBMEJoeEIsR0FBR3RiLE1BQU0vQyxVQUFTc2tCLGtCQUFrQjtBQUM1RCxVQUFNM2xCLFNBQVMyd0MsWUFBWTdwQixNQUFNMWlCLElBQUs7QUFDdEMsUUFBSSxPQUFPcEUsV0FBVyxZQUFZO0FBQ2hDLGFBQU9BLE9BQU8sTUFBTTBmLEdBQUdyZSxVQUFTc2tCLGdCQUFBQTs7QUFHbEMsV0FBTyxDQUFBO0VBQ1Q7RUFFQXRhLGVBQWVoSCxjQUFjO0FBQzNCLFVBQU1zRCxVQUFVLEtBQUtoRCxLQUFLeUcsU0FBUy9HLFlBQWE7QUFDaEQsVUFBTVQsV0FBVyxLQUFLdW9DO0FBQ3RCLFFBQUl2bkMsT0FBT2hCLFNBQVMwRCxPQUFPeEUsQ0FBQUEsTUFBS0EsS0FBS0EsRUFBRWlkLGFBQWFwWSxPQUFBQSxFQUFTOUwsSUFBRztBQUVoRSxRQUFJLENBQUMrSSxNQUFNO0FBQ1RBLGFBQU87UUFDTDVLLE1BQU07UUFDTjJLLE1BQU0sQ0FBQTtRQUNOZ0QsU0FBUztRQUNUbEIsWUFBWTtRQUNaK0IsUUFBUTtRQUNSK0IsU0FBUztRQUNURyxTQUFTO1FBQ1Rpa0MsT0FBT2huQyxXQUFXQSxRQUFRZ25DLFNBQVM7UUFDbkM1cUMsT0FBT007UUFDUDBiLFVBQVVwWTtRQUNWTSxTQUFTLENBQUE7UUFDVDRFLFNBQVM7TUFDWDtBQUNBakosZUFBU3JILEtBQUtxSSxJQUFBQTs7QUFHaEIsV0FBT0E7RUFDVDtFQUVBNEgsYUFBYTtBQUNYLFdBQU8sS0FBS2hELGFBQWEsS0FBS0EsV0FBVzlCLGNBQWMsTUFBTTtNQUFDN04sT0FBTztNQUFNRyxNQUFNO0tBQVE7RUFDM0Y7RUFFQXluQix5QkFBeUI7QUFDdkIsV0FBTyxLQUFLc0QsNkJBQTRCLEVBQUd6cEI7RUFDN0M7RUFFQThnQixpQkFBaUIvWCxjQUFjO0FBQzdCLFVBQU1zRCxVQUFVLEtBQUtoRCxLQUFLeUcsU0FBUy9HLFlBQWE7QUFDaEQsUUFBSSxDQUFDc0QsU0FBUztBQUNaLGFBQU87O0FBR1QsVUFBTS9DLE9BQU8sS0FBS3lHLGVBQWVoSCxZQUFBQTtBQUlqQyxXQUFPLE9BQU9PLEtBQUs0RCxXQUFXLFlBQVksQ0FBQzVELEtBQUs0RCxTQUFTLENBQUNiLFFBQVFhO0VBQ3BFO0VBRUFvb0MscUJBQXFCdnNDLGNBQWN1cUMsU0FBUztBQUMxQyxVQUFNaHFDLE9BQU8sS0FBS3lHLGVBQWVoSCxZQUFBQTtBQUNqQ08sU0FBSzRELFNBQVMsQ0FBQ29tQztFQUNqQjtFQUVBaHZCLHFCQUFxQjdiLFFBQU87QUFDMUIsU0FBSzBvQyxlQUFlMW9DLE1BQU0sSUFBRyxDQUFDLEtBQUswb0MsZUFBZTFvQyxNQUFNO0VBQzFEO0VBRUFzVSxrQkFBa0J0VSxRQUFPO0FBQ3ZCLFdBQU8sQ0FBQyxLQUFLMG9DLGVBQWUxb0MsTUFBTTtFQUNwQztFQUtBOHNDLGtCQUFrQnhzQyxjQUFjeUQsV0FBVzhtQyxTQUFTO0FBQ2xELFVBQU14cUMsT0FBT3dxQyxVQUFVLFNBQVM7QUFDaEMsVUFBTWhxQyxPQUFPLEtBQUt5RyxlQUFlaEgsWUFBQUE7QUFDakMsVUFBTXZLLFFBQVE4SyxLQUFLNkIsV0FBV3FKLG1CQUFtQm5XLFFBQVd5SyxJQUFBQTtBQUU1RCxRQUFJb0wsUUFBUTFILFNBQVksR0FBQTtBQUN0QmxELFdBQUtELEtBQUttRCxTQUFBQSxFQUFXVSxTQUFTLENBQUNvbUM7QUFDL0IsV0FBS3J2QyxPQUFNO1dBQ047QUFDTCxXQUFLcXhDLHFCQUFxQnZzQyxjQUFjdXFDLE9BQUFBO0FBRXhDOTBDLFlBQU15RixPQUFPcUYsTUFBTTtRQUFDZ3FDO01BQU8sQ0FBQTtBQUMzQixXQUFLcnZDLE9BQU8sQ0FBQ3FKLFFBQVFBLElBQUl2RSxpQkFBaUJBLGVBQWVELE9BQU96SyxNQUFTOztFQUU3RTtFQUVBbTNDLEtBQUt6c0MsY0FBY3lELFdBQVc7QUFDNUIsU0FBSytvQyxrQkFBa0J4c0MsY0FBY3lELFdBQVcsS0FBSztFQUN2RDtFQUVBaXBDLEtBQUsxc0MsY0FBY3lELFdBQVc7QUFDNUIsU0FBSytvQyxrQkFBa0J4c0MsY0FBY3lELFdBQVcsSUFBSTtFQUN0RDtFQUtBeW1DLG9CQUFvQmxxQyxjQUFjO0FBQ2hDLFVBQU1PLE9BQU8sS0FBS3VuQyxVQUFVOW5DLFlBQWE7QUFDekMsUUFBSU8sUUFBUUEsS0FBSzZCLFlBQVk7QUFDM0I3QixXQUFLNkIsV0FBV2dGLFNBQVE7O0FBRTFCLFdBQU8sS0FBSzBnQyxVQUFVOW5DLFlBQWE7RUFDckM7RUFFQTJzQyxRQUFRO0FBQ04sUUFBSXoxQyxHQUFHdUk7QUFDUCxTQUFLL0csS0FBSTtBQUNUbUYsYUFBU2pGLE9BQU8sSUFBSTtBQUVwQixTQUFLMUIsSUFBSSxHQUFHdUksT0FBTyxLQUFLYSxLQUFLeUcsU0FBUzlQLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQzNELFdBQUtnekMsb0JBQW9CaHpDLENBQUFBO0lBQzNCO0VBQ0Y7RUFFQTAxQyxVQUFVO0FBQ1IsU0FBSzlYLGNBQWMsZUFBQTtBQUNuQixVQUFNLEVBQUNyTixRQUFRbGpCLElBQUcsSUFBSTtBQUV0QixTQUFLb29DLE1BQUs7QUFDVixTQUFLOXdDLE9BQU84b0MsV0FBVTtBQUV0QixRQUFJbGQsUUFBUTtBQUNWLFdBQUsrakIsYUFBWTtBQUNqQjFDLGtCQUFZcmhCLFFBQVFsakIsR0FBQUE7QUFDcEIsV0FBS21nQyxTQUFTaGQsZUFBZW5qQixHQUFBQTtBQUM3QixXQUFLa2pCLFNBQVM7QUFDZCxXQUFLbGpCLE1BQU07O0FBR2IsV0FBT3NpQyxVQUFVLEtBQUt6bEMsRUFBRTtBQUV4QixTQUFLMHpCLGNBQWMsY0FBQTtFQUNyQjtFQUVBK1gsaUJBQWlCdC9CLE1BQU07QUFDckIsV0FBTyxLQUFLa2EsT0FBT3FsQixVQUFhdi9CLEdBQUFBLElBQUFBO0VBQ2xDO0VBS0FzN0IsYUFBYTtBQUNYLFNBQUtrRSxlQUFjO0FBQ25CLFFBQUksS0FBSy92QyxRQUFRMnJDLFlBQVk7QUFDM0IsV0FBS3FFLHFCQUFvQjtXQUNwQjtBQUNMLFdBQUszRSxXQUFXOztFQUVwQjtFQUtBMEUsaUJBQWlCO0FBQ2YsVUFBTWwzQyxZQUFZLEtBQUtteUM7QUFDdkIsVUFBTXRELFdBQVcsS0FBS0E7QUFFdEIsVUFBTXVJLE9BQU8sQ0FBQ3QzQyxNQUFNaXlCLGNBQWE7QUFDL0I4YyxlQUFTL2MsaUJBQWlCLE1BQU1oeUIsTUFBTWl5QixTQUFBQTtBQUN0Qy94QixnQkFBVUYsSUFBQUEsSUFBUWl5QjtJQUNwQjtBQUVBLFVBQU1BLFdBQVcsQ0FBQ3ZNLEdBQUc1YyxHQUFHQyxNQUFNO0FBQzVCMmMsUUFBRW5GLFVBQVV6WDtBQUNaNGMsUUFBRWxGLFVBQVV6WDtBQUNaLFdBQUt3c0MsY0FBYzd2QixDQUFBQTtJQUNyQjtBQUVBK0wsU0FBSyxLQUFLcHFCLFFBQVFzdUMsUUFBUSxDQUFDMzFDLFNBQVNzM0MsS0FBS3QzQyxNQUFNaXlCLFFBQUFBLENBQUFBO0VBQ2pEO0VBS0FvbEIsdUJBQXVCO0FBQ3JCLFFBQUksQ0FBQyxLQUFLL0Usc0JBQXNCO0FBQzlCLFdBQUtBLHVCQUF1QixDQUFBOztBQUU5QixVQUFNcHlDLFlBQVksS0FBS295QztBQUN2QixVQUFNdkQsV0FBVyxLQUFLQTtBQUV0QixVQUFNdUksT0FBTyxDQUFDdDNDLE1BQU1peUIsY0FBYTtBQUMvQjhjLGVBQVMvYyxpQkFBaUIsTUFBTWh5QixNQUFNaXlCLFNBQUFBO0FBQ3RDL3hCLGdCQUFVRixJQUFBQSxJQUFRaXlCO0lBQ3BCO0FBQ0EsVUFBTXNsQixVQUFVLENBQUN2M0MsTUFBTWl5QixjQUFhO0FBQ2xDLFVBQUkveEIsVUFBVUYsSUFBQUEsR0FBTztBQUNuQit1QyxpQkFBUzdjLG9CQUFvQixNQUFNbHlCLE1BQU1peUIsU0FBQUE7QUFDekMsZUFBTy94QixVQUFVRixJQUFLOztJQUUxQjtBQUVBLFVBQU1peUIsV0FBVyxDQUFDcFYsT0FBT0QsV0FBVztBQUNsQyxVQUFJLEtBQUtrVixRQUFRO0FBQ2YsYUFBSzBELE9BQU8zWSxPQUFPRCxNQUFBQTs7SUFFdkI7QUFFQSxRQUFJNDZCO0FBQ0osVUFBTTlFLFdBQVcsTUFBTTtBQUNyQjZFLGNBQVEsVUFBVTdFLFFBQUFBO0FBRWxCLFdBQUtBLFdBQVc7QUFDaEIsV0FBS2xkLE9BQU07QUFFWDhoQixXQUFLLFVBQVVybEIsUUFBQUE7QUFDZnFsQixXQUFLLFVBQVVFLFFBQUFBO0lBQ2pCO0FBRUFBLGVBQVcsTUFBTTtBQUNmLFdBQUs5RSxXQUFXO0FBRWhCNkUsY0FBUSxVQUFVdGxCLFFBQUFBO0FBR2xCLFdBQUsra0IsTUFBSztBQUNWLFdBQUs1RCxRQUFRLEdBQUcsQ0FBQTtBQUVoQmtFLFdBQUssVUFBVTVFLFFBQUFBO0lBQ2pCO0FBRUEsUUFBSTNELFNBQVMxYyxXQUFXLEtBQUtQLE1BQU0sR0FBRztBQUNwQzRnQixlQUFBQTtXQUNLO0FBQ0w4RSxlQUFBQTs7RUFFSjtFQUtBM0IsZUFBZTtBQUNicGtCLFNBQUssS0FBSzRnQixZQUFZLENBQUNwZ0IsVUFBVWp5QixTQUFTO0FBQ3hDLFdBQUsrdUMsU0FBUzdjLG9CQUFvQixNQUFNbHlCLE1BQU1peUIsUUFBQUE7SUFDaEQsQ0FBQTtBQUNBLFNBQUtvZ0IsYUFBYSxDQUFBO0FBRWxCNWdCLFNBQUssS0FBSzZnQixzQkFBc0IsQ0FBQ3JnQixVQUFVanlCLFNBQVM7QUFDbEQsV0FBSyt1QyxTQUFTN2Msb0JBQW9CLE1BQU1seUIsTUFBTWl5QixRQUFBQTtJQUNoRCxDQUFBO0FBQ0EsU0FBS3FnQix1QkFBdUIzeUM7RUFDOUI7RUFFQTgzQyxpQkFBaUJwMkMsT0FBTytJLE1BQU02dEIsU0FBUztBQUNyQyxVQUFNeWYsU0FBU3pmLFVBQVUsUUFBUTtBQUNqQyxRQUFJcnRCLE1BQU1uSixNQUFNRixHQUFHdUk7QUFFbkIsUUFBSU0sU0FBUyxXQUFXO0FBQ3RCUSxhQUFPLEtBQUt5RyxlQUFlaFEsTUFBTSxDQUFBLEVBQUdnSixZQUFZO0FBQ2hETyxXQUFLNkIsV0FBVyxNQUFNaXJDLFNBQVMsbUJBQW9CLEVBQUE7O0FBR3JELFNBQUtuMkMsSUFBSSxHQUFHdUksT0FBT3pJLE1BQU1DLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQzlDRSxhQUFPSixNQUFNRSxDQUFFO0FBQ2YsWUFBTWtMLGFBQWFoTCxRQUFRLEtBQUs0UCxlQUFlNVAsS0FBSzRJLFlBQVksRUFBRW9DO0FBQ2xFLFVBQUlBLFlBQVk7QUFDZEEsbUJBQVdpckMsU0FBUyxZQUFBLEVBQWNqMkMsS0FBS29NLFNBQVNwTSxLQUFLNEksY0FBYzVJLEtBQUtzSSxLQUFLOztJQUVqRjtFQUNGO0VBTUE0dEMsb0JBQW9CO0FBQ2xCLFdBQU8sS0FBS2oyQyxXQUFXLENBQUE7RUFDekI7RUFNQWsyQyxrQkFBa0JDLGdCQUFnQjtBQUNoQyxVQUFNQyxhQUFhLEtBQUtwMkMsV0FBVyxDQUFBO0FBQ25DLFVBQU00RCxTQUFTdXlDLGVBQWU3eUIsSUFBSSxDQUFDLEVBQUMzYSxjQUFjTixPQUFBQSxPQUFLLE1BQU07QUFDM0QsWUFBTWEsT0FBTyxLQUFLeUcsZUFBZWhILFlBQUFBO0FBQ2pDLFVBQUksQ0FBQ08sTUFBTTtBQUNULGNBQU0sSUFBSW9lLE1BQU0sK0JBQStCM2UsWUFBYzs7QUFHL0QsYUFBTztRQUNMQTtRQUNBd0QsU0FBU2pELEtBQUtELEtBQUtaLE1BQU07UUFDekJBLE9BQUFBO01BQ0Y7SUFDRixDQUFBO0FBQ0EsVUFBTTRtQixVQUFVLENBQUNvbkIsZUFBZXp5QyxRQUFRd3lDLFVBQUFBO0FBRXhDLFFBQUlubkIsU0FBUztBQUNYLFdBQUtqdkIsVUFBVTREO0FBRWYsV0FBSzhzQyxhQUFhO0FBQ2xCLFdBQUtvRCxtQkFBbUJsd0MsUUFBUXd5QyxVQUFBQTs7RUFFcEM7RUFXQTNZLGNBQWNnTSxNQUFNdnpCLE1BQU10SyxRQUFRO0FBQ2hDLFdBQU8sS0FBS2tsQyxTQUFTdEgsT0FBTyxNQUFNQyxNQUFNdnpCLE1BQU10SyxNQUFBQTtFQUNoRDtFQU9BMEMsZ0JBQWdCZ29DLFVBQVU7QUFDeEIsV0FBTyxLQUFLeEYsU0FBU2w2QixPQUFPaEwsT0FBTzZpQyxDQUFBQSxNQUFLQSxFQUFFNUUsT0FBTzkvQixPQUFPdXNDLFFBQUFBLEVBQVUxMkMsV0FBVztFQUMvRTtFQUtBazBDLG1CQUFtQmx3QyxRQUFRd3lDLFlBQVlHLFFBQVE7QUFDN0MsVUFBTUMsZUFBZSxLQUFLN3dDLFFBQVE4d0M7QUFDbEMsVUFBTTN1QixPQUFPLENBQUM1USxHQUFHclAsTUFBTXFQLEVBQUV0TCxPQUFPeEUsQ0FBQUEsTUFBSyxDQUFDUyxFQUFFeWlDLEtBQUtqakMsQ0FBQUEsTUFBS0QsRUFBRXVCLGlCQUFpQnRCLEVBQUVzQixnQkFBZ0J2QixFQUFFaUIsVUFBVWhCLEVBQUVnQixLQUFLLENBQUE7QUFDMUcsVUFBTXF1QyxjQUFjNXVCLEtBQUtzdUIsWUFBWXh5QyxNQUFBQTtBQUNyQyxVQUFNK3lDLFlBQVlKLFNBQVMzeUMsU0FBU2trQixLQUFLbGtCLFFBQVF3eUMsVUFBVztBQUU1RCxRQUFJTSxZQUFZOTJDLFFBQVE7QUFDdEIsV0FBS20yQyxpQkFBaUJXLGFBQWFGLGFBQWE5dEMsTUFBTSxLQUFLOztBQUc3RCxRQUFJaXVDLFVBQVUvMkMsVUFBVTQyQyxhQUFhOXRDLE1BQU07QUFDekMsV0FBS3F0QyxpQkFBaUJZLFdBQVdILGFBQWE5dEMsTUFBTSxJQUFJOztFQUU1RDtFQUtBbXJDLGNBQWM3dkIsR0FBR3V5QixRQUFRO0FBQ3ZCLFVBQU1yZ0MsT0FBTztNQUNYdlYsT0FBT3FqQjtNQUNQdXlCO01BQ0F4TSxZQUFZO01BQ1pnRyxhQUFhLEtBQUs1bEIsY0FBY25HLENBQUFBO0lBQ2xDO0FBQ0EsVUFBTTR5QixjQUFjLENBQUMvTSxZQUFZQSxPQUFPbGtDLFFBQVFzdUMsVUFBVSxLQUFLdHVDLFFBQVFzdUMsUUFBUTNuQixTQUFTdEksRUFBRXlPLE9BQU9uMEIsSUFBSTtBQUVyRyxRQUFJLEtBQUttL0IsY0FBYyxlQUFldm5CLE1BQU0wZ0MsV0FBQUEsTUFBaUIsT0FBTztBQUNsRTs7QUFHRixVQUFNM25CLFVBQVUsS0FBSzRuQixhQUFhN3lCLEdBQUd1eUIsUUFBUXJnQyxLQUFLNjVCLFdBQVc7QUFFN0Q3NUIsU0FBSzZ6QixhQUFhO0FBQ2xCLFNBQUt0TSxjQUFjLGNBQWN2bkIsTUFBTTBnQyxXQUFBQTtBQUV2QyxRQUFJM25CLFdBQVcvWSxLQUFLK1ksU0FBUztBQUMzQixXQUFLOGlCLE9BQU07O0FBR2IsV0FBTztFQUNUO0VBVUE4RSxhQUFhN3lCLEdBQUd1eUIsUUFBUXhHLGFBQWE7QUFDbkMsVUFBTSxFQUFDL3ZDLFNBQVNvMkMsYUFBYSxDQUFBLEdBQUl6d0MsU0FBQUEsU0FBQUEsSUFBVztBQWU1QyxVQUFNc2tCLG1CQUFtQnNzQjtBQUN6QixVQUFNM3lDLFNBQVMsS0FBS2t6QyxtQkFBbUI5eUIsR0FBR295QixZQUFZckcsYUFBYTlsQixnQkFBQUE7QUFDbkUsVUFBTStsQixVQUFVK0csY0FBYy95QixDQUFBQTtBQUM5QixVQUFNOHJCLFlBQVlELG1CQUFtQjdyQixHQUFHLEtBQUswc0IsWUFBWVgsYUFBYUMsT0FBQUE7QUFFdEUsUUFBSUQsYUFBYTtBQUdmLFdBQUtXLGFBQWE7QUFHbEI1RyxlQUFhbmtDLFNBQVFxeEMsU0FBUztRQUFDaHpCO1FBQUdwZ0I7UUFBUTtNQUFLLEdBQUUsSUFBSTtBQUVyRCxVQUFJb3NDLFNBQVM7QUFDWGxHLGlCQUFhbmtDLFNBQVFvZSxTQUFTO1VBQUNDO1VBQUdwZ0I7VUFBUTtRQUFLLEdBQUUsSUFBSTs7O0FBSXpELFVBQU1xckIsVUFBVSxDQUFDb25CLGVBQWV6eUMsUUFBUXd5QyxVQUFBQTtBQUN4QyxRQUFJbm5CLFdBQVdzbkIsUUFBUTtBQUNyQixXQUFLdjJDLFVBQVU0RDtBQUNmLFdBQUtrd0MsbUJBQW1CbHdDLFFBQVF3eUMsWUFBWUcsTUFBQUE7O0FBRzlDLFNBQUs3RixhQUFhWjtBQUVsQixXQUFPN2dCO0VBQ1Q7RUFVQTZuQixtQkFBbUI5eUIsR0FBR295QixZQUFZckcsYUFBYTlsQixrQkFBa0I7QUFDL0QsUUFBSWpHLEVBQUUxbEIsU0FBUyxZQUFZO0FBQ3pCLGFBQU8sQ0FBQTs7QUFHVCxRQUFJLENBQUN5eEMsYUFBYTtBQUVoQixhQUFPcUc7O0FBR1QsVUFBTUksZUFBZSxLQUFLN3dDLFFBQVE4d0M7QUFDbEMsV0FBTyxLQUFLekIsMEJBQTBCaHhCLEdBQUd3eUIsYUFBYTl0QyxNQUFNOHRDLGNBQWN2c0IsZ0JBQUFBO0VBQzVFO0FBQ0Y7QUFyb0NFLGNBRklnbUIsT0FFR2pyQyxZQUFXQTtBQUNsQixjQUhJaXJDLE9BR0dULGFBQVlBO0FBQ25CLGNBSklTLE9BSUd2eUIsYUFBWUE7QUFDbkIsY0FMSXV5QixPQUtHL29CLFlBQVdBO0FBQ2xCLGNBTkkrb0IsT0FNR2dILFdBQVVBO0FBQ2pCLGNBUEloSCxPQU9HUixZQUFXQTtBQW1vQ3BCLFNBQVNTLG9CQUFvQjtBQUMzQixTQUFPbmdCLEtBQUtrZ0IsTUFBTVQsV0FBVyxDQUFDcnhDLFVBQVVBLE1BQU0yeUMsU0FBUzlHLFdBQVUsQ0FBQTtBQUNuRTtBQzV1Q0EsU0FBU2tOLFNBQVNocUMsS0FBK0JmLFNBQXFCOFMsVUFBa0I7QUFDdEYsUUFBTSxFQUFDRCxZQUFZNVgsR0FBR0MsR0FBRytZLGFBQWFELGFBQWF4YSxTQUFBQSxTQUFBQSxJQUFXd0c7QUFDOUQsUUFBTSxFQUFDcVcsYUFBYTIwQixnQkFBQUEsSUFBbUJ4eEM7QUFDdkMsUUFBTXl4QyxpQkFBaUJyNEMsS0FBS0MsSUFBSXdqQixjQUFjcEMsYUFBYWkzQixnQkFBZ0JyNEIsYUFBYUMsUUFBQUEsQ0FBQUE7QUFDeEYvUixNQUFJKzNCLFVBQVM7QUFDYi8zQixNQUFJaVYsSUFBSS9hLEdBQUdDLEdBQUcrWSxjQUFjb0MsY0FBYyxHQUFHeEQsYUFBYW80QixpQkFBaUIsR0FBR240QixXQUFXbTRCLGlCQUFpQixDQUFBO0FBRTFHLE1BQUlqM0IsY0FBYyxHQUFHO0FBQ25CLFVBQU1tM0IsaUJBQWlCdjRDLEtBQUtDLElBQUl3akIsY0FBY3JDLGFBQWFrM0IsZ0JBQWdCcjRCLGFBQWFDLFFBQUFBLENBQUFBO0FBQ3hGL1IsUUFBSWlWLElBQUkvYSxHQUFHQyxHQUFHOFksY0FBY3FDLGNBQWMsR0FBR3ZELFdBQVdxNEIsaUJBQWlCLEdBQUd0NEIsYUFBYXM0QixpQkFBaUIsR0FBRyxJQUFJO1NBQzVHO0FBQ0wsVUFBTUMsWUFBWXg0QyxLQUFLQyxJQUFJd2pCLGNBQWMsR0FBR3BDLGNBQWNpM0IsZ0JBQWdCcjRCLGFBQWFDLFFBQUFBLENBQUFBO0FBRXZGLFFBQUlrNEIsb0JBQW9CLFNBQVM7QUFDL0JqcUMsVUFBSWlWLElBQUkvYSxHQUFHQyxHQUFHa3dDLFdBQVd0NEIsV0FBV2UsS0FBSyxHQUFHaEIsYUFBYWdCLEtBQUssR0FBRyxJQUFJO2VBQzVEbTNCLG9CQUFvQixTQUFTO0FBQ3RDLFlBQU12dkMsSUFBSSxJQUFJMnZDLFlBQVlBO0FBQzFCLFlBQU1qNEIsT0FBTyxDQUFDMVgsSUFBSTdJLEtBQUtvZ0IsSUFBSUYsV0FBV2UsS0FBSyxDQUFLNVksSUFBQUE7QUFDaEQsWUFBTW1ZLE9BQU8sQ0FBQzNYLElBQUk3SSxLQUFLc2dCLElBQUlKLFdBQVdlLEtBQUssQ0FBSzNZLElBQUFBO0FBQ2hELFlBQU02WCxTQUFTdFgsSUFBSTdJLEtBQUtvZ0IsSUFBSUgsYUFBYWdCLEtBQUssQ0FBSzVZLElBQUFBO0FBQ25ELFlBQU1nWSxTQUFTeFgsSUFBSTdJLEtBQUtzZ0IsSUFBSUwsYUFBYWdCLEtBQUssQ0FBSzNZLElBQUFBO0FBQ25ENkYsVUFBSWk0QixPQUFPN2xCLE1BQU1DLElBQUFBO0FBQ2pCclMsVUFBSWk0QixPQUFPam1CLFFBQVFFLE1BQUFBOzs7QUFHdkJsUyxNQUFJc3FDLFVBQVM7QUFFYnRxQyxNQUFJZzRCLE9BQU8sR0FBRyxDQUFBO0FBQ2RoNEIsTUFBSXVxQyxLQUFLLEdBQUcsR0FBR3ZxQyxJQUFJa2pCLE9BQU9qVixPQUFPak8sSUFBSWtqQixPQUFPbFYsTUFBTTtBQUVsRGhPLE1BQUk4RixLQUFLLFNBQUE7QUFDWDtBQUdBLFNBQVMwa0MsUUFBUXhxQyxLQUErQmYsU0FBcUI4UyxVQUFrQjtBQUNyRixRQUFNLEVBQUNELFlBQVkyNEIsYUFBYXZ3QyxHQUFHQyxHQUFHK1ksYUFBYUQsWUFBQUEsSUFBZWhVO0FBQ2xFLE1BQUl5ckMsY0FBY0QsY0FBY3YzQjtBQUloQ2xULE1BQUkrM0IsVUFBUztBQUNiLzNCLE1BQUlpVixJQUFJL2EsR0FBR0MsR0FBRytZLGFBQWFwQixhQUFhNDRCLGFBQWEzNEIsV0FBVzI0QixXQUFBQTtBQUNoRSxNQUFJejNCLGNBQWN3M0IsYUFBYTtBQUM3QkMsa0JBQWNELGNBQWN4M0I7QUFDNUJqVCxRQUFJaVYsSUFBSS9hLEdBQUdDLEdBQUc4WSxhQUFhbEIsV0FBVzI0QixhQUFhNTRCLGFBQWE0NEIsYUFBYSxJQUFJO1NBQzVFO0FBQ0wxcUMsUUFBSWlWLElBQUkvYSxHQUFHQyxHQUFHc3dDLGFBQWExNEIsV0FBV2EsU0FBU2QsYUFBYWMsT0FBQUE7O0FBRTlENVMsTUFBSXNxQyxVQUFTO0FBQ2J0cUMsTUFBSThGLEtBQUk7QUFDVjtBQUVBLFNBQVM2a0MsZ0JBQWdCeHhDLE9BQU87QUFDOUIsU0FBT3l4QyxrQkFBa0J6eEMsT0FBTztJQUFDO0lBQWM7SUFBWTtJQUFjO0VBQVcsQ0FBQTtBQUN0RjtBQUtBLFNBQVMweEMsb0JBQWtCNTFCLEtBQWlCaEMsYUFBcUJDLGFBQXFCNDNCLFlBQW9CO0FBQ3hHLFFBQU1DLElBQUlKLGdCQUFnQjExQixJQUFJeGMsUUFBUXV5QyxZQUFZO0FBQ2xELFFBQU1DLGlCQUFpQi8zQixjQUFjRCxlQUFlO0FBQ3BELFFBQU1pNEIsYUFBYXI1QyxLQUFLQyxJQUFJbTVDLGVBQWVILGFBQWE3M0IsY0FBYyxDQUFBO0FBU3RFLFFBQU1rNEIsb0JBQW9CLENBQUMxOEIsUUFBUTtBQUNqQyxVQUFNMjhCLGlCQUFpQmw0QixjQUFjcmhCLEtBQUtDLElBQUltNUMsZUFBZXg4QixHQUFHLEtBQUtxOEIsYUFBYTtBQUNsRixXQUFPdFosWUFBWS9pQixLQUFLLEdBQUc1YyxLQUFLQyxJQUFJbTVDLGVBQWVHLGFBQUFBLENBQUFBO0VBQ3JEO0FBRUEsU0FBTztJQUNMQyxZQUFZRixrQkFBa0JKLEVBQUVNLFVBQVU7SUFDMUNDLFVBQVVILGtCQUFrQkosRUFBRU8sUUFBUTtJQUN0Q0MsWUFBWS9aLFlBQVl1WixFQUFFUSxZQUFZLEdBQUdMLFVBQUFBO0lBQ3pDTSxVQUFVaGEsWUFBWXVaLEVBQUVTLFVBQVUsR0FBR04sVUFBQUE7RUFDdkM7QUFDRjtBQUtBLFNBQVNPLFdBQVcvd0MsR0FBV2d4QyxPQUFleHhDLEdBQVdDLEdBQVc7QUFDbEUsU0FBTztJQUNMRCxHQUFHQSxJQUFJUSxJQUFJN0ksS0FBS29nQixJQUFJeTVCLEtBQUFBO0lBQ3BCdnhDLEdBQUdBLElBQUlPLElBQUk3SSxLQUFLc2dCLElBQUl1NUIsS0FBQUE7RUFDdEI7QUFDRjtBQWlCQSxTQUFTQyxRQUNQM3JDLEtBQ0FmLFNBQ0F5UixRQUNBZ0QsU0FDQTVaLEtBQ0EwZixVQUNBO0FBQ0EsUUFBTSxFQUFDdGYsR0FBR0MsR0FBRzJYLFlBQVkvZixPQUFPMDRDLGFBQWF4M0IsYUFBYTI0QixPQUFBQSxJQUFVM3NDO0FBRXBFLFFBQU1pVSxjQUFjcmhCLEtBQUtvQyxJQUFJZ0wsUUFBUWlVLGNBQWNRLFVBQVVoRCxTQUFTKzVCLGFBQWEsQ0FBQTtBQUNuRixRQUFNeDNCLGNBQWMyNEIsU0FBUyxJQUFJQSxTQUFTbDRCLFVBQVVoRCxTQUFTKzVCLGNBQWM7QUFFM0UsTUFBSW9CLGdCQUFnQjtBQUNwQixRQUFNQyxTQUFRaHlDLE1BQU0vSDtBQUVwQixNQUFJMmhCLFNBQVM7QUFJWCxVQUFNcTRCLHVCQUF1QkgsU0FBUyxJQUFJQSxTQUFTbDRCLFVBQVU7QUFDN0QsVUFBTXM0Qix1QkFBdUI5NEIsY0FBYyxJQUFJQSxjQUFjUSxVQUFVO0FBQ3ZFLFVBQU11NEIsc0JBQXNCRix1QkFBdUJDLHdCQUF3QjtBQUMzRSxVQUFNRSxnQkFBZ0JELHVCQUF1QixJQUFJSCxTQUFTRyxzQkFBdUJBLHFCQUFxQnY0QixXQUFXbzRCO0FBQ2pIRCxxQkFBaUJDLFNBQVFJLGlCQUFpQjs7QUFHNUMsUUFBTUMsT0FBT3Q2QyxLQUFLb0MsSUFBSSxNQUFPNjNDLFNBQVE1NEIsY0FBY3hDLFNBQVNvQyxFQUFNSSxJQUFBQTtBQUNsRSxRQUFNazVCLGVBQWVOLFNBQVFLLFFBQVE7QUFDckMsUUFBTXI2QixhQUFhL2YsUUFBUXE2QyxjQUFjUDtBQUN6QyxRQUFNOTVCLFdBQVdqWSxNQUFNc3lDLGNBQWNQO0FBQ3JDLFFBQU0sRUFBQ1IsWUFBWUMsVUFBVUMsWUFBWUMsU0FBUSxJQUFJWCxvQkFBa0I1ckMsU0FBU2dVLGFBQWFDLGFBQWFuQixXQUFXRCxVQUFBQTtBQUVySCxRQUFNdTZCLDJCQUEyQm41QixjQUFjbTRCO0FBQy9DLFFBQU1pQix5QkFBeUJwNUIsY0FBY280QjtBQUM3QyxRQUFNaUIsMEJBQTBCejZCLGFBQWF1NUIsYUFBYWdCO0FBQzFELFFBQU1HLHdCQUF3Qno2QixXQUFXdTVCLFdBQVdnQjtBQUVwRCxRQUFNRywyQkFBMkJ4NUIsY0FBY3M0QjtBQUMvQyxRQUFNbUIseUJBQXlCejVCLGNBQWN1NEI7QUFDN0MsUUFBTW1CLDBCQUEwQjc2QixhQUFheTVCLGFBQWFrQjtBQUMxRCxRQUFNRyx3QkFBd0I3NkIsV0FBV3k1QixXQUFXa0I7QUFFcEQxc0MsTUFBSSszQixVQUFTO0FBRWIsTUFBSXZlLFVBQVU7QUFFWixVQUFNcXpCLHlCQUF5Qk4sMEJBQTBCQyx5QkFBeUI7QUFDbEZ4c0MsUUFBSWlWLElBQUkvYSxHQUFHQyxHQUFHK1ksYUFBYXE1Qix5QkFBeUJNLHFCQUFBQTtBQUNwRDdzQyxRQUFJaVYsSUFBSS9hLEdBQUdDLEdBQUcrWSxhQUFhMjVCLHVCQUF1QkwscUJBQUFBO0FBR2xELFFBQUlsQixXQUFXLEdBQUc7QUFDaEIsWUFBTXdCLFVBQVVyQixXQUFXYSx3QkFBd0JFLHVCQUF1QnR5QyxHQUFHQyxDQUFBQTtBQUM3RTZGLFVBQUlpVixJQUFJNjNCLFFBQVE1eUMsR0FBRzR5QyxRQUFRM3lDLEdBQUdteEMsVUFBVWtCLHVCQUF1Qno2QixXQUFXYSxPQUFBQTs7QUFJNUUsVUFBTW02QixLQUFLdEIsV0FBV2lCLHdCQUF3QjM2QixVQUFVN1gsR0FBR0MsQ0FBQUE7QUFDM0Q2RixRQUFJaTRCLE9BQU84VSxHQUFHN3lDLEdBQUc2eUMsR0FBRzV5QyxDQUFDO0FBR3JCLFFBQUlxeEMsV0FBVyxHQUFHO0FBQ2hCLFlBQU1zQixVQUFVckIsV0FBV2lCLHdCQUF3QkUsdUJBQXVCMXlDLEdBQUdDLENBQUFBO0FBQzdFNkYsVUFBSWlWLElBQUk2M0IsUUFBUTV5QyxHQUFHNHlDLFFBQVEzeUMsR0FBR3F4QyxVQUFVejVCLFdBQVdhLFNBQVNnNkIsd0JBQXdCLzZDLEtBQUtpaEIsRUFBRTs7QUFJN0YsVUFBTWs2Qix5QkFBMEJqN0IsV0FBWXk1QixXQUFXdjRCLGVBQWlCbkIsYUFBY3k1QixhQUFhdDRCLGdCQUFpQjtBQUNwSGpULFFBQUlpVixJQUFJL2EsR0FBR0MsR0FBRzhZLGFBQWFsQixXQUFZeTVCLFdBQVd2NEIsYUFBYys1Qix1QkFBdUIsSUFBSTtBQUMzRmh0QyxRQUFJaVYsSUFBSS9hLEdBQUdDLEdBQUc4WSxhQUFhKzVCLHVCQUF1Qmw3QixhQUFjeTVCLGFBQWF0NEIsYUFBYyxJQUFJO0FBRy9GLFFBQUlzNEIsYUFBYSxHQUFHO0FBQ2xCLFlBQU11QixVQUFVckIsV0FBV2dCLDBCQUEwQkUseUJBQXlCenlDLEdBQUdDLENBQUFBO0FBQ2pGNkYsVUFBSWlWLElBQUk2M0IsUUFBUTV5QyxHQUFHNHlDLFFBQVEzeUMsR0FBR294QyxZQUFZb0IsMEJBQTBCOTZDLEtBQUtpaEIsSUFBSWhCLGFBQWFjLE9BQUFBOztBQUk1RixVQUFNcTZCLEtBQUt4QixXQUFXWSwwQkFBMEJ2NkIsWUFBWTVYLEdBQUdDLENBQUFBO0FBQy9ENkYsUUFBSWk0QixPQUFPZ1YsR0FBRy95QyxHQUFHK3lDLEdBQUc5eUMsQ0FBQztBQUdyQixRQUFJa3hDLGFBQWEsR0FBRztBQUNsQixZQUFNeUIsVUFBVXJCLFdBQVdZLDBCQUEwQkUseUJBQXlCcnlDLEdBQUdDLENBQUFBO0FBQ2pGNkYsVUFBSWlWLElBQUk2M0IsUUFBUTV5QyxHQUFHNHlDLFFBQVEzeUMsR0FBR2t4QyxZQUFZdjVCLGFBQWFjLFNBQVMyNUIsdUJBQUFBOztTQUU3RDtBQUNMdnNDLFFBQUlnNEIsT0FBTzk5QixHQUFHQyxDQUFBQTtBQUVkLFVBQU0reUMsY0FBY3I3QyxLQUFLb2dCLElBQUlzNkIsdUJBQUFBLElBQTJCcjVCLGNBQWNoWjtBQUN0RSxVQUFNaXpDLGNBQWN0N0MsS0FBS3NnQixJQUFJbzZCLHVCQUFBQSxJQUEyQnI1QixjQUFjL1k7QUFDdEU2RixRQUFJaTRCLE9BQU9pVixhQUFhQyxXQUFBQTtBQUV4QixVQUFNQyxZQUFZdjdDLEtBQUtvZ0IsSUFBSXU2QixxQkFBQUEsSUFBeUJ0NUIsY0FBY2haO0FBQ2xFLFVBQU1tekMsWUFBWXg3QyxLQUFLc2dCLElBQUlxNkIscUJBQUFBLElBQXlCdDVCLGNBQWMvWTtBQUNsRTZGLFFBQUlpNEIsT0FBT21WLFdBQVdDLFNBQUFBOztBQUd4QnJ0QyxNQUFJc3FDLFVBQVM7QUFDZjtBQUVBLFNBQVNnRCxRQUNQdHRDLEtBQ0FmLFNBQ0F5UixRQUNBZ0QsU0FDQThGLFVBQ0E7QUFDQSxRQUFNLEVBQUMrekIsYUFBYXo3QixZQUFZUCxjQUFBQSxJQUFpQnRTO0FBQ2pELE1BQUk4UyxXQUFXOVMsUUFBUThTO0FBQ3ZCLE1BQUl3N0IsYUFBYTtBQUNmNUIsWUFBUTNyQyxLQUFLZixTQUFTeVIsUUFBUWdELFNBQVMzQixVQUFVeUgsUUFBQUE7QUFDakQsYUFBUzdtQixJQUFJLEdBQUdBLElBQUk0NkMsYUFBYSxFQUFFNTZDLEdBQUc7QUFDcENxTixVQUFJbUIsS0FBSTtJQUNWO0FBQ0EsUUFBSSxDQUFDdU4sTUFBTTZDLGFBQWdCLEdBQUE7QUFDekJRLGlCQUFXRCxjQUFjUCxnQkFBZ0JNLE9BQU9BOzs7QUFHcEQ4NUIsVUFBUTNyQyxLQUFLZixTQUFTeVIsUUFBUWdELFNBQVMzQixVQUFVeUgsUUFBQUE7QUFDakR4WixNQUFJbUIsS0FBSTtBQUNSLFNBQU80UTtBQUNUO0FBRUEsU0FBU3FtQixXQUNQcDRCLEtBQ0FmLFNBQ0F5UixRQUNBZ0QsU0FDQThGLFVBQ0E7QUFDQSxRQUFNLEVBQUMrekIsYUFBYXo3QixZQUFZUCxlQUFlOVksU0FBQUEsU0FBTyxJQUFJd0c7QUFDMUQsUUFBTSxFQUFDcVcsYUFBYTIwQixpQkFBaUIxVSxZQUFZRSxrQkFBa0J1VixhQUFZLElBQUl2eUM7QUFDbkYsUUFBTSswQyxRQUFRLzBDLFNBQVE0YyxnQkFBZ0I7QUFFdEMsTUFBSSxDQUFDQyxhQUFhO0FBQ2hCOztBQUdGdFYsTUFBSTYzQixZQUFZdEMsY0FBYyxDQUFBLENBQUU7QUFDaEN2MUIsTUFBSTgzQixpQkFBaUJyQztBQUVyQixNQUFJK1gsT0FBTztBQUNUeHRDLFFBQUk0VyxZQUFZdEIsY0FBYztBQUM5QnRWLFFBQUl5dEMsV0FBV3hELG1CQUFtQjtTQUM3QjtBQUNManFDLFFBQUk0VyxZQUFZdEI7QUFDaEJ0VixRQUFJeXRDLFdBQVd4RCxtQkFBbUI7O0FBR3BDLE1BQUlsNEIsV0FBVzlTLFFBQVE4UztBQUN2QixNQUFJdzdCLGFBQWE7QUFDZjVCLFlBQVEzckMsS0FBS2YsU0FBU3lSLFFBQVFnRCxTQUFTM0IsVUFBVXlILFFBQUFBO0FBQ2pELGFBQVM3bUIsSUFBSSxHQUFHQSxJQUFJNDZDLGFBQWEsRUFBRTU2QyxHQUFHO0FBQ3BDcU4sVUFBSWs0QixPQUFNO0lBQ1o7QUFDQSxRQUFJLENBQUN4cEIsTUFBTTZDLGFBQWdCLEdBQUE7QUFDekJRLGlCQUFXRCxjQUFjUCxnQkFBZ0JNLE9BQU9BOzs7QUFJcEQsTUFBSTI3QixPQUFPO0FBQ1RoRCxZQUFReHFDLEtBQUtmLFNBQVM4UyxRQUFBQTs7QUFHeEIsTUFBSXRaLFNBQVFpMUMsWUFBWTM3QixXQUFXRCxjQUFjZ0IsTUFBTWs0QixpQkFBaUIsS0FBS2Ysb0JBQW9CLFNBQVM7QUFDeEdELGFBQVNocUMsS0FBS2YsU0FBUzhTLFFBQUFBOztBQUd6QixNQUFJLENBQUN3N0IsYUFBYTtBQUNoQjVCLFlBQVEzckMsS0FBS2YsU0FBU3lSLFFBQVFnRCxTQUFTM0IsVUFBVXlILFFBQUFBO0FBQ2pEeFosUUFBSWs0QixPQUFNOztBQUVkO0FBVWUsSUFBTXlWLGFBQU4sY0FBeUJwbEIsUUFBQUE7RUFvQ3RDOTNCLFlBQVk2RSxLQUFLO0FBQ2YsVUFBSztBQVRQaWM7QUFDQVE7QUFDQXc3QjtBQUNBdDZCO0FBQ0FDO0FBQ0F1M0I7QUFDQTM0QjtBQUtFLFNBQUtyWixVQUFVMUg7QUFDZixTQUFLd2dCLGdCQUFnQnhnQjtBQUNyQixTQUFLK2dCLGFBQWEvZ0I7QUFDbEIsU0FBS2doQixXQUFXaGhCO0FBQ2hCLFNBQUtraUIsY0FBY2xpQjtBQUNuQixTQUFLbWlCLGNBQWNuaUI7QUFDbkIsU0FBSzA1QyxjQUFjO0FBQ25CLFNBQUs4QyxjQUFjO0FBRW5CLFFBQUlqNEMsS0FBSztBQUNQc0MsYUFBT3lCLE9BQU8sTUFBTS9ELEdBQUFBOztFQUV4QjtFQUVBOG5CLFFBQVF3d0IsUUFBZ0JDLFFBQWdCOXdCLGtCQUEyQjtBQUNqRSxVQUFNOUwsUUFBUSxLQUFLcU0sU0FBUztNQUFDO01BQUs7T0FBTVAsZ0JBQUFBO0FBQ3hDLFVBQU0sRUFBQ3hLLE9BQU9zTCxTQUFBQSxJQUFZTixrQkFBa0J0TSxPQUFPO01BQUMvVyxHQUFHMHpDO01BQVF6ekMsR0FBRzB6QztJQUFNLENBQUE7QUFDeEUsVUFBTSxFQUFDLzdCLFlBQVlDLFVBQVVrQixhQUFhQyxhQUFhM0IsY0FBQUEsSUFBaUIsS0FBSytMLFNBQVM7TUFDcEY7TUFDQTtNQUNBO01BQ0E7TUFDQTtPQUNDUCxnQkFBQUE7QUFDSCxVQUFNK3dCLFdBQVcsS0FBS3IxQyxRQUFRaWIsVUFBVSxLQUFLamIsUUFBUTZjLGVBQWU7QUFDcEUsVUFBTVosaUJBQWlCOVMsZUFBZTJQLGVBQWVRLFdBQVdELFVBQUFBO0FBQ2hFLFVBQU1pOEIsaUJBQWlCdjdCLGNBQWNELE9BQU9ULFlBQVlDLFFBQUFBLEtBQWFELGVBQWVDO0FBQ3BGLFVBQU1pOEIsZ0JBQWdCdDVCLGtCQUFrQjdDLE9BQU9rOEI7QUFDL0MsVUFBTUUsZUFBZUMsV0FBV3J3QixVQUFVNUssY0FBYzY2QixTQUFTNTZCLGNBQWM0NkIsT0FBQUE7QUFFL0UsV0FBUUUsaUJBQWlCQztFQUMzQjtFQUVBdHdCLGVBQWVaLGtCQUEyQjtBQUN4QyxVQUFNLEVBQUM3aUIsR0FBR0MsR0FBRzJYLFlBQVlDLFVBQVVrQixhQUFhQyxZQUFXLElBQUksS0FBS29LLFNBQVM7TUFDM0U7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO09BQ0NQLGdCQUFBQTtBQUNILFVBQU0sRUFBQ3JNLFFBQVFnRCxRQUFBQSxJQUFXLEtBQUtqYjtBQUMvQixVQUFNMDFDLGFBQWFyOEIsYUFBYUMsWUFBWTtBQUM1QyxVQUFNcThCLGNBQWNuN0IsY0FBY0MsY0FBY1EsVUFBVWhELFVBQVU7QUFDcEUsV0FBTztNQUNMeFcsR0FBR0EsSUFBSXJJLEtBQUtvZ0IsSUFBSWs4QixTQUFhQyxJQUFBQTtNQUM3QmowQyxHQUFHQSxJQUFJdEksS0FBS3NnQixJQUFJZzhCLFNBQWFDLElBQUFBO0lBQy9CO0VBQ0Y7RUFFQTVsQixnQkFBZ0J6TCxrQkFBMkI7QUFDekMsV0FBTyxLQUFLWSxlQUFlWixnQkFBQUE7RUFDN0I7RUFFQW5xQixLQUFLb04sS0FBK0I7QUFDbEMsVUFBTSxFQUFDdkgsU0FBQUEsVUFBUzhZLGNBQWEsSUFBSTtBQUNqQyxVQUFNYixVQUFValksU0FBUWlZLFVBQVUsS0FBSztBQUN2QyxVQUFNZ0QsV0FBV2piLFNBQVFpYixXQUFXLEtBQUs7QUFDekMsVUFBTThGLFdBQVcvZ0IsU0FBUStnQjtBQUN6QixTQUFLaXhCLGNBQWVoeUMsU0FBUTRjLGdCQUFnQixVQUFXLE9BQU87QUFDOUQsU0FBS2s0QixjQUFjaDhCLGdCQUFnQk0sTUFBTWhnQixLQUFLb0UsTUFBTXNiLGdCQUFnQk0sR0FBQUEsSUFBTztBQUUzRSxRQUFJTixrQkFBa0IsS0FBSyxLQUFLMEIsY0FBYyxLQUFLLEtBQUtDLGNBQWMsR0FBRztBQUN2RTs7QUFHRmxULFFBQUlzM0IsS0FBSTtBQUVSLFVBQU02VyxhQUFhLEtBQUtyOEIsYUFBYSxLQUFLQyxZQUFZO0FBQ3REL1IsUUFBSXF1QyxVQUFVeDhDLEtBQUtvZ0IsSUFBSWs4QixTQUFBQSxJQUFhejlCLFFBQVE3ZSxLQUFLc2dCLElBQUlnOEIsU0FBYXo5QixJQUFBQSxNQUFBQTtBQUNsRSxVQUFNNDlCLE1BQU0sSUFBSXo4QyxLQUFLc2dCLElBQUl0Z0IsS0FBS0MsSUFBSWdoQixJQUFJdkIsaUJBQWlCLENBQUEsQ0FBQTtBQUN2RCxVQUFNZzlCLGVBQWU3OUIsU0FBUzQ5QjtBQUU5QnR1QyxRQUFJdVcsWUFBWTlkLFNBQVErZDtBQUN4QnhXLFFBQUl5VyxjQUFjaGUsU0FBUWllO0FBRTFCNDJCLFlBQVF0dEMsS0FBSyxNQUFNdXVDLGNBQWM3NkIsU0FBUzhGLFFBQUFBO0FBQzFDNGUsZUFBV3A0QixLQUFLLE1BQU11dUMsY0FBYzc2QixTQUFTOEYsUUFBQUE7QUFFN0N4WixRQUFJdzNCLFFBQU87RUFDYjtBQUNGO0FBdkhFLGNBRm1CbVcsWUFFWjl3QyxNQUFLO0FBRVosY0FKbUI4d0MsWUFJWjcxQyxZQUFXO0VBQ2hCdWQsYUFBYTtFQUNicUIsYUFBYTtFQUNiNmUsWUFBWSxDQUFBO0VBQ1pFLGtCQUFrQjtFQUNsQndVLGlCQUFpQmw1QztFQUNqQmk2QyxjQUFjO0VBQ2QxMUIsYUFBYTtFQUNiNUUsUUFBUTtFQUNSZ0QsU0FBUztFQUNUbkIsT0FBT3hoQjtFQUNQeW9CLFVBQVU7RUFDVmswQixVQUFVOztBQUdaLGNBbkJtQkMsWUFtQlova0IsaUJBQWdCO0VBQ3JCcFMsaUJBQWlCOztBQUduQixjQXZCbUJtM0IsWUF1QlpoNEIsZUFBYztFQUNuQkMsYUFBYTtFQUNiQyxZQUFZLENBQUMxRyxTQUFTQSxTQUFTOztBQ3pUbkMsU0FBU3EvQixTQUFTeHVDLEtBQUt2SCxVQUFTNGQsUUFBUTVkLFVBQVM7QUFDL0N1SCxNQUFJeXVDLFVBQVU3c0MsZUFBZXlVLE1BQU1xNEIsZ0JBQWdCajJDLFNBQVFpMkMsY0FBYztBQUN6RTF1QyxNQUFJNjNCLFlBQVlqMkIsZUFBZXlVLE1BQU1rZixZQUFZOThCLFNBQVE4OEIsVUFBVSxDQUFBO0FBQ25FdjFCLE1BQUk4M0IsaUJBQWlCbDJCLGVBQWV5VSxNQUFNb2Ysa0JBQWtCaDlCLFNBQVFnOUIsZ0JBQWdCO0FBQ3BGejFCLE1BQUl5dEMsV0FBVzdyQyxlQUFleVUsTUFBTTR6QixpQkFBaUJ4eEMsU0FBUXd4QyxlQUFlO0FBQzVFanFDLE1BQUk0VyxZQUFZaFYsZUFBZXlVLE1BQU1mLGFBQWE3YyxTQUFRNmMsV0FBVztBQUNyRXRWLE1BQUl5VyxjQUFjN1UsZUFBZXlVLE1BQU1LLGFBQWFqZSxTQUFRaWUsV0FBVztBQUN6RTtBQUVBLFNBQVN1aEIsT0FBT2o0QixLQUFLMnVDLFVBQVVwNUMsUUFBUTtBQUNyQ3lLLE1BQUlpNEIsT0FBTzFpQyxPQUFPMkUsR0FBRzNFLE9BQU80RSxDQUFDO0FBQy9CO0FBS0EsU0FBU3kwQyxjQUFjbjJDLFVBQVM7QUFDOUIsTUFBSUEsU0FBUW8yQyxTQUFTO0FBQ25CLFdBQU9DOztBQUdULE1BQUlyMkMsU0FBUXMyQyxXQUFXdDJDLFNBQVF1MkMsMkJBQTJCLFlBQVk7QUFDcEUsV0FBT0M7O0FBR1QsU0FBT2hYO0FBQ1Q7QUFFQSxTQUFTaVgsU0FBU2wrQixRQUFRMEcsU0FBUzhILFNBQVMsQ0FBQSxHQUFJO0FBQzlDLFFBQU16YixRQUFRaU4sT0FBT3RlO0FBQ3JCLFFBQU0sRUFBQ1gsT0FBT285QyxjQUFjLEdBQUdyMUMsS0FBS3MxQyxZQUFZcnJDLFFBQVEsRUFBQyxJQUFJeWI7QUFDN0QsUUFBTSxFQUFDenRCLE9BQU9zOUMsY0FBY3YxQyxLQUFLdzFDLFdBQUFBLElBQWM1M0I7QUFDL0MsUUFBTTNsQixRQUFRRixLQUFLb0MsSUFBSWs3QyxhQUFhRSxZQUFBQTtBQUNwQyxRQUFNdjFDLE1BQU1qSSxLQUFLQyxJQUFJczlDLFdBQVdFLFVBQUFBO0FBQ2hDLFFBQU1DLFVBQVVKLGNBQWNFLGdCQUFnQkQsWUFBWUMsZ0JBQWdCRixjQUFjRyxjQUFjRixZQUFZRTtBQUVsSCxTQUFPO0lBQ0x2ckM7SUFDQWhTO0lBQ0FxRSxNQUFNc2hCLFFBQVF0aEI7SUFDZDhFLE1BQU1wQixNQUFNL0gsU0FBUyxDQUFDdzlDLFVBQVV4ckMsUUFBUWpLLE1BQU0vSCxRQUFRK0gsTUFBTS9IO0VBQzlEO0FBQ0Y7QUFpQkEsU0FBU3k5QyxZQUFZeHZDLEtBQUtrWCxNQUFNUSxTQUFTOEgsUUFBUTtBQUMvQyxRQUFNLEVBQUN4TyxRQUFRdlksU0FBQUEsU0FBQUEsSUFBV3llO0FBQzFCLFFBQU0sRUFBQ25ULE9BQU9oUyxPQUFPcUUsTUFBTThFLEtBQUFBLElBQVFnMEMsU0FBU2wrQixRQUFRMEcsU0FBUzhILE1BQUFBO0FBQzdELFFBQU1pd0IsYUFBYWIsY0FBY24yQyxRQUFBQTtBQUVqQyxNQUFJLEVBQUNpUSxPQUFPLE1BQU03TyxRQUFPLElBQUkybEIsVUFBVSxDQUFBO0FBQ3ZDLE1BQUk3c0IsR0FBR3NlLE9BQU8vTTtBQUVkLE9BQUt2UixJQUFJLEdBQUdBLEtBQUt1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQzFCc2UsWUFBUUQsUUFBUWpmLFNBQVM4SCxVQUFVcUIsT0FBT3ZJLElBQUlBLE1BQU1vUixLQUFNO0FBRTFELFFBQUlrTixNQUFNRyxNQUFNO0FBRWQ7SUFDRixXQUFXMUksTUFBTTtBQUNmMUksVUFBSWc0QixPQUFPL21CLE1BQU0vVyxHQUFHK1csTUFBTTlXLENBQUM7QUFDM0J1TyxhQUFPO1dBQ0Y7QUFDTCttQyxpQkFBV3p2QyxLQUFLa0UsTUFBTStNLE9BQU9wWCxTQUFTcEIsU0FBUW8yQyxPQUFPOztBQUd2RDNxQyxXQUFPK007RUFDVDtBQUVBLE1BQUk3YSxNQUFNO0FBQ1I2YSxZQUFRRCxRQUFRamYsU0FBUzhILFVBQVVxQixPQUFPLE1BQU02SSxLQUFNO0FBQ3REMHJDLGVBQVd6dkMsS0FBS2tFLE1BQU0rTSxPQUFPcFgsU0FBU3BCLFNBQVFvMkMsT0FBTzs7QUFHdkQsU0FBTyxDQUFDLENBQUN6NEM7QUFDWDtBQWlCQSxTQUFTczVDLGdCQUFnQjF2QyxLQUFLa1gsTUFBTVEsU0FBUzhILFFBQVE7QUFDbkQsUUFBTXhPLFNBQVNrRyxLQUFLbEc7QUFDcEIsUUFBTSxFQUFDak4sT0FBT2hTLE9BQU9tSixLQUFBQSxJQUFRZzBDLFNBQVNsK0IsUUFBUTBHLFNBQVM4SCxNQUFBQTtBQUN2RCxRQUFNLEVBQUM5VyxPQUFPLE1BQU03TyxRQUFPLElBQUkybEIsVUFBVSxDQUFBO0FBQ3pDLE1BQUltd0IsT0FBTztBQUNYLE1BQUlDLFNBQVM7QUFDYixNQUFJajlDLEdBQUdzZSxPQUFPNCtCLE9BQU85OEIsTUFBTUosTUFBTW05QjtBQUVqQyxRQUFNQyxhQUFhLENBQUM1MEMsWUFBV3BKLFNBQVM4SCxVQUFVcUIsT0FBT0MsU0FBUUEsV0FBVTRJO0FBQzNFLFFBQU1pc0MsUUFBUSxNQUFNO0FBQ2xCLFFBQUlqOUIsU0FBU0osTUFBTTtBQUVqQjNTLFVBQUlpNEIsT0FBTzBYLE1BQU1oOUIsSUFBQUE7QUFDakIzUyxVQUFJaTRCLE9BQU8wWCxNQUFNNThCLElBQUFBO0FBR2pCL1MsVUFBSWk0QixPQUFPMFgsTUFBTUcsS0FBQUE7O0VBRXJCO0FBRUEsTUFBSXBuQyxNQUFNO0FBQ1J1SSxZQUFRRCxPQUFPKytCLFdBQVcsQ0FBRyxDQUFBO0FBQzdCL3ZDLFFBQUlnNEIsT0FBTy9tQixNQUFNL1csR0FBRytXLE1BQU05VyxDQUFDOztBQUc3QixPQUFLeEgsSUFBSSxHQUFHQSxLQUFLdUksTUFBTSxFQUFFdkksR0FBRztBQUMxQnNlLFlBQVFELE9BQU8rK0IsV0FBV3A5QyxDQUFHLENBQUE7QUFFN0IsUUFBSXNlLE1BQU1HLE1BQU07QUFFZDs7QUFHRixVQUFNbFgsSUFBSStXLE1BQU0vVztBQUNoQixVQUFNQyxJQUFJOFcsTUFBTTlXO0FBQ2hCLFVBQU04MUMsU0FBUy8xQyxJQUFJO0FBRW5CLFFBQUkrMUMsV0FBV0osT0FBTztBQUVwQixVQUFJMTFDLElBQUk0WSxNQUFNO0FBQ1pBLGVBQU81WTtpQkFDRUEsSUFBSXdZLE1BQU07QUFDbkJBLGVBQU94WTs7QUFHVHcxQyxjQUFRQyxTQUFTRCxPQUFPejFDLEtBQUssRUFBRTAxQztXQUMxQjtBQUNMSSxZQUFBQTtBQUdBaHdDLFVBQUlpNEIsT0FBTy85QixHQUFHQyxDQUFBQTtBQUVkMDFDLGNBQVFJO0FBQ1JMLGVBQVM7QUFDVDc4QixhQUFPSixPQUFPeFk7O0FBR2hCMjFDLFlBQVEzMUM7RUFDVjtBQUNBNjFDLFFBQUFBO0FBQ0Y7QUFPQSxTQUFTRSxrQkFBa0JoNUIsTUFBTTtBQUMvQixRQUFNdGQsT0FBT3NkLEtBQUt6ZTtBQUNsQixRQUFNODhCLGFBQWEzN0IsS0FBSzI3QixjQUFjMzdCLEtBQUsyN0IsV0FBVzdpQztBQUN0RCxRQUFNeTlDLGNBQWMsQ0FBQ2o1QixLQUFLTSxjQUFjLENBQUNOLEtBQUsvZ0IsU0FBUyxDQUFDeUQsS0FBS20xQyxXQUFXbjFDLEtBQUtvMUMsMkJBQTJCLGNBQWMsQ0FBQ3AxQyxLQUFLaTFDLFdBQVcsQ0FBQ3RaO0FBQ3hJLFNBQU80YSxjQUFjVCxrQkFBa0JGO0FBQ3pDO0FBS0EsU0FBU1ksd0JBQXdCMzNDLFVBQVM7QUFDeEMsTUFBSUEsU0FBUW8yQyxTQUFTO0FBQ25CLFdBQU93Qjs7QUFHVCxNQUFJNTNDLFNBQVFzMkMsV0FBV3QyQyxTQUFRdTJDLDJCQUEyQixZQUFZO0FBQ3BFLFdBQU9zQjs7QUFHVCxTQUFPQztBQUNUO0FBRUEsU0FBU0Msb0JBQW9CeHdDLEtBQUtrWCxNQUFNbmxCLE9BQU9nUyxPQUFPO0FBQ3BELE1BQUkwc0MsT0FBT3Y1QixLQUFLdzVCO0FBQ2hCLE1BQUksQ0FBQ0QsTUFBTTtBQUNUQSxXQUFPdjVCLEtBQUt3NUIsUUFBUSxJQUFJQyxPQUFBQTtBQUN4QixRQUFJejVCLEtBQUt1NUIsS0FBS0EsTUFBTTErQyxPQUFPZ1MsS0FBUSxHQUFBO0FBQ2pDMHNDLFdBQUtuRyxVQUFTOzs7QUFHbEJrRSxXQUFTeHVDLEtBQUtrWCxLQUFLemUsT0FBTztBQUMxQnVILE1BQUlrNEIsT0FBT3VZLElBQUFBO0FBQ2I7QUFFQSxTQUFTRyxpQkFBaUI1d0MsS0FBS2tYLE1BQU1ubEIsT0FBT2dTLE9BQU87QUFDakQsUUFBTSxFQUFDOHNDLFVBQVVwNEMsU0FBQUEsU0FBQUEsSUFBV3llO0FBQzVCLFFBQU00NUIsZ0JBQWdCWixrQkFBa0JoNUIsSUFBQUE7QUFFeEMsYUFBV1EsV0FBV201QixVQUFVO0FBQzlCckMsYUFBU3h1QyxLQUFLdkgsVUFBU2lmLFFBQVFyQixLQUFLO0FBQ3BDclcsUUFBSSszQixVQUFTO0FBQ2IsUUFBSStZLGNBQWM5d0MsS0FBS2tYLE1BQU1RLFNBQVM7TUFBQzNsQjtNQUFPK0gsS0FBSy9ILFFBQVFnUyxRQUFRO0tBQUssR0FBQTtBQUN0RS9ELFVBQUlzcUMsVUFBUzs7QUFFZnRxQyxRQUFJazRCLE9BQU07RUFDWjtBQUNGO0FBRUEsSUFBTTZZLFlBQVksT0FBT0osV0FBVztBQUVwQyxTQUFTLzlDLEtBQUtvTixLQUFLa1gsTUFBTW5sQixPQUFPZ1MsT0FBTztBQUNyQyxNQUFJZ3RDLGFBQWEsQ0FBQzc1QixLQUFLemUsUUFBUWlmLFNBQVM7QUFDdEM4NEIsd0JBQW9CeHdDLEtBQUtrWCxNQUFNbmxCLE9BQU9nUyxLQUFBQTtTQUNqQztBQUNMNnNDLHFCQUFpQjV3QyxLQUFLa1gsTUFBTW5sQixPQUFPZ1MsS0FBQUE7O0FBRXZDO0FBRWUsSUFBTWl0QyxjQUFOLGNBQTBCem9CLFFBQUFBO0VBb0N2QzkzQixZQUFZNkUsS0FBSztBQUNmLFVBQUs7QUFFTCxTQUFLcWlCLFdBQVc7QUFDaEIsU0FBS2xmLFVBQVUxSDtBQUNmLFNBQUt3RyxTQUFTeEc7QUFDZCxTQUFLb0YsUUFBUXBGO0FBQ2IsU0FBSzZvQixZQUFZN29CO0FBQ2pCLFNBQUsyL0MsUUFBUTMvQztBQUNiLFNBQUtrZ0QsVUFBVWxnRDtBQUNmLFNBQUttZ0QsWUFBWW5nRDtBQUNqQixTQUFLeW1CLGFBQWE7QUFDbEIsU0FBSzI1QixpQkFBaUI7QUFDdEIsU0FBSzU1QixnQkFBZ0J4bUI7QUFFckIsUUFBSXVFLEtBQUs7QUFDUHNDLGFBQU95QixPQUFPLE1BQU0vRCxHQUFBQTs7RUFFeEI7RUFFQWdqQixvQkFBb0JyUyxXQUFXaEUsV0FBVztBQUN4QyxVQUFNeEosV0FBVSxLQUFLQTtBQUNyQixTQUFLQSxTQUFRczJDLFdBQVd0MkMsU0FBUXUyQywyQkFBMkIsZUFBZSxDQUFDdjJDLFNBQVFvMkMsV0FBVyxDQUFDLEtBQUtzQyxnQkFBZ0I7QUFDbEgsWUFBTS82QyxPQUFPcUMsU0FBUW1mLFdBQVcsS0FBS3poQixRQUFRLEtBQUt5akI7QUFDbER3M0IsaUNBQTJCLEtBQUtILFNBQVN4NEMsVUFBU3dOLFdBQVc3UCxNQUFNNkwsU0FBQUE7QUFDbkUsV0FBS2t2QyxpQkFBaUI7O0VBRTFCO0VBRUEsSUFBSW5nQyxPQUFPQSxRQUFRO0FBQ2pCLFNBQUtpZ0MsVUFBVWpnQztBQUNmLFdBQU8sS0FBS2tnQztBQUNaLFdBQU8sS0FBS1I7QUFDWixTQUFLUyxpQkFBaUI7RUFDeEI7RUFFQSxJQUFJbmdDLFNBQVM7QUFDWCxXQUFPLEtBQUtpZ0M7RUFDZDtFQUVBLElBQUlKLFdBQVc7QUFDYixXQUFPLEtBQUtLLGNBQWMsS0FBS0EsWUFBWUcsaUJBQWlCLE1BQU0sS0FBSzU0QyxRQUFRaWYsT0FBTztFQUN4RjtFQU1BOFIsUUFBUTtBQUNOLFVBQU1xbkIsV0FBVyxLQUFLQTtBQUN0QixVQUFNNy9CLFNBQVMsS0FBS0E7QUFDcEIsV0FBTzYvQixTQUFTbitDLFVBQVVzZSxPQUFPNi9CLFNBQVMsQ0FBQSxFQUFHOStDLEtBQUs7RUFDcEQ7RUFNQW9jLE9BQU87QUFDTCxVQUFNMGlDLFdBQVcsS0FBS0E7QUFDdEIsVUFBTTcvQixTQUFTLEtBQUtBO0FBQ3BCLFVBQU1qTixRQUFROHNDLFNBQVNuK0M7QUFDdkIsV0FBT3FSLFNBQVNpTixPQUFPNi9CLFNBQVM5c0MsUUFBUSxDQUFBLEVBQUdqSyxHQUFHO0VBQ2hEO0VBU0F3M0MsWUFBWXJnQyxPQUFPaXBCLFVBQVU7QUFDM0IsVUFBTXpoQyxXQUFVLEtBQUtBO0FBQ3JCLFVBQU1VLFFBQVE4WCxNQUFNaXBCLFFBQVM7QUFDN0IsVUFBTWxwQixTQUFTLEtBQUtBO0FBQ3BCLFVBQU02L0IsV0FBV1UsZUFBZSxNQUFNO01BQUNyWDtNQUFVbm9DLE9BQU9vSDtNQUFPVyxLQUFLWDtJQUFLLENBQUE7QUFFekUsUUFBSSxDQUFDMDNDLFNBQVNuK0MsUUFBUTtBQUNwQjs7QUFHRixVQUFNNm9CLFNBQVMsQ0FBQTtBQUNmLFVBQU1pMkIsZUFBZXBCLHdCQUF3QjMzQyxRQUFBQTtBQUM3QyxRQUFJOUYsR0FBR3VJO0FBQ1AsU0FBS3ZJLElBQUksR0FBR3VJLE9BQU8yMUMsU0FBU24rQyxRQUFRQyxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUNqRCxZQUFNLEVBQUNaLE9BQU8rSCxJQUFBQSxJQUFPKzJDLFNBQVNsK0MsQ0FBRTtBQUNoQyxZQUFNZ2xDLEtBQUszbUIsT0FBT2pmLEtBQU07QUFDeEIsWUFBTTZsQyxLQUFLNW1CLE9BQU9sWCxHQUFJO0FBQ3RCLFVBQUk2OUIsT0FBT0MsSUFBSTtBQUNicmMsZUFBTzVuQixLQUFLZ2tDLEVBQUFBO0FBQ1o7O0FBRUYsWUFBTWw5QixJQUFJNUksS0FBS3dZLEtBQUtsUixRQUFRdytCLEdBQUd1QyxRQUFBQSxNQUFjdEMsR0FBR3NDLFFBQUFBLElBQVl2QyxHQUFHdUMsUUFBQUEsRUFBUTtBQUN2RSxZQUFNdVgsZUFBZUQsYUFBYTdaLElBQUlDLElBQUluOUIsR0FBR2hDLFNBQVFvMkMsT0FBTztBQUM1RDRDLG1CQUFhdlgsUUFBQUEsSUFBWWpwQixNQUFNaXBCLFFBQVM7QUFDeEMzZSxhQUFPNW5CLEtBQUs4OUMsWUFBQUE7SUFDZDtBQUNBLFdBQU9sMkIsT0FBTzdvQixXQUFXLElBQUk2b0IsT0FBTyxDQUFBLElBQUtBO0VBQzNDO0VBZ0JBaTBCLFlBQVl4dkMsS0FBSzBYLFNBQVM4SCxRQUFRO0FBQ2hDLFVBQU1zeEIsZ0JBQWdCWixrQkFBa0IsSUFBSTtBQUM1QyxXQUFPWSxjQUFjOXdDLEtBQUssTUFBTTBYLFNBQVM4SCxNQUFBQTtFQUMzQztFQVNBaXhCLEtBQUt6d0MsS0FBS2pPLE9BQU9nUyxPQUFPO0FBQ3RCLFVBQU04c0MsV0FBVyxLQUFLQTtBQUN0QixVQUFNQyxnQkFBZ0JaLGtCQUFrQixJQUFJO0FBQzVDLFFBQUk5NUMsT0FBTyxLQUFLRDtBQUVoQnBFLFlBQVFBLFNBQVM7QUFDakJnUyxZQUFRQSxTQUFVLEtBQUtpTixPQUFPdGUsU0FBU1g7QUFFdkMsZUFBVzJsQixXQUFXbTVCLFVBQVU7QUFDOUJ6NkMsY0FBUTA2QyxjQUFjOXdDLEtBQUssTUFBTTBYLFNBQVM7UUFBQzNsQjtRQUFPK0gsS0FBSy9ILFFBQVFnUyxRQUFRO01BQUMsQ0FBQTtJQUMxRTtBQUNBLFdBQU8sQ0FBQyxDQUFDM047RUFDWDtFQVNBeEQsS0FBS29OLEtBQUtpRyxXQUFXbFUsT0FBT2dTLE9BQU87QUFDakMsVUFBTXRMLFdBQVUsS0FBS0EsV0FBVyxDQUFBO0FBQ2hDLFVBQU11WSxTQUFTLEtBQUtBLFVBQVUsQ0FBQTtBQUU5QixRQUFJQSxPQUFPdGUsVUFBVStGLFNBQVE2YyxhQUFhO0FBQ3hDdFYsVUFBSXMzQixLQUFJO0FBRVIxa0MsV0FBS29OLEtBQUssTUFBTWpPLE9BQU9nUyxLQUFBQTtBQUV2Qi9ELFVBQUl3M0IsUUFBTzs7QUFHYixRQUFJLEtBQUs3ZixVQUFVO0FBRWpCLFdBQUt3NUIsaUJBQWlCO0FBQ3RCLFdBQUtULFFBQVEzL0M7O0VBRWpCO0FBQ0Y7QUF4TUUsY0FGbUJpZ0QsYUFFWm4wQyxNQUFLO0FBS1osY0FQbUJtMEMsYUFPWmw1QyxZQUFXO0VBQ2hCNDJDLGdCQUFnQjtFQUNoQm5aLFlBQVksQ0FBQTtFQUNaRSxrQkFBa0I7RUFDbEJ3VSxpQkFBaUI7RUFDakIzMEIsYUFBYTtFQUNibzhCLGlCQUFpQjtFQUNqQjFDLHdCQUF3QjtFQUN4Qjd0QyxNQUFNO0VBQ055VyxVQUFVO0VBQ1ZpM0IsU0FBUztFQUNURSxTQUFTOztBQU1YLGNBeEJtQmlDLGFBd0JacG9CLGlCQUFnQjtFQUNyQnBTLGlCQUFpQjtFQUNqQkUsYUFBYTs7QUFJZixjQTlCbUJzNkIsYUE4QlpyN0IsZUFBYztFQUNuQkMsYUFBYTtFQUNiQyxZQUFZLENBQUMxRyxTQUFTQSxTQUFTLGdCQUFnQkEsU0FBUzs7QUN4UTVELFNBQVNpTyxVQUFRdEIsSUFBa0IwQyxLQUFhcGlCLE1BQWlCMmdCLGtCQUE0QjtBQUMzRixRQUFNdGtCLFdBQVVxakIsR0FBR3JqQjtBQUNuQixRQUFNLEVBQUMsQ0FBQzJELElBQUssR0FBRWpELE1BQUFBLElBQVMyaUIsR0FBR3dCLFNBQVM7SUFBQ2xoQjtLQUFPMmdCLGdCQUFBQTtBQUU1QyxTQUFRbHJCLEtBQUt3WSxJQUFJbVUsTUFBTXJsQixLQUFBQSxJQUFTVixTQUFRc1ksU0FBU3RZLFNBQVFrNUM7QUFDM0Q7QUFJZSxJQUFNQyxlQUFOLGNBQTJCcnBCLFFBQUFBO0VBNkJ4QzkzQixZQUFZNkUsS0FBSztBQUNmLFVBQUs7QUExQlB3STtBQUNBc1Q7QUFDQWpkO0FBMEJFLFNBQUtzRSxVQUFVMUg7QUFDZixTQUFLK00sU0FBUy9NO0FBQ2QsU0FBS3FnQixPQUFPcmdCO0FBQ1osU0FBS29ELE9BQU9wRDtBQUVaLFFBQUl1RSxLQUFLO0FBQ1BzQyxhQUFPeUIsT0FBTyxNQUFNL0QsR0FBQUE7O0VBRXhCO0VBRUE4bkIsUUFBUXkwQixRQUFnQkMsUUFBZ0IvMEIsa0JBQTRCO0FBQ2xFLFVBQU10a0IsV0FBVSxLQUFLQTtBQUNyQixVQUFNLEVBQUN5QixHQUFHQyxFQUFBQSxJQUFLLEtBQUttakIsU0FBUztNQUFDO01BQUs7T0FBTVAsZ0JBQUFBO0FBQ3pDLFdBQVNsckIsS0FBS2dyQixJQUFJZzFCLFNBQVMzM0MsR0FBRyxDQUFBLElBQUtySSxLQUFLZ3JCLElBQUlpMUIsU0FBUzMzQyxHQUFHLENBQUEsSUFBTXRJLEtBQUtnckIsSUFBSXBrQixTQUFRazVDLFlBQVlsNUMsU0FBUXNZLFFBQVEsQ0FBQTtFQUM3RztFQUVBZ2hDLFNBQVNGLFFBQWdCOTBCLGtCQUE0QjtBQUNuRCxXQUFPSyxVQUFRLE1BQU15MEIsUUFBUSxLQUFLOTBCLGdCQUFBQTtFQUNwQztFQUVBaTFCLFNBQVNGLFFBQWdCLzBCLGtCQUE0QjtBQUNuRCxXQUFPSyxVQUFRLE1BQU0wMEIsUUFBUSxLQUFLLzBCLGdCQUFBQTtFQUNwQztFQUVBWSxlQUFlWixrQkFBNEI7QUFDekMsVUFBTSxFQUFDN2lCLEdBQUdDLEVBQUFBLElBQUssS0FBS21qQixTQUFTO01BQUM7TUFBSztPQUFNUCxnQkFBQUE7QUFDekMsV0FBTztNQUFDN2lCO01BQUdDO0lBQUM7RUFDZDtFQUVBZixLQUFLWCxVQUFxRDtBQUN4REEsSUFBQUEsV0FBVUEsWUFBVyxLQUFLQSxXQUFXLENBQUE7QUFDckMsUUFBSXNZLFNBQVN0WSxTQUFRc1ksVUFBVTtBQUMvQkEsYUFBU2xmLEtBQUtvQyxJQUFJOGMsUUFBUUEsVUFBVXRZLFNBQVF3NUMsZUFBZSxDQUFBO0FBQzNELFVBQU0zOEIsY0FBY3ZFLFVBQVV0WSxTQUFRNmMsZUFBZTtBQUNyRCxZQUFRdkUsU0FBU3VFLGVBQWU7RUFDbEM7RUFFQTFpQixLQUFLb04sS0FBK0JnRyxNQUFpQjtBQUNuRCxVQUFNdk4sV0FBVSxLQUFLQTtBQUVyQixRQUFJLEtBQUsyWSxRQUFRM1ksU0FBUXNZLFNBQVMsT0FBTyxDQUFDb00sZUFBZSxNQUFNblgsTUFBTSxLQUFLNU0sS0FBS1gsUUFBQUEsSUFBVyxDQUFJLEdBQUE7QUFDNUY7O0FBR0Z1SCxRQUFJeVcsY0FBY2hlLFNBQVFpZTtBQUMxQjFXLFFBQUk0VyxZQUFZbmUsU0FBUTZjO0FBQ3hCdFYsUUFBSXVXLFlBQVk5ZCxTQUFRK2Q7QUFDeEIwN0IsY0FBVWx5QyxLQUFLdkgsVUFBUyxLQUFLeUIsR0FBRyxLQUFLQyxDQUFDO0VBQ3hDO0VBRUE0aEIsV0FBVztBQUNULFVBQU10akIsV0FBVSxLQUFLQSxXQUFXLENBQUE7QUFFaEMsV0FBT0EsU0FBUXNZLFNBQVN0WSxTQUFRazVDO0VBQ2xDO0FBQ0Y7QUFyRkUsY0FGbUJDLGNBRVovMEMsTUFBSzs7OztBQVNaLGNBWG1CKzBDLGNBV1o5NUMsWUFBVztFQUNoQndkLGFBQWE7RUFDYnE4QixXQUFXO0VBQ1hwOEIsa0JBQWtCO0VBQ2xCMDhCLGFBQWE7RUFDYjk3QixZQUFZO0VBQ1pwRixRQUFRO0VBQ1JPLFVBQVU7Ozs7O0FBTVosY0F4Qm1Cc2dDLGNBd0JaaHBCLGlCQUFnQjtFQUNyQnBTLGlCQUFpQjtFQUNqQkUsYUFBYTs7QUMvQmpCLFNBQVN5N0IsYUFBYUMsS0FBS3IxQixrQkFBa0I7QUFDM0MsUUFBTSxFQUFDN2lCLEdBQUdDLEdBQUdvUyxNQUFNMEIsT0FBT0QsT0FBQUEsSUFBbUNva0MsSUFBSTkwQixTQUFTO0lBQUM7SUFBSztJQUFLO0lBQVE7SUFBUztLQUFXUCxnQkFBQUE7QUFFakgsTUFBSXhpQixNQUFNRixPQUFPRCxLQUFLRSxRQUFRKzNDO0FBRTlCLE1BQUlELElBQUk5bEMsWUFBWTtBQUNsQitsQyxXQUFPcmtDLFNBQVM7QUFDaEJ6VCxXQUFPMUksS0FBS0MsSUFBSW9JLEdBQUdxUyxJQUFBQTtBQUNuQmxTLFlBQVF4SSxLQUFLb0MsSUFBSWlHLEdBQUdxUyxJQUFBQTtBQUNwQm5TLFVBQU1ELElBQUlrNEM7QUFDVi8zQyxhQUFTSCxJQUFJazRDO1NBQ1I7QUFDTEEsV0FBT3BrQyxRQUFRO0FBQ2YxVCxXQUFPTCxJQUFJbTRDO0FBQ1hoNEMsWUFBUUgsSUFBSW00QztBQUNaajRDLFVBQU12SSxLQUFLQyxJQUFJcUksR0FBR29TLElBQUFBO0FBQ2xCalMsYUFBU3pJLEtBQUtvQyxJQUFJa0csR0FBR29TLElBQUFBOztBQUd2QixTQUFPO0lBQUNoUztJQUFNSDtJQUFLQztJQUFPQztFQUFNO0FBQ2xDO0FBRUEsU0FBU2c0QyxZQUFZbGhDLE9BQU1qWSxPQUFPckgsS0FBS21DLEtBQUs7QUFDMUMsU0FBT21kLFFBQU8sSUFBSW9nQixZQUFZcjRCLE9BQU9ySCxLQUFLbUMsR0FBSTtBQUNoRDtBQUVBLFNBQVNzK0MsaUJBQWlCSCxLQUFLSSxNQUFNQyxNQUFNO0FBQ3pDLFFBQU10NUMsUUFBUWk1QyxJQUFJMzVDLFFBQVE2YztBQUMxQixRQUFNbEUsUUFBT2doQyxJQUFJMWxDO0FBQ2pCLFFBQU1xK0IsSUFBSTJILE9BQU92NUMsS0FBQUE7QUFFakIsU0FBTztJQUNMc0IsR0FBRzYzQyxZQUFZbGhDLE1BQUtoWCxLQUFLMndDLEVBQUUzd0MsS0FBSyxHQUFHcTRDLElBQUFBO0lBQ25DLzNDLEdBQUc0M0MsWUFBWWxoQyxNQUFLL1csT0FBTzB3QyxFQUFFMXdDLE9BQU8sR0FBR200QyxJQUFBQTtJQUN2QzczQyxHQUFHMjNDLFlBQVlsaEMsTUFBSzlXLFFBQVF5d0MsRUFBRXp3QyxRQUFRLEdBQUdtNEMsSUFBQUE7SUFDekM3M0MsR0FBRzAzQyxZQUFZbGhDLE1BQUs3VyxNQUFNd3dDLEVBQUV4d0MsTUFBTSxHQUFHaTRDLElBQUFBO0VBQ3ZDO0FBQ0Y7QUFFQSxTQUFTM0gsa0JBQWtCdUgsS0FBS0ksTUFBTUMsTUFBTTtBQUMxQyxRQUFNLEVBQUM5bEMsbUJBQWtCLElBQUl5bEMsSUFBSTkwQixTQUFTO0lBQUM7RUFBcUIsQ0FBQTtBQUNoRSxRQUFNbmtCLFFBQVFpNUMsSUFBSTM1QyxRQUFRdXlDO0FBQzFCLFFBQU1ELElBQUk0SCxjQUFjeDVDLEtBQUFBO0FBQ3hCLFFBQU15NUMsT0FBTy9nRCxLQUFLQyxJQUFJMGdELE1BQU1DLElBQUFBO0FBQzVCLFFBQU1yaEMsUUFBT2doQyxJQUFJMWxDO0FBSWpCLFFBQU1tbUMsZUFBZWxtQyxzQkFBc0JqVixTQUFTeUIsS0FBQUE7QUFFcEQsU0FBTztJQUNMMjVDLFNBQVNSLFlBQVksQ0FBQ08sZ0JBQWdCemhDLE1BQUtoWCxPQUFPZ1gsTUFBSzdXLE1BQU13d0MsRUFBRStILFNBQVMsR0FBR0YsSUFBQUE7SUFDM0VHLFVBQVVULFlBQVksQ0FBQ08sZ0JBQWdCemhDLE1BQUtoWCxPQUFPZ1gsTUFBSy9XLE9BQU8wd0MsRUFBRWdJLFVBQVUsR0FBR0gsSUFBQUE7SUFDOUVJLFlBQVlWLFlBQVksQ0FBQ08sZ0JBQWdCemhDLE1BQUs5VyxVQUFVOFcsTUFBSzdXLE1BQU13d0MsRUFBRWlJLFlBQVksR0FBR0osSUFBQUE7SUFDcEZLLGFBQWFYLFlBQVksQ0FBQ08sZ0JBQWdCemhDLE1BQUs5VyxVQUFVOFcsTUFBSy9XLE9BQU8wd0MsRUFBRWtJLGFBQWEsR0FBR0wsSUFBQUE7RUFDekY7QUFDRjtBQUVBLFNBQVNNLGNBQWNkLEtBQUs7QUFDMUIsUUFBTWUsU0FBU2hCLGFBQWFDLEdBQUFBO0FBQzVCLFFBQU1ua0MsUUFBUWtsQyxPQUFPOTRDLFFBQVE4NEMsT0FBTzU0QztBQUNwQyxRQUFNeVQsU0FBU21sQyxPQUFPNzRDLFNBQVM2NEMsT0FBTy80QztBQUN0QyxRQUFNK2QsU0FBU282QixpQkFBaUJILEtBQUtua0MsUUFBUSxHQUFHRCxTQUFTLENBQUE7QUFDekQsUUFBTStDLFNBQVM4NUIsa0JBQWtCdUgsS0FBS25rQyxRQUFRLEdBQUdELFNBQVMsQ0FBQTtBQUUxRCxTQUFPO0lBQ0xvbEMsT0FBTztNQUNMbDVDLEdBQUdpNUMsT0FBTzU0QztNQUNWSixHQUFHZzVDLE9BQU8vNEM7TUFDVjRtQixHQUFHL1M7TUFDSGlULEdBQUdsVDtNQUNIK0M7SUFDRjtJQUNBeThCLE9BQU87TUFDTHR6QyxHQUFHaTVDLE9BQU81NEMsT0FBTzRkLE9BQU92ZDtNQUN4QlQsR0FBR2c1QyxPQUFPLzRDLE1BQU0rZCxPQUFPMWQ7TUFDdkJ1bUIsR0FBRy9TLFFBQVFrSyxPQUFPdmQsSUFBSXVkLE9BQU96ZDtNQUM3QndtQixHQUFHbFQsU0FBU21LLE9BQU8xZCxJQUFJMGQsT0FBT3hkO01BQzlCb1csUUFBUTtRQUNOK2hDLFNBQVNqaEQsS0FBS29DLElBQUksR0FBRzhjLE9BQU8raEMsVUFBVWpoRCxLQUFLb0MsSUFBSWtrQixPQUFPMWQsR0FBRzBkLE9BQU92ZCxDQUFDLENBQUE7UUFDakVtNEMsVUFBVWxoRCxLQUFLb0MsSUFBSSxHQUFHOGMsT0FBT2dpQyxXQUFXbGhELEtBQUtvQyxJQUFJa2tCLE9BQU8xZCxHQUFHMGQsT0FBT3pkLENBQUMsQ0FBQTtRQUNuRXM0QyxZQUFZbmhELEtBQUtvQyxJQUFJLEdBQUc4YyxPQUFPaWlDLGFBQWFuaEQsS0FBS29DLElBQUlra0IsT0FBT3hkLEdBQUd3ZCxPQUFPdmQsQ0FBQyxDQUFBO1FBQ3ZFcTRDLGFBQWFwaEQsS0FBS29DLElBQUksR0FBRzhjLE9BQU9raUMsY0FBY3BoRCxLQUFLb0MsSUFBSWtrQixPQUFPeGQsR0FBR3dkLE9BQU96ZCxDQUFDLENBQUE7TUFDM0U7SUFDRjtFQUNGO0FBQ0Y7QUFFQSxTQUFTMGlCLFFBQVFnMUIsS0FBS2w0QyxHQUFHQyxHQUFHNGlCLGtCQUFrQjtBQUM1QyxRQUFNczJCLFFBQVFuNUMsTUFBTTtBQUNwQixRQUFNbzVDLFFBQVFuNUMsTUFBTTtBQUNwQixRQUFNbzVDLFdBQVdGLFNBQVNDO0FBQzFCLFFBQU1ILFNBQVNmLE9BQU8sQ0FBQ21CLFlBQVlwQixhQUFhQyxLQUFLcjFCLGdCQUFBQTtBQUVyRCxTQUFPbzJCLFdBQ0hFLFNBQVNuRixXQUFXaDBDLEdBQUdpNUMsT0FBTzU0QyxNQUFNNDRDLE9BQU85NEMsS0FBSyxPQUNoRGk1QyxTQUFTcEYsV0FBVy96QyxHQUFHZzVDLE9BQU8vNEMsS0FBSys0QyxPQUFPNzRDLE1BQU07QUFDdEQ7QUFFQSxTQUFTazVDLFVBQVV6aUMsUUFBUTtBQUN6QixTQUFPQSxPQUFPK2hDLFdBQVcvaEMsT0FBT2dpQyxZQUFZaGlDLE9BQU9paUMsY0FBY2ppQyxPQUFPa2lDO0FBQzFFO0FBT0EsU0FBU1Esa0JBQWtCenpDLEtBQUt1cUMsTUFBTTtBQUNwQ3ZxQyxNQUFJdXFDLEtBQUtBLEtBQUtyd0MsR0FBR3F3QyxLQUFLcHdDLEdBQUdvd0MsS0FBS3ZwQixHQUFHdXBCLEtBQUtycEIsQ0FBQztBQUN6QztBQUVBLFNBQVN3eUIsWUFBWW5KLE1BQU1vSixRQUFRQyxVQUFVLENBQUEsR0FBSTtBQUMvQyxRQUFNMTVDLElBQUlxd0MsS0FBS3J3QyxNQUFNMDVDLFFBQVExNUMsSUFBSSxDQUFDeTVDLFNBQVM7QUFDM0MsUUFBTXg1QyxJQUFJb3dDLEtBQUtwd0MsTUFBTXk1QyxRQUFRejVDLElBQUksQ0FBQ3c1QyxTQUFTO0FBQzNDLFFBQU0zeUIsS0FBS3VwQixLQUFLcndDLElBQUlxd0MsS0FBS3ZwQixNQUFNNHlCLFFBQVExNUMsSUFBSTA1QyxRQUFRNXlCLElBQUkyeUIsU0FBUyxLQUFLejVDO0FBQ3JFLFFBQU1nbkIsS0FBS3FwQixLQUFLcHdDLElBQUlvd0MsS0FBS3JwQixNQUFNMHlCLFFBQVF6NUMsSUFBSXk1QyxRQUFRMXlCLElBQUl5eUIsU0FBUyxLQUFLeDVDO0FBQ3JFLFNBQU87SUFDTEQsR0FBR3F3QyxLQUFLcndDLElBQUlBO0lBQ1pDLEdBQUdvd0MsS0FBS3B3QyxJQUFJQTtJQUNaNm1CLEdBQUd1cEIsS0FBS3ZwQixJQUFJQTtJQUNaRSxHQUFHcXBCLEtBQUtycEIsSUFBSUE7SUFDWm5RLFFBQVF3NUIsS0FBS3g1QjtFQUNmO0FBQ0Y7QUFFZSxJQUFNOGlDLGFBQU4sY0FBeUJ0ckIsUUFBQUE7RUF1QnRDOTNCLFlBQVk2RSxLQUFLO0FBQ2YsVUFBSztBQUVMLFNBQUttRCxVQUFVMUg7QUFDZixTQUFLdWIsYUFBYXZiO0FBQ2xCLFNBQUt3YixPQUFPeGI7QUFDWixTQUFLa2QsUUFBUWxkO0FBQ2IsU0FBS2lkLFNBQVNqZDtBQUNkLFNBQUtxYyxnQkFBZ0JyYztBQUVyQixRQUFJdUUsS0FBSztBQUNQc0MsYUFBT3lCLE9BQU8sTUFBTS9ELEdBQUFBOztFQUV4QjtFQUVBMUMsS0FBS29OLEtBQUs7QUFDUixVQUFNLEVBQUNvTixlQUFlM1UsU0FBUyxFQUFDaWUsYUFBYUYsZ0JBQUFBLEVBQWdCLElBQUk7QUFDakUsVUFBTSxFQUFDZzNCLE9BQU80RixNQUFBQSxJQUFTRixjQUFjLElBQUk7QUFDekMsVUFBTVksY0FBY04sVUFBVUosTUFBTXJpQyxNQUFNLElBQUlnakMscUJBQXFCTjtBQUVuRXp6QyxRQUFJczNCLEtBQUk7QUFFUixRQUFJOGIsTUFBTXB5QixNQUFNd3NCLE1BQU14c0IsS0FBS295QixNQUFNbHlCLE1BQU1zc0IsTUFBTXRzQixHQUFHO0FBQzlDbGhCLFVBQUkrM0IsVUFBUztBQUNiK2Isa0JBQVk5ekMsS0FBSzB6QyxZQUFZTixPQUFPaG1DLGVBQWVvZ0MsS0FBQUEsQ0FBQUE7QUFDbkR4dEMsVUFBSThGLEtBQUk7QUFDUmd1QyxrQkFBWTl6QyxLQUFLMHpDLFlBQVlsRyxPQUFPLENBQUNwZ0MsZUFBZWdtQyxLQUFBQSxDQUFBQTtBQUNwRHB6QyxVQUFJdVcsWUFBWUc7QUFDaEIxVyxVQUFJbUIsS0FBSyxTQUFBOztBQUdYbkIsUUFBSSszQixVQUFTO0FBQ2IrYixnQkFBWTl6QyxLQUFLMHpDLFlBQVlsRyxPQUFPcGdDLGFBQUFBLENBQUFBO0FBQ3BDcE4sUUFBSXVXLFlBQVlDO0FBQ2hCeFcsUUFBSW1CLEtBQUk7QUFFUm5CLFFBQUl3M0IsUUFBTztFQUNiO0VBRUFwYSxRQUFReTBCLFFBQVFDLFFBQVEvMEIsa0JBQWtCO0FBQ3hDLFdBQU9LLFFBQVEsTUFBTXkwQixRQUFRQyxRQUFRLzBCLGdCQUFBQTtFQUN2QztFQUVBZzFCLFNBQVNGLFFBQVE5MEIsa0JBQWtCO0FBQ2pDLFdBQU9LLFFBQVEsTUFBTXkwQixRQUFRLE1BQU05MEIsZ0JBQUFBO0VBQ3JDO0VBRUFpMUIsU0FBU0YsUUFBUS8wQixrQkFBa0I7QUFDakMsV0FBT0ssUUFBUSxNQUFNLE1BQU0wMEIsUUFBUS8wQixnQkFBQUE7RUFDckM7RUFFQVksZUFBZVosa0JBQWtCO0FBQy9CLFVBQU0sRUFBQzdpQixHQUFHQyxHQUFHb1MsTUFBTUQsV0FBVSxJQUE2QixLQUFLZ1IsU0FBUztNQUFDO01BQUs7TUFBSztNQUFRO09BQWVQLGdCQUFBQTtBQUMxRyxXQUFPO01BQ0w3aUIsR0FBR29TLGNBQWNwUyxJQUFJcVMsUUFBUSxJQUFJclM7TUFDakNDLEdBQUdtUyxhQUFhblMsS0FBS0EsSUFBSW9TLFFBQVE7SUFDbkM7RUFDRjtFQUVBd1AsU0FBUzNmLE1BQU07QUFDYixXQUFPQSxTQUFTLE1BQU0sS0FBSzZSLFFBQVEsSUFBSSxLQUFLRCxTQUFTO0VBQ3ZEO0FBQ0Y7QUFuRkUsY0FGbUI2bEMsWUFFWmgzQyxNQUFLO0FBS1osY0FQbUJnM0MsWUFPWi83QyxZQUFXO0VBQ2hCNFUsZUFBZTtFQUNmNEksYUFBYTtFQUNiMDFCLGNBQWM7RUFDZDU5QixlQUFlO0VBQ2YrSSxZQUFZcGxCOztBQU1kLGNBbEJtQjhpRCxZQWtCWmpyQixpQkFBZ0I7RUFDckJwUyxpQkFBaUI7RUFDakJFLGFBQWE7Ozs7Ozs7OztBQ25KakIsSUFBTXM5QixnQkFBZ0I7RUFDcEI7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7O0FBQ0Q7QUFHRCxJQUFNQyxvQkFBb0NELDhCQUFjNTlCLElBQUl2aEIsQ0FBQUEsV0FBU0EsT0FBTXEvQyxRQUFRLFFBQVEsT0FBU0EsRUFBQUEsUUFBUSxLQUFLLFFBQUEsQ0FBQTtBQUVqSCxTQUFTQyxlQUFleGhELEdBQVc7QUFDakMsU0FBT3FoRCxjQUFjcmhELElBQUlxaEQsY0FBY3RoRCxNQUFNO0FBQy9DO0FBRUEsU0FBUzBoRCxtQkFBbUJ6aEQsR0FBVztBQUNyQyxTQUFPc2hELGtCQUFrQnRoRCxJQUFJc2hELGtCQUFrQnZoRCxNQUFNO0FBQ3ZEO0FBRUEsU0FBUzJoRCx1QkFBdUJ0MUMsU0FBdUJwTSxHQUFXO0FBQ2hFb00sVUFBUTJYLGNBQWN5OUIsZUFBZXhoRCxDQUFBQTtBQUNyQ29NLFVBQVF5WCxrQkFBa0I0OUIsbUJBQW1CemhELENBQUFBO0FBRTdDLFNBQU8sRUFBRUE7QUFDWDtBQUVBLFNBQVMyaEQsd0JBQXdCdjFDLFNBQXVCcE0sR0FBVztBQUNqRW9NLFVBQVF5WCxrQkFBa0J6WCxRQUFRaEQsS0FBS3FhLElBQUksTUFBTSs5QixlQUFleGhELEdBQUFBLENBQUFBO0FBRWhFLFNBQU9BO0FBQ1Q7QUFFQSxTQUFTNGhELHlCQUF5QngxQyxTQUF1QnBNLEdBQVc7QUFDbEVvTSxVQUFReVgsa0JBQWtCelgsUUFBUWhELEtBQUtxYSxJQUFJLE1BQU1nK0IsbUJBQW1CemhELEdBQUFBLENBQUFBO0FBRXBFLFNBQU9BO0FBQ1Q7QUFFQSxTQUFTNmhELGFBQWF2akQsT0FBYztBQUNsQyxNQUFJMEIsSUFBSTtBQUVSLFNBQU8sQ0FBQ29NLFNBQXVCdEQsaUJBQXlCO0FBQ3RELFVBQU1vQyxhQUFhNU0sTUFBTXdSLGVBQWVoSCxZQUFBQSxFQUFjb0M7QUFFdEQsUUFBSUEsc0JBQXNCbVYsb0JBQW9CO0FBQzVDcmdCLFVBQUkyaEQsd0JBQXdCdjFDLFNBQVNwTSxDQUFBQTtlQUM1QmtMLHNCQUFzQjBhLHFCQUFxQjtBQUNwRDVsQixVQUFJNGhELHlCQUF5QngxQyxTQUFTcE0sQ0FBQUE7SUFDeEMsV0FBV2tMLFlBQVk7QUFDckJsTCxVQUFJMGhELHVCQUF1QnQxQyxTQUFTcE0sQ0FBQUE7O0VBRXhDO0FBQ0Y7QUFFQSxTQUFTOGhELDBCQUNQOStCLGNBQ0E7QUFDQSxNQUFJKytCO0FBRUosT0FBS0EsS0FBSy8rQixjQUFhO0FBQ3JCLFFBQUlBLGFBQVkrK0IsQ0FBQUEsRUFBR2grQixlQUFlZixhQUFZKytCLENBQUFBLEVBQUdsK0IsaUJBQWlCO0FBQ2hFLGFBQU87O0VBRVg7QUFFQSxTQUFPO0FBQ1Q7QUFFQSxTQUFTbStCLHlCQUNQalksWUFDQTtBQUNBLFNBQU9BLGVBQWVBLFdBQVdobUIsZUFBZWdtQixXQUFXbG1CO0FBQzdEO0FBRUEsU0FBU28rQixtQ0FBbUM7QUFDMUMsU0FBTzk4QyxTQUFTNGUsZ0JBQWdCLHFCQUFxQjVlLFNBQVMwZSxvQkFBb0I7QUFDcEY7QUFFQSxJQUFBLGdCQUFlO0VBQ2IzWixJQUFJO0VBRUovRSxVQUFVO0lBQ1J1eEIsU0FBUztJQUNUd3JCLGVBQWU7RUFDakI7RUFFQS94QixhQUFhN3hCLE9BQWM2akQsT0FBT3I4QyxVQUE4QjtBQUM5RCxRQUFJLENBQUNBLFNBQVE0d0IsU0FBUztBQUNwQjs7QUFHRixVQUFNLEVBQ0p0dEIsTUFBTSxFQUFDeUcsU0FBQUEsR0FDUC9KLFNBQVNzOEMsYUFBWSxJQUNuQjlqRCxNQUFNcUc7QUFDVixVQUFNLEVBQUN5TyxVQUFBQSxVQUFRLElBQUlndkM7QUFFbkIsVUFBTUMsMEJBQ0pQLDBCQUEwQmp5QyxRQUFBQSxLQUMxQm15Qyx5QkFBeUJJLFlBQ3hCaHZDLEtBQUFBLGFBQVkwdUMsMEJBQTBCMXVDLFNBQ3ZDNnVDLEtBQUFBLGlDQUFBQTtBQUVGLFFBQUksQ0FBQ244QyxTQUFRbzhDLGlCQUFpQkcseUJBQXlCO0FBQ3JEOztBQUdGLFVBQU1DLFlBQVlULGFBQWF2akQsS0FBQUE7QUFFL0J1UixhQUFTL1EsUUFBUXdqRCxTQUFBQTtFQUNuQjtBQUNGO0FDNUhBLFNBQVNDLGVBQWVuNUMsTUFBTWhLLE9BQU9nUyxPQUFPOGIsZ0JBQWdCcG5CLFVBQVM7QUFTbkUsUUFBTTA4QyxVQUFVMThDLFNBQVEwOEMsV0FBV3QxQjtBQUVuQyxNQUFJczFCLFdBQVdweEMsT0FBTztBQUNwQixXQUFPaEksS0FBSzBmLE1BQU0xcEIsT0FBT0EsUUFBUWdTLEtBQUFBOztBQUduQyxRQUFNcXhDLFlBQVksQ0FBQTtBQUVsQixRQUFNQyxlQUFldHhDLFFBQVEsTUFBTW94QyxVQUFVO0FBQzdDLE1BQUlHLGVBQWU7QUFDbkIsUUFBTUMsV0FBV3hqRCxRQUFRZ1MsUUFBUTtBQUVqQyxNQUFJaUcsSUFBSWpZO0FBQ1IsTUFBSVksR0FBRzZpRCxjQUFjQyxTQUFTenZDLE1BQU0wdkM7QUFFcENOLFlBQVVFLGNBQUFBLElBQWtCdjVDLEtBQUtpTyxDQUFFO0FBRW5DLE9BQUtyWCxJQUFJLEdBQUdBLElBQUl3aUQsVUFBVSxHQUFHeGlELEtBQUs7QUFDaEMsUUFBSWc5QyxPQUFPO0FBQ1gsUUFBSWdHLE9BQU87QUFDWCxRQUFJdjVCO0FBR0osVUFBTXc1QixnQkFBZ0IvakQsS0FBS29FLE9BQU90RCxJQUFJLEtBQUswaUQsV0FBQUEsSUFBZSxJQUFJdGpEO0FBQzlELFVBQU04akQsY0FBY2hrRCxLQUFLQyxJQUFJRCxLQUFLb0UsT0FBT3RELElBQUksS0FBSzBpRCxXQUFBQSxJQUFlLEdBQUd0eEMsS0FBU2hTLElBQUFBO0FBQzdFLFVBQU0rakQsaUJBQWlCRCxjQUFjRDtBQUVyQyxTQUFLeDVCLElBQUl3NUIsZUFBZXg1QixJQUFJeTVCLGFBQWF6NUIsS0FBSztBQUM1Q3V6QixjQUFRNXpDLEtBQUtxZ0IsQ0FBRSxFQUFDbGlCO0FBQ2hCeTdDLGNBQVE1NUMsS0FBS3FnQixDQUFFLEVBQUNqaUI7SUFDbEI7QUFFQXcxQyxZQUFRbUc7QUFDUkgsWUFBUUc7QUFHUixVQUFNQyxZQUFZbGtELEtBQUtvRSxNQUFNdEQsSUFBSTBpRCxXQUFBQSxJQUFlLElBQUl0akQ7QUFDcEQsVUFBTWlrRCxVQUFVbmtELEtBQUtDLElBQUlELEtBQUtvRSxPQUFPdEQsSUFBSSxLQUFLMGlELFdBQUFBLElBQWUsR0FBR3R4QyxLQUFTaFMsSUFBQUE7QUFDekUsVUFBTSxFQUFDbUksR0FBRys3QyxTQUFTOTdDLEdBQUcrN0MsUUFBQUEsSUFBV242QyxLQUFLaU8sQ0FBRTtBQU94Q3lyQyxjQUFVenZDLE9BQU87QUFFakIsU0FBS29XLElBQUkyNUIsV0FBVzM1QixJQUFJNDVCLFNBQVM1NUIsS0FBSztBQUNwQ3BXLGFBQU8sTUFBTW5VLEtBQUt3WSxLQUNmNHJDLFVBQVV0RyxTQUFTNXpDLEtBQUtxZ0IsQ0FBQUEsRUFBR2ppQixJQUFJKzdDLFlBQy9CRCxVQUFVbDZDLEtBQUtxZ0IsQ0FBRSxFQUFDbGlCLE1BQU15N0MsT0FBT08sUUFBTTtBQUd4QyxVQUFJbHdDLE9BQU95dkMsU0FBUztBQUNsQkEsa0JBQVV6dkM7QUFDVnd2Qyx1QkFBZXo1QyxLQUFLcWdCLENBQUU7QUFDdEJzNUIsZ0JBQVF0NUI7O0lBRVo7QUFFQWc1QixjQUFVRSxjQUFBQSxJQUFrQkU7QUFDNUJ4ckMsUUFBSTByQztFQUNOO0FBR0FOLFlBQVVFLGNBQUFBLElBQWtCdjVDLEtBQUt3NUMsUUFBUztBQUUxQyxTQUFPSDtBQUNUO0FBRUEsU0FBU2UsaUJBQWlCcDZDLE1BQU1oSyxPQUFPZ1MsT0FBTzhiLGdCQUFnQjtBQUM1RCxNQUFJOHZCLE9BQU87QUFDWCxNQUFJQyxTQUFTO0FBQ2IsTUFBSWo5QyxHQUFHc2UsT0FBTy9XLEdBQUdDLEdBQUcwMUMsT0FBT3VHLFVBQVVDLFVBQVVDLFlBQVl2akMsTUFBTUo7QUFDakUsUUFBTXlpQyxZQUFZLENBQUE7QUFDbEIsUUFBTUcsV0FBV3hqRCxRQUFRZ1MsUUFBUTtBQUVqQyxRQUFNd3lDLE9BQU94NkMsS0FBS2hLLEtBQUFBLEVBQU9tSTtBQUN6QixRQUFNczhDLE9BQU96NkMsS0FBS3c1QyxRQUFBQSxFQUFVcjdDO0FBQzVCLFFBQU11OEMsS0FBS0QsT0FBT0Q7QUFFbEIsT0FBSzVqRCxJQUFJWixPQUFPWSxJQUFJWixRQUFRZ1MsT0FBTyxFQUFFcFIsR0FBRztBQUN0Q3NlLFlBQVFsVixLQUFLcEosQ0FBRTtBQUNmdUgsU0FBSytXLE1BQU0vVyxJQUFJcThDLFFBQVFFLEtBQUs1MkI7QUFDNUIxbEIsUUFBSThXLE1BQU05VztBQUNWLFVBQU04MUMsU0FBUy8xQyxJQUFJO0FBRW5CLFFBQUkrMUMsV0FBV0osT0FBTztBQUVwQixVQUFJMTFDLElBQUk0WSxNQUFNO0FBQ1pBLGVBQU81WTtBQUNQaThDLG1CQUFXempEO2lCQUNGd0gsSUFBSXdZLE1BQU07QUFDbkJBLGVBQU94WTtBQUNQazhDLG1CQUFXMWpEOztBQUliZzlDLGNBQVFDLFNBQVNELE9BQU8xK0IsTUFBTS9XLEtBQUssRUFBRTAxQztXQUNoQztBQUVMLFlBQU04RyxZQUFZL2pELElBQUk7QUFFdEIsVUFBSSxDQUFDb1ksY0FBY3FyQyxRQUFhLEtBQUEsQ0FBQ3JyQyxjQUFjc3JDLFFBQVcsR0FBQTtBQUt4RCxjQUFNTSxxQkFBcUI5a0QsS0FBS0MsSUFBSXNrRCxVQUFVQyxRQUFBQTtBQUM5QyxjQUFNTyxxQkFBcUIva0QsS0FBS29DLElBQUltaUQsVUFBVUMsUUFBQUE7QUFFOUMsWUFBSU0sdUJBQXVCTCxjQUFjSyx1QkFBdUJELFdBQVc7QUFDekV0QixvQkFBVXpoRCxLQUFLO1lBQ2IsR0FBR29JLEtBQUs0NkMsa0JBQW1CO1lBQzNCejhDLEdBQUd5MUM7VUFDTCxDQUFBOztBQUVGLFlBQUlpSCx1QkFBdUJOLGNBQWNNLHVCQUF1QkYsV0FBVztBQUN6RXRCLG9CQUFVemhELEtBQUs7WUFDYixHQUFHb0ksS0FBSzY2QyxrQkFBbUI7WUFDM0IxOEMsR0FBR3kxQztVQUNMLENBQUE7OztBQU1KLFVBQUloOUMsSUFBSSxLQUFLK2pELGNBQWNKLFlBQVk7QUFFckNsQixrQkFBVXpoRCxLQUFLb0ksS0FBSzI2QyxTQUFVLENBQUE7O0FBSWhDdEIsZ0JBQVV6aEQsS0FBS3NkLEtBQUFBO0FBQ2Y0K0IsY0FBUUk7QUFDUkwsZUFBUztBQUNUNzhCLGFBQU9KLE9BQU94WTtBQUNkaThDLGlCQUFXQyxXQUFXQyxhQUFhM2pEOztFQUV2QztBQUVBLFNBQU95aUQ7QUFDVDtBQUVBLFNBQVN5QixzQkFBc0I5M0MsU0FBUztBQUN0QyxNQUFJQSxRQUFReVksWUFBWTtBQUN0QixVQUFNemIsT0FBT2dELFFBQVFzQjtBQUNyQixXQUFPdEIsUUFBUXlZO0FBQ2YsV0FBT3pZLFFBQVFzQjtBQUNmekksV0FBT2svQyxlQUFlLzNDLFNBQVMsUUFBUTtNQUNyQ2c0QyxjQUFjO01BQ2RDLFlBQVk7TUFDWkMsVUFBVTtNQUNWOTlDLE9BQU80QztJQUNULENBQUE7O0FBRUo7QUFFQSxTQUFTbTdDLG1CQUFtQmptRCxPQUFPO0FBQ2pDQSxRQUFNOEssS0FBS3lHLFNBQVMvUSxRQUFRLENBQUNzTixZQUFZO0FBQ3ZDODNDLDBCQUFzQjkzQyxPQUFBQTtFQUN4QixDQUFBO0FBQ0Y7QUFFQSxTQUFTbzRDLDBDQUEwQ243QyxNQUFNZ1YsUUFBUTtBQUMvRCxRQUFNb21DLGFBQWFwbUMsT0FBT3RlO0FBRTFCLE1BQUlYLFFBQVE7QUFDWixNQUFJZ1M7QUFFSixRQUFNLEVBQUM5SCxPQUFNLElBQUlEO0FBQ2pCLFFBQU0sRUFBQ2xLLEtBQUttQyxLQUFLOEksWUFBWUMsV0FBVSxJQUFJZixPQUFPYSxjQUFhO0FBRS9ELE1BQUlDLFlBQVk7QUFDZGhMLFlBQVF5L0IsWUFBWWxXLGFBQWF0SyxRQUFRL1UsT0FBT0csTUFBTXRLLEdBQUs0cEIsRUFBQUEsSUFBSSxHQUFHMDdCLGFBQWEsQ0FBQTs7QUFFakYsTUFBSXA2QyxZQUFZO0FBQ2QrRyxZQUFReXRCLFlBQVlsVyxhQUFhdEssUUFBUS9VLE9BQU9HLE1BQU1uSSxHQUFBQSxFQUFLNG5CLEtBQUssR0FBRzlwQixPQUFPcWxELFVBQWNybEQsSUFBQUE7U0FDbkY7QUFDTGdTLFlBQVFxekMsYUFBYXJsRDs7QUFHdkIsU0FBTztJQUFDQTtJQUFPZ1M7RUFBSztBQUN0QjtBQUVBLElBQUEsb0JBQWU7RUFDYmxILElBQUk7RUFFSi9FLFVBQVU7SUFDUnUvQyxXQUFXO0lBQ1hodUIsU0FBUztFQUNYO0VBRUFpdUIsc0JBQXNCLENBQUNybUQsT0FBTytYLE1BQU12USxhQUFZO0FBQzlDLFFBQUksQ0FBQ0EsU0FBUTR3QixTQUFTO0FBRXBCNnRCLHlCQUFtQmptRCxLQUFBQTtBQUNuQjs7QUFJRixVQUFNNHVCLGlCQUFpQjV1QixNQUFNZ2Q7QUFFN0JoZCxVQUFNOEssS0FBS3lHLFNBQVMvUSxRQUFRLENBQUNzTixTQUFTdEQsaUJBQWlCO0FBQ3JELFlBQU0sRUFBQzRFLE9BQU80QixVQUFBQSxJQUFhbEQ7QUFDM0IsWUFBTS9DLE9BQU8vSyxNQUFNd1IsZUFBZWhILFlBQUFBO0FBQ2xDLFlBQU1NLE9BQU9zRSxTQUFTdEIsUUFBUWhEO0FBRTlCLFVBQUlyRyxRQUFRO1FBQUN1TTtRQUFXaFIsTUFBTXdILFFBQVF3SjtNQUFVLENBQUEsTUFBTSxLQUFLO0FBRXpEOztBQUdGLFVBQUksQ0FBQ2pHLEtBQUs2QixXQUFXOEMsb0JBQW9CO0FBRXZDOztBQUdGLFlBQU00MkMsUUFBUXRtRCxNQUFNd04sT0FBT3pDLEtBQUsyRixPQUFPO0FBQ3ZDLFVBQUk0MUMsTUFBTW5tRCxTQUFTLFlBQVltbUQsTUFBTW5tRCxTQUFTLFFBQVE7QUFFcEQ7O0FBR0YsVUFBSUgsTUFBTXdILFFBQVFvTCxTQUFTO0FBRXpCOztBQUdGLFVBQUksRUFBQzlSLE9BQU9nUyxNQUFBQSxJQUFTb3pDLDBDQUEwQ243QyxNQUFNRCxJQUFBQTtBQUNyRSxZQUFNeTdDLFlBQVkvK0MsU0FBUSsrQyxhQUFhLElBQUkzM0I7QUFDM0MsVUFBSTliLFNBQVN5ekMsV0FBVztBQUV0QlgsOEJBQXNCOTNDLE9BQUFBO0FBQ3RCOztBQUdGLFVBQUlnTSxjQUFjMUssS0FBUSxHQUFBO0FBSXhCdEIsZ0JBQVFzQixRQUFRdEU7QUFDaEIsZUFBT2dELFFBQVFoRDtBQUNmbkUsZUFBT2svQyxlQUFlLzNDLFNBQVMsUUFBUTtVQUNyQ2c0QyxjQUFjO1VBQ2RDLFlBQVk7VUFDWjVqRCxLQUFLLFdBQVc7QUFDZCxtQkFBTyxLQUFLb2tCO1VBQ2Q7VUFDQWprQixLQUFLLFNBQVNtckMsR0FBRztBQUNmLGlCQUFLcitCLFFBQVFxK0I7VUFDZjtRQUNGLENBQUE7O0FBSUYsVUFBSTBXO0FBQ0osY0FBUTM4QyxTQUFRNCtDLFdBQVM7UUFDekIsS0FBSztBQUNIakMsc0JBQVlGLGVBQWVuNUMsTUFBTWhLLE9BQU9nUyxPQUFPOGIsZ0JBQWdCcG5CLFFBQUFBO0FBQy9EO1FBQ0YsS0FBSztBQUNIMjhDLHNCQUFZZSxpQkFBaUJwNkMsTUFBTWhLLE9BQU9nUyxPQUFPOGIsY0FBQUE7QUFDakQ7UUFDRjtBQUNFLGdCQUFNLElBQUl6RixNQUFNLHFDQUFxQzNoQixTQUFRNCtDLFNBQVMsR0FBRztNQUMzRTtBQUVBdDRDLGNBQVF5WSxhQUFhNDlCO0lBQ3ZCLENBQUE7RUFDRjtFQUVBL00sUUFBUXAzQyxPQUFPO0FBQ2JpbUQsdUJBQW1Cam1ELEtBQUFBO0VBQ3JCO0FBQ0Y7QUM1Uk8sU0FBU2lnRCxVQUFVaDZCLE1BQU0zaEIsUUFBUTJrQyxVQUFVO0FBQ2hELFFBQU0yVyxXQUFXMzVCLEtBQUsyNUI7QUFDdEIsUUFBTTcvQixTQUFTa0csS0FBS2xHO0FBQ3BCLFFBQU15bUMsVUFBVWxpRCxPQUFPeWI7QUFDdkIsUUFBTXdwQixRQUFRLENBQUE7QUFFZCxhQUFXOWlCLFdBQVdtNUIsVUFBVTtBQUM5QixRQUFJLEVBQUM5K0MsT0FBTytILElBQUFBLElBQU80ZDtBQUNuQjVkLFVBQU00OUMsZ0JBQWdCM2xELE9BQU8rSCxLQUFLa1gsTUFBQUE7QUFFbEMsVUFBTW1pQyxTQUFTd0UsV0FBV3pkLFVBQVVscEIsT0FBT2pmLEtBQUFBLEdBQVFpZixPQUFPbFgsR0FBQUEsR0FBTTRkLFFBQVF0aEIsSUFBSTtBQUU1RSxRQUFJLENBQUNiLE9BQU9zN0MsVUFBVTtBQUdwQnJXLFlBQU03bUMsS0FBSztRQUNUazhCLFFBQVFuWTtRQUNSbmlCLFFBQVE0OUM7UUFDUnBoRCxPQUFPaWYsT0FBT2pmLEtBQU07UUFDcEIrSCxLQUFLa1gsT0FBT2xYLEdBQUk7TUFDbEIsQ0FBQTtBQUNBOztBQUlGLFVBQU04OUMsaUJBQWlCckcsZUFBZWg4QyxRQUFRNDlDLE1BQUFBO0FBRTlDLGVBQVcwRSxPQUFPRCxnQkFBZ0I7QUFDaEMsWUFBTUUsWUFBWUgsV0FBV3pkLFVBQVV1ZCxRQUFRSSxJQUFJOWxELEtBQUssR0FBRzBsRCxRQUFRSSxJQUFJLzlDLEdBQUcsR0FBRys5QyxJQUFJemhELElBQUk7QUFDckYsWUFBTTJoRCxjQUFjQyxjQUFjdGdDLFNBQVMxRyxRQUFROG1DLFNBQUFBO0FBRW5ELGlCQUFXRyxjQUFjRixhQUFhO0FBQ3BDdmQsY0FBTTdtQyxLQUFLO1VBQ1RrOEIsUUFBUW9vQjtVQUNSMWlELFFBQVFzaUQ7VUFDUjlsRCxPQUFPO1lBQ0wsQ0FBQ21vQyxRQUFBQSxHQUFXZ2UsU0FBUy9FLFFBQVEyRSxXQUFXLFNBQVNqbUQsS0FBS29DLEdBQUc7VUFDM0Q7VUFDQTZGLEtBQUs7WUFDSCxDQUFDb2dDLFFBQUFBLEdBQVdnZSxTQUFTL0UsUUFBUTJFLFdBQVcsT0FBT2ptRCxLQUFLQyxHQUFHO1VBQ3pEO1FBQ0YsQ0FBQTtNQUNGO0lBQ0Y7RUFDRjtBQUNBLFNBQU8wb0M7QUFDVDtBQUVPLFNBQVNtZCxXQUFXemQsVUFBVTFRLE9BQU9yYixNQUFNL1gsTUFBTTtBQUN0RCxNQUFJQSxNQUFNO0FBQ1I7O0FBRUYsTUFBSXJFLFFBQVF5M0IsTUFBTTBRLFFBQVM7QUFDM0IsTUFBSXBnQyxNQUFNcVUsS0FBSytyQixRQUFTO0FBRXhCLE1BQUlBLGFBQWEsU0FBUztBQUN4Qm5vQyxZQUFRbzRDLGdCQUFnQnA0QyxLQUFBQTtBQUN4QitILFVBQU1xd0MsZ0JBQWdCcndDLEdBQUFBOztBQUV4QixTQUFPO0lBQUNvZ0M7SUFBVW5vQztJQUFPK0g7RUFBRztBQUM5QjtBQUVPLFNBQVNxK0Msb0JBQW9CQyxVQUFVbGhDLE1BQU07QUFDbEQsUUFBTSxFQUFDaGQsSUFBSSxNQUFNQyxJQUFJLEtBQUksSUFBSWkrQyxZQUFZLENBQUE7QUFDekMsUUFBTUMsYUFBYW5oQyxLQUFLbEc7QUFDeEIsUUFBTUEsU0FBUyxDQUFBO0FBQ2ZrRyxPQUFLMjVCLFNBQVNwL0MsUUFBUSxDQUFDLEVBQUNNLE9BQU8rSCxJQUFHLE1BQU07QUFDdENBLFVBQU00OUMsZ0JBQWdCM2xELE9BQU8rSCxLQUFLdStDLFVBQUFBO0FBQ2xDLFVBQU03dUIsUUFBUTZ1QixXQUFXdG1ELEtBQU07QUFDL0IsVUFBTW9jLE9BQU9rcUMsV0FBV3YrQyxHQUFJO0FBQzVCLFFBQUlLLE1BQU0sTUFBTTtBQUNkNlcsYUFBT3JkLEtBQUs7UUFBQ3VHLEdBQUdzdkIsTUFBTXR2QjtRQUFHQztNQUFDLENBQUE7QUFDMUI2VyxhQUFPcmQsS0FBSztRQUFDdUcsR0FBR2lVLEtBQUtqVTtRQUFHQztNQUFDLENBQUE7ZUFDaEJELE1BQU0sTUFBTTtBQUNyQjhXLGFBQU9yZCxLQUFLO1FBQUN1RztRQUFHQyxHQUFHcXZCLE1BQU1ydkI7TUFBQyxDQUFBO0FBQzFCNlcsYUFBT3JkLEtBQUs7UUFBQ3VHO1FBQUdDLEdBQUdnVSxLQUFLaFU7TUFBQyxDQUFBOztFQUU3QixDQUFBO0FBQ0EsU0FBTzZXO0FBQ1Q7QUFFTyxTQUFTMG1DLGdCQUFnQjNsRCxPQUFPK0gsS0FBS2tYLFFBQVE7QUFDbEQsU0FBTWxYLE1BQU0vSCxPQUFPK0gsT0FBTztBQUN4QixVQUFNbVgsUUFBUUQsT0FBT2xYLEdBQUk7QUFDekIsUUFBSSxDQUFDNFUsTUFBTXVDLE1BQU0vVyxDQUFDLEtBQUssQ0FBQ3dVLE1BQU11QyxNQUFNOVcsQ0FBQyxHQUFHO0FBQ3RDOztFQUVKO0FBQ0EsU0FBT0w7QUFDVDtBQUVBLFNBQVNvK0MsU0FBU2x1QyxHQUFHclAsR0FBR25GLE1BQU05RCxJQUFJO0FBQ2hDLE1BQUlzWSxLQUFLclAsR0FBRztBQUNWLFdBQU9qSixHQUFHc1ksRUFBRXhVLElBQUFBLEdBQU9tRixFQUFFbkYsSUFBSyxDQUFBOztBQUU1QixTQUFPd1UsSUFBSUEsRUFBRXhVLElBQUssSUFBR21GLElBQUlBLEVBQUVuRixJQUFLLElBQUc7QUFDckM7QUNuRk8sU0FBUzhpRCxvQkFBb0JGLFVBQVVsaEMsTUFBTTtBQUNsRCxNQUFJbEcsU0FBUyxDQUFBO0FBQ2IsTUFBSTdhLFFBQVE7QUFFWixNQUFJaUMsUUFBUWdnRCxRQUFXLEdBQUE7QUFDckJqaUQsWUFBUTtBQUVSNmEsYUFBU29uQztTQUNKO0FBQ0xwbkMsYUFBU21uQyxvQkFBb0JDLFVBQVVsaEMsSUFBQUE7O0FBR3pDLFNBQU9sRyxPQUFPdGUsU0FBUyxJQUFJcytDLFlBQVk7SUFDckNoZ0M7SUFDQXZZLFNBQVM7TUFBQ3MyQyxTQUFTO0lBQUM7SUFDcEI1NEM7SUFDQXlqQixXQUFXempCO0VBQ2IsQ0FBQSxJQUFLO0FBQ1A7QUFFTyxTQUFTb2lELGlCQUFpQjFvQixRQUFRO0FBQ3ZDLFNBQU9BLFVBQVVBLE9BQU8xdUIsU0FBUztBQUNuQztBQzVCTyxTQUFTcTNDLGVBQWVDLFNBQVN0OUMsUUFBT3U5QyxXQUFXO0FBQ3hELFFBQU03b0IsU0FBUzRvQixRQUFRdDlDLE1BQU07QUFDN0IsTUFBSWdHLFFBQU8wdUIsT0FBTzF1QjtBQUNsQixRQUFNdzNDLFVBQVU7SUFBQ3g5QztFQUFNO0FBQ3ZCLE1BQUk1RjtBQUVKLE1BQUksQ0FBQ21qRCxXQUFXO0FBQ2QsV0FBT3YzQzs7QUFHVCxTQUFPQSxVQUFTLFNBQVN3M0MsUUFBUWhxQyxRQUFReE4sS0FBQUEsTUFBVSxJQUFJO0FBQ3JELFFBQUksQ0FBQ3ZGLGVBQVN1RixLQUFPLEdBQUE7QUFDbkIsYUFBT0E7O0FBR1Q1TCxhQUFTa2pELFFBQVF0M0MsS0FBSztBQUN0QixRQUFJLENBQUM1TCxRQUFRO0FBQ1gsYUFBTzs7QUFHVCxRQUFJQSxPQUFPeXdDLFNBQVM7QUFDbEIsYUFBTzdrQzs7QUFHVHczQyxZQUFRaGxELEtBQUt3TixLQUFBQTtBQUNiQSxJQUFBQSxRQUFPNUwsT0FBTzRMO0VBQ2hCO0FBRUEsU0FBTztBQUNUO0FBT08sU0FBU3kzQyxZQUFZMWhDLE1BQU0vYixRQUFPNEksT0FBTztBQUU5QyxRQUFNNUMsUUFBTzAzQyxnQkFBZ0IzaEMsSUFBQUE7QUFFN0IsTUFBSXhmLFNBQVN5SixLQUFPLEdBQUE7QUFDbEIsV0FBT3VOLE1BQU12TixNQUFLaEksS0FBSyxJQUFJLFFBQVFnSTs7QUFHckMsTUFBSTVMLFNBQVN1akQsV0FBVzMzQyxLQUFBQTtBQUV4QixNQUFJdkYsZUFBU3JHLE1BQVcxRCxLQUFBQSxLQUFLb0UsTUFBTVYsTUFBQUEsTUFBWUEsUUFBUTtBQUNyRCxXQUFPd2pELGtCQUFrQjUzQyxNQUFLLENBQUUsR0FBRWhHLFFBQU81RixRQUFRd08sS0FBQUE7O0FBR25ELFNBQU87SUFBQztJQUFVO0lBQVM7SUFBTztJQUFTO0lBQVM0SyxRQUFReE4sS0FBQUEsS0FBUyxLQUFLQTtBQUM1RTtBQUVBLFNBQVM0M0Msa0JBQWtCQyxTQUFTNzlDLFFBQU81RixRQUFRd08sT0FBTztBQUN4RCxNQUFJaTFDLFlBQVksT0FBT0EsWUFBWSxLQUFLO0FBQ3RDempELGFBQVM0RixTQUFRNUY7O0FBR25CLE1BQUlBLFdBQVc0RixVQUFTNUYsU0FBUyxLQUFLQSxVQUFVd08sT0FBTztBQUNyRCxXQUFPOztBQUdULFNBQU94TztBQUNUO0FBT08sU0FBUzBqRCxnQkFBZ0I5M0MsT0FBTXpILE9BQU87QUFDM0MsTUFBSSs1QixRQUFRO0FBQ1osTUFBSXR5QixVQUFTLFNBQVM7QUFDcEJzeUIsWUFBUS81QixNQUFNWTthQUNMNkcsVUFBUyxPQUFPO0FBQ3pCc3lCLFlBQVEvNUIsTUFBTVU7YUFDTDFDLFNBQVN5SixLQUFPLEdBQUE7QUFFekJzeUIsWUFBUS81QixNQUFNNFEsaUJBQWlCbkosTUFBS2hJLEtBQUs7YUFDaENPLE1BQU04VCxjQUFjO0FBQzdCaW1CLFlBQVEvNUIsTUFBTThULGFBQVk7O0FBRTVCLFNBQU9pbUI7QUFDVDtBQVFPLFNBQVN5bEIsZ0JBQWdCLzNDLE9BQU16SCxPQUFPK1IsWUFBWTtBQUN2RCxNQUFJdFM7QUFFSixNQUFJZ0ksVUFBUyxTQUFTO0FBQ3BCaEksWUFBUXNTO2FBQ0N0SyxVQUFTLE9BQU87QUFDekJoSSxZQUFRTyxNQUFNakIsUUFBUW9CLFVBQVVILE1BQU01SCxNQUFNNEgsTUFBTXpGO2FBQ3pDeUQsU0FBU3lKLEtBQU8sR0FBQTtBQUV6QmhJLFlBQVFnSSxNQUFLaEk7U0FDUjtBQUNMQSxZQUFRTyxNQUFNbzZCLGFBQVk7O0FBRTVCLFNBQU8zNkI7QUFDVDtBQUtBLFNBQVMwL0MsZ0JBQWdCM2hDLE1BQU07QUFDN0IsUUFBTXplLFdBQVV5ZSxLQUFLemU7QUFDckIsUUFBTTBnRCxhQUFhMWdELFNBQVEwSTtBQUMzQixNQUFJQSxRQUFPUyxlQUFldTNDLGNBQWNBLFdBQVc1akQsUUFBUTRqRCxVQUFBQTtBQUUzRCxNQUFJaDRDLFVBQVNwUSxRQUFXO0FBQ3RCb1EsSUFBQUEsUUFBTyxDQUFDLENBQUMxSSxTQUFRK2Q7O0FBR25CLE1BQUlyVixVQUFTLFNBQVNBLFVBQVMsTUFBTTtBQUNuQyxXQUFPOztBQUdULE1BQUlBLFVBQVMsTUFBTTtBQUNqQixXQUFPOztBQUVULFNBQU9BO0FBQ1Q7QUMxSE8sU0FBU2k0QyxnQkFBZ0J2cEIsUUFBUTtBQUN0QyxRQUFNLEVBQUNuMkIsT0FBT3lCLE9BQUFBLFFBQU8rYixLQUFBQSxJQUFRMlk7QUFDN0IsUUFBTTdlLFNBQVMsQ0FBQTtBQUNmLFFBQU02L0IsV0FBVzM1QixLQUFLMjVCO0FBQ3RCLFFBQU13SSxlQUFlbmlDLEtBQUtsRztBQUMxQixRQUFNc29DLGFBQWFDLGNBQWM3L0MsT0FBT3lCLE1BQUFBO0FBQ3hDbStDLGFBQVczbEQsS0FBSzJrRCxvQkFBb0I7SUFBQ3ArQyxHQUFHO0lBQU1DLEdBQUdULE1BQU1ZO0tBQVM0YyxJQUFBQSxDQUFBQTtBQUVoRSxXQUFTdmtCLElBQUksR0FBR0EsSUFBSWsrQyxTQUFTbitDLFFBQVFDLEtBQUs7QUFDeEMsVUFBTStrQixVQUFVbTVCLFNBQVNsK0MsQ0FBRTtBQUMzQixhQUFTeXBCLElBQUkxRSxRQUFRM2xCLE9BQU9xcUIsS0FBSzFFLFFBQVE1ZCxLQUFLc2lCLEtBQUs7QUFDakRvOUIscUJBQWV4b0MsUUFBUXFvQyxhQUFhajlCLENBQUFBLEdBQUlrOUIsVUFBQUE7SUFDMUM7RUFDRjtBQUNBLFNBQU8sSUFBSXRJLFlBQVk7SUFBQ2hnQztJQUFRdlksU0FBUyxDQUFBO0VBQUUsQ0FBQTtBQUM3QztBQU9BLFNBQVM4Z0QsY0FBYzcvQyxPQUFPeUIsUUFBTztBQUNuQyxRQUFNcytDLFFBQVEsQ0FBQTtBQUNkLFFBQU1yckIsUUFBUTEwQixNQUFNaUUsd0JBQXdCLE1BQUE7QUFFNUMsV0FBU2hMLElBQUksR0FBR0EsSUFBSXk3QixNQUFNMTdCLFFBQVFDLEtBQUs7QUFDckMsVUFBTXFKLE9BQU9veUIsTUFBTXo3QixDQUFFO0FBQ3JCLFFBQUlxSixLQUFLYixVQUFVQSxRQUFPO0FBQ3hCOztBQUVGLFFBQUksQ0FBQ2EsS0FBSzRELFFBQVE7QUFDaEI2NUMsWUFBTUMsUUFBUTE5QyxLQUFLK0MsT0FBTzs7RUFFOUI7QUFDQSxTQUFPMDZDO0FBQ1Q7QUFPQSxTQUFTRCxlQUFleG9DLFFBQVEyb0MsYUFBYUwsWUFBWTtBQUN2RCxRQUFNTSxZQUFZLENBQUE7QUFDbEIsV0FBU3g5QixJQUFJLEdBQUdBLElBQUlrOUIsV0FBVzVtRCxRQUFRMHBCLEtBQUs7QUFDMUMsVUFBTWxGLE9BQU9vaUMsV0FBV2w5QixDQUFFO0FBQzFCLFVBQU0sRUFBQ29OLE9BQU9yYixNQUFNOEMsTUFBQUEsSUFBUzRvQyxVQUFVM2lDLE1BQU15aUMsYUFBYSxHQUFBO0FBRTFELFFBQUksQ0FBQzFvQyxTQUFVdVksU0FBU3JiLE1BQU87QUFDN0I7O0FBRUYsUUFBSXFiLE9BQU87QUFFVG93QixnQkFBVUYsUUFBUXpvQyxLQUFBQTtXQUNiO0FBQ0xELGFBQU9yZCxLQUFLc2QsS0FBQUE7QUFDWixVQUFJLENBQUM5QyxNQUFNO0FBRVQ7OztFQUdOO0FBQ0E2QyxTQUFPcmQsS0FBUWltRCxHQUFBQSxTQUFBQTtBQUNqQjtBQVFBLFNBQVNDLFVBQVUzaUMsTUFBTXlpQyxhQUFhemYsVUFBVTtBQUM5QyxRQUFNanBCLFFBQVFpRyxLQUFLbzZCLFlBQVlxSSxhQUFhemYsUUFBQUE7QUFDNUMsTUFBSSxDQUFDanBCLE9BQU87QUFDVixXQUFPLENBQUE7O0FBR1QsUUFBTTZvQyxhQUFhN29DLE1BQU1pcEIsUUFBUztBQUNsQyxRQUFNMlcsV0FBVzM1QixLQUFLMjVCO0FBQ3RCLFFBQU13SCxhQUFhbmhDLEtBQUtsRztBQUN4QixNQUFJd1ksUUFBUTtBQUNaLE1BQUlyYixPQUFPO0FBQ1gsV0FBU3hiLElBQUksR0FBR0EsSUFBSWsrQyxTQUFTbitDLFFBQVFDLEtBQUs7QUFDeEMsVUFBTStrQixVQUFVbTVCLFNBQVNsK0MsQ0FBRTtBQUMzQixVQUFNb25ELGFBQWExQixXQUFXM2dDLFFBQVEzbEIsS0FBSyxFQUFFbW9DLFFBQVM7QUFDdEQsVUFBTThmLFlBQVkzQixXQUFXM2dDLFFBQVE1ZCxHQUFHLEVBQUVvZ0MsUUFBUztBQUNuRCxRQUFJZ1UsV0FBVzRMLFlBQVlDLFlBQVlDLFNBQVksR0FBQTtBQUNqRHh3QixjQUFRc3dCLGVBQWVDO0FBQ3ZCNXJDLGFBQU8yckMsZUFBZUU7QUFDdEI7O0VBRUo7QUFDQSxTQUFPO0lBQUN4d0I7SUFBT3JiO0lBQU04QztFQUFLO0FBQzVCO0FDekdPLElBQU1ncEMsWUFBTixNQUFNQTtFQUNYeHBELFlBQVltSixNQUFNO0FBQ2hCLFNBQUtNLElBQUlOLEtBQUtNO0FBQ2QsU0FBS0MsSUFBSVAsS0FBS087QUFDZCxTQUFLNFcsU0FBU25YLEtBQUttWDtFQUNyQjtFQUVBeStCLFlBQVl4dkMsS0FBS216QyxRQUFRdjVDLE1BQU07QUFDN0IsVUFBTSxFQUFDTSxHQUFHQyxHQUFHNFcsT0FBTSxJQUFJO0FBQ3ZCb2lDLGFBQVNBLFVBQVU7TUFBQ3BoRCxPQUFPO01BQUcrSCxLQUFLK1g7SUFBRztBQUN0QzdSLFFBQUlpVixJQUFJL2EsR0FBR0MsR0FBRzRXLFFBQVFvaUMsT0FBT3I1QyxLQUFLcTVDLE9BQU9waEQsT0FBTyxJQUFJO0FBQ3BELFdBQU8sQ0FBQzZILEtBQUt1NUM7RUFDZjtFQUVBN0IsWUFBWXJnQyxPQUFPO0FBQ2pCLFVBQU0sRUFBQy9XLEdBQUdDLEdBQUc0VyxPQUFNLElBQUk7QUFDdkIsVUFBTXdCLFFBQVF0QixNQUFNc0I7QUFDcEIsV0FBTztNQUNMclksR0FBR0EsSUFBSXJJLEtBQUtvZ0IsSUFBSU0sS0FBU3hCLElBQUFBO01BQ3pCNVcsR0FBR0EsSUFBSXRJLEtBQUtzZ0IsSUFBSUksS0FBU3hCLElBQUFBO01BQ3pCd0I7SUFDRjtFQUNGO0FBQ0Y7QUNkTyxTQUFTMm5DLFdBQVdycUIsUUFBUTtBQUNqQyxRQUFNLEVBQUM1K0IsT0FBT2tRLE1BQUFBLE9BQU0rVixLQUFBQSxJQUFRMlk7QUFFNUIsTUFBSWowQixlQUFTdUYsS0FBTyxHQUFBO0FBQ2xCLFdBQU9nNUMsZUFBZWxwRCxPQUFPa1EsS0FBQUE7O0FBRy9CLE1BQUlBLFVBQVMsU0FBUztBQUNwQixXQUFPaTRDLGdCQUFnQnZwQixNQUFBQTs7QUFHekIsTUFBSTF1QixVQUFTLFNBQVM7QUFDcEIsV0FBTzs7QUFHVCxRQUFNaTNDLFdBQVdnQyxnQkFBZ0J2cUIsTUFBQUE7QUFFakMsTUFBSXVvQixvQkFBb0I2QixXQUFXO0FBQ2pDLFdBQU83Qjs7QUFHVCxTQUFPRSxvQkFBb0JGLFVBQVVsaEMsSUFBQUE7QUFDdkM7QUFNQSxTQUFTaWpDLGVBQWVscEQsT0FBT2tLLFFBQU87QUFDcEMsUUFBTWEsT0FBTy9LLE1BQU13UixlQUFldEgsTUFBQUE7QUFDbEMsUUFBTTZxQyxVQUFVaHFDLFFBQVEvSyxNQUFNdWlCLGlCQUFpQnJZLE1BQUFBO0FBQy9DLFNBQU82cUMsVUFBVWhxQyxLQUFLK0MsVUFBVTtBQUNsQztBQUVBLFNBQVNxN0MsZ0JBQWdCdnFCLFFBQVE7QUFDL0IsUUFBTW4yQixRQUFRbTJCLE9BQU9uMkIsU0FBUyxDQUFBO0FBRTlCLE1BQUlBLE1BQU1vZ0IsMEJBQTBCO0FBQ2xDLFdBQU91Z0Msd0JBQXdCeHFCLE1BQUFBOztBQUVqQyxTQUFPeXFCLHNCQUFzQnpxQixNQUFBQTtBQUMvQjtBQUdBLFNBQVN5cUIsc0JBQXNCenFCLFFBQVE7QUFDckMsUUFBTSxFQUFDbjJCLFFBQVEsQ0FBQSxHQUFJeUgsTUFBQUEsTUFBQUEsSUFBUTB1QjtBQUMzQixRQUFNNEQsUUFBUXdsQixnQkFBZ0I5M0MsT0FBTXpILEtBQUFBO0FBRXBDLE1BQUlrQyxlQUFTNjNCLEtBQVEsR0FBQTtBQUNuQixVQUFNbm5CLGFBQWE1UyxNQUFNMFMsYUFBWTtBQUVyQyxXQUFPO01BQ0xsUyxHQUFHb1MsYUFBYW1uQixRQUFRO01BQ3hCdDVCLEdBQUdtUyxhQUFhLE9BQU9tbkI7SUFDekI7O0FBR0YsU0FBTztBQUNUO0FBRUEsU0FBUzRtQix3QkFBd0J4cUIsUUFBUTtBQUN2QyxRQUFNLEVBQUNuMkIsT0FBT3lILE1BQUFBLE1BQUFBLElBQVEwdUI7QUFDdEIsUUFBTXAzQixXQUFVaUIsTUFBTWpCO0FBQ3RCLFFBQU0vRixTQUFTZ0gsTUFBTThLLFVBQVMsRUFBRzlSO0FBQ2pDLFFBQU1YLFFBQVEwRyxTQUFRb0IsVUFBVUgsTUFBTXpGLE1BQU15RixNQUFNNUg7QUFDbEQsUUFBTXFILFFBQVErL0MsZ0JBQWdCLzNDLE9BQU16SCxPQUFPM0gsS0FBQUE7QUFDM0MsUUFBTXdELFNBQVMsQ0FBQTtBQUVmLE1BQUlrRCxTQUFRa1ksS0FBSzZJLFVBQVU7QUFDekIsVUFBTXpMLFNBQVNyVSxNQUFNb2dCLHlCQUF5QixHQUFHL25CLEtBQUFBO0FBQ2pELFdBQU8sSUFBSWtvRCxVQUFVO01BQ25CLy9DLEdBQUc2VCxPQUFPN1Q7TUFDVkMsR0FBRzRULE9BQU81VDtNQUNWNFcsUUFBUXJYLE1BQU0yZiw4QkFBOEJsZ0IsS0FBQUE7SUFDOUMsQ0FBQTs7QUFHRixXQUFTeEcsSUFBSSxHQUFHQSxJQUFJRCxRQUFRLEVBQUVDLEdBQUc7QUFDL0I0QyxXQUFPNUIsS0FBSytGLE1BQU1vZ0IseUJBQXlCbm5CLEdBQUd3RyxLQUFBQSxDQUFBQTtFQUNoRDtBQUNBLFNBQU81RDtBQUNUO0FDekZPLFNBQVNnbEQsVUFBVXY2QyxLQUFLNnZCLFFBQVE3cEIsTUFBTTtBQUMzQyxRQUFNelEsU0FBUzJrRCxXQUFXcnFCLE1BQUFBO0FBQzFCLFFBQU0sRUFBQzUrQixPQUFPa0ssT0FBQUEsUUFBTytiLE1BQU14ZCxPQUFPMEMsS0FBSSxJQUFJeXpCO0FBQzFDLFFBQU0ycUIsV0FBV3RqQyxLQUFLemU7QUFDdEIsUUFBTTBnRCxhQUFhcUIsU0FBU3I1QztBQUM1QixRQUFNdE0sU0FBUTJsRCxTQUFTaGtDO0FBQ3ZCLFFBQU0sRUFBQ2lrQyxRQUFRNWxELFFBQU80a0QsUUFBUTVrRCxPQUFLLElBQUlza0QsY0FBYyxDQUFBO0FBQ3JELFFBQU1uOUMsT0FBTy9LLE1BQU13UixlQUFldEgsTUFBQUE7QUFDbEMsUUFBTTJLLE9BQU8raEMsbUJBQW1CNTJDLE9BQU8rSyxJQUFBQTtBQUN2QyxNQUFJekcsVUFBVTJoQixLQUFLbEcsT0FBT3RlLFFBQVE7QUFDaEM2bEMsYUFBU3Y0QixLQUFLZ0csSUFBQUE7QUFDZDAwQyxXQUFPMTZDLEtBQUs7TUFBQ2tYO01BQU0zaEI7TUFBUWtsRDtNQUFPaEI7TUFBT3p6QztNQUFNdE07TUFBTzBDO01BQU0wSjtJQUFJLENBQUE7QUFDaEU0eUIsZUFBVzE0QixHQUFBQTs7QUFFZjtBQUVBLFNBQVMwNkMsT0FBTzE2QyxLQUFLMUssS0FBSztBQUN4QixRQUFNLEVBQUM0aEIsTUFBTTNoQixRQUFRa2xELE9BQU9oQixPQUFPenpDLE1BQU10TSxPQUFPb00sS0FBQUEsSUFBUXhRO0FBQ3hELFFBQU00a0MsV0FBV2hqQixLQUFLL2dCLFFBQVEsVUFBVWIsSUFBSThHO0FBRTVDNEQsTUFBSXMzQixLQUFJO0FBRVIsTUFBSXFqQixZQUFZbEI7QUFDaEIsTUFBSUEsVUFBVWdCLE9BQU87QUFDbkIsUUFBSXZnQixhQUFhLEtBQUs7QUFDcEIwZ0IsbUJBQWE1NkMsS0FBS3pLLFFBQVF5USxLQUFLNUwsR0FBRztBQUNsQytHLFdBQUtuQixLQUFLO1FBQUNrWDtRQUFNM2hCO1FBQVFWLE9BQU80bEQ7UUFBTy9nRDtRQUFPd2dDO1FBQVVwMEI7TUFBSSxDQUFBO0FBQzVEOUYsVUFBSXczQixRQUFPO0FBQ1h4M0IsVUFBSXMzQixLQUFJO0FBQ1JzakIsbUJBQWE1NkMsS0FBS3pLLFFBQVF5USxLQUFLMUwsTUFBTTtlQUM1QjQvQixhQUFhLEtBQUs7QUFDM0IyZ0IscUJBQWU3NkMsS0FBS3pLLFFBQVF5USxLQUFLekwsSUFBSTtBQUNyQzRHLFdBQUtuQixLQUFLO1FBQUNrWDtRQUFNM2hCO1FBQVFWLE9BQU80a0Q7UUFBTy8vQztRQUFPd2dDO1FBQVVwMEI7TUFBSSxDQUFBO0FBQzVEOUYsVUFBSXczQixRQUFPO0FBQ1h4M0IsVUFBSXMzQixLQUFJO0FBQ1J1akIscUJBQWU3NkMsS0FBS3pLLFFBQVF5USxLQUFLM0wsS0FBSztBQUN0Q3NnRCxrQkFBWUY7OztBQUdoQnQ1QyxPQUFLbkIsS0FBSztJQUFDa1g7SUFBTTNoQjtJQUFRVixPQUFPOGxEO0lBQVdqaEQ7SUFBT3dnQztJQUFVcDBCO0VBQUksQ0FBQTtBQUVoRTlGLE1BQUl3M0IsUUFBTztBQUNiO0FBRUEsU0FBU29qQixhQUFhNTZDLEtBQUt6SyxRQUFRdWxELE9BQU87QUFDeEMsUUFBTSxFQUFDakssVUFBVTcvQixPQUFBQSxJQUFVemI7QUFDM0IsTUFBSWkwQixRQUFRO0FBQ1osTUFBSXV4QixXQUFXO0FBRWYvNkMsTUFBSSszQixVQUFTO0FBQ2IsYUFBV3JnQixXQUFXbTVCLFVBQVU7QUFDOUIsVUFBTSxFQUFDOStDLE9BQU8rSCxJQUFBQSxJQUFPNGQ7QUFDckIsVUFBTVUsYUFBYXBILE9BQU9qZixLQUFNO0FBQ2hDLFVBQU1zbUIsWUFBWXJILE9BQU8wbUMsZ0JBQWdCM2xELE9BQU8rSCxLQUFLa1gsTUFBUSxDQUFBO0FBQzdELFFBQUl3WSxPQUFPO0FBQ1R4cEIsVUFBSWc0QixPQUFPNWYsV0FBV2xlLEdBQUdrZSxXQUFXamUsQ0FBQztBQUNyQ3F2QixjQUFRO1dBQ0g7QUFDTHhwQixVQUFJaTRCLE9BQU83ZixXQUFXbGUsR0FBRzRnRCxLQUFBQTtBQUN6Qjk2QyxVQUFJaTRCLE9BQU83ZixXQUFXbGUsR0FBR2tlLFdBQVdqZSxDQUFDOztBQUV2QzRnRCxlQUFXLENBQUMsQ0FBQ3hsRCxPQUFPaTZDLFlBQVl4dkMsS0FBSzBYLFNBQVM7TUFBQ2hQLE1BQU1xeUM7SUFBUSxDQUFBO0FBQzdELFFBQUlBLFVBQVU7QUFDWi82QyxVQUFJc3FDLFVBQVM7V0FDUjtBQUNMdHFDLFVBQUlpNEIsT0FBTzVmLFVBQVVuZSxHQUFHNGdELEtBQUFBOztFQUU1QjtBQUVBOTZDLE1BQUlpNEIsT0FBTzFpQyxPQUFPaTBCLE1BQUssRUFBR3R2QixHQUFHNGdELEtBQUFBO0FBQzdCOTZDLE1BQUlzcUMsVUFBUztBQUNidHFDLE1BQUk4RixLQUFJO0FBQ1Y7QUFFQSxTQUFTKzBDLGVBQWU3NkMsS0FBS3pLLFFBQVF5bEQsT0FBTztBQUMxQyxRQUFNLEVBQUNuSyxVQUFVNy9CLE9BQUFBLElBQVV6YjtBQUMzQixNQUFJaTBCLFFBQVE7QUFDWixNQUFJdXhCLFdBQVc7QUFFZi82QyxNQUFJKzNCLFVBQVM7QUFDYixhQUFXcmdCLFdBQVdtNUIsVUFBVTtBQUM5QixVQUFNLEVBQUM5K0MsT0FBTytILElBQUFBLElBQU80ZDtBQUNyQixVQUFNVSxhQUFhcEgsT0FBT2pmLEtBQU07QUFDaEMsVUFBTXNtQixZQUFZckgsT0FBTzBtQyxnQkFBZ0IzbEQsT0FBTytILEtBQUtrWCxNQUFRLENBQUE7QUFDN0QsUUFBSXdZLE9BQU87QUFDVHhwQixVQUFJZzRCLE9BQU81ZixXQUFXbGUsR0FBR2tlLFdBQVdqZSxDQUFDO0FBQ3JDcXZCLGNBQVE7V0FDSDtBQUNMeHBCLFVBQUlpNEIsT0FBTytpQixPQUFPNWlDLFdBQVdqZSxDQUFDO0FBQzlCNkYsVUFBSWk0QixPQUFPN2YsV0FBV2xlLEdBQUdrZSxXQUFXamUsQ0FBQzs7QUFFdkM0Z0QsZUFBVyxDQUFDLENBQUN4bEQsT0FBT2k2QyxZQUFZeHZDLEtBQUswWCxTQUFTO01BQUNoUCxNQUFNcXlDO0lBQVEsQ0FBQTtBQUM3RCxRQUFJQSxVQUFVO0FBQ1ovNkMsVUFBSXNxQyxVQUFTO1dBQ1I7QUFDTHRxQyxVQUFJaTRCLE9BQU8raUIsT0FBTzNpQyxVQUFVbGUsQ0FBQzs7RUFFakM7QUFFQTZGLE1BQUlpNEIsT0FBTytpQixPQUFPemxELE9BQU9pMEIsTUFBSyxFQUFHcnZCLENBQUM7QUFDbEM2RixNQUFJc3FDLFVBQVM7QUFDYnRxQyxNQUFJOEYsS0FBSTtBQUNWO0FBRUEsU0FBUzNFLEtBQUtuQixLQUFLMUssS0FBSztBQUN0QixRQUFNLEVBQUM0aEIsTUFBTTNoQixRQUFRMmtDLFVBQVVybEMsT0FBQUEsUUFBTzZFLE9BQU9vTSxLQUFBQSxJQUFReFE7QUFDckQsUUFBTXU3QyxXQUFXSyxVQUFVaDZCLE1BQU0zaEIsUUFBUTJrQyxRQUFBQTtBQUV6QyxhQUFXLEVBQUNySyxRQUFRb3JCLEtBQUsxbEQsUUFBUXNpRCxLQUFLOWxELE9BQU8rSCxJQUFHLEtBQUsrMkMsVUFBVTtBQUM3RCxVQUFNLEVBQUN4NkIsT0FBTyxFQUFDRyxrQkFBa0IzaEIsT0FBQUEsSUFBUyxDQUFBLEVBQUUsSUFBSW9tRDtBQUNoRCxVQUFNQyxXQUFXM2xELFdBQVc7QUFFNUJ5SyxRQUFJczNCLEtBQUk7QUFDUnQzQixRQUFJdVcsWUFBWUM7QUFFaEIya0MsZUFBV243QyxLQUFLdEcsT0FBT29NLE1BQU1vMUMsWUFBWXZELFdBQVd6ZCxVQUFVbm9DLE9BQU8rSCxHQUFBQSxDQUFBQTtBQUVyRWtHLFFBQUkrM0IsVUFBUztBQUViLFVBQU1nakIsV0FBVyxDQUFDLENBQUM3akMsS0FBS3M0QixZQUFZeHZDLEtBQUtpN0MsR0FBQUE7QUFFekMsUUFBSTdrRDtBQUNKLFFBQUk4a0QsVUFBVTtBQUNaLFVBQUlILFVBQVU7QUFDWi82QyxZQUFJc3FDLFVBQVM7YUFDUjtBQUNMOFEsMkJBQW1CcDdDLEtBQUt6SyxRQUFRdUUsS0FBS29nQyxRQUFBQTs7QUFHdkMsWUFBTW1oQixhQUFhLENBQUMsQ0FBQzlsRCxPQUFPaTZDLFlBQVl4dkMsS0FBSzYzQyxLQUFLO1FBQUNudkMsTUFBTXF5QztRQUFVbGhELFNBQVM7TUFBSSxDQUFBO0FBQ2hGekQsYUFBTzJrRCxZQUFZTTtBQUNuQixVQUFJLENBQUNqbEQsTUFBTTtBQUNUZ2xELDJCQUFtQnA3QyxLQUFLekssUUFBUXhELE9BQU9tb0MsUUFBQUE7OztBQUkzQ2w2QixRQUFJc3FDLFVBQVM7QUFDYnRxQyxRQUFJbUIsS0FBSy9LLE9BQU8sWUFBWSxTQUFTO0FBRXJDNEosUUFBSXczQixRQUFPO0VBQ2I7QUFDRjtBQUVBLFNBQVMyakIsV0FBV243QyxLQUFLdEcsT0FBT29NLE1BQU1xdEMsUUFBUTtBQUM1QyxRQUFNbHRDLFlBQVl2TSxNQUFNekksTUFBTWdWO0FBQzlCLFFBQU0sRUFBQ2kwQixVQUFVbm9DLE9BQU8rSCxJQUFHLElBQUlxNUMsVUFBVSxDQUFBO0FBRXpDLE1BQUlqWixhQUFhLE9BQU9BLGFBQWEsS0FBSztBQUN4QyxRQUFJMy9CLE1BQU1ILEtBQUtDLE9BQU9DO0FBRXRCLFFBQUk0L0IsYUFBYSxLQUFLO0FBQ3BCMy9CLGFBQU94STtBQUNQcUksWUFBTTZMLFVBQVU3TDtBQUNoQkMsY0FBUVA7QUFDUlEsZUFBUzJMLFVBQVUzTDtXQUNkO0FBQ0xDLGFBQU8wTCxVQUFVMUw7QUFDakJILFlBQU1ySTtBQUNOc0ksY0FBUTRMLFVBQVU1TDtBQUNsQkMsZUFBU1I7O0FBR1hrRyxRQUFJKzNCLFVBQVM7QUFFYixRQUFJanlCLE1BQU07QUFDUnZMLGFBQU8xSSxLQUFLb0MsSUFBSXNHLE1BQU11TCxLQUFLdkwsSUFBSTtBQUMvQkYsY0FBUXhJLEtBQUtDLElBQUl1SSxPQUFPeUwsS0FBS3pMLEtBQUs7QUFDbENELFlBQU12SSxLQUFLb0MsSUFBSW1HLEtBQUswTCxLQUFLMUwsR0FBRztBQUM1QkUsZUFBU3pJLEtBQUtDLElBQUl3SSxRQUFRd0wsS0FBS3hMLE1BQU07O0FBR3ZDMEYsUUFBSXVxQyxLQUFLaHdDLE1BQU1ILEtBQUtDLFFBQVFFLE1BQU1ELFNBQVNGLEdBQUFBO0FBQzNDNEYsUUFBSThGLEtBQUk7O0FBRVo7QUFFQSxTQUFTczFDLG1CQUFtQnA3QyxLQUFLekssUUFBUTBiLE9BQU9pcEIsVUFBVTtBQUN4RCxRQUFNb2hCLG9CQUFvQi9sRCxPQUFPKzdDLFlBQVlyZ0MsT0FBT2lwQixRQUFBQTtBQUNwRCxNQUFJb2hCLG1CQUFtQjtBQUNyQnQ3QyxRQUFJaTRCLE9BQU9xakIsa0JBQWtCcGhELEdBQUdvaEQsa0JBQWtCbmhELENBQUM7O0FBRXZEO0FDOUtBLElBQUEsUUFBZTtFQUNiMEMsSUFBSTtFQUVKMCtDLG9CQUFvQnRxRCxPQUFPNmpELE9BQU9yOEMsVUFBUztBQUN6QyxVQUFNc0wsU0FBUzlTLE1BQU04SyxLQUFLeUcsWUFBWSxDQUFBLEdBQUk5UDtBQUMxQyxVQUFNK2xELFVBQVUsQ0FBQTtBQUNoQixRQUFJejhDLE1BQU1ySixHQUFHdWtCLE1BQU0yWTtBQUVuQixTQUFLbDlCLElBQUksR0FBR0EsSUFBSW9SLE9BQU8sRUFBRXBSLEdBQUc7QUFDMUJxSixhQUFPL0ssTUFBTXdSLGVBQWU5UCxDQUFBQTtBQUM1QnVrQixhQUFPbGIsS0FBSytDO0FBQ1o4d0IsZUFBUztBQUVULFVBQUkzWSxRQUFRQSxLQUFLemUsV0FBV3llLGdCQUFnQjg1QixhQUFhO0FBQ3ZEbmhCLGlCQUFTO1VBQ1BtVyxTQUFTLzBDLE1BQU11aUIsaUJBQWlCN2dCLENBQUFBO1VBQ2hDd0ksT0FBT3hJO1VBQ1B3TyxNQUFNeTNDLFlBQVkxaEMsTUFBTXZrQixHQUFHb1IsS0FBQUE7VUFDM0I5UztVQUNBbUwsTUFBTUosS0FBSzZCLFdBQVdwRixRQUFRd0o7VUFDOUJ2SSxPQUFPc0MsS0FBS0U7VUFDWmdiO1FBQ0Y7O0FBR0ZsYixXQUFLdy9DLFVBQVUzckI7QUFDZjRvQixjQUFROWtELEtBQUtrOEIsTUFBQUE7SUFDZjtBQUVBLFNBQUtsOUIsSUFBSSxHQUFHQSxJQUFJb1IsT0FBTyxFQUFFcFIsR0FBRztBQUMxQms5QixlQUFTNG9CLFFBQVE5bEQsQ0FBRTtBQUNuQixVQUFJLENBQUNrOUIsVUFBVUEsT0FBTzF1QixTQUFTLE9BQU87QUFDcEM7O0FBR0YwdUIsYUFBTzF1QixPQUFPcTNDLGVBQWVDLFNBQVM5bEQsR0FBRzhGLFNBQVFpZ0QsU0FBUztJQUM1RDtFQUNGO0VBRUErQyxXQUFXeHFELE9BQU82akQsT0FBT3I4QyxVQUFTO0FBQ2hDLFVBQU03RixRQUFPNkYsU0FBUWlqRCxhQUFhO0FBQ2xDLFVBQU0xZ0QsV0FBVy9KLE1BQU1rckIsNkJBQTRCO0FBQ25ELFVBQU1uVyxPQUFPL1UsTUFBTWdWO0FBQ25CLGFBQVN0VCxJQUFJcUksU0FBU3RJLFNBQVMsR0FBR0MsS0FBSyxHQUFHLEVBQUVBLEdBQUc7QUFDN0MsWUFBTWs5QixTQUFTNzBCLFNBQVNySSxDQUFBQSxFQUFHNm9EO0FBQzNCLFVBQUksQ0FBQzNyQixRQUFRO0FBQ1g7O0FBR0ZBLGFBQU8zWSxLQUFLb0Isb0JBQW9CdFMsTUFBTTZwQixPQUFPenpCLElBQUk7QUFDakQsVUFBSXhKLFNBQVFpOUIsT0FBTzF1QixNQUFNO0FBQ3ZCbzVDLGtCQUFVdHBELE1BQU0rTyxLQUFLNnZCLFFBQVE3cEIsSUFBQUE7O0lBRWpDO0VBQ0Y7RUFFQTIxQyxtQkFBbUIxcUQsT0FBTzZqRCxPQUFPcjhDLFVBQVM7QUFDeEMsUUFBSUEsU0FBUWlqRCxhQUFhLHNCQUFzQjtBQUM3Qzs7QUFHRixVQUFNMWdELFdBQVcvSixNQUFNa3JCLDZCQUE0QjtBQUNuRCxhQUFTeHBCLElBQUlxSSxTQUFTdEksU0FBUyxHQUFHQyxLQUFLLEdBQUcsRUFBRUEsR0FBRztBQUM3QyxZQUFNazlCLFNBQVM3MEIsU0FBU3JJLENBQUFBLEVBQUc2b0Q7QUFFM0IsVUFBSWpELGlCQUFpQjFvQixNQUFTLEdBQUE7QUFDNUIwcUIsa0JBQVV0cEQsTUFBTStPLEtBQUs2dkIsUUFBUTUrQixNQUFNZ1YsU0FBUzs7SUFFaEQ7RUFDRjtFQUVBMjFDLGtCQUFrQjNxRCxPQUFPK1gsTUFBTXZRLFVBQVM7QUFDdEMsVUFBTW8zQixTQUFTN21CLEtBQUtoTixLQUFLdy9DO0FBRXpCLFFBQUksQ0FBQ2pELGlCQUFpQjFvQixNQUFBQSxLQUFXcDNCLFNBQVFpakQsYUFBYSxxQkFBcUI7QUFDekU7O0FBR0ZuQixjQUFVdHBELE1BQU0rTyxLQUFLNnZCLFFBQVE1K0IsTUFBTWdWLFNBQVM7RUFDOUM7RUFFQW5PLFVBQVU7SUFDUjRnRCxXQUFXO0lBQ1hnRCxVQUFVO0VBQ1o7QUFDRjtBQ3pFQSxJQUFNRyxhQUFhLENBQUNDLFdBQVc5aUIsYUFBYTtBQUMxQyxNQUFJLEVBQUMraUIsWUFBWS9pQixVQUFVZ2pCLFdBQVdoakIsU0FBQUEsSUFBWThpQjtBQUVsRCxNQUFJQSxVQUFVRyxlQUFlO0FBQzNCRixnQkFBWWxxRCxLQUFLQyxJQUFJaXFELFdBQVcvaUIsUUFBQUE7QUFDaENnakIsZUFBV0YsVUFBVUksbUJBQW1CcnFELEtBQUtDLElBQUlrcUQsVUFBVWhqQixRQUFBQTs7QUFHN0QsU0FBTztJQUNMZ2pCO0lBQ0FEO0lBQ0FJLFlBQVl0cUQsS0FBS29DLElBQUkra0MsVUFBVStpQixTQUFBQTtFQUNqQztBQUNGO0FBRUEsSUFBTUssYUFBYSxDQUFDcHlDLEdBQUdyUCxNQUFNcVAsTUFBTSxRQUFRclAsTUFBTSxRQUFRcVAsRUFBRXZPLGlCQUFpQmQsRUFBRWMsZ0JBQWdCdU8sRUFBRTdPLFVBQVVSLEVBQUVRO0FBRXJHLElBQU1raEQsU0FBTixjQUFxQjl6QixRQUFBQTtFQUsxQjkzQixZQUFZNkcsUUFBUTtBQUNsQixVQUFLO0FBRUwsU0FBS2dsRCxTQUFTO0FBR2QsU0FBS0MsaUJBQWlCLENBQUE7QUFLdEIsU0FBS0MsZUFBZTtBQUdwQixTQUFLQyxlQUFlO0FBRXBCLFNBQUt4ckQsUUFBUXFHLE9BQU9yRztBQUNwQixTQUFLd0gsVUFBVW5CLE9BQU9tQjtBQUN0QixTQUFLdUgsTUFBTTFJLE9BQU8wSTtBQUNsQixTQUFLMDhDLGNBQWMzckQ7QUFDbkIsU0FBSzRyRCxjQUFjNXJEO0FBQ25CLFNBQUs2ckQsYUFBYTdyRDtBQUNsQixTQUFLbWpCLFlBQVluakI7QUFDakIsU0FBS2tqQixXQUFXbGpCO0FBQ2hCLFNBQUtxSixNQUFNcko7QUFDWCxTQUFLdUosU0FBU3ZKO0FBQ2QsU0FBS3dKLE9BQU94SjtBQUNaLFNBQUtzSixRQUFRdEo7QUFDYixTQUFLaWQsU0FBU2pkO0FBQ2QsU0FBS2tkLFFBQVFsZDtBQUNiLFNBQUsrN0IsV0FBVy83QjtBQUNoQixTQUFLa3JCLFdBQVdsckI7QUFDaEIsU0FBSzJrQixTQUFTM2tCO0FBQ2QsU0FBSzZ1QixXQUFXN3VCO0VBQ2xCO0VBRUE0RixPQUFPc2QsVUFBVUMsV0FBV3lhLFNBQVM7QUFDbkMsU0FBSzFhLFdBQVdBO0FBQ2hCLFNBQUtDLFlBQVlBO0FBQ2pCLFNBQUs0WSxXQUFXNkI7QUFFaEIsU0FBS0ksY0FBYTtBQUNsQixTQUFLOHRCLFlBQVc7QUFDaEIsU0FBSzdzQixJQUFHO0VBQ1Y7RUFFQWpCLGdCQUFnQjtBQUNkLFFBQUksS0FBSzNpQixhQUFZLEdBQUk7QUFDdkIsV0FBSzZCLFFBQVEsS0FBS2dHO0FBQ2xCLFdBQUsxWixPQUFPLEtBQUt1eUIsU0FBU3Z5QjtBQUMxQixXQUFLRixRQUFRLEtBQUs0VDtXQUNiO0FBQ0wsV0FBS0QsU0FBUyxLQUFLa0c7QUFDbkIsV0FBSzlaLE1BQU0sS0FBSzB5QixTQUFTMXlCO0FBQ3pCLFdBQUtFLFNBQVMsS0FBSzBUOztFQUV2QjtFQUVBNnVDLGNBQWM7QUFDWixVQUFNZixZQUFZLEtBQUtyakQsUUFBUThMLFVBQVUsQ0FBQTtBQUN6QyxRQUFJbTRDLGNBQWN4cUQsU0FBSzRwRCxVQUFVNWxDLGdCQUFnQjtNQUFDLEtBQUtqbEI7T0FBUSxJQUFJLEtBQUssQ0FBQTtBQUV4RSxRQUFJNnFELFVBQVVwOUMsUUFBUTtBQUNwQmcrQyxvQkFBY0EsWUFBWWgrQyxPQUFPLENBQUM3TCxTQUFTaXBELFVBQVVwOUMsT0FBTzdMLE1BQU0sS0FBSzVCLE1BQU04SyxJQUFJLENBQUE7O0FBR25GLFFBQUkrL0MsVUFBVS94QyxNQUFNO0FBQ2xCMnlDLG9CQUFjQSxZQUFZM3lDLEtBQUssQ0FBQ0MsR0FBR3JQLE1BQU1taEQsVUFBVS94QyxLQUFLQyxHQUFHclAsR0FBRyxLQUFLMUosTUFBTThLLElBQUksQ0FBQTs7QUFHL0UsUUFBSSxLQUFLdEQsUUFBUW9CLFNBQVM7QUFDeEI2aUQsa0JBQVk3aUQsUUFBTzs7QUFHckIsU0FBSzZpRCxjQUFjQTtFQUNyQjtFQUVBMXNCLE1BQU07QUFDSixVQUFNLEVBQUN2M0IsU0FBQUEsVUFBU3VILElBQUcsSUFBSTtBQU12QixRQUFJLENBQUN2SCxTQUFROGdCLFNBQVM7QUFDcEIsV0FBS3RMLFFBQVEsS0FBS0QsU0FBUztBQUMzQjs7QUFHRixVQUFNOHRDLFlBQVlyakQsU0FBUThMO0FBQzFCLFVBQU11NEMsWUFBWTd3QixPQUFPNnZCLFVBQVU5dkIsSUFBSTtBQUN2QyxVQUFNZ04sV0FBVzhqQixVQUFVMWpEO0FBQzNCLFVBQU0wNEIsY0FBYyxLQUFLaXJCLG9CQUFtQjtBQUM1QyxVQUFNLEVBQUNmLFVBQVVHLFdBQUFBLElBQWNOLFdBQVdDLFdBQVc5aUIsUUFBQUE7QUFFckQsUUFBSS9xQixPQUFPRDtBQUVYaE8sUUFBSWdzQixPQUFPOHdCLFVBQVV6cEI7QUFFckIsUUFBSSxLQUFLam5CLGFBQVksR0FBSTtBQUN2QjZCLGNBQVEsS0FBS2dHO0FBQ2JqRyxlQUFTLEtBQUtndkMsU0FBU2xyQixhQUFha0gsVUFBVWdqQixVQUFVRyxVQUFjLElBQUE7V0FDakU7QUFDTG51QyxlQUFTLEtBQUtrRztBQUNkakcsY0FBUSxLQUFLZ3ZDLFNBQVNuckIsYUFBYWdyQixXQUFXZCxVQUFVRyxVQUFjLElBQUE7O0FBR3hFLFNBQUtsdUMsUUFBUXBjLEtBQUtDLElBQUltYyxPQUFPeFYsU0FBUXdiLFlBQVksS0FBS0EsUUFBUTtBQUM5RCxTQUFLakcsU0FBU25jLEtBQUtDLElBQUlrYyxRQUFRdlYsU0FBUXliLGFBQWEsS0FBS0EsU0FBUztFQUNwRTtFQUtBOG9DLFNBQVNsckIsYUFBYWtILFVBQVVnakIsVUFBVUcsWUFBWTtBQUNwRCxVQUFNLEVBQUNuOEMsS0FBS2lVLFVBQVV4YixTQUFTLEVBQUM4TCxRQUFRLEVBQUM0ZCxRQUFBQSxFQUFRLEVBQUMsSUFBSTtBQUN0RCxVQUFNKzZCLFdBQVcsS0FBS1gsaUJBQWlCLENBQUE7QUFFdkMsVUFBTUssYUFBYSxLQUFLQSxhQUFhO01BQUM7SUFBRTtBQUN4QyxVQUFNendCLGFBQWFnd0IsYUFBYWg2QjtBQUNoQyxRQUFJZzdCLGNBQWNyckI7QUFFbEI5eEIsUUFBSWkyQixZQUFZO0FBQ2hCajJCLFFBQUlvMkIsZUFBZTtBQUVuQixRQUFJZ25CLE1BQU07QUFDVixRQUFJaGpELE1BQU0sQ0FBQyt4QjtBQUNYLFNBQUt1d0IsWUFBWWpyRCxRQUFRLENBQUNzbEIsWUFBWXBrQixNQUFNO0FBQzFDLFlBQU0wcUQsWUFBWXJCLFdBQVloakIsV0FBVyxJQUFLaDVCLElBQUlzOUMsWUFBWXZtQyxXQUFXVCxJQUFJLEVBQUVySTtBQUUvRSxVQUFJdGIsTUFBTSxLQUFLaXFELFdBQVdBLFdBQVdscUQsU0FBUyxDQUFBLElBQUsycUQsWUFBWSxJQUFJbDdCLFVBQVVsTyxVQUFVO0FBQ3JGa3BDLHVCQUFlaHhCO0FBQ2Z5d0IsbUJBQVdBLFdBQVdscUQsVUFBVUMsSUFBSSxJQUFJLElBQUksRUFBQSxJQUFNO0FBQ2xEeUgsZUFBTyt4QjtBQUNQaXhCOztBQUdGRixlQUFTdnFELENBQUFBLElBQUs7UUFBQzRILE1BQU07UUFBR0g7UUFBS2dqRDtRQUFLbnZDLE9BQU9vdkM7UUFBV3J2QyxRQUFRbXVDO01BQVU7QUFFdEVTLGlCQUFXQSxXQUFXbHFELFNBQVMsQ0FBQSxLQUFNMnFELFlBQVlsN0I7SUFDbkQsQ0FBQTtBQUVBLFdBQU9nN0I7RUFDVDtFQUVBRixTQUFTbnJCLGFBQWFnckIsV0FBV2QsVUFBVXVCLGFBQWE7QUFDdEQsVUFBTSxFQUFDdjlDLEtBQUtrVSxXQUFXemIsU0FBUyxFQUFDOEwsUUFBUSxFQUFDNGQsUUFBQUEsRUFBUSxFQUFDLElBQUk7QUFDdkQsVUFBTSs2QixXQUFXLEtBQUtYLGlCQUFpQixDQUFBO0FBQ3ZDLFVBQU1JLGNBQWMsS0FBS0EsY0FBYyxDQUFBO0FBQ3ZDLFVBQU1hLGNBQWN0cEMsWUFBWTRkO0FBRWhDLFFBQUkyckIsYUFBYXQ3QjtBQUNqQixRQUFJdTdCLGtCQUFrQjtBQUN0QixRQUFJQyxtQkFBbUI7QUFFdkIsUUFBSXBqRCxPQUFPO0FBQ1gsUUFBSXFqRCxNQUFNO0FBRVYsU0FBS2xCLFlBQVlqckQsUUFBUSxDQUFDc2xCLFlBQVlwa0IsTUFBTTtBQUMxQyxZQUFNLEVBQUMwcUQsV0FBV2xCLFdBQVUsSUFBSTBCLGtCQUFrQjdCLFVBQVVjLFdBQVc5OEMsS0FBSytXLFlBQVl3bUMsV0FBQUE7QUFHeEYsVUFBSTVxRCxJQUFJLEtBQUtnckQsbUJBQW1CeEIsYUFBYSxJQUFJaDZCLFVBQVVxN0IsYUFBYTtBQUN0RUMsc0JBQWNDLGtCQUFrQnY3QjtBQUNoQ3c2QixvQkFBWWhwRCxLQUFLO1VBQUNzYSxPQUFPeXZDO1VBQWlCMXZDLFFBQVEydkM7UUFBZ0IsQ0FBQTtBQUNsRXBqRCxnQkFBUW1qRCxrQkFBa0J2N0I7QUFDMUJ5N0I7QUFDQUYsMEJBQWtCQyxtQkFBbUI7O0FBSXZDVCxlQUFTdnFELENBQUFBLElBQUs7UUFBQzRIO1FBQU1ILEtBQUt1akQ7UUFBa0JDO1FBQUszdkMsT0FBT292QztRQUFXcnZDLFFBQVFtdUM7TUFBVTtBQUdyRnVCLHdCQUFrQjdyRCxLQUFLb0MsSUFBSXlwRCxpQkFBaUJMLFNBQUFBO0FBQzVDTSwwQkFBb0J4QixhQUFhaDZCO0lBQ25DLENBQUE7QUFFQXM3QixrQkFBY0M7QUFDZGYsZ0JBQVlocEQsS0FBSztNQUFDc2EsT0FBT3l2QztNQUFpQjF2QyxRQUFRMnZDO0lBQWdCLENBQUE7QUFFbEUsV0FBT0Y7RUFDVDtFQUVBSyxpQkFBaUI7QUFDZixRQUFJLENBQUMsS0FBS3JsRCxRQUFROGdCLFNBQVM7QUFDekI7O0FBRUYsVUFBTXVZLGNBQWMsS0FBS2lyQixvQkFBbUI7QUFDNUMsVUFBTSxFQUFDUixnQkFBZ0JXLFVBQVV6a0QsU0FBUyxFQUFDbXlCLE9BQU9ybUIsUUFBUSxFQUFDNGQsUUFBTyxHQUFHNDdCLElBQUFBLEVBQUksSUFBSTtBQUM3RSxVQUFNQyxZQUFZQyxjQUFjRixLQUFLLEtBQUt4akQsTUFBTSxLQUFLMFQsS0FBSztBQUMxRCxRQUFJLEtBQUs3QixhQUFZLEdBQUk7QUFDdkIsVUFBSWd4QyxNQUFNO0FBQ1YsVUFBSTdpRCxPQUFPb3lCLGVBQWUvQixPQUFPLEtBQUtyd0IsT0FBTzRuQixTQUFTLEtBQUs5bkIsUUFBUSxLQUFLdWlELFdBQVdRLEdBQUksQ0FBQTtBQUN2RixpQkFBV2MsVUFBVWhCLFVBQVU7QUFDN0IsWUFBSUUsUUFBUWMsT0FBT2QsS0FBSztBQUN0QkEsZ0JBQU1jLE9BQU9kO0FBQ2I3aUQsaUJBQU9veUIsZUFBZS9CLE9BQU8sS0FBS3J3QixPQUFPNG5CLFNBQVMsS0FBSzluQixRQUFRLEtBQUt1aUQsV0FBV1EsR0FBSSxDQUFBOztBQUVyRmMsZUFBTzlqRCxPQUFPLEtBQUtBLE1BQU0wM0IsY0FBYzNQO0FBQ3ZDKzdCLGVBQU8zakQsT0FBT3lqRCxVQUFVRyxXQUFXSCxVQUFVOWpELEVBQUVLLElBQU8yakQsR0FBQUEsT0FBT2p3QyxLQUFLO0FBQ2xFMVQsZ0JBQVEyakQsT0FBT2p3QyxRQUFRa1U7TUFDekI7V0FDSztBQUNMLFVBQUl5N0IsTUFBTTtBQUNWLFVBQUl4akQsTUFBTXV5QixlQUFlL0IsT0FBTyxLQUFLeHdCLE1BQU0wM0IsY0FBYzNQLFNBQVMsS0FBSzduQixTQUFTLEtBQUtxaUQsWUFBWWlCLEdBQUFBLEVBQUs1dkMsTUFBTTtBQUM1RyxpQkFBV2t3QyxVQUFVaEIsVUFBVTtBQUM3QixZQUFJZ0IsT0FBT04sUUFBUUEsS0FBSztBQUN0QkEsZ0JBQU1NLE9BQU9OO0FBQ2J4akQsZ0JBQU11eUIsZUFBZS9CLE9BQU8sS0FBS3h3QixNQUFNMDNCLGNBQWMzUCxTQUFTLEtBQUs3bkIsU0FBUyxLQUFLcWlELFlBQVlpQixHQUFBQSxFQUFLNXZDLE1BQU07O0FBRTFHa3dDLGVBQU85akQsTUFBTUE7QUFDYjhqRCxlQUFPM2pELFFBQVEsS0FBS0EsT0FBTzRuQjtBQUMzQis3QixlQUFPM2pELE9BQU95akQsVUFBVUcsV0FBV0gsVUFBVTlqRCxFQUFFZ2tELE9BQU8zakQsSUFBSSxHQUFHMmpELE9BQU9qd0MsS0FBSztBQUN6RTdULGVBQU84akQsT0FBT2x3QyxTQUFTbVU7TUFDekI7O0VBRUo7RUFFQS9WLGVBQWU7QUFDYixXQUFPLEtBQUszVCxRQUFRd2pCLGFBQWEsU0FBUyxLQUFLeGpCLFFBQVF3akIsYUFBYTtFQUN0RTtFQUVBcnBCLE9BQU87QUFDTCxRQUFJLEtBQUs2RixRQUFROGdCLFNBQVM7QUFDeEIsWUFBTXZaLE1BQU0sS0FBS0E7QUFDakJ1NEIsZUFBU3Y0QixLQUFLLElBQUk7QUFFbEIsV0FBS28rQyxNQUFLO0FBRVYxbEIsaUJBQVcxNEIsR0FBQUE7O0VBRWY7RUFLQW8rQyxRQUFRO0FBQ04sVUFBTSxFQUFDM2xELFNBQVNtQixNQUFNK2lELGFBQWFDLFlBQVk1OEMsSUFBQUEsSUFBTztBQUN0RCxVQUFNLEVBQUM0cUIsT0FBT3JtQixRQUFRdTNDLFVBQUFBLElBQWFsaUQ7QUFDbkMsVUFBTXlrRCxlQUFldm1ELFNBQVNqRDtBQUM5QixVQUFNbXBELFlBQVlDLGNBQWNya0QsS0FBS21rRCxLQUFLLEtBQUt4akQsTUFBTSxLQUFLMFQsS0FBSztBQUMvRCxVQUFNNnVDLFlBQVk3d0IsT0FBTzZ2QixVQUFVOXZCLElBQUk7QUFDdkMsVUFBTSxFQUFDN0osUUFBTyxJQUFJMjVCO0FBQ2xCLFVBQU05aUIsV0FBVzhqQixVQUFVMWpEO0FBQzNCLFVBQU1rbEQsZUFBZXRsQixXQUFXO0FBQ2hDLFFBQUl1bEI7QUFFSixTQUFLNWxCLFVBQVM7QUFHZDM0QixRQUFJaTJCLFlBQVkrbkIsVUFBVS9uQixVQUFVLE1BQUE7QUFDcENqMkIsUUFBSW8yQixlQUFlO0FBQ25CcDJCLFFBQUk0VyxZQUFZO0FBQ2hCNVcsUUFBSWdzQixPQUFPOHdCLFVBQVV6cEI7QUFFckIsVUFBTSxFQUFDMm9CLFVBQVVELFdBQVdJLFdBQVUsSUFBSU4sV0FBV0MsV0FBVzlpQixRQUFBQTtBQUdoRSxVQUFNd2xCLGdCQUFnQixTQUFTdGtELEdBQUdDLEdBQUc0YyxZQUFZO0FBQy9DLFVBQUlySSxNQUFNc3RDLFFBQWFBLEtBQUFBLFlBQVksS0FBS3R0QyxNQUFNcXRDLFNBQUFBLEtBQWNBLFlBQVksR0FBRztBQUN6RTs7QUFJRi83QyxVQUFJczNCLEtBQUk7QUFFUixZQUFNMWdCLFlBQVloVixlQUFlbVYsV0FBV0gsV0FBVyxDQUFBO0FBQ3ZENVcsVUFBSXVXLFlBQVkzVSxlQUFlbVYsV0FBV1IsV0FBVzhuQyxZQUFBQTtBQUNyRHIrQyxVQUFJeXVDLFVBQVU3c0MsZUFBZW1WLFdBQVcwM0IsU0FBUyxNQUFBO0FBQ2pEenVDLFVBQUk4M0IsaUJBQWlCbDJCLGVBQWVtVixXQUFXK2dCLGdCQUFnQixDQUFBO0FBQy9EOTNCLFVBQUl5dEMsV0FBVzdyQyxlQUFlbVYsV0FBVzAyQixVQUFVLE9BQUE7QUFDbkR6dEMsVUFBSTRXLFlBQVlBO0FBQ2hCNVcsVUFBSXlXLGNBQWM3VSxlQUFlbVYsV0FBV04sYUFBYTRuQyxZQUFBQTtBQUV6RHIrQyxVQUFJNjNCLFlBQVlqMkIsZUFBZW1WLFdBQVcwbkMsVUFBVSxDQUFBLENBQUUsQ0FBQTtBQUV0RCxVQUFJM0MsVUFBVUcsZUFBZTtBQUczQixjQUFNeUMsY0FBYztVQUNsQjN0QyxRQUFRZ3JDLFlBQVlscUQsS0FBSzhzRCxRQUFRO1VBQ2pDeG9DLFlBQVlZLFdBQVdaO1VBQ3ZCN0UsVUFBVXlGLFdBQVd6RjtVQUNyQmdFLGFBQWFzQjtRQUNmO0FBQ0EsY0FBTTlCLFVBQVVrcEMsVUFBVVksTUFBTTFrRCxHQUFHOGhELFdBQVcsQ0FBQTtBQUM5QyxjQUFNam5DLFVBQVU1YSxJQUFJbWtEO0FBR3BCTyx3QkFBZ0I3K0MsS0FBSzArQyxhQUFhNXBDLFNBQVNDLFNBQVMrbUMsVUFBVUksbUJBQW1CRixRQUFBQTthQUM1RTtBQUdMLGNBQU04QyxVQUFVM2tELElBQUl0SSxLQUFLb0MsS0FBSytrQyxXQUFXK2lCLGFBQWEsR0FBRyxDQUFBO0FBQ3pELGNBQU1nRCxXQUFXZixVQUFVRyxXQUFXamtELEdBQUc4aEQsUUFBQUE7QUFDekMsY0FBTWhSLGVBQWUySCxjQUFjNTdCLFdBQVdpMEIsWUFBWTtBQUUxRGhyQyxZQUFJKzNCLFVBQVM7QUFFYixZQUFJbmdDLE9BQU9XLE9BQU95eUMsWUFBQUEsRUFBYzVOLEtBQUtsd0IsQ0FBQUEsTUFBS0EsTUFBTSxDQUFJLEdBQUE7QUFDbEQ2bUMsNkJBQW1CL3pDLEtBQUs7WUFDdEI5RixHQUFHNmtEO1lBQ0g1a0QsR0FBRzJrRDtZQUNIOTlCLEdBQUdnN0I7WUFDSDk2QixHQUFHNjZCO1lBQ0hockMsUUFBUWk2QjtVQUNWLENBQUE7ZUFDSztBQUNMaHJDLGNBQUl1cUMsS0FBS3dVLFVBQVVELFNBQVM5QyxVQUFVRCxTQUFBQTs7QUFHeEMvN0MsWUFBSW1CLEtBQUk7QUFDUixZQUFJeVYsY0FBYyxHQUFHO0FBQ25CNVcsY0FBSWs0QixPQUFNOzs7QUFJZGw0QixVQUFJdzNCLFFBQU87SUFDYjtBQUVBLFVBQU13bkIsV0FBVyxTQUFTOWtELEdBQUdDLEdBQUc0YyxZQUFZO0FBQzFDMGhCLGlCQUFXejRCLEtBQUsrVyxXQUFXVCxNQUFNcGMsR0FBR0MsSUFBS2dpRCxhQUFhLEdBQUlXLFdBQVc7UUFDbkVtQyxlQUFlbG9DLFdBQVduWDtRQUMxQnEyQixXQUFXK25CLFVBQVUvbkIsVUFBVWxmLFdBQVdrZixTQUFTO01BQ3JELENBQUE7SUFDRjtBQUdBLFVBQU03cEIsZUFBZSxLQUFLQSxhQUFZO0FBQ3RDLFVBQU0wbEIsY0FBYyxLQUFLaXJCLG9CQUFtQjtBQUM1QyxRQUFJM3dDLGNBQWM7QUFDaEJteUMsZUFBUztRQUNQcmtELEdBQUd5eUIsZUFBZS9CLE9BQU8sS0FBS3J3QixPQUFPNG5CLFNBQVMsS0FBSzluQixRQUFRdWlELFdBQVcsQ0FBRSxDQUFBO1FBQ3hFemlELEdBQUcsS0FBS0MsTUFBTStuQixVQUFVMlA7UUFDeEI1YSxNQUFNO01BQ1I7V0FDSztBQUNMcW5DLGVBQVM7UUFDUHJrRCxHQUFHLEtBQUtLLE9BQU80bkI7UUFDZmhvQixHQUFHd3lCLGVBQWUvQixPQUFPLEtBQUt4d0IsTUFBTTAzQixjQUFjM1AsU0FBUyxLQUFLN25CLFNBQVNxaUQsWUFBWSxDQUFBLEVBQUczdUMsTUFBTTtRQUM5RmtKLE1BQU07TUFDUjs7QUFHRmdvQywwQkFBc0IsS0FBS2wvQyxLQUFLcEcsS0FBS3VsRCxhQUFhO0FBRWxELFVBQU1oekIsYUFBYWd3QixhQUFhaDZCO0FBQ2hDLFNBQUt1NkIsWUFBWWpyRCxRQUFRLENBQUNzbEIsWUFBWXBrQixNQUFNO0FBQzFDcU4sVUFBSXlXLGNBQWNNLFdBQVdKO0FBQzdCM1csVUFBSXVXLFlBQVlRLFdBQVdKO0FBRTNCLFlBQU15b0MsWUFBWXAvQyxJQUFJczlDLFlBQVl2bUMsV0FBV1QsSUFBSSxFQUFFckk7QUFDbkQsWUFBTWdvQixZQUFZK25CLFVBQVUvbkIsVUFBVWxmLFdBQVdrZixjQUFjbGYsV0FBV2tmLFlBQVk2bEIsVUFBVTdsQixVQUFRO0FBQ3hHLFlBQU1ob0IsUUFBUSt0QyxXQUFXc0MsZUFBZWM7QUFDeEMsVUFBSWxsRCxJQUFJcWtELE9BQU9ya0Q7QUFDZixVQUFJQyxJQUFJb2tELE9BQU9wa0Q7QUFFZjZqRCxnQkFBVXFCLFNBQVMsS0FBS3B4QyxLQUFLO0FBRTdCLFVBQUk3QixjQUFjO0FBQ2hCLFlBQUl6WixJQUFJLEtBQUt1SCxJQUFJK1QsUUFBUWtVLFVBQVUsS0FBSzluQixPQUFPO0FBQzdDRixjQUFJb2tELE9BQU9wa0QsS0FBS2d5QjtBQUNoQm95QixpQkFBT3JuQztBQUNQaGQsY0FBSXFrRCxPQUFPcmtELElBQUl5eUIsZUFBZS9CLE9BQU8sS0FBS3J3QixPQUFPNG5CLFNBQVMsS0FBSzluQixRQUFRdWlELFdBQVcyQixPQUFPcm5DLElBQUksQ0FBQzs7aUJBRXZGdmtCLElBQUksS0FBS3dILElBQUlneUIsYUFBYSxLQUFLN3hCLFFBQVE7QUFDaERKLFlBQUlxa0QsT0FBT3JrRCxJQUFJQSxJQUFJeWlELFlBQVk0QixPQUFPcm5DLElBQUksRUFBRWpKLFFBQVFrVTtBQUNwRG84QixlQUFPcm5DO0FBQ1AvYyxZQUFJb2tELE9BQU9wa0QsSUFBSXd5QixlQUFlL0IsT0FBTyxLQUFLeHdCLE1BQU0wM0IsY0FBYzNQLFNBQVMsS0FBSzduQixTQUFTcWlELFlBQVk0QixPQUFPcm5DLElBQUksRUFBRWxKLE1BQU07O0FBR3RILFlBQU1zeEMsUUFBUXRCLFVBQVU5akQsRUFBRUEsQ0FBQUE7QUFFMUJza0Qsb0JBQWNjLE9BQU9ubEQsR0FBRzRjLFVBQUFBO0FBRXhCN2MsVUFBSXFsRCxPQUFPdHBCLFdBQVcvN0IsSUFBSThoRCxXQUFXc0MsY0FBY2x5QyxlQUFlbFMsSUFBSStULFFBQVEsS0FBSzVULE9BQU9ULEtBQUtta0QsR0FBRztBQUdsR2lCLGVBQVNoQixVQUFVOWpELEVBQUVBLENBQUFBLEdBQUlDLEdBQUc0YyxVQUFBQTtBQUU1QixVQUFJM0ssY0FBYztBQUNoQm15QyxlQUFPcmtELEtBQUsrVCxRQUFRa1U7TUFDdEIsV0FBVyxPQUFPcEwsV0FBV1QsU0FBUyxVQUFVO0FBQzlDLGNBQU1rcEMsaUJBQWlCMUMsVUFBVTN3QjtBQUNqQ295QixlQUFPcGtELEtBQUtzbEQsMEJBQTBCMW9DLFlBQVl5b0MsY0FBa0JyOUIsSUFBQUE7YUFDL0Q7QUFDTG84QixlQUFPcGtELEtBQUtneUI7O0lBRWhCLENBQUE7QUFFQXV6Qix5QkFBcUIsS0FBSzEvQyxLQUFLcEcsS0FBS3VsRCxhQUFhO0VBQ25EO0VBS0F4bUIsWUFBWTtBQUNWLFVBQU0vK0IsT0FBTyxLQUFLbkI7QUFDbEIsVUFBTW01QixZQUFZaDRCLEtBQUs2M0I7QUFDdkIsVUFBTWt1QixZQUFZMXpCLE9BQU8yRixVQUFVNUYsSUFBSTtBQUN2QyxVQUFNNHpCLGVBQWVsOUIsVUFBVWtQLFVBQVV6UCxPQUFPO0FBRWhELFFBQUksQ0FBQ3lQLFVBQVVyWSxTQUFTO0FBQ3RCOztBQUdGLFVBQU15a0MsWUFBWUMsY0FBY3JrRCxLQUFLbWtELEtBQUssS0FBS3hqRCxNQUFNLEtBQUswVCxLQUFLO0FBQy9ELFVBQU1qTyxNQUFNLEtBQUtBO0FBQ2pCLFVBQU1pYyxXQUFXMlYsVUFBVTNWO0FBQzNCLFVBQU1xaUMsZUFBZXFCLFVBQVV2bUQsT0FBTztBQUN0QyxVQUFNeW1ELDZCQUE2QkQsYUFBYXhsRCxNQUFNa2tEO0FBQ3RELFFBQUlua0Q7QUFJSixRQUFJSSxPQUFPLEtBQUtBO0FBQ2hCLFFBQUkwWixXQUFXLEtBQUtoRztBQUVwQixRQUFJLEtBQUs3QixhQUFZLEdBQUk7QUFFdkI2SCxpQkFBV3BpQixLQUFLb0MsSUFBTyxHQUFBLEtBQUsyb0QsVUFBVTtBQUN0Q3ppRCxVQUFJLEtBQUtDLE1BQU15bEQ7QUFDZnRsRCxhQUFPb3lCLGVBQWUveUIsS0FBS2d4QixPQUFPcndCLE1BQU0sS0FBS0YsUUFBUTRaLFFBQUFBO1dBQ2hEO0FBRUwsWUFBTUMsWUFBWSxLQUFLeW9DLFlBQVk3b0QsT0FBTyxDQUFDQyxLQUFLcUYsU0FBU3ZILEtBQUtvQyxJQUFJRixLQUFLcUYsS0FBSzRVLE1BQU0sR0FBRyxDQUFBO0FBQ3JGN1QsVUFBSTBsRCw2QkFBNkJsekIsZUFBZS95QixLQUFLZ3hCLE9BQU8sS0FBS3h3QixLQUFLLEtBQUtFLFNBQVM0WixZQUFZdGEsS0FBSzJLLE9BQU80ZCxVQUFVLEtBQUs0NkIsb0JBQW1CLENBQUE7O0FBS2hKLFVBQU03aUQsSUFBSXl5QixlQUFlMVEsVUFBVTFoQixNQUFNQSxPQUFPMFosUUFBQUE7QUFHaERqVSxRQUFJaTJCLFlBQVkrbkIsVUFBVS9uQixVQUFVMUosbUJBQW1CdFEsUUFBQUEsQ0FBQUE7QUFDdkRqYyxRQUFJbzJCLGVBQWU7QUFDbkJwMkIsUUFBSXlXLGNBQWNtYixVQUFVLzhCO0FBQzVCbUwsUUFBSXVXLFlBQVlxYixVQUFVLzhCO0FBQzFCbUwsUUFBSWdzQixPQUFPMnpCLFVBQVV0c0I7QUFFckJvRixlQUFXejRCLEtBQUs0eEIsVUFBVXRiLE1BQU1wYyxHQUFHQyxHQUFHd2xELFNBQUFBO0VBQ3hDO0VBS0E1QyxzQkFBc0I7QUFDcEIsVUFBTW5yQixZQUFZLEtBQUtuNUIsUUFBUWc1QjtBQUMvQixVQUFNa3VCLFlBQVkxekIsT0FBTzJGLFVBQVU1RixJQUFJO0FBQ3ZDLFVBQU00ekIsZUFBZWw5QixVQUFVa1AsVUFBVXpQLE9BQU87QUFDaEQsV0FBT3lQLFVBQVVyWSxVQUFVb21DLFVBQVV4ekIsYUFBYXl6QixhQUFhNXhDLFNBQVM7RUFDMUU7RUFLQTh4QyxpQkFBaUI1bEQsR0FBR0MsR0FBRztBQUNyQixRQUFJeEgsR0FBR290RCxRQUFRQztBQUVmLFFBQUk5UixXQUFXaDBDLEdBQUcsS0FBS0ssTUFBTSxLQUFLRixLQUFLLEtBQ2xDNnpDLFdBQVcvekMsR0FBRyxLQUFLQyxLQUFLLEtBQUtFLE1BQU0sR0FBRztBQUV6QzBsRCxXQUFLLEtBQUt6RDtBQUNWLFdBQUs1cEQsSUFBSSxHQUFHQSxJQUFJcXRELEdBQUd0dEQsUUFBUSxFQUFFQyxHQUFHO0FBQzlCb3RELGlCQUFTQyxHQUFHcnRELENBQUU7QUFFZCxZQUFJdTdDLFdBQVdoMEMsR0FBRzZsRCxPQUFPeGxELE1BQU13bEQsT0FBT3hsRCxPQUFPd2xELE9BQU85eEMsS0FBSyxLQUNwRGlnQyxXQUFXL3pDLEdBQUc0bEQsT0FBTzNsRCxLQUFLMmxELE9BQU8zbEQsTUFBTTJsRCxPQUFPL3hDLE1BQU0sR0FBRztBQUUxRCxpQkFBTyxLQUFLMHVDLFlBQVkvcEQsQ0FBRTs7TUFFOUI7O0FBR0YsV0FBTztFQUNUO0VBTUFzdEQsWUFBWW5wQyxHQUFHO0FBQ2IsVUFBTWxkLE9BQU8sS0FBS25CO0FBQ2xCLFFBQUksQ0FBQ3luRCxXQUFXcHBDLEVBQUUxbEIsTUFBTXdJLElBQU8sR0FBQTtBQUM3Qjs7QUFJRixVQUFNdW1ELGNBQWMsS0FBS0wsaUJBQWlCaHBDLEVBQUU1YyxHQUFHNGMsRUFBRTNjLENBQUM7QUFFbEQsUUFBSTJjLEVBQUUxbEIsU0FBUyxlQUFlMGxCLEVBQUUxbEIsU0FBUyxZQUFZO0FBQ25ELFlBQU11OUMsV0FBVyxLQUFLNk47QUFDdEIsWUFBTTRELFdBQVdoRSxXQUFXek4sVUFBVXdSLFdBQUFBO0FBQ3RDLFVBQUl4UixZQUFZLENBQUN5UixVQUFVO0FBQ3pCbHVELGlCQUFLMEgsS0FBS3ltRCxTQUFTO1VBQUN2cEM7VUFBRzYzQjtVQUFVO1FBQUssR0FBRSxJQUFJOztBQUc5QyxXQUFLNk4sZUFBZTJEO0FBRXBCLFVBQUlBLGVBQWUsQ0FBQ0MsVUFBVTtBQUM1Qmx1RCxpQkFBSzBILEtBQUtrd0MsU0FBUztVQUFDaHpCO1VBQUdxcEM7VUFBYTtRQUFLLEdBQUUsSUFBSTs7SUFFbkQsV0FBV0EsYUFBYTtBQUN0Qmp1RCxlQUFLMEgsS0FBS2lkLFNBQVM7UUFBQ0M7UUFBR3FwQztRQUFhO01BQUssR0FBRSxJQUFJOztFQUVuRDtBQUNGO0FBRUEsU0FBU3RDLGtCQUFrQjdCLFVBQVVjLFdBQVc5OEMsS0FBSytXLFlBQVl3bUMsYUFBYTtBQUM1RSxRQUFNRixZQUFZaUQsbUJBQW1CdnBDLFlBQVlpbEMsVUFBVWMsV0FBVzk4QyxHQUFBQTtBQUN0RSxRQUFNbThDLGFBQWFvRSxvQkFBb0JoRCxhQUFheG1DLFlBQVkrbEMsVUFBVTN3QixVQUFVO0FBQ3BGLFNBQU87SUFBQ2t4QjtJQUFXbEI7RUFBVTtBQUMvQjtBQUVBLFNBQVNtRSxtQkFBbUJ2cEMsWUFBWWlsQyxVQUFVYyxXQUFXOThDLEtBQUs7QUFDaEUsTUFBSXdnRCxpQkFBaUJ6cEMsV0FBV1Q7QUFDaEMsTUFBSWtxQyxrQkFBa0IsT0FBT0EsbUJBQW1CLFVBQVU7QUFDeERBLHFCQUFpQkEsZUFBZTFzRCxPQUFPLENBQUNrVyxHQUFHclAsTUFBTXFQLEVBQUV0WCxTQUFTaUksRUFBRWpJLFNBQVNzWCxJQUFJclAsQ0FBQzs7QUFFOUUsU0FBT3FoRCxXQUFZYyxVQUFVMWpELE9BQU8sSUFBSzRHLElBQUlzOUMsWUFBWWtELGNBQUFBLEVBQWdCdnlDO0FBQzNFO0FBRUEsU0FBU3N5QyxvQkFBb0JoRCxhQUFheG1DLFlBQVl5b0MsZ0JBQWdCO0FBQ3BFLE1BQUlyRCxhQUFhb0I7QUFDakIsTUFBSSxPQUFPeG1DLFdBQVdULFNBQVMsVUFBVTtBQUN2QzZsQyxpQkFBYXNELDBCQUEwQjFvQyxZQUFZeW9DLGNBQUFBOztBQUVyRCxTQUFPckQ7QUFDVDtBQUVBLFNBQVNzRCwwQkFBMEIxb0MsWUFBWXlvQyxnQkFBZ0I7QUFDN0QsUUFBTXZ0QixjQUFjbGIsV0FBV1QsT0FBT1MsV0FBV1QsS0FBSzVqQixTQUFTO0FBQy9ELFNBQU84c0QsaUJBQWlCdnRCO0FBQzFCO0FBRUEsU0FBU2l1QixXQUFXOXVELE1BQU13SSxNQUFNO0FBQzlCLE9BQUt4SSxTQUFTLGVBQWVBLFNBQVMsZ0JBQWdCd0ksS0FBS2t3QyxXQUFXbHdDLEtBQUt5bUQsVUFBVTtBQUNuRixXQUFPOztBQUVULE1BQUl6bUQsS0FBS2lkLFlBQVl6bEIsU0FBUyxXQUFXQSxTQUFTLFlBQVk7QUFDNUQsV0FBTzs7QUFFVCxTQUFPO0FBQ1Q7QUFFQSxJQUFBLGdCQUFlO0VBQ2J5TCxJQUFJO0VBTUo0akQsVUFBVXBFO0VBRVZ0cUQsTUFBTWQsT0FBTzZqRCxPQUFPcjhDLFVBQVM7QUFDM0IsVUFBTXdkLFNBQVNobEIsTUFBTWdsQixTQUFTLElBQUlvbUMsT0FBTztNQUFDcjhDLEtBQUsvTyxNQUFNK087TUFBS3ZILFNBQUFBO01BQVN4SDtJQUFLLENBQUE7QUFDeEVpdUIsWUFBUXpuQixVQUFVeEcsT0FBT2dsQixRQUFReGQsUUFBQUE7QUFDakN5bUIsWUFBUWtELE9BQU9ueEIsT0FBT2dsQixNQUFBQTtFQUN4QjtFQUVBOWhCLEtBQUtsRCxPQUFPO0FBQ1ZpdUIsWUFBUXFELFVBQVV0eEIsT0FBT0EsTUFBTWdsQixNQUFNO0FBQ3JDLFdBQU9obEIsTUFBTWdsQjtFQUNmO0VBS0F5WSxhQUFhejlCLE9BQU82akQsT0FBT3I4QyxVQUFTO0FBQ2xDLFVBQU13ZCxTQUFTaGxCLE1BQU1nbEI7QUFDckJpSixZQUFRem5CLFVBQVV4RyxPQUFPZ2xCLFFBQVF4ZCxRQUFBQTtBQUNqQ3dkLFdBQU94ZCxVQUFVQTtFQUNuQjtFQUlBeTNCLFlBQVlqL0IsT0FBTztBQUNqQixVQUFNZ2xCLFNBQVNobEIsTUFBTWdsQjtBQUNyQkEsV0FBTzRtQyxZQUFXO0FBQ2xCNW1DLFdBQU82bkMsZUFBYztFQUN2QjtFQUdBNEMsV0FBV3p2RCxPQUFPK1gsTUFBTTtBQUN0QixRQUFJLENBQUNBLEtBQUtxZ0MsUUFBUTtBQUNoQnA0QyxZQUFNZ2xCLE9BQU9ncUMsWUFBWWozQyxLQUFLdlYsS0FBSzs7RUFFdkM7RUFFQXFFLFVBQVU7SUFDUnloQixTQUFTO0lBQ1QwQyxVQUFVO0lBQ1YyTyxPQUFPO0lBQ1BoTCxVQUFVO0lBQ1YvbEIsU0FBUztJQUNUNmIsUUFBUTtJQUdSbUIsUUFBUUMsR0FBR0MsWUFBWWQsUUFBUTtBQUM3QixZQUFNOWEsU0FBUTRiLFdBQVd0YjtBQUN6QixZQUFNa2xELEtBQUsxcUMsT0FBT2hsQjtBQUNsQixVQUFJMHZELEdBQUdudEMsaUJBQWlCclksTUFBUSxHQUFBO0FBQzlCd2xELFdBQUd6WSxLQUFLL3NDLE1BQUFBO0FBQ1I0YixtQkFBV25YLFNBQVM7YUFDZjtBQUNMK2dELFdBQUd4WSxLQUFLaHRDLE1BQUFBO0FBQ1I0YixtQkFBV25YLFNBQVM7O0lBRXhCO0lBRUFrcUMsU0FBUztJQUNUdVcsU0FBUztJQUVUOTdDLFFBQVE7TUFDTjFQLE9BQU8sQ0FBQ21MLFFBQVFBLElBQUkvTyxNQUFNd0gsUUFBUTVEO01BQ2xDbW5ELFVBQVU7TUFDVjc1QixTQUFTO01BWVRqTSxlQUFlamxCLE9BQU87QUFDcEIsY0FBTXVSLFdBQVd2UixNQUFNOEssS0FBS3lHO0FBQzVCLGNBQU0sRUFBQytCLFFBQVEsRUFBQzAzQyxlQUFlOWxDLFlBQVk4ZixXQUFXcGhDLE9BQUFBLFFBQU8rckQsaUJBQWlCNVYsYUFBQUEsRUFBYSxJQUFJLzVDLE1BQU1nbEIsT0FBT3hkO0FBRTVHLGVBQU94SCxNQUFNZ0ssdUJBQXNCLEVBQUdtYixJQUFJLENBQUNwYSxTQUFTO0FBQ2xELGdCQUFNcWEsUUFBUXJhLEtBQUs2QixXQUFXc0ksU0FBUzgxQyxnQkFBZ0IsSUFBSWxyRCxNQUFTO0FBQ3BFLGdCQUFNdWtCLGNBQWNvTixVQUFVck0sTUFBTWYsV0FBVztBQUUvQyxpQkFBTztZQUNMZ0IsTUFBTTlULFNBQVN4RyxLQUFLYixLQUFLLEVBQUV3SztZQUMzQjRRLFdBQVdGLE1BQU1HO1lBQ2pCRyxXQUFXOWhCO1lBQ1grSyxRQUFRLENBQUM1RCxLQUFLZ3FDO1lBQ2R5SSxTQUFTcDRCLE1BQU1xNEI7WUFDZitQLFVBQVVwb0MsTUFBTWtmO1lBQ2hCdUMsZ0JBQWdCemhCLE1BQU1vZjtZQUN0QmdZLFVBQVVwM0IsTUFBTTR6QjtZQUNoQnJ6QixZQUFZdEIsWUFBWXJILFFBQVFxSCxZQUFZdEgsVUFBVTtZQUN0RHlJLGFBQWFKLE1BQU1LO1lBQ25CUCxZQUFZQSxjQUFjRSxNQUFNRjtZQUNoQzdFLFVBQVUrRSxNQUFNL0U7WUFDaEIya0IsV0FBV0EsYUFBYTVmLE1BQU00ZjtZQUM5QitVLGNBQWM0VixvQkFBb0I1VixnQkFBZ0IzMEIsTUFBTTIwQjtZQUd4RHZ2QyxjQUFjTyxLQUFLYjtVQUNyQjtRQUNGLEdBQUcsSUFBSTtNQUNUO0lBQ0Y7SUFFQXMyQixPQUFPO01BQ0w1OEIsT0FBTyxDQUFDbUwsUUFBUUEsSUFBSS9PLE1BQU13SCxRQUFRNUQ7TUFDbEMwa0IsU0FBUztNQUNUMEMsVUFBVTtNQUNWM0YsTUFBTTtJQUNSO0VBQ0Y7RUFFQVgsYUFBYTtJQUNYQyxhQUFhLENBQUN6RyxTQUFTLENBQUNBLEtBQUsyRyxXQUFXLElBQUE7SUFDeEN2UixRQUFRO01BQ05xUixhQUFhLENBQUN6RyxTQUFTLENBQUM7UUFBQztRQUFrQjtRQUFVO01BQU8sRUFBQ2lRLFNBQVNqUSxJQUFBQTtJQUN4RTtFQUNGO0FBQ0Y7QUN6c0JPLElBQU0weEMsUUFBTixjQUFvQnQ0QixRQUFBQTtFQUl6QjkzQixZQUFZNkcsUUFBUTtBQUNsQixVQUFLO0FBRUwsU0FBS3JHLFFBQVFxRyxPQUFPckc7QUFDcEIsU0FBS3dILFVBQVVuQixPQUFPbUI7QUFDdEIsU0FBS3VILE1BQU0xSSxPQUFPMEk7QUFDbEIsU0FBSzhnRCxXQUFXL3ZEO0FBQ2hCLFNBQUtxSixNQUFNcko7QUFDWCxTQUFLdUosU0FBU3ZKO0FBQ2QsU0FBS3dKLE9BQU94SjtBQUNaLFNBQUtzSixRQUFRdEo7QUFDYixTQUFLa2QsUUFBUWxkO0FBQ2IsU0FBS2lkLFNBQVNqZDtBQUNkLFNBQUtrckIsV0FBV2xyQjtBQUNoQixTQUFLMmtCLFNBQVMza0I7QUFDZCxTQUFLNnVCLFdBQVc3dUI7RUFDbEI7RUFFQTRGLE9BQU9zZCxVQUFVQyxXQUFXO0FBQzFCLFVBQU10YSxPQUFPLEtBQUtuQjtBQUVsQixTQUFLOEIsT0FBTztBQUNaLFNBQUtILE1BQU07QUFFWCxRQUFJLENBQUNSLEtBQUsyZixTQUFTO0FBQ2pCLFdBQUt0TCxRQUFRLEtBQUtELFNBQVMsS0FBSzNULFFBQVEsS0FBS0MsU0FBUztBQUN0RDs7QUFHRixTQUFLMlQsUUFBUSxLQUFLNVQsUUFBUTRaO0FBQzFCLFNBQUtqRyxTQUFTLEtBQUsxVCxTQUFTNFo7QUFFNUIsVUFBTWdpQixZQUFZOTlCLFFBQVF3QixLQUFLMGMsSUFBSSxJQUFJMWMsS0FBSzBjLEtBQUs1akIsU0FBUztBQUMxRCxTQUFLb3VELFdBQVdwK0IsVUFBVTlvQixLQUFLdW9CLE9BQU87QUFDdEMsVUFBTTQrQixXQUFXN3FCLFlBQVlqSyxPQUFPcnlCLEtBQUtveUIsSUFBSSxFQUFFRyxhQUFhLEtBQUsyMEIsU0FBUzl5QztBQUUxRSxRQUFJLEtBQUs1QixhQUFZLEdBQUk7QUFDdkIsV0FBSzRCLFNBQVMreUM7V0FDVDtBQUNMLFdBQUs5eUMsUUFBUTh5Qzs7RUFFakI7RUFFQTMwQyxlQUFlO0FBQ2IsVUFBTW9TLE1BQU0sS0FBSy9sQixRQUFRd2pCO0FBQ3pCLFdBQU91QyxRQUFRLFNBQVNBLFFBQVE7RUFDbEM7RUFFQXdpQyxVQUFVdHdDLFFBQVE7QUFDaEIsVUFBTSxFQUFDdFcsS0FBS0csTUFBTUQsUUFBUUQsT0FBTzVCLFNBQUFBLFNBQUFBLElBQVc7QUFDNUMsVUFBTW15QixRQUFRbnlCLFNBQVFteUI7QUFDdEIsUUFBSXRaLFdBQVc7QUFDZixRQUFJMkMsVUFBVXdZLFFBQVFDO0FBRXRCLFFBQUksS0FBS3RnQixhQUFZLEdBQUk7QUFDdkJxZ0IsZUFBU0UsZUFBZS9CLE9BQU9yd0IsTUFBTUYsS0FBQUE7QUFDckNxeUIsZUFBU3R5QixNQUFNc1c7QUFDZnVELGlCQUFXNVosUUFBUUU7V0FDZDtBQUNMLFVBQUk5QixTQUFRd2pCLGFBQWEsUUFBUTtBQUMvQndRLGlCQUFTbHlCLE9BQU9tVztBQUNoQmdjLGlCQUFTQyxlQUFlL0IsT0FBT3R3QixRQUFRRixHQUFBQTtBQUN2Q2tYLG1CQUFXd0IsS0FBSzthQUNYO0FBQ0wyWixpQkFBU3B5QixRQUFRcVc7QUFDakJnYyxpQkFBU0MsZUFBZS9CLE9BQU94d0IsS0FBS0UsTUFBQUE7QUFDcENnWCxtQkFBV3dCLEtBQUs7O0FBRWxCbUIsaUJBQVczWixTQUFTRjs7QUFFdEIsV0FBTztNQUFDcXlCO01BQVFDO01BQVF6WTtNQUFVM0M7SUFBUTtFQUM1QztFQUVBMWUsT0FBTztBQUNMLFVBQU1vTixNQUFNLEtBQUtBO0FBQ2pCLFVBQU1wRyxPQUFPLEtBQUtuQjtBQUVsQixRQUFJLENBQUNtQixLQUFLMmYsU0FBUztBQUNqQjs7QUFHRixVQUFNMG5DLFdBQVdoMUIsT0FBT3J5QixLQUFLb3lCLElBQUk7QUFDakMsVUFBTUcsYUFBYTgwQixTQUFTOTBCO0FBQzVCLFVBQU16YixTQUFTeWIsYUFBYSxJQUFJLEtBQUsyMEIsU0FBUzFtRDtBQUM5QyxVQUFNLEVBQUNxeUIsUUFBUUMsUUFBUXpZLFVBQVUzQyxTQUFBQSxJQUFZLEtBQUswdkMsVUFBVXR3QyxNQUFBQTtBQUU1RCtuQixlQUFXejRCLEtBQUtwRyxLQUFLMGMsTUFBTSxHQUFHLEdBQUcycUMsVUFBVTtNQUN6Q3BzRCxPQUFPK0UsS0FBSy9FO01BQ1pvZjtNQUNBM0M7TUFDQTJrQixXQUFXMUosbUJBQW1CM3lCLEtBQUtneEIsS0FBSztNQUN4Q3dMLGNBQWM7TUFDZGUsYUFBYTtRQUFDMUs7UUFBUUM7TUFBTztJQUMvQixDQUFBO0VBQ0Y7QUFDRjtBQUVBLFNBQVN3MEIsWUFBWWp3RCxPQUFPMmdDLFdBQVc7QUFDckMsUUFBTUgsUUFBUSxJQUFJb3ZCLE1BQU07SUFDdEI3Z0QsS0FBSy9PLE1BQU0rTztJQUNYdkgsU0FBU201QjtJQUNUM2dDO0VBQ0YsQ0FBQTtBQUVBaXVCLFVBQVF6bkIsVUFBVXhHLE9BQU93Z0MsT0FBT0csU0FBQUE7QUFDaEMxUyxVQUFRa0QsT0FBT254QixPQUFPd2dDLEtBQUFBO0FBQ3RCeGdDLFFBQU1rd0QsYUFBYTF2QjtBQUNyQjtBQUVBLElBQUEsZUFBZTtFQUNiNTBCLElBQUk7RUFNSjRqRCxVQUFVSTtFQUVWOXVELE1BQU1kLE9BQU82akQsT0FBT3I4QyxVQUFTO0FBQzNCeW9ELGdCQUFZandELE9BQU93SCxRQUFBQTtFQUNyQjtFQUVBdEUsS0FBS2xELE9BQU87QUFDVixVQUFNa3dELGFBQWFsd0QsTUFBTWt3RDtBQUN6QmppQyxZQUFRcUQsVUFBVXR4QixPQUFPa3dELFVBQUFBO0FBQ3pCLFdBQU9sd0QsTUFBTWt3RDtFQUNmO0VBRUF6eUIsYUFBYXo5QixPQUFPNmpELE9BQU9yOEMsVUFBUztBQUNsQyxVQUFNZzVCLFFBQVF4Z0MsTUFBTWt3RDtBQUNwQmppQyxZQUFRem5CLFVBQVV4RyxPQUFPd2dDLE9BQU9oNUIsUUFBQUE7QUFDaENnNUIsVUFBTWg1QixVQUFVQTtFQUNsQjtFQUVBWCxVQUFVO0lBQ1I4eUIsT0FBTztJQUNQclIsU0FBUztJQUNUeVMsTUFBTTtNQUNKdFcsUUFBUTtJQUNWO0lBQ0FrSyxVQUFVO0lBQ1Z1QyxTQUFTO0lBQ1RsRyxVQUFVO0lBQ1YzRixNQUFNO0lBQ05aLFFBQVE7RUFDVjtFQUVBa1QsZUFBZTtJQUNiL3pCLE9BQU87RUFDVDtFQUVBOGdCLGFBQWE7SUFDWEMsYUFBYTtJQUNiQyxZQUFZO0VBQ2Q7QUFDRjtBQ2xLQSxJQUFNTyxPQUFNLG9CQUFJZ3JDLFFBQUFBO0FBRWhCLElBQUEsa0JBQWU7RUFDYnZrRCxJQUFJO0VBRUo5SyxNQUFNZCxPQUFPNmpELE9BQU9yOEMsVUFBUztBQUMzQixVQUFNZzVCLFFBQVEsSUFBSW92QixNQUFNO01BQ3RCN2dELEtBQUsvTyxNQUFNK087TUFDWHZILFNBQUFBO01BQ0F4SDtJQUNGLENBQUE7QUFFQWl1QixZQUFRem5CLFVBQVV4RyxPQUFPd2dDLE9BQU9oNUIsUUFBQUE7QUFDaEN5bUIsWUFBUWtELE9BQU9ueEIsT0FBT3dnQyxLQUFBQTtBQUN0QnJiLElBQUFBLEtBQUk3aUIsSUFBSXRDLE9BQU93Z0MsS0FBQUE7RUFDakI7RUFFQXQ5QixLQUFLbEQsT0FBTztBQUNWaXVCLFlBQVFxRCxVQUFVdHhCLE9BQU9tbEIsS0FBSWhqQixJQUFJbkMsS0FBQUEsQ0FBQUE7QUFDakNtbEIsSUFBQUEsS0FBSTloQixPQUFPckQsS0FBQUE7RUFDYjtFQUVBeTlCLGFBQWF6OUIsT0FBTzZqRCxPQUFPcjhDLFVBQVM7QUFDbEMsVUFBTWc1QixRQUFRcmIsS0FBSWhqQixJQUFJbkMsS0FBQUE7QUFDdEJpdUIsWUFBUXpuQixVQUFVeEcsT0FBT3dnQyxPQUFPaDVCLFFBQUFBO0FBQ2hDZzVCLFVBQU1oNUIsVUFBVUE7RUFDbEI7RUFFQVgsVUFBVTtJQUNSOHlCLE9BQU87SUFDUHJSLFNBQVM7SUFDVHlTLE1BQU07TUFDSnRXLFFBQVE7SUFDVjtJQUNBa0ssVUFBVTtJQUNWdUMsU0FBUztJQUNUbEcsVUFBVTtJQUNWM0YsTUFBTTtJQUNOWixRQUFRO0VBQ1Y7RUFFQWtULGVBQWU7SUFDYi96QixPQUFPO0VBQ1Q7RUFFQThnQixhQUFhO0lBQ1hDLGFBQWE7SUFDYkMsWUFBWTtFQUNkO0FBQ0Y7QUNwQ0EsSUFBTXdyQyxjQUFjO0VBSWxCQyxRQUFRN3VELE9BQU87QUFDYixRQUFJLENBQUNBLE1BQU1DLFFBQVE7QUFDakIsYUFBTzs7QUFHVCxRQUFJQyxHQUFHKzNCO0FBQ1AsUUFBSTYyQixPQUFPLG9CQUFJNWhCLElBQUFBO0FBQ2YsUUFBSXhsQyxJQUFJO0FBQ1IsUUFBSTRKLFFBQVE7QUFFWixTQUFLcFIsSUFBSSxHQUFHKzNCLE1BQU1qNEIsTUFBTUMsUUFBUUMsSUFBSSszQixLQUFLLEVBQUUvM0IsR0FBRztBQUM1QyxZQUFNbXBCLEtBQUtycEIsTUFBTUUsQ0FBQUEsRUFBR3NNO0FBQ3BCLFVBQUk2YyxNQUFNQSxHQUFHMk0sU0FBUSxHQUFJO0FBQ3ZCLGNBQU1qSyxNQUFNMUMsR0FBRzBNLGdCQUFlO0FBQzlCKzRCLGFBQUszdEQsSUFBSTRxQixJQUFJdGtCLENBQUM7QUFDZEMsYUFBS3FrQixJQUFJcmtCO0FBQ1QsVUFBRTRKOztJQUVOO0FBR0EsUUFBSUEsVUFBVSxLQUFLdzlDLEtBQUtub0QsU0FBUyxHQUFHO0FBQ2xDLGFBQU87O0FBR1QsVUFBTW9vRCxXQUFXO01BQUlELEdBQUFBO01BQU16dEQsT0FBTyxDQUFDa1csR0FBR3JQLE1BQU1xUCxJQUFJclAsQ0FBQUEsSUFBSzRtRCxLQUFLbm9EO0FBRTFELFdBQU87TUFDTGMsR0FBR3NuRDtNQUNIcm5ELEdBQUdBLElBQUk0SjtJQUNUO0VBQ0Y7RUFLQXFhLFFBQVEzckIsT0FBT2d2RCxlQUFlO0FBQzVCLFFBQUksQ0FBQ2h2RCxNQUFNQyxRQUFRO0FBQ2pCLGFBQU87O0FBR1QsUUFBSXdILElBQUl1bkQsY0FBY3ZuRDtBQUN0QixRQUFJQyxJQUFJc25ELGNBQWN0bkQ7QUFDdEIsUUFBSXVqQixjQUFjemdCLE9BQU9FO0FBQ3pCLFFBQUl4SyxHQUFHKzNCLEtBQUtnM0I7QUFFWixTQUFLL3VELElBQUksR0FBRyszQixNQUFNajRCLE1BQU1DLFFBQVFDLElBQUkrM0IsS0FBSyxFQUFFLzNCLEdBQUc7QUFDNUMsWUFBTW1wQixLQUFLcnBCLE1BQU1FLENBQUFBLEVBQUdzTTtBQUNwQixVQUFJNmMsTUFBTUEsR0FBRzJNLFNBQVEsR0FBSTtBQUN2QixjQUFNMWEsU0FBUytOLEdBQUc2QixlQUFjO0FBQ2hDLGNBQU0rZ0IsSUFBSWlqQixzQkFBc0JGLGVBQWUxekMsTUFBQUE7QUFFL0MsWUFBSTJ3QixJQUFJaGhCLGFBQWE7QUFDbkJBLHdCQUFjZ2hCO0FBQ2RnakIsMkJBQWlCNWxDOzs7SUFHdkI7QUFFQSxRQUFJNGxDLGdCQUFnQjtBQUNsQixZQUFNRSxLQUFLRixlQUFlbDVCLGdCQUFlO0FBQ3pDdHVCLFVBQUkwbkQsR0FBRzFuRDtBQUNQQyxVQUFJeW5ELEdBQUd6bkQ7O0FBR1QsV0FBTztNQUNMRDtNQUNBQztJQUNGO0VBQ0Y7QUFDRjtBQUdBLFNBQVMwbkQsYUFBYXQxQyxNQUFNdTFDLFFBQVE7QUFDbEMsTUFBSUEsUUFBUTtBQUNWLFFBQUkxcEQsUUFBUTBwRCxNQUFTLEdBQUE7QUFFbkJ2bEQsWUFBTWllLFVBQVU3bUIsS0FBS291RCxNQUFNeDFDLE1BQU11MUMsTUFBQUE7V0FDNUI7QUFDTHYxQyxXQUFLNVksS0FBS211RCxNQUFBQTs7O0FBSWQsU0FBT3YxQztBQUNUO0FBUUEsU0FBU3kxQyxjQUFjQyxLQUFLO0FBQzFCLE9BQUssT0FBT0EsUUFBUSxZQUFZQSxlQUFlQyxXQUFXRCxJQUFJdHpDLFFBQVEsSUFBQSxJQUFRLElBQUk7QUFDaEYsV0FBT3N6QyxJQUFJN25CLE1BQU0sSUFBQTs7QUFFbkIsU0FBTzZuQjtBQUNUO0FBU0EsU0FBU0Usa0JBQWtCbHhELE9BQU80QixNQUFNO0FBQ3RDLFFBQU0sRUFBQ29NLFNBQVN4RCxjQUFjTixPQUFBQSxPQUFBQSxJQUFTdEk7QUFDdkMsUUFBTWdMLGFBQWE1TSxNQUFNd1IsZUFBZWhILFlBQUFBLEVBQWNvQztBQUN0RCxRQUFNLEVBQUM4SCxPQUFPeE0sTUFBQUEsSUFBUzBFLFdBQVc2SCxpQkFBaUJ2SyxNQUFBQTtBQUVuRCxTQUFPO0lBQ0xsSztJQUNBMFU7SUFDQTdILFFBQVFELFdBQVdnSCxVQUFVMUosTUFBQUE7SUFDN0JnRSxLQUFLbE8sTUFBTThLLEtBQUt5RyxTQUFTL0csWUFBYSxFQUFDTSxLQUFLWixNQUFNO0lBQ2xEaW5ELGdCQUFnQmpwRDtJQUNoQjRGLFNBQVNsQixXQUFXMkQsV0FBVTtJQUM5QnRDLFdBQVcvRDtJQUNYTTtJQUNBd0Q7RUFDRjtBQUNGO0FBS0EsU0FBU29qRCxlQUFlQyxTQUFTN3BELFVBQVM7QUFDeEMsUUFBTXVILE1BQU1zaUQsUUFBUXJ4RCxNQUFNK087QUFDMUIsUUFBTSxFQUFDdWlELE1BQU1DLFFBQVEvd0IsTUFBQUEsSUFBUzZ3QjtBQUM5QixRQUFNLEVBQUN0RyxVQUFVRCxVQUFBQSxJQUFhdGpEO0FBQzlCLFFBQU1ncUQsV0FBV3gyQixPQUFPeHpCLFNBQVFncUQsUUFBUTtBQUN4QyxRQUFNOUMsWUFBWTF6QixPQUFPeHpCLFNBQVFrbkQsU0FBUztBQUMxQyxRQUFNK0MsYUFBYXoyQixPQUFPeHpCLFNBQVFpcUQsVUFBVTtBQUM1QyxRQUFNQyxpQkFBaUJseEIsTUFBTS8rQjtBQUM3QixRQUFNa3dELGtCQUFrQkosT0FBTzl2RDtBQUMvQixRQUFNbXdELG9CQUFvQk4sS0FBSzd2RDtBQUUvQixRQUFNeXZCLFVBQVVPLFVBQVVqcUIsU0FBUTBwQixPQUFPO0FBQ3pDLE1BQUluVSxTQUFTbVUsUUFBUW5VO0FBQ3JCLE1BQUlDLFFBQVE7QUFHWixNQUFJNjBDLHFCQUFxQlAsS0FBS3p1RCxPQUFPLENBQUNpUSxPQUFPZy9DLGFBQWFoL0MsUUFBUWcvQyxTQUFTQyxPQUFPdHdELFNBQVNxd0QsU0FBUzcyQixNQUFNeDVCLFNBQVNxd0QsU0FBU0UsTUFBTXZ3RCxRQUFRLENBQUE7QUFDMUlvd0Qsd0JBQXNCUixRQUFRWSxXQUFXeHdELFNBQVM0dkQsUUFBUWEsVUFBVXp3RDtBQUVwRSxNQUFJaXdELGdCQUFnQjtBQUNsQjMwQyxjQUFVMjBDLGlCQUFpQmhELFVBQVV4ekIsY0FDbkN3MkIsaUJBQWlCLEtBQUtscUQsU0FBUTJxRCxlQUMvQjNxRCxTQUFRNHFEOztBQUVYLE1BQUlQLG9CQUFvQjtBQUV0QixVQUFNUSxpQkFBaUI3cUQsU0FBUThxRCxnQkFBZ0IxeEQsS0FBS29DLElBQUk4bkQsV0FBVzBHLFNBQVN0MkIsVUFBVSxJQUFJczJCLFNBQVN0MkI7QUFDbkduZSxjQUFVNjBDLG9CQUFvQlMsa0JBQzVCUixxQkFBcUJELHFCQUFxQkosU0FBU3QyQixjQUNuRDIyQixxQkFBcUIsS0FBS3JxRCxTQUFRK3FEOztBQUV0QyxNQUFJWixpQkFBaUI7QUFDbkI1MEMsY0FBVXZWLFNBQVFnckQsa0JBQ2pCYixrQkFBa0JGLFdBQVd2MkIsY0FDNUJ5MkIsa0JBQWtCLEtBQUtucUQsU0FBUWlyRDs7QUFJbkMsTUFBSUMsZUFBZTtBQUNuQixRQUFNQyxlQUFlLFNBQVMxc0MsTUFBTTtBQUNsQ2pKLFlBQVFwYyxLQUFLb0MsSUFBSWdhLE9BQU9qTyxJQUFJczlDLFlBQVlwbUMsSUFBTWpKLEVBQUFBLFFBQVEwMUMsWUFBQUE7RUFDeEQ7QUFFQTNqRCxNQUFJczNCLEtBQUk7QUFFUnQzQixNQUFJZ3NCLE9BQU8yekIsVUFBVXRzQjtBQUNyQnhRLE9BQUt5L0IsUUFBUTd3QixPQUFPbXlCLFlBQUFBO0FBR3BCNWpELE1BQUlnc0IsT0FBT3kyQixTQUFTcHZCO0FBQ3BCeFEsT0FBS3kvQixRQUFRWSxXQUFXcjVDLE9BQU95NEMsUUFBUWEsU0FBUyxHQUFHUyxZQUFBQTtBQUduREQsaUJBQWVsckQsU0FBUThxRCxnQkFBaUJ2SCxXQUFXLElBQUl2akQsU0FBUStuQixhQUFjO0FBQzdFcUMsT0FBSzAvQixNQUFNLENBQUNRLGFBQWE7QUFDdkJsZ0MsU0FBS2tnQyxTQUFTQyxRQUFRWSxZQUFBQTtBQUN0Qi9nQyxTQUFLa2dDLFNBQVM3MkIsT0FBTzAzQixZQUFBQTtBQUNyQi9nQyxTQUFLa2dDLFNBQVNFLE9BQU9XLFlBQUFBO0VBQ3ZCLENBQUE7QUFHQUQsaUJBQWU7QUFHZjNqRCxNQUFJZ3NCLE9BQU8wMkIsV0FBV3J2QjtBQUN0QnhRLE9BQUt5L0IsUUFBUUUsUUFBUW9CLFlBQUFBO0FBRXJCNWpELE1BQUl3M0IsUUFBTztBQUdYdnBCLFdBQVNrVSxRQUFRbFU7QUFFakIsU0FBTztJQUFDQTtJQUFPRDtFQUFNO0FBQ3ZCO0FBRUEsU0FBUzYxQyxnQkFBZ0I1eUQsT0FBT21JLE1BQU07QUFDcEMsUUFBTSxFQUFDZSxHQUFHNlQsT0FBQUEsSUFBVTVVO0FBRXBCLE1BQUllLElBQUk2VCxTQUFTLEdBQUc7QUFDbEIsV0FBTztFQUNULFdBQVc3VCxJQUFLbEosTUFBTStjLFNBQVNBLFNBQVMsR0FBSTtBQUMxQyxXQUFPOztBQUVULFNBQU87QUFDVDtBQUVBLFNBQVM4MUMsb0JBQW9CQyxRQUFROXlELE9BQU93SCxVQUFTVyxNQUFNO0FBQ3pELFFBQU0sRUFBQ2MsR0FBRytULE1BQUFBLElBQVM3VTtBQUNuQixRQUFNNHFELFNBQVF2ckQsU0FBUXdyRCxZQUFZeHJELFNBQVF5ckQ7QUFDMUMsTUFBSUgsV0FBVyxVQUFVN3BELElBQUkrVCxRQUFRKzFDLFNBQVEveUQsTUFBTWdkLE9BQU87QUFDeEQsV0FBTzs7QUFHVCxNQUFJODFDLFdBQVcsV0FBVzdwRCxJQUFJK1QsUUFBUSsxQyxTQUFRLEdBQUc7QUFDL0MsV0FBTzs7QUFFWDtBQUVBLFNBQVNHLGdCQUFnQmx6RCxPQUFPd0gsVUFBU1csTUFBTWdyRCxRQUFRO0FBQ3JELFFBQU0sRUFBQ2xxRCxHQUFHK1QsTUFBQUEsSUFBUzdVO0FBQ25CLFFBQU0sRUFBQzZVLE9BQU9vMkMsWUFBWXArQyxXQUFXLEVBQUMxTCxNQUFNRixNQUFLLEVBQUMsSUFBSXBKO0FBQ3RELE1BQUk4eUQsU0FBUztBQUViLE1BQUlLLFdBQVcsVUFBVTtBQUN2QkwsYUFBUzdwRCxNQUFNSyxPQUFPRixTQUFTLElBQUksU0FBUzthQUNuQ0gsS0FBSytULFFBQVEsR0FBRztBQUN6QjgxQyxhQUFTO0VBQ1gsV0FBVzdwRCxLQUFLbXFELGFBQWFwMkMsUUFBUSxHQUFHO0FBQ3RDODFDLGFBQVM7O0FBR1gsTUFBSUQsb0JBQW9CQyxRQUFROXlELE9BQU93SCxVQUFTVyxJQUFPLEdBQUE7QUFDckQycUQsYUFBUzs7QUFHWCxTQUFPQTtBQUNUO0FBS0EsU0FBU08sbUJBQW1CcnpELE9BQU93SCxVQUFTVyxNQUFNO0FBQ2hELFFBQU1nckQsU0FBU2hyRCxLQUFLZ3JELFVBQVUzckQsU0FBUTJyRCxVQUFVUCxnQkFBZ0I1eUQsT0FBT21JLElBQUFBO0FBRXZFLFNBQU87SUFDTDJxRCxRQUFRM3FELEtBQUsycUQsVUFBVXRyRCxTQUFRc3JELFVBQVVJLGdCQUFnQmx6RCxPQUFPd0gsVUFBU1csTUFBTWdyRCxNQUFBQTtJQUMvRUE7RUFDRjtBQUNGO0FBRUEsU0FBU0csT0FBT25yRCxNQUFNMnFELFFBQVE7QUFDNUIsTUFBSSxFQUFDN3BELEdBQUcrVCxNQUFBQSxJQUFTN1U7QUFDakIsTUFBSTJxRCxXQUFXLFNBQVM7QUFDdEI3cEQsU0FBSytUO2FBQ0k4MUMsV0FBVyxVQUFVO0FBQzlCN3BELFNBQU0rVCxRQUFROztBQUVoQixTQUFPL1Q7QUFDVDtBQUVBLFNBQVNzcUQsT0FBT3ByRCxNQUFNZ3JELFFBQVFLLGdCQUFnQjtBQUU1QyxNQUFJLEVBQUN0cUQsR0FBRzZULE9BQUFBLElBQVU1VTtBQUNsQixNQUFJZ3JELFdBQVcsT0FBTztBQUNwQmpxRCxTQUFLc3FEO2FBQ0lMLFdBQVcsVUFBVTtBQUM5QmpxRCxTQUFLNlQsU0FBU3kyQztTQUNUO0FBQ0x0cUQsU0FBTTZULFNBQVM7O0FBRWpCLFNBQU83VDtBQUNUO0FBS0EsU0FBU3VxRCxtQkFBbUJqc0QsVUFBU1csTUFBTXVyRCxXQUFXMXpELE9BQU87QUFDM0QsUUFBTSxFQUFDZ3pELFdBQVdDLGNBQWNVLGFBQUFBLElBQWdCbnNEO0FBQ2hELFFBQU0sRUFBQ3NyRCxRQUFRSyxPQUFBQSxJQUFVTztBQUN6QixRQUFNRixpQkFBaUJSLFlBQVlDO0FBQ25DLFFBQU0sRUFBQ3BSLFNBQVNDLFVBQVVDLFlBQVlDLFlBQUFBLElBQWVOLGNBQWNpUyxZQUFBQTtBQUVuRSxNQUFJMXFELElBQUlxcUQsT0FBT25yRCxNQUFNMnFELE1BQUFBO0FBQ3JCLFFBQU01cEQsSUFBSXFxRCxPQUFPcHJELE1BQU1nckQsUUFBUUssY0FBQUE7QUFFL0IsTUFBSUwsV0FBVyxVQUFVO0FBQ3ZCLFFBQUlMLFdBQVcsUUFBUTtBQUNyQjdwRCxXQUFLdXFEO2VBQ0lWLFdBQVcsU0FBUztBQUM3QjdwRCxXQUFLdXFEOzthQUVFVixXQUFXLFFBQVE7QUFDNUI3cEQsU0FBS3JJLEtBQUtvQyxJQUFJNitDLFNBQVNFLFVBQWNpUixJQUFBQTthQUM1QkYsV0FBVyxTQUFTO0FBQzdCN3BELFNBQUtySSxLQUFLb0MsSUFBSTgrQyxVQUFVRSxXQUFlZ1IsSUFBQUE7O0FBR3pDLFNBQU87SUFDTC9wRCxHQUFHczNCLFlBQVl0M0IsR0FBRyxHQUFHakosTUFBTWdkLFFBQVE3VSxLQUFLNlUsS0FBSztJQUM3QzlULEdBQUdxM0IsWUFBWXIzQixHQUFHLEdBQUdsSixNQUFNK2MsU0FBUzVVLEtBQUs0VSxNQUFNO0VBQ2pEO0FBQ0Y7QUFFQSxTQUFTNjJDLFlBQVl2QyxTQUFTMTNCLE9BQU9ueUIsVUFBUztBQUM1QyxRQUFNMHBCLFVBQVVPLFVBQVVqcUIsU0FBUTBwQixPQUFPO0FBRXpDLFNBQU95SSxVQUFVLFdBQ2IwM0IsUUFBUXBvRCxJQUFJb29ELFFBQVFyMEMsUUFBUSxJQUM1QjJjLFVBQVUsVUFDUjAzQixRQUFRcG9ELElBQUlvb0QsUUFBUXIwQyxRQUFRa1UsUUFBUTluQixRQUNwQ2lvRCxRQUFRcG9ELElBQUlpb0IsUUFBUTVuQjtBQUM1QjtBQUtBLFNBQVN1cUQsd0JBQXdCcDBCLFdBQVU7QUFDekMsU0FBT214QixhQUFhLENBQUEsR0FBSUcsY0FBY3R4QixTQUFBQSxDQUFBQTtBQUN4QztBQUVBLFNBQVNxMEIscUJBQXFCbG1ELFFBQVF5akQsU0FBUzBDLGNBQWM7QUFDM0QsU0FBT2xtRCxjQUFjRCxRQUFRO0lBQzNCeWpEO0lBQ0EwQztJQUNBNXpELE1BQU07RUFDUixDQUFBO0FBQ0Y7QUFFQSxTQUFTNnpELGtCQUFrQjV6RCxXQUFXaVYsU0FBUztBQUM3QyxRQUFNZ1UsV0FBV2hVLFdBQVdBLFFBQVF2SCxXQUFXdUgsUUFBUXZILFFBQVF1akQsV0FBV2g4QyxRQUFRdkgsUUFBUXVqRCxRQUFRanhEO0FBQ2xHLFNBQU9pcEIsV0FBV2pwQixVQUFVaXBCLFNBQVNBLFFBQUFBLElBQVlqcEI7QUFDbkQ7QUFFQSxJQUFNNnpELG1CQUFtQjtFQUV2QkMsYUFBYUM7RUFDYjN6QixNQUFNdXpCLGNBQWM7QUFDbEIsUUFBSUEsYUFBYXR5RCxTQUFTLEdBQUc7QUFDM0IsWUFBTUcsT0FBT215RCxhQUFhLENBQUU7QUFDNUIsWUFBTXpnRCxTQUFTMVIsS0FBSzVCLE1BQU04SyxLQUFLd0k7QUFDL0IsWUFBTThnRCxhQUFhOWdELFNBQVNBLE9BQU83UixTQUFTO0FBRTVDLFVBQUksUUFBUSxLQUFLK0YsV0FBVyxLQUFLQSxRQUFRK0MsU0FBUyxXQUFXO0FBQzNELGVBQU8zSSxLQUFLa00sUUFBUTRHLFNBQVM7aUJBQ3BCOVMsS0FBSzhTLE9BQU87QUFDckIsZUFBTzlTLEtBQUs4UztNQUNkLFdBQVcwL0MsYUFBYSxLQUFLeHlELEtBQUtxTSxZQUFZbW1ELFlBQVk7QUFDeEQsZUFBTzlnRCxPQUFPMVIsS0FBS3FNLFNBQVM7OztBQUloQyxXQUFPO0VBQ1Q7RUFDQW9tRCxZQUFZRjtFQUdabEMsWUFBWWtDO0VBR1pHLGFBQWFIO0VBQ2J6L0MsTUFBTTYvQyxhQUFhO0FBQ2pCLFFBQUksUUFBUSxLQUFLL3NELFdBQVcsS0FBS0EsUUFBUStDLFNBQVMsV0FBVztBQUMzRCxhQUFPZ3FELFlBQVk3L0MsUUFBUSxPQUFPNi9DLFlBQVlwRCxrQkFBa0JvRCxZQUFZcEQ7O0FBRzlFLFFBQUl6OEMsUUFBUTYvQyxZQUFZem1ELFFBQVE0RyxTQUFTO0FBRXpDLFFBQUlBLE9BQU87QUFDVEEsZUFBUzs7QUFFWCxVQUFNeE0sUUFBUXFzRCxZQUFZcEQ7QUFDMUIsUUFBSSxDQUFDcjNDLGNBQWM1UixLQUFRLEdBQUE7QUFDekJ3TSxlQUFTeE07O0FBRVgsV0FBT3dNO0VBQ1Q7RUFDQTgvQyxXQUFXRCxhQUFhO0FBQ3RCLFVBQU14cEQsT0FBT3dwRCxZQUFZdjBELE1BQU13UixlQUFlK2lELFlBQVkvcEQsWUFBWTtBQUN0RSxVQUFNaEQsV0FBVXVELEtBQUs2QixXQUFXc0ksU0FBU3EvQyxZQUFZdG1ELFNBQVM7QUFDOUQsV0FBTztNQUNMd1gsYUFBYWplLFNBQVFpZTtNQUNyQkYsaUJBQWlCL2QsU0FBUStkO01BQ3pCbEIsYUFBYTdjLFNBQVE2YztNQUNyQmlnQixZQUFZOThCLFNBQVE4OEI7TUFDcEJFLGtCQUFrQmg5QixTQUFRZzlCO01BQzFCdVYsY0FBYztJQUNoQjtFQUNGO0VBQ0EwYSxpQkFBaUI7QUFDZixXQUFPLEtBQUtqdEQsUUFBUWt0RDtFQUN0QjtFQUNBQyxnQkFBZ0JKLGFBQWE7QUFDM0IsVUFBTXhwRCxPQUFPd3BELFlBQVl2MEQsTUFBTXdSLGVBQWUraUQsWUFBWS9wRCxZQUFZO0FBQ3RFLFVBQU1oRCxXQUFVdUQsS0FBSzZCLFdBQVdzSSxTQUFTcS9DLFlBQVl0bUQsU0FBUztBQUM5RCxXQUFPO01BQ0xpWCxZQUFZMWQsU0FBUTBkO01BQ3BCN0UsVUFBVTdZLFNBQVE2WTtJQUNwQjtFQUNGO0VBQ0F1MEMsWUFBWVQ7RUFHWmpDLFdBQVdpQztFQUdYVSxjQUFjVjtFQUNkNUMsUUFBUTRDO0VBQ1JXLGFBQWFYO0FBQ2Y7QUFXQSxTQUFTWSwyQkFBMkIzMEQsV0FBVzhkLE1BQU1uUCxLQUFLNDdCLEtBQUs7QUFDN0QsUUFBTXJnQixTQUFTbHFCLFVBQVU4ZCxJQUFBQSxFQUFNamQsS0FBSzhOLEtBQUs0N0IsR0FBQUE7QUFFekMsTUFBSSxPQUFPcmdCLFdBQVcsYUFBYTtBQUNqQyxXQUFPMnBDLGlCQUFpQi8xQyxJQUFBQSxFQUFNamQsS0FBSzhOLEtBQUs0N0IsR0FBQUE7O0FBRzFDLFNBQU9yZ0I7QUFDVDtBQUVPLElBQU0wcUMsVUFBTixjQUFzQjE5QixRQUFBQTtFQU8zQjkzQixZQUFZNkcsUUFBUTtBQUNsQixVQUFLO0FBRUwsU0FBSzR1RCxVQUFVO0FBQ2YsU0FBS3B6RCxVQUFVLENBQUE7QUFDZixTQUFLcXpELGlCQUFpQnAxRDtBQUN0QixTQUFLcTFELFFBQVFyMUQ7QUFDYixTQUFLczFELG9CQUFvQnQxRDtBQUN6QixTQUFLdTFELGdCQUFnQixDQUFBO0FBQ3JCLFNBQUt2dEQsY0FBY2hJO0FBQ25CLFNBQUs2UCxXQUFXN1A7QUFDaEIsU0FBS0UsUUFBUXFHLE9BQU9yRztBQUNwQixTQUFLd0gsVUFBVW5CLE9BQU9tQjtBQUN0QixTQUFLOHRELGFBQWF4MUQ7QUFDbEIsU0FBSzBnQyxRQUFRMWdDO0FBQ2IsU0FBS215RCxhQUFhbnlEO0FBQ2xCLFNBQUt3eEQsT0FBT3h4RDtBQUNaLFNBQUtveUQsWUFBWXB5RDtBQUNqQixTQUFLeXhELFNBQVN6eEQ7QUFDZCxTQUFLZ3pELFNBQVNoekQ7QUFDZCxTQUFLcXpELFNBQVNyekQ7QUFDZCxTQUFLbUosSUFBSW5KO0FBQ1QsU0FBS29KLElBQUlwSjtBQUNULFNBQUtpZCxTQUFTamQ7QUFDZCxTQUFLa2QsUUFBUWxkO0FBQ2IsU0FBS3kxRCxTQUFTejFEO0FBQ2QsU0FBSzAxRCxTQUFTMTFEO0FBR2QsU0FBSzIxRCxjQUFjMzFEO0FBQ25CLFNBQUs0MUQsbUJBQW1CNTFEO0FBQ3hCLFNBQUs2MUQsa0JBQWtCNzFEO0VBQ3pCO0VBRUFpUSxXQUFXdkksVUFBUztBQUNsQixTQUFLQSxVQUFVQTtBQUNmLFNBQUs0dEQsb0JBQW9CdDFEO0FBQ3pCLFNBQUs2UCxXQUFXN1A7RUFDbEI7RUFLQW1XLHFCQUFxQjtBQUNuQixVQUFNMUgsU0FBUyxLQUFLNm1EO0FBRXBCLFFBQUk3bUQsUUFBUTtBQUNWLGFBQU9BOztBQUdULFVBQU12TyxRQUFRLEtBQUtBO0FBQ25CLFVBQU13SCxXQUFVLEtBQUtBLFFBQVF1MUIsV0FBVyxLQUFLcHFCLFdBQVUsQ0FBQTtBQUN2RCxVQUFNaEssT0FBT25CLFNBQVE0d0IsV0FBV3A0QixNQUFNd0gsUUFBUVYsYUFBYVUsU0FBUUU7QUFDbkUsVUFBTUEsYUFBYSxJQUFJdEIsV0FBVyxLQUFLcEcsT0FBTzJJLElBQUFBO0FBQzlDLFFBQUlBLEtBQUt5TixZQUFZO0FBQ25CLFdBQUtnL0Msb0JBQW9CenVELE9BQU9xUCxPQUFPdE8sVUFBQUE7O0FBR3pDLFdBQU9BO0VBQ1Q7RUFLQWlMLGFBQWE7QUFDWCxXQUFPLEtBQUtoRCxhQUNaLEtBQUtBLFdBQVdta0QscUJBQXFCLEtBQUs5ekQsTUFBTTJTLFdBQVUsR0FBSSxNQUFNLEtBQUswaUQsYUFBYTtFQUN4RjtFQUVBTyxTQUFTdmdELFNBQVM3TixVQUFTO0FBQ3pCLFVBQU0sRUFBQ3BILFVBQVMsSUFBSW9IO0FBRXBCLFVBQU0wc0QsY0FBY2EsMkJBQTJCMzBELFdBQVcsZUFBZSxNQUFNaVYsT0FBQUE7QUFDL0UsVUFBTW1yQixRQUFRdTBCLDJCQUEyQjMwRCxXQUFXLFNBQVMsTUFBTWlWLE9BQUFBO0FBQ25FLFVBQU1nL0MsYUFBYVUsMkJBQTJCMzBELFdBQVcsY0FBYyxNQUFNaVYsT0FBQUE7QUFFN0UsUUFBSTRsQixRQUFRLENBQUE7QUFDWkEsWUFBUTIxQixhQUFhMzFCLE9BQU84MUIsY0FBY21ELFdBQUFBLENBQUFBO0FBQzFDajVCLFlBQVEyMUIsYUFBYTMxQixPQUFPODFCLGNBQWN2d0IsS0FBQUEsQ0FBQUE7QUFDMUN2RixZQUFRMjFCLGFBQWEzMUIsT0FBTzgxQixjQUFjc0QsVUFBQUEsQ0FBQUE7QUFFMUMsV0FBT3A1QjtFQUNUO0VBRUE0NkIsY0FBYzlCLGNBQWN2c0QsVUFBUztBQUNuQyxXQUFPcXNELHdCQUNMa0IsMkJBQTJCdnRELFNBQVFwSCxXQUFXLGNBQWMsTUFBTTJ6RCxZQUFBQSxDQUFBQTtFQUV0RTtFQUVBK0IsUUFBUS9CLGNBQWN2c0QsVUFBUztBQUM3QixVQUFNLEVBQUNwSCxVQUFTLElBQUlvSDtBQUNwQixVQUFNdXVELFlBQVksQ0FBQTtBQUVsQm5rQyxTQUFLbWlDLGNBQWMsQ0FBQzErQyxZQUFZO0FBQzlCLFlBQU15OEMsV0FBVztRQUNmQyxRQUFRLENBQUE7UUFDUjkyQixPQUFPLENBQUE7UUFDUCsyQixPQUFPLENBQUE7TUFDVDtBQUNBLFlBQU1nRSxTQUFTaEMsa0JBQWtCNXpELFdBQVdpVixPQUFBQTtBQUM1Q3U3QyxtQkFBYWtCLFNBQVNDLFFBQVFoQixjQUFjZ0UsMkJBQTJCaUIsUUFBUSxlQUFlLE1BQU0zZ0QsT0FBQUEsQ0FBQUEsQ0FBQUE7QUFDcEd1N0MsbUJBQWFrQixTQUFTNzJCLE9BQU84NUIsMkJBQTJCaUIsUUFBUSxTQUFTLE1BQU0zZ0QsT0FBQUEsQ0FBQUE7QUFDL0V1N0MsbUJBQWFrQixTQUFTRSxPQUFPakIsY0FBY2dFLDJCQUEyQmlCLFFBQVEsY0FBYyxNQUFNM2dELE9BQUFBLENBQUFBLENBQUFBO0FBRWxHMGdELGdCQUFVcnpELEtBQUtvdkQsUUFBQUE7SUFDakIsQ0FBQTtBQUVBLFdBQU9pRTtFQUNUO0VBRUFFLGFBQWFsQyxjQUFjdnNELFVBQVM7QUFDbEMsV0FBT3FzRCx3QkFDTGtCLDJCQUEyQnZ0RCxTQUFRcEgsV0FBVyxhQUFhLE1BQU0yekQsWUFBQUEsQ0FBQUE7RUFFckU7RUFHQW1DLFVBQVVuQyxjQUFjdnNELFVBQVM7QUFDL0IsVUFBTSxFQUFDcEgsVUFBUyxJQUFJb0g7QUFFcEIsVUFBTXF0RCxlQUFlRSwyQkFBMkIzMEQsV0FBVyxnQkFBZ0IsTUFBTTJ6RCxZQUFBQTtBQUNqRixVQUFNeEMsU0FBU3dELDJCQUEyQjMwRCxXQUFXLFVBQVUsTUFBTTJ6RCxZQUFBQTtBQUNyRSxVQUFNZSxjQUFjQywyQkFBMkIzMEQsV0FBVyxlQUFlLE1BQU0yekQsWUFBQUE7QUFFL0UsUUFBSTk0QixRQUFRLENBQUE7QUFDWkEsWUFBUTIxQixhQUFhMzFCLE9BQU84MUIsY0FBYzhELFlBQUFBLENBQUFBO0FBQzFDNTVCLFlBQVEyMUIsYUFBYTMxQixPQUFPODFCLGNBQWNRLE1BQUFBLENBQUFBO0FBQzFDdDJCLFlBQVEyMUIsYUFBYTMxQixPQUFPODFCLGNBQWMrRCxXQUFBQSxDQUFBQTtBQUUxQyxXQUFPNzVCO0VBQ1Q7RUFLQWs3QixhQUFhM3VELFVBQVM7QUFDcEIsVUFBTS9CLFNBQVMsS0FBSzVEO0FBQ3BCLFVBQU1pSixPQUFPLEtBQUs5SyxNQUFNOEs7QUFDeEIsVUFBTTJxRCxjQUFjLENBQUE7QUFDcEIsVUFBTUMsbUJBQW1CLENBQUE7QUFDekIsVUFBTUMsa0JBQWtCLENBQUE7QUFDeEIsUUFBSTVCLGVBQWUsQ0FBQTtBQUNuQixRQUFJcnlELEdBQUcrM0I7QUFFUCxTQUFLLzNCLElBQUksR0FBRyszQixNQUFNaDBCLE9BQU9oRSxRQUFRQyxJQUFJKzNCLEtBQUssRUFBRS8zQixHQUFHO0FBQzdDcXlELG1CQUFhcnhELEtBQUt3dUQsa0JBQWtCLEtBQUtseEQsT0FBT3lGLE9BQU8vRCxDQUFFLENBQUEsQ0FBQTtJQUMzRDtBQUdBLFFBQUk4RixTQUFRaUcsUUFBUTtBQUNsQnNtRCxxQkFBZUEsYUFBYXRtRCxPQUFPLENBQUNPLFNBQVM5RCxRQUFPb2pCLFVBQVU5bEIsU0FBUWlHLE9BQU9PLFNBQVM5RCxRQUFPb2pCLE9BQU94aUIsSUFBQUEsQ0FBQUE7O0FBSXRHLFFBQUl0RCxTQUFRNHVELFVBQVU7QUFDcEJyQyxxQkFBZUEsYUFBYWo3QyxLQUFLLENBQUNDLEdBQUdyUCxNQUFNbEMsU0FBUTR1RCxTQUFTcjlDLEdBQUdyUCxHQUFHb0IsSUFBQUEsQ0FBQUE7O0FBSXBFOG1CLFNBQUttaUMsY0FBYyxDQUFDMStDLFlBQVk7QUFDOUIsWUFBTTJnRCxTQUFTaEMsa0JBQWtCeHNELFNBQVFwSCxXQUFXaVYsT0FBQUE7QUFDcERvZ0Qsa0JBQVkveUQsS0FBS3F5RCwyQkFBMkJpQixRQUFRLGNBQWMsTUFBTTNnRCxPQUFBQSxDQUFBQTtBQUN4RXFnRCx1QkFBaUJoekQsS0FBS3F5RCwyQkFBMkJpQixRQUFRLG1CQUFtQixNQUFNM2dELE9BQUFBLENBQUFBO0FBQ2xGc2dELHNCQUFnQmp6RCxLQUFLcXlELDJCQUEyQmlCLFFBQVEsa0JBQWtCLE1BQU0zZ0QsT0FBQUEsQ0FBQUE7SUFDbEYsQ0FBQTtBQUVBLFNBQUtvZ0QsY0FBY0E7QUFDbkIsU0FBS0MsbUJBQW1CQTtBQUN4QixTQUFLQyxrQkFBa0JBO0FBQ3ZCLFNBQUtMLGFBQWF2QjtBQUNsQixXQUFPQTtFQUNUO0VBRUFydUQsT0FBT29yQixTQUFTc25CLFFBQVE7QUFDdEIsVUFBTTV3QyxXQUFVLEtBQUtBLFFBQVF1MUIsV0FBVyxLQUFLcHFCLFdBQVUsQ0FBQTtBQUN2RCxVQUFNbE4sU0FBUyxLQUFLNUQ7QUFDcEIsUUFBSXVGO0FBQ0osUUFBSTJzRCxlQUFlLENBQUE7QUFFbkIsUUFBSSxDQUFDdHVELE9BQU9oRSxRQUFRO0FBQ2xCLFVBQUksS0FBS3d6RCxZQUFZLEdBQUc7QUFDdEI3dEQscUJBQWE7VUFDWDZ0RCxTQUFTO1FBQ1g7O1dBRUc7QUFDTCxZQUFNanFDLFdBQVdvbEMsWUFBWTVvRCxTQUFRd2pCLFFBQVEsRUFBRS9wQixLQUFLLE1BQU13RSxRQUFRLEtBQUt5dkQsY0FBYztBQUNyRm5CLHFCQUFlLEtBQUtvQyxhQUFhM3VELFFBQUFBO0FBRWpDLFdBQUtnNUIsUUFBUSxLQUFLbzFCLFNBQVM3QixjQUFjdnNELFFBQUFBO0FBQ3pDLFdBQUt5cUQsYUFBYSxLQUFLNEQsY0FBYzlCLGNBQWN2c0QsUUFBQUE7QUFDbkQsV0FBSzhwRCxPQUFPLEtBQUt3RSxRQUFRL0IsY0FBY3ZzRCxRQUFBQTtBQUN2QyxXQUFLMHFELFlBQVksS0FBSytELGFBQWFsQyxjQUFjdnNELFFBQUFBO0FBQ2pELFdBQUsrcEQsU0FBUyxLQUFLMkUsVUFBVW5DLGNBQWN2c0QsUUFBQUE7QUFFM0MsWUFBTVcsT0FBTyxLQUFLZ3RELFFBQVEvRCxlQUFlLE1BQU01cEQsUUFBQUE7QUFDL0MsWUFBTTZ1RCxrQkFBa0IxdkQsT0FBT3lCLE9BQU8sQ0FBQSxHQUFJNGlCLFVBQVU3aUIsSUFBQUE7QUFDcEQsWUFBTXVyRCxZQUFZTCxtQkFBbUIsS0FBS3J6RCxPQUFPd0gsVUFBUzZ1RCxlQUFBQTtBQUMxRCxZQUFNQyxrQkFBa0I3QyxtQkFBbUJqc0QsVUFBUzZ1RCxpQkFBaUIzQyxXQUFXLEtBQUsxekQsS0FBSztBQUUxRixXQUFLOHlELFNBQVNZLFVBQVVaO0FBQ3hCLFdBQUtLLFNBQVNPLFVBQVVQO0FBRXhCL3JELG1CQUFhO1FBQ1g2dEQsU0FBUztRQUNUaHNELEdBQUdxdEQsZ0JBQWdCcnREO1FBQ25CQyxHQUFHb3RELGdCQUFnQnB0RDtRQUNuQjhULE9BQU83VSxLQUFLNlU7UUFDWkQsUUFBUTVVLEtBQUs0VTtRQUNidzRDLFFBQVF2cUMsU0FBUy9oQjtRQUNqQnVzRCxRQUFReHFDLFNBQVM5aEI7TUFDbkI7O0FBR0YsU0FBS21zRCxnQkFBZ0J0QjtBQUNyQixTQUFLcGtELFdBQVc3UDtBQUVoQixRQUFJc0gsWUFBWTtBQUNkLFdBQUs2TyxtQkFBa0IsRUFBR3ZRLE9BQU8sTUFBTTBCLFVBQUFBOztBQUd6QyxRQUFJMHBCLFdBQVd0cEIsU0FBUSt1RCxVQUFVO0FBQy9CL3VELE1BQUFBLFNBQVErdUQsU0FBU3QxRCxLQUFLLE1BQU07UUFBQ2pCLE9BQU8sS0FBS0E7UUFBT3F4RCxTQUFTO1FBQU1qWjtNQUFNLENBQUE7O0VBRXpFO0VBRUFvZSxVQUFVQyxjQUFjMW5ELEtBQUs1RyxNQUFNWCxVQUFTO0FBQzFDLFVBQU1rdkQsZ0JBQWdCLEtBQUtDLGlCQUFpQkYsY0FBY3R1RCxNQUFNWCxRQUFBQTtBQUVoRXVILFFBQUlpNEIsT0FBTzB2QixjQUFjN3lCLElBQUk2eUIsY0FBYzV5QixFQUFFO0FBQzdDLzBCLFFBQUlpNEIsT0FBTzB2QixjQUFjM3lCLElBQUkyeUIsY0FBYzF5QixFQUFFO0FBQzdDajFCLFFBQUlpNEIsT0FBTzB2QixjQUFjRSxJQUFJRixjQUFjRyxFQUFFO0VBQy9DO0VBRUFGLGlCQUFpQkYsY0FBY3R1RCxNQUFNWCxVQUFTO0FBQzVDLFVBQU0sRUFBQ3NyRCxRQUFRSyxPQUFNLElBQUk7QUFDekIsVUFBTSxFQUFDSCxXQUFXVyxhQUFBQSxJQUFnQm5zRDtBQUNsQyxVQUFNLEVBQUNxNkMsU0FBU0MsVUFBVUMsWUFBWUMsWUFBQUEsSUFBZU4sY0FBY2lTLFlBQUFBO0FBQ25FLFVBQU0sRUFBQzFxRCxHQUFHNnRELEtBQUs1dEQsR0FBRzZ0RCxJQUFBQSxJQUFPTjtBQUN6QixVQUFNLEVBQUN6NUMsT0FBT0QsT0FBQUEsSUFBVTVVO0FBQ3hCLFFBQUkwN0IsSUFBSUUsSUFBSTZ5QixJQUFJOXlCLElBQUlFLElBQUk2eUI7QUFFeEIsUUFBSTFELFdBQVcsVUFBVTtBQUN2Qm52QixXQUFLK3lCLE1BQU9oNkMsU0FBUztBQUVyQixVQUFJKzFDLFdBQVcsUUFBUTtBQUNyQmp2QixhQUFLaXpCO0FBQ0wveUIsYUFBS0YsS0FBS212QjtBQUdWbHZCLGFBQUtFLEtBQUtndkI7QUFDVjZELGFBQUs3eUIsS0FBS2d2QjthQUNMO0FBQ0xudkIsYUFBS2l6QixNQUFNOTVDO0FBQ1grbUIsYUFBS0YsS0FBS212QjtBQUdWbHZCLGFBQUtFLEtBQUtndkI7QUFDVjZELGFBQUs3eUIsS0FBS2d2Qjs7QUFHWjRELFdBQUsveUI7V0FDQTtBQUNMLFVBQUlpdkIsV0FBVyxRQUFRO0FBQ3JCL3VCLGFBQUsreUIsTUFBTWwyRCxLQUFLb0MsSUFBSTYrQyxTQUFTRSxVQUFlaVIsSUFBQUE7aUJBQ25DRixXQUFXLFNBQVM7QUFDN0IvdUIsYUFBSyt5QixNQUFNOTVDLFFBQVFwYyxLQUFLb0MsSUFBSTgrQyxVQUFVRSxXQUFlZ1IsSUFBQUE7YUFDaEQ7QUFDTGp2QixhQUFLLEtBQUt3eEI7O0FBR1osVUFBSXBDLFdBQVcsT0FBTztBQUNwQnJ2QixhQUFLaXpCO0FBQ0wveUIsYUFBS0YsS0FBS2t2QjtBQUdWbnZCLGFBQUtFLEtBQUtpdkI7QUFDVjRELGFBQUs3eUIsS0FBS2l2QjthQUNMO0FBQ0xsdkIsYUFBS2l6QixNQUFNaDZDO0FBQ1hpbkIsYUFBS0YsS0FBS2t2QjtBQUdWbnZCLGFBQUtFLEtBQUtpdkI7QUFDVjRELGFBQUs3eUIsS0FBS2l2Qjs7QUFFWjZELFdBQUsveUI7O0FBRVAsV0FBTztNQUFDRDtNQUFJRTtNQUFJNnlCO01BQUk5eUI7TUFBSUU7TUFBSTZ5QjtJQUFFO0VBQ2hDO0VBRUFudkIsVUFBVXN2QixJQUFJam9ELEtBQUt2SCxVQUFTO0FBQzFCLFVBQU1nNUIsUUFBUSxLQUFLQTtBQUNuQixVQUFNLytCLFNBQVMrK0IsTUFBTS8rQjtBQUNyQixRQUFJaXRELFdBQVd5RCxjQUFjendEO0FBRTdCLFFBQUlELFFBQVE7QUFDVixZQUFNc3JELFlBQVlDLGNBQWN4bEQsU0FBUXNsRCxLQUFLLEtBQUs3akQsR0FBRyxLQUFLK1QsS0FBSztBQUUvRGc2QyxTQUFHL3RELElBQUkycUQsWUFBWSxNQUFNcHNELFNBQVE2ekIsWUFBWTd6QixRQUFBQTtBQUU3Q3VILFVBQUlpMkIsWUFBWStuQixVQUFVL25CLFVBQVV4OUIsU0FBUTZ6QixVQUFVO0FBQ3REdHNCLFVBQUlvMkIsZUFBZTtBQUVuQnVwQixrQkFBWTF6QixPQUFPeHpCLFNBQVFrbkQsU0FBUztBQUNwQ3lELHFCQUFlM3FELFNBQVEycUQ7QUFFdkJwakQsVUFBSXVXLFlBQVk5ZCxTQUFReXZEO0FBQ3hCbG9ELFVBQUlnc0IsT0FBTzJ6QixVQUFVdHNCO0FBRXJCLFdBQUsxZ0MsSUFBSSxHQUFHQSxJQUFJRCxRQUFRLEVBQUVDLEdBQUc7QUFDM0JxTixZQUFJZy9DLFNBQVN2dEIsTUFBTTkrQixDQUFBQSxHQUFJcXJELFVBQVU5akQsRUFBRSt0RCxHQUFHL3RELENBQUMsR0FBRyt0RCxHQUFHOXRELElBQUl3bEQsVUFBVXh6QixhQUFhLENBQUE7QUFDeEU4N0IsV0FBRzl0RCxLQUFLd2xELFVBQVV4ekIsYUFBYWkzQjtBQUUvQixZQUFJendELElBQUksTUFBTUQsUUFBUTtBQUNwQnUxRCxhQUFHOXRELEtBQUsxQixTQUFRNHFELG9CQUFvQkQ7O01BRXhDOztFQUVKO0VBS0ErRSxjQUFjbm9ELEtBQUtpb0QsSUFBSXQxRCxHQUFHcXJELFdBQVd2bEQsVUFBUztBQUM1QyxVQUFNZ3RELGFBQWEsS0FBS2lCLFlBQVkvekQsQ0FBRTtBQUN0QyxVQUFNaXpELGtCQUFrQixLQUFLZSxpQkFBaUJoMEQsQ0FBRTtBQUNoRCxVQUFNLEVBQUNvcEQsV0FBV0MsU0FBQUEsSUFBWXZqRDtBQUM5QixVQUFNZ3FELFdBQVd4MkIsT0FBT3h6QixTQUFRZ3FELFFBQVE7QUFDeEMsVUFBTTJGLFNBQVN2RCxZQUFZLE1BQU0sUUFBUXBzRCxRQUFBQTtBQUN6QyxVQUFNNHZELFlBQVlySyxVQUFVOWpELEVBQUVrdUQsTUFBQUE7QUFDOUIsVUFBTUUsVUFBVXZNLFlBQVkwRyxTQUFTdDJCLGNBQWNzMkIsU0FBU3QyQixhQUFhNHZCLGFBQWEsSUFBSTtBQUMxRixVQUFNd00sU0FBU04sR0FBRzl0RCxJQUFJbXVEO0FBRXRCLFFBQUk3dkQsU0FBUXdqRCxlQUFlO0FBQ3pCLFlBQU15QyxjQUFjO1FBQ2xCM3RDLFFBQVFsZixLQUFLQyxJQUFJa3FELFVBQVVELFNBQWEsSUFBQTtRQUN4QzVsQyxZQUFZeXZDLGdCQUFnQnp2QztRQUM1QjdFLFVBQVVzMEMsZ0JBQWdCdDBDO1FBQzFCZ0UsYUFBYTtNQUNmO0FBR0EsWUFBTVIsVUFBVWtwQyxVQUFVRyxXQUFXa0ssV0FBV3JNLFFBQUFBLElBQVlBLFdBQVc7QUFDdkUsWUFBTWpuQyxVQUFVd3pDLFNBQVN4TSxZQUFZO0FBR3JDLzdDLFVBQUl5VyxjQUFjaGUsU0FBUSt2RDtBQUMxQnhvRCxVQUFJdVcsWUFBWTlkLFNBQVErdkQ7QUFDeEJ0VyxnQkFBVWx5QyxLQUFLMCtDLGFBQWE1cEMsU0FBU0MsT0FBQUE7QUFHckMvVSxVQUFJeVcsY0FBY2d2QyxXQUFXL3VDO0FBQzdCMVcsVUFBSXVXLFlBQVlrdkMsV0FBV2p2QztBQUMzQjA3QixnQkFBVWx5QyxLQUFLMCtDLGFBQWE1cEMsU0FBU0MsT0FBQUE7V0FDaEM7QUFFTC9VLFVBQUk0VyxZQUFZbGYsU0FBUyt0RCxXQUFXbndDLFdBQVcsSUFBSXpqQixLQUFLb0MsSUFBTzJELEdBQUFBLE9BQU9XLE9BQU9rdEQsV0FBV253QyxXQUFXLENBQU1td0MsSUFBQUEsV0FBV253QyxlQUFlO0FBQ25JdFYsVUFBSXlXLGNBQWNndkMsV0FBVy91QztBQUM3QjFXLFVBQUk2M0IsWUFBWTR0QixXQUFXbHdCLGNBQWMsQ0FBQSxDQUFFO0FBQzNDdjFCLFVBQUk4M0IsaUJBQWlCMnRCLFdBQVdod0Isb0JBQW9CO0FBR3BELFlBQU1nekIsU0FBU3pLLFVBQVVHLFdBQVdrSyxXQUFXck0sUUFBQUE7QUFDL0MsWUFBTTBNLFNBQVMxSyxVQUFVRyxXQUFXSCxVQUFVWSxNQUFNeUosV0FBVyxDQUFBLEdBQUlyTSxXQUFXLENBQUE7QUFDOUUsWUFBTWhSLGVBQWUySCxjQUFjOFMsV0FBV3phLFlBQVk7QUFFMUQsVUFBSXB6QyxPQUFPVyxPQUFPeXlDLFlBQUFBLEVBQWM1TixLQUFLbHdCLENBQUFBLE1BQUtBLE1BQU0sQ0FBSSxHQUFBO0FBQ2xEbE4sWUFBSSszQixVQUFTO0FBQ2IvM0IsWUFBSXVXLFlBQVk5ZCxTQUFRK3ZEO0FBQ3hCelUsMkJBQW1CL3pDLEtBQUs7VUFDdEI5RixHQUFHdXVEO1VBQ0h0dUQsR0FBR291RDtVQUNIdm5DLEdBQUdnN0I7VUFDSDk2QixHQUFHNjZCO1VBQ0hockMsUUFBUWk2QjtRQUNWLENBQUE7QUFDQWhyQyxZQUFJbUIsS0FBSTtBQUNSbkIsWUFBSWs0QixPQUFNO0FBR1ZsNEIsWUFBSXVXLFlBQVlrdkMsV0FBV2p2QztBQUMzQnhXLFlBQUkrM0IsVUFBUztBQUNiZ2MsMkJBQW1CL3pDLEtBQUs7VUFDdEI5RixHQUFHd3VEO1VBQ0h2dUQsR0FBR291RCxTQUFTO1VBQ1p2bkMsR0FBR2c3QixXQUFXO1VBQ2Q5NkIsR0FBRzY2QixZQUFZO1VBQ2ZockMsUUFBUWk2QjtRQUNWLENBQUE7QUFDQWhyQyxZQUFJbUIsS0FBSTthQUNIO0FBRUxuQixZQUFJdVcsWUFBWTlkLFNBQVErdkQ7QUFDeEJ4b0QsWUFBSXUzQixTQUFTa3hCLFFBQVFGLFFBQVF2TSxVQUFVRCxTQUFBQTtBQUN2Qy83QyxZQUFJMm9ELFdBQVdGLFFBQVFGLFFBQVF2TSxVQUFVRCxTQUFBQTtBQUV6Qy83QyxZQUFJdVcsWUFBWWt2QyxXQUFXanZDO0FBQzNCeFcsWUFBSXUzQixTQUFTbXhCLFFBQVFILFNBQVMsR0FBR3ZNLFdBQVcsR0FBR0QsWUFBWSxDQUFBOzs7QUFLL0QvN0MsUUFBSXVXLFlBQVksS0FBS3F3QyxnQkFBZ0JqMEQsQ0FBRTtFQUN6QztFQUVBaTJELFNBQVNYLElBQUlqb0QsS0FBS3ZILFVBQVM7QUFDekIsVUFBTSxFQUFDOHBELEtBQUFBLElBQVE7QUFDZixVQUFNLEVBQUNpQixhQUFhcUYsV0FBV3RGLGVBQWV4SCxXQUFXQyxVQUFVeDdCLFdBQUFBLElBQWMvbkI7QUFDakYsVUFBTWdxRCxXQUFXeDJCLE9BQU94ekIsU0FBUWdxRCxRQUFRO0FBQ3hDLFFBQUlhLGlCQUFpQmIsU0FBU3QyQjtBQUM5QixRQUFJMjhCLGVBQWU7QUFFbkIsVUFBTTlLLFlBQVlDLGNBQWN4bEQsU0FBUXNsRCxLQUFLLEtBQUs3akQsR0FBRyxLQUFLK1QsS0FBSztBQUUvRCxVQUFNODZDLGlCQUFpQixTQUFTN3hDLE1BQU07QUFDcENsWCxVQUFJZy9DLFNBQVM5bkMsTUFBTThtQyxVQUFVOWpELEVBQUUrdEQsR0FBRy90RCxJQUFJNHVELFlBQUFBLEdBQWViLEdBQUc5dEQsSUFBSW1wRCxpQkFBaUIsQ0FBQTtBQUM3RTJFLFNBQUc5dEQsS0FBS21wRCxpQkFBaUJFO0lBQzNCO0FBRUEsVUFBTXdGLDBCQUEwQmhMLFVBQVUvbkIsVUFBVTR5QixTQUFBQTtBQUNwRCxRQUFJOUYsVUFBVWtHLFdBQVcvOEIsT0FBT3Y1QixHQUFHeXBCLEdBQUdsaEIsTUFBTTgzQjtBQUU1Q2h6QixRQUFJaTJCLFlBQVk0eUI7QUFDaEI3b0QsUUFBSW8yQixlQUFlO0FBQ25CcDJCLFFBQUlnc0IsT0FBT3kyQixTQUFTcHZCO0FBRXBCNDBCLE9BQUcvdEQsSUFBSTJxRCxZQUFZLE1BQU1tRSx5QkFBeUJ2d0QsUUFBQUE7QUFHbER1SCxRQUFJdVcsWUFBWTlkLFNBQVFrdEQ7QUFDeEI5aUMsU0FBSyxLQUFLcWdDLFlBQVk2RixjQUFBQTtBQUV0QkQsbUJBQWV2RixpQkFBaUJ5Riw0QkFBNEIsVUFDeERILGNBQWMsV0FBWTdNLFdBQVcsSUFBSXg3QixhQUFldzdCLFdBQVcsSUFBSXg3QixhQUN2RTtBQUdKLFNBQUs3dEIsSUFBSSxHQUFHdUksT0FBT3FuRCxLQUFLN3ZELFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQzdDb3dELGlCQUFXUixLQUFLNXZELENBQUU7QUFDbEJzMkQsa0JBQVksS0FBS3JDLGdCQUFnQmowRCxDQUFFO0FBRW5DcU4sVUFBSXVXLFlBQVkweUM7QUFDaEJwbUMsV0FBS2tnQyxTQUFTQyxRQUFRK0YsY0FBQUE7QUFFdEI3OEIsY0FBUTYyQixTQUFTNzJCO0FBRWpCLFVBQUlxM0IsaUJBQWlCcjNCLE1BQU14NUIsUUFBUTtBQUNqQyxhQUFLeTFELGNBQWNub0QsS0FBS2lvRCxJQUFJdDFELEdBQUdxckQsV0FBV3ZsRCxRQUFBQTtBQUMxQzZxRCx5QkFBaUJ6eEQsS0FBS29DLElBQUl3dUQsU0FBU3QyQixZQUFZNHZCLFNBQUFBOztBQUdqRCxXQUFLMy9CLElBQUksR0FBRzRXLE9BQU85RyxNQUFNeDVCLFFBQVEwcEIsSUFBSTRXLE1BQU0sRUFBRTVXLEdBQUc7QUFDOUMyc0MsdUJBQWU3OEIsTUFBTTlQLENBQUUsQ0FBQTtBQUV2QmtuQyx5QkFBaUJiLFNBQVN0MkI7TUFDNUI7QUFFQXRKLFdBQUtrZ0MsU0FBU0UsT0FBTzhGLGNBQUFBO0lBQ3ZCO0FBR0FELG1CQUFlO0FBQ2Z4RixxQkFBaUJiLFNBQVN0MkI7QUFHMUJ0SixTQUFLLEtBQUtzZ0MsV0FBVzRGLGNBQUFBO0FBQ3JCZCxPQUFHOXRELEtBQUtxcEQ7RUFDVjtFQUVBMEYsV0FBV2pCLElBQUlqb0QsS0FBS3ZILFVBQVM7QUFDM0IsVUFBTStwRCxTQUFTLEtBQUtBO0FBQ3BCLFVBQU05dkQsU0FBUzh2RCxPQUFPOXZEO0FBQ3RCLFFBQUlnd0QsWUFBWS92RDtBQUVoQixRQUFJRCxRQUFRO0FBQ1YsWUFBTXNyRCxZQUFZQyxjQUFjeGxELFNBQVFzbEQsS0FBSyxLQUFLN2pELEdBQUcsS0FBSytULEtBQUs7QUFFL0RnNkMsU0FBRy90RCxJQUFJMnFELFlBQVksTUFBTXBzRCxTQUFRMHdELGFBQWExd0QsUUFBQUE7QUFDOUN3dkQsU0FBRzl0RCxLQUFLMUIsU0FBUWdyRDtBQUVoQnpqRCxVQUFJaTJCLFlBQVkrbkIsVUFBVS9uQixVQUFVeDlCLFNBQVEwd0QsV0FBVztBQUN2RG5wRCxVQUFJbzJCLGVBQWU7QUFFbkJzc0IsbUJBQWF6MkIsT0FBT3h6QixTQUFRaXFELFVBQVU7QUFFdEMxaUQsVUFBSXVXLFlBQVk5ZCxTQUFRMndEO0FBQ3hCcHBELFVBQUlnc0IsT0FBTzAyQixXQUFXcnZCO0FBRXRCLFdBQUsxZ0MsSUFBSSxHQUFHQSxJQUFJRCxRQUFRLEVBQUVDLEdBQUc7QUFDM0JxTixZQUFJZy9DLFNBQVN3RCxPQUFPN3ZELENBQUFBLEdBQUlxckQsVUFBVTlqRCxFQUFFK3RELEdBQUcvdEQsQ0FBQyxHQUFHK3RELEdBQUc5dEQsSUFBSXVvRCxXQUFXdjJCLGFBQWEsQ0FBQTtBQUMxRTg3QixXQUFHOXRELEtBQUt1b0QsV0FBV3YyQixhQUFhMXpCLFNBQVFpckQ7TUFDMUM7O0VBRUo7RUFFQXJzQixlQUFlNHdCLElBQUlqb0QsS0FBS3FwRCxhQUFhNXdELFVBQVM7QUFDNUMsVUFBTSxFQUFDc3JELFFBQVFLLE9BQU0sSUFBSTtBQUN6QixVQUFNLEVBQUNscUQsR0FBR0MsRUFBQUEsSUFBSzh0RDtBQUNmLFVBQU0sRUFBQ2g2QyxPQUFPRCxPQUFBQSxJQUFVcTdDO0FBQ3hCLFVBQU0sRUFBQ3ZXLFNBQVNDLFVBQVVDLFlBQVlDLFlBQUFBLElBQWVOLGNBQWNsNkMsU0FBUW1zRCxZQUFZO0FBRXZGNWtELFFBQUl1VyxZQUFZOWQsU0FBUStkO0FBQ3hCeFcsUUFBSXlXLGNBQWNoZSxTQUFRaWU7QUFDMUIxVyxRQUFJNFcsWUFBWW5lLFNBQVE2YztBQUV4QnRWLFFBQUkrM0IsVUFBUztBQUNiLzNCLFFBQUlnNEIsT0FBTzk5QixJQUFJNDRDLFNBQVMzNEMsQ0FBQUE7QUFDeEIsUUFBSWlxRCxXQUFXLE9BQU87QUFDcEIsV0FBS3FELFVBQVVRLElBQUlqb0QsS0FBS3FwRCxhQUFhNXdELFFBQUFBOztBQUV2Q3VILFFBQUlpNEIsT0FBTy85QixJQUFJK1QsUUFBUThrQyxVQUFVNTRDLENBQUFBO0FBQ2pDNkYsUUFBSXNwRCxpQkFBaUJwdkQsSUFBSStULE9BQU85VCxHQUFHRCxJQUFJK1QsT0FBTzlULElBQUk0NEMsUUFBQUE7QUFDbEQsUUFBSXFSLFdBQVcsWUFBWUwsV0FBVyxTQUFTO0FBQzdDLFdBQUswRCxVQUFVUSxJQUFJam9ELEtBQUtxcEQsYUFBYTV3RCxRQUFBQTs7QUFFdkN1SCxRQUFJaTRCLE9BQU8vOUIsSUFBSStULE9BQU85VCxJQUFJNlQsU0FBU2lsQyxXQUFBQTtBQUNuQ2p6QyxRQUFJc3BELGlCQUFpQnB2RCxJQUFJK1QsT0FBTzlULElBQUk2VCxRQUFROVQsSUFBSStULFFBQVFnbEMsYUFBYTk0QyxJQUFJNlQsTUFBQUE7QUFDekUsUUFBSW8yQyxXQUFXLFVBQVU7QUFDdkIsV0FBS3FELFVBQVVRLElBQUlqb0QsS0FBS3FwRCxhQUFhNXdELFFBQUFBOztBQUV2Q3VILFFBQUlpNEIsT0FBTy85QixJQUFJODRDLFlBQVk3NEMsSUFBSTZULE1BQUFBO0FBQy9CaE8sUUFBSXNwRCxpQkFBaUJwdkQsR0FBR0MsSUFBSTZULFFBQVE5VCxHQUFHQyxJQUFJNlQsU0FBU2dsQyxVQUFBQTtBQUNwRCxRQUFJb1IsV0FBVyxZQUFZTCxXQUFXLFFBQVE7QUFDNUMsV0FBSzBELFVBQVVRLElBQUlqb0QsS0FBS3FwRCxhQUFhNXdELFFBQUFBOztBQUV2Q3VILFFBQUlpNEIsT0FBTy85QixHQUFHQyxJQUFJMjRDLE9BQUFBO0FBQ2xCOXlDLFFBQUlzcEQsaUJBQWlCcHZELEdBQUdDLEdBQUdELElBQUk0NEMsU0FBUzM0QyxDQUFBQTtBQUN4QzZGLFFBQUlzcUMsVUFBUztBQUVidHFDLFFBQUltQixLQUFJO0FBRVIsUUFBSTFJLFNBQVE2YyxjQUFjLEdBQUc7QUFDM0J0VixVQUFJazRCLE9BQU07O0VBRWQ7RUFNQXF4Qix1QkFBdUI5d0QsVUFBUztBQUM5QixVQUFNeEgsUUFBUSxLQUFLQTtBQUNuQixVQUFNQyxRQUFRLEtBQUs2SDtBQUNuQixVQUFNeXdELFFBQVF0NEQsU0FBU0EsTUFBTWdKO0FBQzdCLFVBQU11dkQsUUFBUXY0RCxTQUFTQSxNQUFNaUo7QUFDN0IsUUFBSXF2RCxTQUFTQyxPQUFPO0FBQ2xCLFlBQU14dEMsV0FBV29sQyxZQUFZNW9ELFNBQVF3akIsUUFBUSxFQUFFL3BCLEtBQUssTUFBTSxLQUFLWSxTQUFTLEtBQUtxekQsY0FBYztBQUMzRixVQUFJLENBQUNscUMsVUFBVTtBQUNiOztBQUVGLFlBQU03aUIsT0FBTyxLQUFLZ3RELFFBQVEvRCxlQUFlLE1BQU01cEQsUUFBQUE7QUFDL0MsWUFBTTZ1RCxrQkFBa0IxdkQsT0FBT3lCLE9BQU8sQ0FBQSxHQUFJNGlCLFVBQVUsS0FBS21xQyxLQUFLO0FBQzlELFlBQU16QixZQUFZTCxtQkFBbUJyekQsT0FBT3dILFVBQVM2dUQsZUFBQUE7QUFDckQsWUFBTXIyQyxRQUFReXpDLG1CQUFtQmpzRCxVQUFTNnVELGlCQUFpQjNDLFdBQVcxekQsS0FBQUE7QUFDdEUsVUFBSXU0RCxNQUFNaHpELFFBQVF5YSxNQUFNL1csS0FBS3V2RCxNQUFNanpELFFBQVF5YSxNQUFNOVcsR0FBRztBQUNsRCxhQUFLNHBELFNBQVNZLFVBQVVaO0FBQ3hCLGFBQUtLLFNBQVNPLFVBQVVQO0FBQ3hCLGFBQUtuMkMsUUFBUTdVLEtBQUs2VTtBQUNsQixhQUFLRCxTQUFTNVUsS0FBSzRVO0FBQ25CLGFBQUt3NEMsU0FBU3ZxQyxTQUFTL2hCO0FBQ3ZCLGFBQUt1c0QsU0FBU3hxQyxTQUFTOWhCO0FBQ3ZCLGFBQUsrTSxtQkFBa0IsRUFBR3ZRLE9BQU8sTUFBTXNhLEtBQUFBOzs7RUFHN0M7RUFNQXk0QyxjQUFjO0FBQ1osV0FBTyxDQUFDLENBQUMsS0FBS3hEO0VBQ2hCO0VBRUF0ekQsS0FBS29OLEtBQUs7QUFDUixVQUFNdkgsV0FBVSxLQUFLQSxRQUFRdTFCLFdBQVcsS0FBS3BxQixXQUFVLENBQUE7QUFDdkQsUUFBSXNpRCxVQUFVLEtBQUtBO0FBRW5CLFFBQUksQ0FBQ0EsU0FBUztBQUNaOztBQUdGLFNBQUtxRCx1QkFBdUI5d0QsUUFBQUE7QUFFNUIsVUFBTTR3RCxjQUFjO01BQ2xCcDdDLE9BQU8sS0FBS0E7TUFDWkQsUUFBUSxLQUFLQTtJQUNmO0FBQ0EsVUFBTWk2QyxLQUFLO01BQ1QvdEQsR0FBRyxLQUFLQTtNQUNSQyxHQUFHLEtBQUtBO0lBQ1Y7QUFHQStyRCxjQUFVcjBELEtBQUt3WSxJQUFJNjdDLE9BQVcsSUFBQSxPQUFPLElBQUlBO0FBRXpDLFVBQU0vakMsVUFBVU8sVUFBVWpxQixTQUFRMHBCLE9BQU87QUFHekMsVUFBTXduQyxvQkFBb0IsS0FBS2w0QixNQUFNLytCLFVBQVUsS0FBS3d3RCxXQUFXeHdELFVBQVUsS0FBSzZ2RCxLQUFLN3ZELFVBQVUsS0FBS3l3RCxVQUFVendELFVBQVUsS0FBSzh2RCxPQUFPOXZEO0FBRWxJLFFBQUkrRixTQUFRNHdCLFdBQVdzZ0MsbUJBQW1CO0FBQ3hDM3BELFVBQUlzM0IsS0FBSTtBQUNSdDNCLFVBQUk0cEQsY0FBYzFEO0FBR2xCLFdBQUs3dUIsZUFBZTR3QixJQUFJam9ELEtBQUtxcEQsYUFBYTV3RCxRQUFBQTtBQUUxQ3ltRCw0QkFBc0JsL0MsS0FBS3ZILFNBQVEwbUQsYUFBYTtBQUVoRDhJLFNBQUc5dEQsS0FBS2dvQixRQUFRL25CO0FBR2hCLFdBQUt1K0IsVUFBVXN2QixJQUFJam9ELEtBQUt2SCxRQUFBQTtBQUd4QixXQUFLbXdELFNBQVNYLElBQUlqb0QsS0FBS3ZILFFBQUFBO0FBR3ZCLFdBQUt5d0QsV0FBV2pCLElBQUlqb0QsS0FBS3ZILFFBQUFBO0FBRXpCaW5ELDJCQUFxQjEvQyxLQUFLdkgsU0FBUTBtRCxhQUFhO0FBRS9Dbi9DLFVBQUl3M0IsUUFBTzs7RUFFZjtFQU1BdVIsb0JBQW9CO0FBQ2xCLFdBQU8sS0FBS2oyQyxXQUFXLENBQUE7RUFDekI7RUFPQWsyQyxrQkFBa0JDLGdCQUFnQndZLGVBQWU7QUFDL0MsVUFBTXZZLGFBQWEsS0FBS3AyQztBQUN4QixVQUFNNEQsU0FBU3V5QyxlQUFlN3lCLElBQUksQ0FBQyxFQUFDM2EsY0FBY04sT0FBQUEsT0FBSyxNQUFNO0FBQzNELFlBQU1hLE9BQU8sS0FBSy9LLE1BQU13UixlQUFlaEgsWUFBQUE7QUFFdkMsVUFBSSxDQUFDTyxNQUFNO0FBQ1QsY0FBTSxJQUFJb2UsTUFBTSxvQ0FBb0MzZSxZQUFjOztBQUdwRSxhQUFPO1FBQ0xBO1FBQ0F3RCxTQUFTakQsS0FBS0QsS0FBS1osTUFBTTtRQUN6QkEsT0FBQUE7TUFDRjtJQUNGLENBQUE7QUFDQSxVQUFNNG1CLFVBQVUsQ0FBQ29uQixlQUFlRCxZQUFZeHlDLE1BQUFBO0FBQzVDLFVBQU1tekQsa0JBQWtCLEtBQUtDLGlCQUFpQnB6RCxRQUFRK3FELGFBQUFBO0FBRXRELFFBQUkxL0IsV0FBVzhuQyxpQkFBaUI7QUFDOUIsV0FBSy8yRCxVQUFVNEQ7QUFDZixXQUFLeXZELGlCQUFpQjFFO0FBQ3RCLFdBQUtzSSxzQkFBc0I7QUFDM0IsV0FBS3B6RCxPQUFPLElBQUk7O0VBRXBCO0VBU0FzcEQsWUFBWW5wQyxHQUFHdXlCLFFBQVF4RyxjQUFjLE1BQU07QUFDekMsUUFBSXdHLFVBQVUsS0FBSzBnQixxQkFBcUI7QUFDdEMsYUFBTzs7QUFFVCxTQUFLQSxzQkFBc0I7QUFFM0IsVUFBTXR4RCxXQUFVLEtBQUtBO0FBQ3JCLFVBQU15d0MsYUFBYSxLQUFLcDJDLFdBQVcsQ0FBQTtBQUNuQyxVQUFNNEQsU0FBUyxLQUFLa3pDLG1CQUFtQjl5QixHQUFHb3lCLFlBQVlHLFFBQVF4RyxXQUFBQTtBQUs5RCxVQUFNZ25CLGtCQUFrQixLQUFLQyxpQkFBaUJwekQsUUFBUW9nQixDQUFBQTtBQUd0RCxVQUFNaUwsVUFBVXNuQixVQUFVLENBQUNGLGVBQWV6eUMsUUFBUXd5QyxVQUFlMmdCLEtBQUFBO0FBR2pFLFFBQUk5bkMsU0FBUztBQUNYLFdBQUtqdkIsVUFBVTREO0FBRWYsVUFBSStCLFNBQVE0d0IsV0FBVzV3QixTQUFRK3VELFVBQVU7QUFDdkMsYUFBS3JCLGlCQUFpQjtVQUNwQmpzRCxHQUFHNGMsRUFBRTVjO1VBQ0xDLEdBQUcyYyxFQUFFM2M7UUFDUDtBQUVBLGFBQUt4RCxPQUFPLE1BQU0weUMsTUFBQUE7OztBQUl0QixXQUFPdG5CO0VBQ1Q7RUFXQTZuQixtQkFBbUI5eUIsR0FBR295QixZQUFZRyxRQUFReEcsYUFBYTtBQUNyRCxVQUFNcHFDLFdBQVUsS0FBS0E7QUFFckIsUUFBSXFlLEVBQUUxbEIsU0FBUyxZQUFZO0FBQ3pCLGFBQU8sQ0FBQTs7QUFHVCxRQUFJLENBQUN5eEMsYUFBYTtBQUdoQixhQUFPcUcsV0FBV3hxQyxPQUFPL0wsQ0FBQUEsTUFDdkIsS0FBSzFCLE1BQU04SyxLQUFLeUcsU0FBUzdQLEVBQUU4SSxZQUFZLEtBQ3ZDLEtBQUt4SyxNQUFNd1IsZUFBZTlQLEVBQUU4SSxZQUFZLEVBQUVvQyxXQUFXZ0gsVUFBVWxTLEVBQUV3SSxLQUFLLE1BQU1wSyxNQUFBQTs7QUFLaEYsVUFBTTJGLFNBQVMsS0FBS3pGLE1BQU02MkMsMEJBQTBCaHhCLEdBQUdyZSxTQUFRK0MsTUFBTS9DLFVBQVM0d0MsTUFBQUE7QUFFOUUsUUFBSTV3QyxTQUFRb0IsU0FBUztBQUNuQm5ELGFBQU9tRCxRQUFPOztBQUdoQixXQUFPbkQ7RUFDVDtFQVNBb3pELGlCQUFpQnB6RCxRQUFRb2dCLEdBQUc7QUFDMUIsVUFBTSxFQUFDMHZDLFFBQVFDLFFBQVFodUQsU0FBQUEsU0FBTyxJQUFJO0FBQ2xDLFVBQU13akIsV0FBV29sQyxZQUFZNW9ELFNBQVF3akIsUUFBUSxFQUFFL3BCLEtBQUssTUFBTXdFLFFBQVFvZ0IsQ0FBQUE7QUFDbEUsV0FBT21GLGFBQWEsVUFBVXVxQyxXQUFXdnFDLFNBQVMvaEIsS0FBS3VzRCxXQUFXeHFDLFNBQVM5aEI7RUFDN0U7QUFDRjtBQXZ2QkUsY0FMVzhyRCxTQUtKNUUsZUFBY0E7QUF5dkJ2QixJQUFBLGlCQUFlO0VBQ2J4a0QsSUFBSTtFQUNKNGpELFVBQVV3RjtFQUNWNUU7RUFFQTJJLFVBQVUvNEQsT0FBTzZqRCxPQUFPcjhDLFVBQVM7QUFDL0IsUUFBSUEsVUFBUztBQUNYeEgsWUFBTXF4RCxVQUFVLElBQUkyRCxRQUFRO1FBQUNoMUQ7UUFBT3dILFNBQUFBO01BQU8sQ0FBQTs7RUFFL0M7RUFFQWkyQixhQUFhejlCLE9BQU82akQsT0FBT3I4QyxVQUFTO0FBQ2xDLFFBQUl4SCxNQUFNcXhELFNBQVM7QUFDakJyeEQsWUFBTXF4RCxRQUFRdGhELFdBQVd2SSxRQUFBQTs7RUFFN0I7RUFFQW1LLE1BQU0zUixPQUFPNmpELE9BQU9yOEMsVUFBUztBQUMzQixRQUFJeEgsTUFBTXF4RCxTQUFTO0FBQ2pCcnhELFlBQU1xeEQsUUFBUXRoRCxXQUFXdkksUUFBQUE7O0VBRTdCO0VBRUF3eEQsVUFBVWg1RCxPQUFPO0FBQ2YsVUFBTXF4RCxVQUFVcnhELE1BQU1xeEQ7QUFFdEIsUUFBSUEsV0FBV0EsUUFBUW9ILFlBQVcsR0FBSTtBQUNwQyxZQUFNMWdELE9BQU87UUFDWHM1QztNQUNGO0FBRUEsVUFBSXJ4RCxNQUFNcy9CLGNBQWMscUJBQXFCO1FBQUMsR0FBR3ZuQjtRQUFNNnpCLFlBQVk7TUFBSSxDQUFBLE1BQU8sT0FBTztBQUNuRjs7QUFHRnlsQixjQUFRMXZELEtBQUszQixNQUFNK08sR0FBRztBQUV0Qi9PLFlBQU1zL0IsY0FBYyxvQkFBb0J2bkIsSUFBQUE7O0VBRTVDO0VBRUEwM0MsV0FBV3p2RCxPQUFPK1gsTUFBTTtBQUN0QixRQUFJL1gsTUFBTXF4RCxTQUFTO0FBRWpCLFlBQU12bEMsbUJBQW1CL1QsS0FBS3FnQztBQUM5QixVQUFJcDRDLE1BQU1xeEQsUUFBUXJDLFlBQVlqM0MsS0FBS3ZWLE9BQU9zcEIsa0JBQWtCL1QsS0FBSzY1QixXQUFXLEdBQUc7QUFFN0U3NUIsYUFBSytZLFVBQVU7OztFQUdyQjtFQUVBanFCLFVBQVU7SUFDUnV4QixTQUFTO0lBQ1RtK0IsVUFBVTtJQUNWdnJDLFVBQVU7SUFDVnpGLGlCQUFpQjtJQUNqQjB4QyxZQUFZO0lBQ1p2SSxXQUFXO01BQ1RqcUMsUUFBUTtJQUNWO0lBQ0EwdEMsY0FBYztJQUNkQyxtQkFBbUI7SUFDbkIvMkIsWUFBWTtJQUNacTVCLFdBQVc7SUFDWG5DLGFBQWE7SUFDYmYsVUFBVSxDQUFBO0lBRVZvRyxXQUFXO0lBQ1hPLGFBQWE7SUFDYjFGLGVBQWU7SUFDZkQsaUJBQWlCO0lBQ2pCZixZQUFZO01BQ1ZodEMsUUFBUTtJQUNWO0lBQ0F5ekMsYUFBYTtJQUNiaG5DLFNBQVM7SUFDVCtoQyxjQUFjO0lBQ2RELFdBQVc7SUFDWFcsY0FBYztJQUNkN0ksV0FBVyxDQUFDLzdDLEtBQUtwRyxTQUFTQSxLQUFLNm9ELFNBQVNycEQ7SUFDeEM0aUQsVUFBVSxDQUFDaDhDLEtBQUtwRyxTQUFTQSxLQUFLNm9ELFNBQVNycEQ7SUFDdkNvdkQsb0JBQW9CO0lBQ3BCakYsZUFBZTtJQUNmL2lDLFlBQVk7SUFDWjlKLGFBQWE7SUFDYnBCLGFBQWE7SUFDYnZkLFdBQVc7TUFDVHZHLFVBQVU7TUFDVnNFLFFBQVE7SUFDVjtJQUNBNkMsWUFBWTtNQUNWNFgsU0FBUztRQUNQbmYsTUFBTTtRQUNOaUgsWUFBWTtVQUFDO1VBQUs7VUFBSztVQUFTO1VBQVU7VUFBVTtRQUFTO01BQy9EO01BQ0E2dEQsU0FBUztRQUNQcHdELFFBQVE7UUFDUnRFLFVBQVU7TUFDWjtJQUNGO0lBQ0FILFdBQVc2ekQ7RUFDYjtFQUVBdDhCLGVBQWU7SUFDYjY1QixVQUFVO0lBQ1ZDLFlBQVk7SUFDWi9DLFdBQVc7RUFDYjtFQUVBaHFDLGFBQWE7SUFDWEMsYUFBYSxDQUFDekcsU0FBU0EsU0FBUyxZQUFZQSxTQUFTLGNBQWNBLFNBQVM7SUFDNUUwRyxZQUFZO0lBQ1p4a0IsV0FBVztNQUNUdWtCLGFBQWE7TUFDYkMsWUFBWTtJQUNkO0lBQ0E5ZCxXQUFXO01BQ1RteUQsV0FBVztJQUNiO0lBQ0F2eEQsWUFBWTtNQUNWdXhELFdBQVc7SUFDYjtFQUNGO0VBR0EzcEIsd0JBQXdCO0lBQUM7RUFBYztBQUN6Qzs7Ozs7Ozs7Ozs7QUNsMENBLElBQU00cEIsY0FBYyxDQUFDNWxELFFBQVFwRixLQUFLaEUsUUFBT2l2RCxnQkFBZ0I7QUFDdkQsTUFBSSxPQUFPanJELFFBQVEsVUFBVTtBQUMzQmhFLElBQUFBLFNBQVFvSixPQUFPNVEsS0FBS3dMLEdBQU8sSUFBQTtBQUMzQmlyRCxnQkFBWTFRLFFBQVE7TUFBQ3YrQyxPQUFBQTtNQUFPd0ssT0FBT3hHO0lBQUcsQ0FBQTthQUM3QnVQLE1BQU12UCxHQUFNLEdBQUE7QUFDckJoRSxJQUFBQSxTQUFROztBQUVWLFNBQU9BO0FBQ1Q7QUFFQSxTQUFTa3ZELGVBQWU5bEQsUUFBUXBGLEtBQUtoRSxRQUFPaXZELGFBQWE7QUFDdkQsUUFBTTVnQyxRQUFRamxCLE9BQU9vSyxRQUFReFAsR0FBQUE7QUFDN0IsTUFBSXFxQixVQUFVLElBQUk7QUFDaEIsV0FBTzJnQyxZQUFZNWxELFFBQVFwRixLQUFLaEUsUUFBT2l2RCxXQUFBQTs7QUFFekMsUUFBTWo4QyxPQUFPNUosT0FBTytsRCxZQUFZbnJELEdBQUFBO0FBQ2hDLFNBQU9xcUIsVUFBVXJiLE9BQU9oVCxTQUFRcXVCO0FBQ2xDO0FBRUEsSUFBTTZCLGFBQWEsQ0FBQ2x3QixRQUFPbEgsUUFBUWtILFdBQVUsT0FBTyxPQUFPcTJCLFlBQVkzL0IsS0FBS2c0QixNQUFNMXVCLE1BQUFBLEdBQVEsR0FBR2xILEdBQUk7QUFFakcsU0FBU3MyRCxrQkFBa0JweEQsT0FBTztBQUNoQyxRQUFNb0wsU0FBUyxLQUFLQyxVQUFTO0FBRTdCLE1BQUlyTCxTQUFTLEtBQUtBLFFBQVFvTCxPQUFPN1IsUUFBUTtBQUN2QyxXQUFPNlIsT0FBT3BMLEtBQU07O0FBRXRCLFNBQU9BO0FBQ1Q7QUFFZSxJQUFNcXhELGdCQUFOLGNBQTRCMzlCLE1BQUFBO0VBYXpDcDhCLFlBQVk2RSxLQUFLO0FBQ2YsVUFBTUEsR0FBQUE7QUFHTixTQUFLbTFELGNBQWMxNUQ7QUFDbkIsU0FBSzI1RCxjQUFjO0FBQ25CLFNBQUtDLGVBQWUsQ0FBQTtFQUN0QjtFQUVBbHdDLEtBQUs0akIsY0FBYztBQUNqQixVQUFNdXNCLFFBQVEsS0FBS0Q7QUFDbkIsUUFBSUMsTUFBTWw0RCxRQUFRO0FBQ2hCLFlBQU02UixTQUFTLEtBQUtDLFVBQVM7QUFDN0IsaUJBQVcsRUFBQ3JKLE9BQUFBLFFBQU93SyxNQUFLLEtBQUtpbEQsT0FBTztBQUNsQyxZQUFJcm1ELE9BQU9wSixNQUFNLE1BQUt3SyxPQUFPO0FBQzNCcEIsaUJBQU91RSxPQUFPM04sUUFBTyxDQUFBOztNQUV6QjtBQUNBLFdBQUt3dkQsZUFBZSxDQUFBOztBQUV0QixVQUFNbHdDLEtBQUs0akIsWUFBQUE7RUFDYjtFQUVBdjZCLE1BQU0zRSxLQUFLaEUsUUFBTztBQUNoQixRQUFJNFAsY0FBYzVMLEdBQU0sR0FBQTtBQUN0QixhQUFPOztBQUVULFVBQU1vRixTQUFTLEtBQUtDLFVBQVM7QUFDN0JySixJQUFBQSxTQUFRUyxTQUFTVCxNQUFVb0osS0FBQUEsT0FBT3BKLE1BQUFBLE1BQVdnRSxNQUFNaEUsU0FDL0NrdkQsZUFBZTlsRCxRQUFRcEYsS0FBS3lDLGVBQWV6RyxRQUFPZ0UsR0FBQUEsR0FBTSxLQUFLd3JELFlBQVk7QUFDN0UsV0FBT3QvQixXQUFXbHdCLFFBQU9vSixPQUFPN1IsU0FBUyxDQUFBO0VBQzNDO0VBRUF3OEIsc0JBQXNCO0FBQ3BCLFVBQU0sRUFBQ255QixZQUFZQyxXQUFBQSxJQUFjLEtBQUtGLGNBQWE7QUFDbkQsUUFBSSxFQUFDaEwsS0FBS21DLElBQUcsSUFBSSxLQUFLa1IsVUFBVSxJQUFJO0FBRXBDLFFBQUksS0FBSzFNLFFBQVEwNkMsV0FBVyxTQUFTO0FBQ25DLFVBQUksQ0FBQ3AyQyxZQUFZO0FBQ2ZqTCxjQUFNOztBQUVSLFVBQUksQ0FBQ2tMLFlBQVk7QUFDZi9JLGNBQU0sS0FBS3VRLFVBQVMsRUFBRzlSLFNBQVM7OztBQUlwQyxTQUFLWixNQUFNQTtBQUNYLFNBQUttQyxNQUFNQTtFQUNiO0VBRUFxN0IsYUFBYTtBQUNYLFVBQU14OUIsTUFBTSxLQUFLQTtBQUNqQixVQUFNbUMsTUFBTSxLQUFLQTtBQUNqQixVQUFNeWMsU0FBUyxLQUFLalksUUFBUWlZO0FBQzVCLFVBQU1uRyxRQUFRLENBQUE7QUFDZCxRQUFJaEcsU0FBUyxLQUFLQyxVQUFTO0FBRzNCRCxhQUFTLFFBQVMsS0FBS3RRLFFBQVFzUSxPQUFPN1IsU0FBUyxJQUFLNlIsU0FBU0EsT0FBT2tYLE1BQU0zcEIsS0FBS21DLE1BQU0sQ0FBRTtBQUV2RixTQUFLeTJELGNBQWM3NEQsS0FBS29DLElBQUlzUSxPQUFPN1IsVUFBVWdlLFNBQVMsSUFBSSxJQUFJLENBQUE7QUFDOUQsU0FBSys1QyxjQUFjLEtBQUszNEQsT0FBTzRlLFNBQVMsTUFBTTtBQUU5QyxhQUFTdlgsUUFBUXJILEtBQUtxSCxTQUFTbEYsS0FBS2tGLFNBQVM7QUFDM0NvUixZQUFNNVcsS0FBSztRQUFDd0Y7TUFBSyxDQUFBO0lBQ25CO0FBQ0EsV0FBT29SO0VBQ1Q7RUFFQTNFLGlCQUFpQnpNLE9BQU87QUFDdEIsV0FBT294RCxrQkFBa0JyNEQsS0FBSyxNQUFNaUgsS0FBQUE7RUFDdEM7RUFLQTFCLFlBQVk7QUFDVixVQUFNQSxVQUFTO0FBRWYsUUFBSSxDQUFDLEtBQUsyVSxhQUFZLEdBQUk7QUFFeEIsV0FBS2dQLGlCQUFpQixDQUFDLEtBQUtBOztFQUVoQztFQUdBOVEsaUJBQWlCblIsT0FBTztBQUN0QixRQUFJLE9BQU9BLFVBQVUsVUFBVTtBQUM3QkEsY0FBUSxLQUFLMkssTUFBTTNLLEtBQUFBOztBQUdyQixXQUFPQSxVQUFVLE9BQU8rTCxNQUFNLEtBQUt5SyxvQkFBb0J4VyxRQUFRLEtBQUtzeEQsZUFBZSxLQUFLQyxXQUFXO0VBQ3JHO0VBSUFsZ0QsZ0JBQWdCclAsUUFBTztBQUNyQixVQUFNb1AsUUFBUSxLQUFLQTtBQUNuQixRQUFJcFAsU0FBUSxLQUFLQSxTQUFRb1AsTUFBTTdYLFNBQVMsR0FBRztBQUN6QyxhQUFPOztBQUVULFdBQU8sS0FBSzRYLGlCQUFpQkMsTUFBTXBQLE1BQUFBLEVBQU9oQyxLQUFLO0VBQ2pEO0VBRUEwVyxpQkFBaUI0akIsT0FBTztBQUN0QixXQUFPNWhDLEtBQUtnNEIsTUFBTSxLQUFLNGdDLGNBQWMsS0FBSzUyQixtQkFBbUJKLEtBQVMsSUFBQSxLQUFLaTNCLFdBQVc7RUFDeEY7RUFFQWw5QyxlQUFlO0FBQ2IsV0FBTyxLQUFLbFQ7RUFDZDtBQUNGO0FBMUhFLGNBRm1Ca3dELGVBRVozdEQsTUFBSztBQUtaLGNBUG1CMnRELGVBT1oxeUQsWUFBVztFQUNoQnlTLE9BQU87SUFDTG1tQixVQUFVNjVCO0VBQ1o7O0FDbkJKLFNBQVNNLGdCQUFjQyxtQkFBbUJDLFdBQVc7QUFDbkQsUUFBTXhnRCxRQUFRLENBQUE7QUFLZCxRQUFNeWdELGNBQWM7QUFDcEIsUUFBTSxFQUFDN1gsUUFBUWhlLE1BQU1yakMsS0FBS21DLEtBQUtnM0QsV0FBV2xuRCxPQUFPbW5ELFVBQVVDLFdBQVdDLGNBQUFBLElBQWlCTjtBQUN2RixRQUFNTyxPQUFPbDJCLFFBQVE7QUFDckIsUUFBTW0yQixZQUFZSixXQUFXO0FBQzdCLFFBQU0sRUFBQ3A1RCxLQUFLeTVELE1BQU10M0QsS0FBS3UzRCxLQUFBQSxJQUFRVDtBQUMvQixRQUFNaHVELGFBQWEsQ0FBQ2dPLGNBQWNqWixHQUFBQTtBQUNsQyxRQUFNa0wsYUFBYSxDQUFDK04sY0FBYzlXLEdBQUFBO0FBQ2xDLFFBQU13M0QsZUFBZSxDQUFDMWdELGNBQWNoSCxLQUFBQTtBQUNwQyxRQUFNMm5ELGNBQWNGLE9BQU9ELFNBQVNKLFlBQVk7QUFDaEQsTUFBSXozQyxVQUFVaTRDLFNBQVNILE9BQU9ELFFBQVFELFlBQVlELElBQVFBLElBQUFBO0FBQzFELE1BQUl6MkQsUUFBUWczRCxTQUFTQyxTQUFTQztBQUk5QixNQUFJcDRDLFVBQVVzM0MsZUFBZSxDQUFDanVELGNBQWMsQ0FBQ0MsWUFBWTtBQUN2RCxXQUFPO01BQUM7UUFBQzdELE9BQU9veUQ7TUFBSTtNQUFHO1FBQUNweUQsT0FBT3F5RDtNQUFJO0lBQUU7O0FBR3ZDTSxjQUFZajZELEtBQUswNEIsS0FBS2loQyxPQUFPOTNDLE9BQUFBLElBQVc3aEIsS0FBS29FLE1BQU1zMUQsT0FBTzczQyxPQUFBQTtBQUMxRCxNQUFJbzRDLFlBQVlSLFdBQVc7QUFFekI1M0MsY0FBVWk0QyxRQUFRRyxZQUFZcDRDLFVBQVU0M0MsWUFBWUQsSUFBUUEsSUFBQUE7O0FBRzlELE1BQUksQ0FBQ3RnRCxjQUFja2dELFNBQVksR0FBQTtBQUU3QnIyRCxhQUFTL0MsS0FBS2dyQixJQUFJLElBQUlvdUMsU0FBQUE7QUFDdEJ2M0MsY0FBVTdoQixLQUFLMDRCLEtBQUs3VyxVQUFVOWUsTUFBVUEsSUFBQUE7O0FBRzFDLE1BQUl1K0MsV0FBVyxTQUFTO0FBQ3RCeVksY0FBVS81RCxLQUFLb0UsTUFBTXMxRCxPQUFPNzNDLE9BQVdBLElBQUFBO0FBQ3ZDbTRDLGNBQVVoNkQsS0FBSzA0QixLQUFLaWhDLE9BQU85M0MsT0FBV0EsSUFBQUE7U0FDakM7QUFDTGs0QyxjQUFVTDtBQUNWTSxjQUFVTDs7QUFHWixNQUFJenVELGNBQWNDLGNBQWNtNEIsUUFBUTQyQixhQUFhOTNELE1BQU1uQyxPQUFPcWpDLE1BQU16aEIsVUFBVSxHQUFPLEdBQUE7QUFLdkZvNEMsZ0JBQVlqNkQsS0FBS2c0QixNQUFNaDRCLEtBQUtDLEtBQUttQyxNQUFNbkMsT0FBTzRoQixTQUFTdzNDLFFBQUFBLENBQUFBO0FBQ3ZEeDNDLGVBQVd6ZixNQUFNbkMsT0FBT2c2RDtBQUN4QkYsY0FBVTk1RDtBQUNWKzVELGNBQVU1M0Q7RUFDWixXQUFXdzNELGNBQWM7QUFJdkJHLGNBQVU3dUQsYUFBYWpMLE1BQU04NUQ7QUFDN0JDLGNBQVU3dUQsYUFBYS9JLE1BQU00M0Q7QUFDN0JDLGdCQUFZL25ELFFBQVE7QUFDcEIyUCxlQUFXbTRDLFVBQVVELFdBQVdFO1NBQzNCO0FBRUxBLGlCQUFhRCxVQUFVRCxXQUFXbDRDO0FBR2xDLFFBQUlzNEMsYUFBYUYsV0FBV2o2RCxLQUFLZzRCLE1BQU1paUMsU0FBQUEsR0FBWXA0QyxVQUFVLEdBQU8sR0FBQTtBQUNsRW80QyxrQkFBWWo2RCxLQUFLZzRCLE1BQU1paUMsU0FBQUE7V0FDbEI7QUFDTEEsa0JBQVlqNkQsS0FBSzA0QixLQUFLdWhDLFNBQUFBOzs7QUFNMUIsUUFBTUcsZ0JBQWdCcDZELEtBQUtvQyxJQUN6Qmk0RCxlQUFleDRDLE9BQUFBLEdBQ2Z3NEMsZUFBZU4sT0FBQUEsQ0FBQUE7QUFFakJoM0QsV0FBUy9DLEtBQUtnckIsSUFBSSxJQUFJOVIsY0FBY2tnRCxTQUFBQSxJQUFhZ0IsZ0JBQWdCaEIsU0FBUztBQUMxRVcsWUFBVS81RCxLQUFLZzRCLE1BQU0raEMsVUFBVWgzRCxNQUFVQSxJQUFBQTtBQUN6Q2kzRCxZQUFVaDZELEtBQUtnNEIsTUFBTWdpQyxVQUFVajNELE1BQVVBLElBQUFBO0FBRXpDLE1BQUl3bkIsSUFBSTtBQUNSLE1BQUlyZixZQUFZO0FBQ2QsUUFBSXF1RCxpQkFBaUJRLFlBQVk5NUQsS0FBSztBQUNwQ3lZLFlBQU01VyxLQUFLO1FBQUN3RixPQUFPckg7TUFBRyxDQUFBO0FBRXRCLFVBQUk4NUQsVUFBVTk1RCxLQUFLO0FBQ2pCc3FCOztBQUdGLFVBQUk0dkMsYUFBYW42RCxLQUFLZzRCLE9BQU8raEMsVUFBVXh2QyxJQUFJMUksV0FBVzllLE1BQUFBLElBQVVBLFFBQVE5QyxLQUFLcTZELGtCQUFrQnI2RCxLQUFLNDVELFlBQVlaLGlCQUFxQixDQUFBLEdBQUE7QUFDbkkxdUM7O2VBRU93dkMsVUFBVTk1RCxLQUFLO0FBQ3hCc3FCOzs7QUFJSixTQUFPQSxJQUFJMHZDLFdBQVcsRUFBRTF2QyxHQUFHO0FBQ3pCLFVBQU1nd0MsWUFBWXY2RCxLQUFLZzRCLE9BQU8raEMsVUFBVXh2QyxJQUFJMUksV0FBVzllLE1BQVVBLElBQUFBO0FBQ2pFLFFBQUlvSSxjQUFjb3ZELFlBQVluNEQsS0FBSztBQUNqQzs7QUFFRnNXLFVBQU01VyxLQUFLO01BQUN3RixPQUFPaXpEO0lBQVMsQ0FBQTtFQUM5QjtBQUVBLE1BQUlwdkQsY0FBY291RCxpQkFBaUJTLFlBQVk1M0QsS0FBSztBQUVsRCxRQUFJc1csTUFBTTdYLFVBQVVzNUQsYUFBYXpoRCxNQUFNQSxNQUFNN1gsU0FBUyxDQUFBLEVBQUd5RyxPQUFPbEYsS0FBS2s0RCxrQkFBa0JsNEQsS0FBS3kzRCxZQUFZWixpQkFBcUIsQ0FBQSxHQUFBO0FBQzNIdmdELFlBQU1BLE1BQU03WCxTQUFTLENBQUUsRUFBQ3lHLFFBQVFsRjtXQUMzQjtBQUNMc1csWUFBTTVXLEtBQUs7UUFBQ3dGLE9BQU9sRjtNQUFHLENBQUE7O0VBRTFCLFdBQVcsQ0FBQytJLGNBQWM2dUQsWUFBWTUzRCxLQUFLO0FBQ3pDc1csVUFBTTVXLEtBQUs7TUFBQ3dGLE9BQU8weUQ7SUFBTyxDQUFBOztBQUc1QixTQUFPdGhEO0FBQ1Q7QUFFQSxTQUFTNGhELGtCQUFrQmh6RCxPQUFPdXlELFlBQVksRUFBQ3AvQyxZQUFZdWtCLFlBQVcsR0FBRztBQUN2RSxRQUFNdzdCLE1BQU1oNUMsVUFBVXdkLFdBQUFBO0FBQ3RCLFFBQU0vbEIsU0FBU3dCLGFBQWF6YSxLQUFLc2dCLElBQUlrNkMsR0FBQUEsSUFBT3g2RCxLQUFLb2dCLElBQUlvNkMsR0FBQUEsTUFBUztBQUM5RCxRQUFNMzVELFNBQVMsT0FBT2c1RCxjQUFjLEtBQUt2eUQsT0FBT3pHO0FBQ2hELFNBQU9iLEtBQUtDLElBQUk0NUQsYUFBYTVnRCxPQUFPcFksTUFBQUE7QUFDdEM7QUFFZSxJQUFNNDVELGtCQUFOLGNBQThCei9CLE1BQUFBO0VBRTNDcDhCLFlBQVk2RSxLQUFLO0FBQ2YsVUFBTUEsR0FBQUE7QUFHTixTQUFLdkQsUUFBUWhCO0FBRWIsU0FBSytJLE1BQU0vSTtBQUVYLFNBQUswNUQsY0FBYzE1RDtBQUVuQixTQUFLdzdELFlBQVl4N0Q7QUFDakIsU0FBSzI1RCxjQUFjO0VBQ3JCO0VBRUE1bUQsTUFBTTNFLEtBQUtoRSxRQUFPO0FBQ2hCLFFBQUk0UCxjQUFjNUwsR0FBTSxHQUFBO0FBQ3RCLGFBQU87O0FBRVQsU0FBSyxPQUFPQSxRQUFRLFlBQVlBLGVBQWVsQyxXQUFXLENBQUNyQixTQUFTLENBQUN1RCxHQUFNLEdBQUE7QUFDekUsYUFBTzs7QUFHVCxXQUFPLENBQUNBO0VBQ1Y7RUFFQXF0RCx5QkFBeUI7QUFDdkIsVUFBTSxFQUFDMzdDLFlBQVcsSUFBSSxLQUFLcFk7QUFDM0IsVUFBTSxFQUFDc0UsWUFBWUMsV0FBQUEsSUFBYyxLQUFLRixjQUFhO0FBQ25ELFFBQUksRUFBQ2hMLEtBQUttQyxJQUFHLElBQUk7QUFFakIsVUFBTXc0RCxTQUFTdi9DLENBQUFBLE1BQU1wYixNQUFNaUwsYUFBYWpMLE1BQU1vYjtBQUM5QyxVQUFNdy9DLFNBQVN4L0MsQ0FBQUEsTUFBTWpaLE1BQU0rSSxhQUFhL0ksTUFBTWlaO0FBRTlDLFFBQUkyRCxhQUFhO0FBQ2YsWUFBTTg3QyxVQUFVOXdELEtBQUsvSixHQUFBQTtBQUNyQixZQUFNODZELFVBQVUvd0QsS0FBSzVILEdBQUFBO0FBRXJCLFVBQUkwNEQsVUFBVSxLQUFLQyxVQUFVLEdBQUc7QUFDOUJGLGVBQU8sQ0FBQTtNQUNULFdBQVdDLFVBQVUsS0FBS0MsVUFBVSxHQUFHO0FBQ3JDSCxlQUFPLENBQUE7OztBQUlYLFFBQUkzNkQsUUFBUW1DLEtBQUs7QUFDZixVQUFJeWMsU0FBU3pjLFFBQVEsSUFBSSxJQUFJcEMsS0FBS3dZLElBQUlwVyxNQUFNLElBQUs7QUFFakR5NEQsYUFBT3o0RCxNQUFNeWMsTUFBQUE7QUFFYixVQUFJLENBQUNHLGFBQWE7QUFDaEI0N0MsZUFBTzM2RCxNQUFNNGUsTUFBQUE7OztBQUdqQixTQUFLNWUsTUFBTUE7QUFDWCxTQUFLbUMsTUFBTUE7RUFDYjtFQUVBNDRELGVBQWU7QUFDYixVQUFNL2pDLFdBQVcsS0FBS3J3QixRQUFROFI7QUFFOUIsUUFBSSxFQUFDMmUsZUFBZTRqQyxTQUFBQSxJQUFZaGtDO0FBQ2hDLFFBQUlvaUM7QUFFSixRQUFJNEIsVUFBVTtBQUNaNUIsaUJBQVdyNUQsS0FBSzA0QixLQUFLLEtBQUt0MkIsTUFBTTY0RCxRQUFZajdELElBQUFBLEtBQUtvRSxNQUFNLEtBQUtuRSxNQUFNZzdELFFBQVksSUFBQTtBQUM5RSxVQUFJNUIsV0FBVyxLQUFNO0FBQ25CN3BELGdCQUFRQyxLQUFLLFVBQVUsS0FBS3pFLEVBQUUsb0JBQW9CaXdELFFBQVMsa0NBQWlDNUIsUUFBQUEsMkJBQW1DO0FBQy9IQSxtQkFBVzs7V0FFUjtBQUNMQSxpQkFBVyxLQUFLNkIsaUJBQWdCO0FBQ2hDN2pDLHNCQUFnQkEsaUJBQWlCOztBQUduQyxRQUFJQSxlQUFlO0FBQ2pCZ2lDLGlCQUFXcjVELEtBQUtDLElBQUlvM0IsZUFBZWdpQyxRQUFBQTs7QUFHckMsV0FBT0E7RUFDVDtFQUtBNkIsbUJBQW1CO0FBQ2pCLFdBQU85dkQsT0FBT0U7RUFDaEI7RUFFQW15QixhQUFhO0FBQ1gsVUFBTTExQixPQUFPLEtBQUtuQjtBQUNsQixVQUFNcXdCLFdBQVdsdkIsS0FBSzJRO0FBTXRCLFFBQUkyZ0QsV0FBVyxLQUFLMkIsYUFBWTtBQUNoQzNCLGVBQVdyNUQsS0FBS29DLElBQUksR0FBR2kzRCxRQUFBQTtBQUV2QixVQUFNOEIsMEJBQTBCO01BQzlCOUI7TUFDQS9YLFFBQVF2NUMsS0FBS3U1QztNQUNicmhELEtBQUs4SCxLQUFLOUg7TUFDVm1DLEtBQUsyRixLQUFLM0Y7TUFDVmczRCxXQUFXbmlDLFNBQVNtaUM7TUFDcEI5MUIsTUFBTXJNLFNBQVNna0M7TUFDZi9vRCxPQUFPK2tCLFNBQVMva0I7TUFDaEJvbkQsV0FBVyxLQUFLcHlCLFdBQVU7TUFDMUJ6c0IsWUFBWSxLQUFLRixhQUFZO01BQzdCeWtCLGFBQWEvSCxTQUFTK0gsZUFBZTtNQUNyQ3U2QixlQUFldGlDLFNBQVNzaUMsa0JBQWtCO0lBQzVDO0FBQ0EsVUFBTUwsWUFBWSxLQUFLMzlCLFVBQVU7QUFDakMsVUFBTTdpQixRQUFRc2dELGdCQUFjbUMseUJBQXlCakMsU0FBQUE7QUFJckQsUUFBSW54RCxLQUFLdTVDLFdBQVcsU0FBUztBQUMzQjhaLHlCQUFtQjFpRCxPQUFPLE1BQU0sT0FBQTs7QUFHbEMsUUFBSTNRLEtBQUtDLFNBQVM7QUFDaEIwUSxZQUFNMVEsUUFBTztBQUViLFdBQUs5SCxRQUFRLEtBQUtrQztBQUNsQixXQUFLNkYsTUFBTSxLQUFLaEk7V0FDWDtBQUNMLFdBQUtDLFFBQVEsS0FBS0Q7QUFDbEIsV0FBS2dJLE1BQU0sS0FBSzdGOztBQUdsQixXQUFPc1c7RUFDVDtFQUtBOVMsWUFBWTtBQUNWLFVBQU04UyxRQUFRLEtBQUtBO0FBQ25CLFFBQUl4WSxRQUFRLEtBQUtEO0FBQ2pCLFFBQUlnSSxNQUFNLEtBQUs3RjtBQUVmLFVBQU13RCxVQUFTO0FBRWYsUUFBSSxLQUFLZ0IsUUFBUWlZLFVBQVVuRyxNQUFNN1gsUUFBUTtBQUN2QyxZQUFNZ2UsVUFBVTVXLE1BQU0vSCxTQUFTRixLQUFLb0MsSUFBSXNXLE1BQU03WCxTQUFTLEdBQUcsQ0FBSyxJQUFBO0FBQy9EWCxlQUFTMmU7QUFDVDVXLGFBQU80Vzs7QUFFVCxTQUFLKzVDLGNBQWMxNEQ7QUFDbkIsU0FBS3c2RCxZQUFZenlEO0FBQ2pCLFNBQUs0d0QsY0FBYzV3RCxNQUFNL0g7RUFDM0I7RUFFQTZULGlCQUFpQnpNLE9BQU87QUFDdEIsV0FBT2djLGFBQWFoYyxPQUFPLEtBQUtsSSxNQUFNd0gsUUFBUTJjLFFBQVEsS0FBSzNjLFFBQVE4UixNQUFNb1EsTUFBTTtFQUNqRjtBQUNGO0FDblRlLElBQU11eUMsY0FBTixjQUEwQlosZ0JBQUFBO0VBY3ZDcDlCLHNCQUFzQjtBQUNwQixVQUFNLEVBQUNwOUIsS0FBS21DLElBQUcsSUFBSSxLQUFLa1IsVUFBVSxJQUFJO0FBRXRDLFNBQUtyVCxNQUFNOEosZUFBUzlKLEdBQUFBLElBQU9BLE1BQU07QUFDakMsU0FBS21DLE1BQU0ySCxlQUFTM0gsR0FBQUEsSUFBT0EsTUFBTTtBQUdqQyxTQUFLdTRELHVCQUFzQjtFQUM3QjtFQU1BTyxtQkFBbUI7QUFDakIsVUFBTXpnRCxhQUFhLEtBQUtGLGFBQVk7QUFDcEMsVUFBTTFaLFNBQVM0WixhQUFhLEtBQUsyQixRQUFRLEtBQUtEO0FBQzlDLFVBQU02aUIsY0FBY3hkLFVBQVUsS0FBSzVhLFFBQVE4UixNQUFNc21CLFdBQVc7QUFDNUQsVUFBTS9sQixTQUFTd0IsYUFBYXphLEtBQUtzZ0IsSUFBSTBlLFdBQUFBLElBQWVoL0IsS0FBS29nQixJQUFJNGUsV0FBQUEsTUFBaUI7QUFDOUUsVUFBTW9DLFdBQVcsS0FBS0csd0JBQXdCLENBQUE7QUFDOUMsV0FBT3ZoQyxLQUFLMDRCLEtBQUs3M0IsU0FBU2IsS0FBS0MsSUFBSSxJQUFJbWhDLFNBQVM5RyxhQUFhcmhCLEtBQUFBLENBQUFBO0VBQy9EO0VBR0FSLGlCQUFpQm5SLE9BQU87QUFDdEIsV0FBT0EsVUFBVSxPQUFPK0wsTUFBTSxLQUFLeUssb0JBQW9CeFcsUUFBUSxLQUFLc3hELGVBQWUsS0FBS0MsV0FBVztFQUNyRztFQUVBNzZDLGlCQUFpQjRqQixPQUFPO0FBQ3RCLFdBQU8sS0FBS2czQixjQUFjLEtBQUs1MkIsbUJBQW1CSixLQUFBQSxJQUFTLEtBQUtpM0I7RUFDbEU7QUFDRjtBQTNDRSxjQUZtQndDLGFBRVpyd0QsTUFBSztBQUtaLGNBUG1CcXdELGFBT1pwMUQsWUFBVztFQUNoQnlTLE9BQU87SUFDTG1tQixVQUFVeThCLE1BQU1DLFdBQVdDO0VBQzdCOztBQ1JKLElBQU1DLGFBQWFwZ0QsQ0FBQUEsTUFBS3JiLEtBQUtvRSxNQUFNczNELE1BQU1yZ0QsQ0FBQUEsQ0FBQUE7QUFDekMsSUFBTXNnRCxpQkFBaUIsQ0FBQ3RnRCxHQUFHdWdELE1BQU01N0QsS0FBS2dyQixJQUFJLElBQUl5d0MsV0FBV3BnRCxDQUFLdWdELElBQUFBLENBQUFBO0FBRTlELFNBQVNDLFFBQVFDLFNBQVM7QUFDeEIsUUFBTTkyRCxTQUFTODJELFVBQVc5N0QsS0FBS2dyQixJQUFJLElBQUl5d0MsV0FBV0ssT0FBQUEsQ0FBQUE7QUFDbEQsU0FBTzkyRCxXQUFXO0FBQ3BCO0FBRUEsU0FBUysyRCxNQUFNOTdELEtBQUttQyxLQUFLNDVELFVBQVU7QUFDakMsUUFBTUMsWUFBWWo4RCxLQUFLZ3JCLElBQUksSUFBSWd4QyxRQUFBQTtBQUMvQixRQUFNOTdELFFBQVFGLEtBQUtvRSxNQUFNbkUsTUFBTWc4RCxTQUFBQTtBQUMvQixRQUFNaDBELE1BQU1qSSxLQUFLMDRCLEtBQUt0MkIsTUFBTTY1RCxTQUFBQTtBQUM1QixTQUFPaDBELE1BQU0vSDtBQUNmO0FBRUEsU0FBU2c4RCxTQUFTajhELEtBQUttQyxLQUFLO0FBQzFCLFFBQU0rUSxRQUFRL1EsTUFBTW5DO0FBQ3BCLE1BQUkrN0QsV0FBV1AsV0FBV3RvRCxLQUFBQTtBQUMxQixTQUFPNG9ELE1BQU05N0QsS0FBS21DLEtBQUs0NUQsUUFBQUEsSUFBWSxJQUFJO0FBQ3JDQTtFQUNGO0FBQ0EsU0FBT0QsTUFBTTk3RCxLQUFLbUMsS0FBSzQ1RCxRQUFBQSxJQUFZLElBQUk7QUFDckNBO0VBQ0Y7QUFDQSxTQUFPaDhELEtBQUtDLElBQUkrN0QsVUFBVVAsV0FBV3g3RCxHQUFBQSxDQUFBQTtBQUN2QztBQVNBLFNBQVMrNEQsY0FBY0MsbUJBQW1CLEVBQUNoNUQsS0FBS21DLElBQUcsR0FBRztBQUNwRG5DLFFBQU1xOEIsZ0JBQWdCMjhCLGtCQUFrQmg1RCxLQUFLQSxHQUFBQTtBQUM3QyxRQUFNeVksUUFBUSxDQUFBO0FBQ2QsUUFBTXlqRCxTQUFTVixXQUFXeDdELEdBQUFBO0FBQzFCLE1BQUltOEQsTUFBTUYsU0FBU2o4RCxLQUFLbUMsR0FBQUE7QUFDeEIsTUFBSWczRCxZQUFZZ0QsTUFBTSxJQUFJcDhELEtBQUtnckIsSUFBSSxJQUFJaHJCLEtBQUt3WSxJQUFJNGpELEdBQUFBLENBQUFBLElBQVE7QUFDeEQsUUFBTW5CLFdBQVdqN0QsS0FBS2dyQixJQUFJLElBQUlveEMsR0FBQUE7QUFDOUIsUUFBTTFoRCxPQUFPeWhELFNBQVNDLE1BQU1wOEQsS0FBS2dyQixJQUFJLElBQUlteEMsTUFBQUEsSUFBVTtBQUNuRCxRQUFNajhELFFBQVFGLEtBQUtnNEIsT0FBTy8zQixNQUFNeWEsUUFBUTArQyxTQUFhQSxJQUFBQTtBQUNyRCxRQUFNdjZDLFNBQVM3ZSxLQUFLb0UsT0FBT25FLE1BQU15YSxRQUFRdWdELFdBQVcsRUFBQSxJQUFNQSxXQUFXO0FBQ3JFLE1BQUlvQixjQUFjcjhELEtBQUtvRSxPQUFPbEUsUUFBUTJlLFVBQVU3ZSxLQUFLZ3JCLElBQUksSUFBSW94QyxHQUFBQSxDQUFBQTtBQUM3RCxNQUFJOTBELFFBQVFnMUIsZ0JBQWdCMjhCLGtCQUFrQmg1RCxLQUFLRCxLQUFLZzRCLE9BQU90ZCxPQUFPbUUsU0FBU3c5QyxjQUFjcjhELEtBQUtnckIsSUFBSSxJQUFJb3hDLEdBQUFBLEtBQVFoRCxTQUFhQSxJQUFBQSxTQUFBQTtBQUMvSCxTQUFPOXhELFFBQVFsRixLQUFLO0FBQ2xCc1csVUFBTTVXLEtBQUs7TUFBQ3dGO01BQU9pd0IsT0FBT3NrQyxRQUFRdjBELEtBQUFBO01BQVErMEQ7SUFBVyxDQUFBO0FBQ3JELFFBQUlBLGVBQWUsSUFBSTtBQUNyQkEsb0JBQWNBLGNBQWMsS0FBSyxLQUFLO1dBQ2pDO0FBQ0xBOztBQUVGLFFBQUlBLGVBQWUsSUFBSTtBQUNyQkQ7QUFDQUMsb0JBQWM7QUFDZGpELGtCQUFZZ0QsT0FBTyxJQUFJLElBQUloRDs7QUFFN0I5eEQsWUFBUXRILEtBQUtnNEIsT0FBT3RkLE9BQU9tRSxTQUFTdzlDLGNBQWNyOEQsS0FBS2dyQixJQUFJLElBQUlveEMsR0FBQUEsS0FBUWhELFNBQWFBLElBQUFBO0VBQ3RGO0FBQ0EsUUFBTWtELFdBQVdoZ0MsZ0JBQWdCMjhCLGtCQUFrQjcyRCxLQUFLa0YsS0FBQUE7QUFDeERvUixRQUFNNVcsS0FBSztJQUFDd0YsT0FBT2cxRDtJQUFVL2tDLE9BQU9za0MsUUFBUVMsUUFBQUE7SUFBV0Q7RUFBVyxDQUFBO0FBRWxFLFNBQU8zakQ7QUFDVDtBQUVlLElBQU02akQsbUJBQU4sY0FBK0J2aEMsTUFBQUE7RUFpQjVDcDhCLFlBQVk2RSxLQUFLO0FBQ2YsVUFBTUEsR0FBQUE7QUFHTixTQUFLdkQsUUFBUWhCO0FBRWIsU0FBSytJLE1BQU0vSTtBQUVYLFNBQUswNUQsY0FBYzE1RDtBQUNuQixTQUFLMjVELGNBQWM7RUFDckI7RUFFQTVtRCxNQUFNM0UsS0FBS2hFLFFBQU87QUFDaEIsVUFBTWhDLFFBQVFtekQsZ0JBQWdCOXhDLFVBQVUxVyxNQUFNaStDLE1BQU0sTUFBTTtNQUFDNWlEO01BQUtoRTtJQUFNLENBQUE7QUFDdEUsUUFBSWhDLFVBQVUsR0FBRztBQUNmLFdBQUtrMUQsUUFBUTtBQUNiLGFBQU90OUQ7O0FBRVQsV0FBTzZLLGVBQVN6QyxLQUFBQSxLQUFVQSxRQUFRLElBQUlBLFFBQVE7RUFDaEQ7RUFFQSsxQixzQkFBc0I7QUFDcEIsVUFBTSxFQUFDcDlCLEtBQUttQyxJQUFHLElBQUksS0FBS2tSLFVBQVUsSUFBSTtBQUV0QyxTQUFLclQsTUFBTThKLGVBQVM5SixHQUFBQSxJQUFPRCxLQUFLb0MsSUFBSSxHQUFHbkMsR0FBQUEsSUFBTztBQUM5QyxTQUFLbUMsTUFBTTJILGVBQVMzSCxHQUFBQSxJQUFPcEMsS0FBS29DLElBQUksR0FBR0EsR0FBQUEsSUFBTztBQUU5QyxRQUFJLEtBQUt3RSxRQUFRb1ksYUFBYTtBQUM1QixXQUFLdzlDLFFBQVE7O0FBS2YsUUFBSSxLQUFLQSxTQUFTLEtBQUt2OEQsUUFBUSxLQUFLODdCLGlCQUFpQixDQUFDaHlCLGVBQVMsS0FBSzh4QixRQUFRLEdBQUc7QUFDN0UsV0FBSzU3QixNQUFNQSxRQUFRMDdELGVBQWUsS0FBSzE3RCxLQUFLLENBQUswN0QsSUFBQUEsZUFBZSxLQUFLMTdELEtBQUssRUFBQyxJQUFLMDdELGVBQWUsS0FBSzE3RCxLQUFLLENBQUU7O0FBRzdHLFNBQUswNkQsdUJBQXNCO0VBQzdCO0VBRUFBLHlCQUF5QjtBQUN2QixVQUFNLEVBQUN6dkQsWUFBWUMsV0FBQUEsSUFBYyxLQUFLRixjQUFhO0FBQ25ELFFBQUloTCxNQUFNLEtBQUtBO0FBQ2YsUUFBSW1DLE1BQU0sS0FBS0E7QUFFZixVQUFNdzRELFNBQVN2L0MsQ0FBQUEsTUFBTXBiLE1BQU1pTCxhQUFhakwsTUFBTW9iO0FBQzlDLFVBQU13L0MsU0FBU3gvQyxDQUFBQSxNQUFNalosTUFBTStJLGFBQWEvSSxNQUFNaVo7QUFFOUMsUUFBSXBiLFFBQVFtQyxLQUFLO0FBQ2YsVUFBSW5DLE9BQU8sR0FBRztBQUNaMjZELGVBQU8sQ0FBQTtBQUNQQyxlQUFPLEVBQUE7YUFDRjtBQUNMRCxlQUFPZSxlQUFlMTdELEtBQUssRUFBQyxDQUFBO0FBQzVCNDZELGVBQU9jLGVBQWV2NUQsS0FBSyxDQUFDLENBQUE7OztBQUdoQyxRQUFJbkMsT0FBTyxHQUFHO0FBQ1oyNkQsYUFBT2UsZUFBZXY1RCxLQUFLLEVBQUMsQ0FBQTs7QUFFOUIsUUFBSUEsT0FBTyxHQUFHO0FBRVp5NEQsYUFBT2MsZUFBZTE3RCxLQUFLLENBQUMsQ0FBQTs7QUFHOUIsU0FBS0EsTUFBTUE7QUFDWCxTQUFLbUMsTUFBTUE7RUFDYjtFQUVBcTdCLGFBQWE7QUFDWCxVQUFNMTFCLE9BQU8sS0FBS25CO0FBRWxCLFVBQU1xeUQsb0JBQW9CO01BQ3hCaDVELEtBQUssS0FBSzQ3QjtNQUNWejVCLEtBQUssS0FBS3c1QjtJQUNaO0FBQ0EsVUFBTWxqQixRQUFRc2dELGNBQWNDLG1CQUFtQixJQUFJO0FBSW5ELFFBQUlseEQsS0FBS3U1QyxXQUFXLFNBQVM7QUFDM0I4Wix5QkFBbUIxaUQsT0FBTyxNQUFNLE9BQUE7O0FBR2xDLFFBQUkzUSxLQUFLQyxTQUFTO0FBQ2hCMFEsWUFBTTFRLFFBQU87QUFFYixXQUFLOUgsUUFBUSxLQUFLa0M7QUFDbEIsV0FBSzZGLE1BQU0sS0FBS2hJO1dBQ1g7QUFDTCxXQUFLQyxRQUFRLEtBQUtEO0FBQ2xCLFdBQUtnSSxNQUFNLEtBQUs3Rjs7QUFHbEIsV0FBT3NXO0VBQ1Q7RUFNQTNFLGlCQUFpQnpNLE9BQU87QUFDdEIsV0FBT0EsVUFBVXBJLFNBQ2IsTUFDQW9rQixhQUFhaGMsT0FBTyxLQUFLbEksTUFBTXdILFFBQVEyYyxRQUFRLEtBQUszYyxRQUFROFIsTUFBTW9RLE1BQU07RUFDOUU7RUFLQWxqQixZQUFZO0FBQ1YsVUFBTTFGLFFBQVEsS0FBS0Q7QUFFbkIsVUFBTTJGLFVBQVM7QUFFZixTQUFLZ3pELGNBQWM4QyxNQUFNeDdELEtBQUFBO0FBQ3pCLFNBQUsyNEQsY0FBYzZDLE1BQU0sS0FBS3Q1RCxHQUFHLElBQUlzNUQsTUFBTXg3RCxLQUFBQTtFQUM3QztFQUVBdVksaUJBQWlCblIsT0FBTztBQUN0QixRQUFJQSxVQUFVcEksVUFBYW9JLFVBQVUsR0FBRztBQUN0Q0EsY0FBUSxLQUFLckg7O0FBRWYsUUFBSXFILFVBQVUsUUFBUXVWLE1BQU12VixLQUFRLEdBQUE7QUFDbEMsYUFBTytMOztBQUVULFdBQU8sS0FBS3lLLG1CQUFtQnhXLFVBQVUsS0FBS3JILE1BQzFDLEtBQ0N5N0QsTUFBTXAwRCxLQUFBQSxJQUFTLEtBQUtzeEQsZUFBZSxLQUFLQyxXQUFXO0VBQzFEO0VBRUE3NkMsaUJBQWlCNGpCLE9BQU87QUFDdEIsVUFBTUMsVUFBVSxLQUFLRyxtQkFBbUJKLEtBQUFBO0FBQ3hDLFdBQU81aEMsS0FBS2dyQixJQUFJLElBQUksS0FBSzR0QyxjQUFjLzJCLFVBQVUsS0FBS2czQixXQUFXO0VBQ25FO0FBQ0Y7QUF0SkUsY0FGbUIwRCxrQkFFWnZ4RCxNQUFLO0FBS1osY0FQbUJ1eEQsa0JBT1p0MkQsWUFBVztFQUNoQnlTLE9BQU87SUFDTG1tQixVQUFVeThCLE1BQU1DLFdBQVdrQjtJQUMzQmxsQyxPQUFPO01BQ0xDLFNBQVM7SUFDWDtFQUNGOztBQzlFSixTQUFTa2xDLHNCQUFzQjMwRCxNQUFNO0FBQ25DLFFBQU1rdkIsV0FBV2x2QixLQUFLMlE7QUFFdEIsTUFBSXVlLFNBQVN2UCxXQUFXM2YsS0FBSzJmLFNBQVM7QUFDcEMsVUFBTTRJLFVBQVVPLFVBQVVvRyxTQUFTbU8sZUFBZTtBQUNsRCxXQUFPcjFCLGVBQWVrbkIsU0FBU2tELFFBQVFsRCxTQUFTa0QsS0FBSzV5QixNQUFNdEIsU0FBU2swQixLQUFLNXlCLElBQUksSUFBSStvQixRQUFRblU7O0FBRTNGLFNBQU87QUFDVDtBQUVBLFNBQVN3Z0QsaUJBQWlCeHVELEtBQUtnc0IsTUFBTXJtQixPQUFPO0FBQzFDQSxVQUFRdk4sUUFBUXVOLEtBQUFBLElBQVNBLFFBQVE7SUFBQ0E7RUFBTTtBQUN4QyxTQUFPO0lBQ0xxYixHQUFHeXRDLGFBQWF6dUQsS0FBS2dzQixLQUFLcUgsUUFBUTF0QixLQUFBQTtJQUNsQ3ViLEdBQUd2YixNQUFNalQsU0FBU3M1QixLQUFLRztFQUN6QjtBQUNGO0FBRUEsU0FBU3VpQyxnQkFBZ0JuOEMsT0FBT2lNLEtBQUtwbEIsTUFBTXRILEtBQUttQyxLQUFLO0FBQ25ELE1BQUlzZSxVQUFVemdCLE9BQU95Z0IsVUFBVXRlLEtBQUs7QUFDbEMsV0FBTztNQUNMbEMsT0FBT3lzQixNQUFPcGxCLE9BQU87TUFDckJVLEtBQUswa0IsTUFBT3BsQixPQUFPO0lBQ3JCO0VBQ0YsV0FBV21aLFFBQVF6Z0IsT0FBT3lnQixRQUFRdGUsS0FBSztBQUNyQyxXQUFPO01BQ0xsQyxPQUFPeXNCLE1BQU1wbEI7TUFDYlUsS0FBSzBrQjtJQUNQOztBQUdGLFNBQU87SUFDTHpzQixPQUFPeXNCO0lBQ1Axa0IsS0FBSzBrQixNQUFNcGxCO0VBQ2I7QUFDRjtBQUtBLFNBQVN1MUQsbUJBQW1CajFELE9BQU87QUE4QmpDLFFBQU1xVCxPQUFPO0lBQ1huUyxHQUFHbEIsTUFBTWEsT0FBT2IsTUFBTW9uRCxTQUFTdm1EO0lBQy9CRyxHQUFHaEIsTUFBTVcsUUFBUVgsTUFBTW9uRCxTQUFTem1EO0lBQ2hDSSxHQUFHZixNQUFNVSxNQUFNVixNQUFNb25ELFNBQVMxbUQ7SUFDOUJPLEdBQUdqQixNQUFNWSxTQUFTWixNQUFNb25ELFNBQVN4bUQ7RUFDbkM7QUFDQSxRQUFNczBELFNBQVNoM0QsT0FBT3lCLE9BQU8sQ0FBQSxHQUFJMFQsSUFBQUE7QUFDakMsUUFBTW1rQixhQUFhLENBQUE7QUFDbkIsUUFBTS9PLFVBQVUsQ0FBQTtBQUNoQixRQUFNMHNDLGFBQWFuMUQsTUFBTW8xRCxhQUFhcDhEO0FBQ3RDLFFBQU1xOEQsaUJBQWlCcjFELE1BQU1qQixRQUFRZ2hCO0FBQ3JDLFFBQU11MUMsa0JBQWtCRCxlQUFlRSxvQkFBb0JuOEMsS0FBSys3QyxhQUFhO0FBRTdFLFdBQVNsOEQsSUFBSSxHQUFHQSxJQUFJazhELFlBQVlsOEQsS0FBSztBQUNuQyxVQUFNaUgsT0FBT20xRCxlQUFlL2dDLFdBQVd0MEIsTUFBTXcxRCxxQkFBcUJ2OEQsQ0FBQUEsQ0FBQUE7QUFDbEV3dkIsWUFBUXh2QixDQUFBQSxJQUFLaUgsS0FBS3VvQjtBQUNsQixVQUFNdEksZ0JBQWdCbmdCLE1BQU15MUQsaUJBQWlCeDhELEdBQUcrRyxNQUFNMDFELGNBQWNqdEMsUUFBUXh2QixDQUFBQSxHQUFJcThELGVBQUFBO0FBQ2hGLFVBQU1LLFNBQVNwakMsT0FBT3J5QixLQUFLb3lCLElBQUk7QUFDL0IsVUFBTSswQixXQUFXeU4saUJBQWlCOTBELE1BQU1zRyxLQUFLcXZELFFBQVEzMUQsTUFBTW8xRCxhQUFhbjhELENBQUUsQ0FBQTtBQUMxRXUrQixlQUFXditCLENBQUFBLElBQUtvdUQ7QUFFaEIsVUFBTS91QixlQUFlbVksZ0JBQWdCendDLE1BQU11ZixjQUFjdG1CLENBQUtxOEQsSUFBQUEsZUFBQUE7QUFDOUQsVUFBTXo4QyxRQUFRMWdCLEtBQUtnNEIsTUFBTTZILFVBQVVNLFlBQUFBLENBQUFBO0FBQ25DLFVBQU1zOUIsVUFBVVosZ0JBQWdCbjhDLE9BQU9zSCxjQUFjM2YsR0FBRzZtRCxTQUFTLy9CLEdBQUcsR0FBRyxHQUFBO0FBQ3ZFLFVBQU11dUMsVUFBVWIsZ0JBQWdCbjhDLE9BQU9zSCxjQUFjMWYsR0FBRzRtRCxTQUFTNy9CLEdBQUcsSUFBSSxHQUFBO0FBQ3hFc3VDLGlCQUFhWixRQUFRN2hELE1BQU1pbEIsY0FBY3M5QixTQUFTQyxPQUFBQTtFQUNwRDtBQUVBNzFELFFBQU0rMUQsZUFDSjFpRCxLQUFLblMsSUFBSWcwRCxPQUFPaDBELEdBQ2hCZzBELE9BQU9sMEQsSUFBSXFTLEtBQUtyUyxHQUNoQnFTLEtBQUt0UyxJQUFJbTBELE9BQU9uMEQsR0FDaEJtMEQsT0FBT2owRCxJQUFJb1MsS0FBS3BTLENBQUM7QUFJbkJqQixRQUFNZzJELG1CQUFtQkMscUJBQXFCajJELE9BQU93M0IsWUFBWS9PLE9BQUFBO0FBQ25FO0FBRUEsU0FBU3F0QyxhQUFhWixRQUFRN2hELE1BQU13RixPQUFPKzhDLFNBQVNDLFNBQVM7QUFDM0QsUUFBTXA5QyxNQUFNdGdCLEtBQUt3WSxJQUFJeFksS0FBS3NnQixJQUFJSSxLQUFBQSxDQUFBQTtBQUM5QixRQUFNTixNQUFNcGdCLEtBQUt3WSxJQUFJeFksS0FBS29nQixJQUFJTSxLQUFBQSxDQUFBQTtBQUM5QixNQUFJclksSUFBSTtBQUNSLE1BQUlDLElBQUk7QUFDUixNQUFJbTFELFFBQVF2OUQsUUFBUWdiLEtBQUtuUyxHQUFHO0FBQzFCVixTQUFLNlMsS0FBS25TLElBQUkwMEQsUUFBUXY5RCxTQUFTb2dCO0FBQy9CeThDLFdBQU9oMEQsSUFBSS9JLEtBQUtDLElBQUk4OEQsT0FBT2gwRCxHQUFHbVMsS0FBS25TLElBQUlWLENBQUFBO0VBQ3pDLFdBQVdvMUQsUUFBUXgxRCxNQUFNaVQsS0FBS3JTLEdBQUc7QUFDL0JSLFNBQUtvMUQsUUFBUXgxRCxNQUFNaVQsS0FBS3JTLEtBQUt5WDtBQUM3Qnk4QyxXQUFPbDBELElBQUk3SSxLQUFLb0MsSUFBSTI2RCxPQUFPbDBELEdBQUdxUyxLQUFLclMsSUFBSVIsQ0FBQUE7O0FBRXpDLE1BQUlxMUQsUUFBUXg5RCxRQUFRZ2IsS0FBS3RTLEdBQUc7QUFDMUJOLFNBQUs0UyxLQUFLdFMsSUFBSTgwRCxRQUFReDlELFNBQVNrZ0I7QUFDL0IyOEMsV0FBT24wRCxJQUFJNUksS0FBS0MsSUFBSTg4RCxPQUFPbjBELEdBQUdzUyxLQUFLdFMsSUFBSU4sQ0FBQUE7RUFDekMsV0FBV28xRCxRQUFRejFELE1BQU1pVCxLQUFLcFMsR0FBRztBQUMvQlIsU0FBS28xRCxRQUFRejFELE1BQU1pVCxLQUFLcFMsS0FBS3NYO0FBQzdCMjhDLFdBQU9qMEQsSUFBSTlJLEtBQUtvQyxJQUFJMjZELE9BQU9qMEQsR0FBR29TLEtBQUtwUyxJQUFJUixDQUFBQTs7QUFFM0M7QUFFQSxTQUFTeTFELHFCQUFxQmwyRCxPQUFPeUIsUUFBTzAwRCxVQUFVO0FBQ3BELFFBQU1DLGdCQUFnQnAyRCxNQUFNMDFEO0FBQzVCLFFBQU0sRUFBQ1csT0FBT2YsaUJBQWlCN3NDLFNBQVMvb0IsS0FBSSxJQUFJeTJEO0FBQ2hELFFBQU1HLHFCQUFxQnQyRCxNQUFNeTFELGlCQUFpQmgwRCxRQUFPMjBELGdCQUFnQkMsUUFBUTV0QyxTQUFTNnNDLGVBQUFBO0FBQzFGLFFBQU16OEMsUUFBUTFnQixLQUFLZzRCLE1BQU02SCxVQUFVeVksZ0JBQWdCNmxCLG1CQUFtQno5QyxRQUFRSyxPQUFBQSxDQUFBQSxDQUFBQTtBQUM5RSxRQUFNelksSUFBSTgxRCxVQUFVRCxtQkFBbUI3MUQsR0FBR2YsS0FBSzhuQixHQUFHM08sS0FBQUE7QUFDbEQsUUFBTTBqQixZQUFZaTZCLHFCQUFxQjM5QyxLQUFBQTtBQUN2QyxRQUFNaFksT0FBTzQxRCxpQkFBaUJILG1CQUFtQjkxRCxHQUFHZCxLQUFLNG5CLEdBQUdpVixTQUFBQTtBQUM1RCxTQUFPO0lBRUwrUCxTQUFTO0lBR1Q5ckMsR0FBRzgxRCxtQkFBbUI5MUQ7SUFDdEJDO0lBR0E4N0I7SUFHQTE3QjtJQUNBSCxLQUFLRDtJQUNMRSxPQUFPRSxPQUFPbkIsS0FBSzRuQjtJQUNuQjFtQixRQUFRSCxJQUFJZixLQUFLOG5CO0VBQ25CO0FBQ0Y7QUFFQSxTQUFTa3ZDLGdCQUFnQnY5RCxNQUFNbVQsTUFBTTtBQUNuQyxNQUFJLENBQUNBLE1BQU07QUFDVCxXQUFPOztBQUVULFFBQU0sRUFBQ3pMLE1BQU1ILEtBQUtDLE9BQU9DLE9BQU0sSUFBSXpIO0FBQ25DLFFBQU13OUQsZUFBZWx6QyxlQUFlO0lBQUNqakIsR0FBR0s7SUFBTUosR0FBR0M7RUFBRyxHQUFHNEwsSUFBQUEsS0FBU21YLGVBQWU7SUFBQ2pqQixHQUFHSztJQUFNSixHQUFHRztFQUFNLEdBQUcwTCxJQUFBQSxLQUNuR21YLGVBQWU7SUFBQ2pqQixHQUFHRztJQUFPRixHQUFHQztFQUFHLEdBQUc0TCxJQUFBQSxLQUFTbVgsZUFBZTtJQUFDampCLEdBQUdHO0lBQU9GLEdBQUdHO0tBQVMwTCxJQUFBQTtBQUNwRixTQUFPLENBQUNxcUQ7QUFDVjtBQUVBLFNBQVNWLHFCQUFxQmoyRCxPQUFPdzNCLFlBQVkvTyxTQUFTO0FBQ3hELFFBQU0xdkIsUUFBUSxDQUFBO0FBQ2QsUUFBTW84RCxhQUFhbjFELE1BQU1vMUQsYUFBYXA4RDtBQUN0QyxRQUFNa0gsT0FBT0YsTUFBTWpCO0FBQ25CLFFBQU0sRUFBQ3cyRCxtQkFBbUIxMUMsUUFBQUEsSUFBVzNmLEtBQUs2ZjtBQUMxQyxRQUFNbzJDLFdBQVc7SUFDZkUsT0FBT3hCLHNCQUFzQjMwRCxJQUFRLElBQUE7SUFDckNvMUQsaUJBQWlCQyxvQkFBb0JuOEMsS0FBSys3QyxhQUFhO0VBQ3pEO0FBQ0EsTUFBSTdvRDtBQUVKLFdBQVNyVCxJQUFJLEdBQUdBLElBQUlrOEQsWUFBWWw4RCxLQUFLO0FBQ25DazlELGFBQVMxdEMsVUFBVUEsUUFBUXh2QixDQUFFO0FBQzdCazlELGFBQVN6MkQsT0FBTzgzQixXQUFXditCLENBQUU7QUFFN0IsVUFBTUUsT0FBTys4RCxxQkFBcUJsMkQsT0FBTy9HLEdBQUdrOUQsUUFBQUE7QUFDNUNwOUQsVUFBTWtCLEtBQUtkLElBQUFBO0FBQ1gsUUFBSTBtQixZQUFZLFFBQVE7QUFDdEIxbUIsV0FBS216QyxVQUFVb3FCLGdCQUFnQnY5RCxNQUFNbVQsSUFBQUE7QUFDckMsVUFBSW5ULEtBQUttekMsU0FBUztBQUNoQmhnQyxlQUFPblQ7OztFQUdiO0FBQ0EsU0FBT0o7QUFDVDtBQUVBLFNBQVN5OUQscUJBQXFCMzlDLE9BQU87QUFDbkMsTUFBSUEsVUFBVSxLQUFLQSxVQUFVLEtBQUs7QUFDaEMsV0FBTzthQUNFQSxRQUFRLEtBQUs7QUFDdEIsV0FBTzs7QUFHVCxTQUFPO0FBQ1Q7QUFFQSxTQUFTNDlDLGlCQUFpQmoyRCxHQUFHOG1CLEdBQUc0SixPQUFPO0FBQ3JDLE1BQUlBLFVBQVUsU0FBUztBQUNyQjF3QixTQUFLOG1CO2FBQ0k0SixVQUFVLFVBQVU7QUFDN0Ixd0IsU0FBTThtQixJQUFJOztBQUVaLFNBQU85bUI7QUFDVDtBQUVBLFNBQVMrMUQsVUFBVTkxRCxHQUFHK21CLEdBQUczTyxPQUFPO0FBQzlCLE1BQUlBLFVBQVUsTUFBTUEsVUFBVSxLQUFLO0FBQ2pDcFksU0FBTSttQixJQUFJO0VBQ1osV0FBVzNPLFFBQVEsT0FBT0EsUUFBUSxJQUFJO0FBQ3BDcFksU0FBSyttQjs7QUFFUCxTQUFPL21CO0FBQ1Q7QUFFQSxTQUFTbTJELGtCQUFrQnR3RCxLQUFLcEcsTUFBTS9HLE1BQU07QUFDMUMsUUFBTSxFQUFDMEgsTUFBTUgsS0FBS0MsT0FBT0MsT0FBTSxJQUFJekg7QUFDbkMsUUFBTSxFQUFDcWtDLGNBQWEsSUFBSXQ5QjtBQUV4QixNQUFJLENBQUNtUixjQUFjbXNCLGFBQWdCLEdBQUE7QUFDakMsVUFBTThULGVBQWUySCxjQUFjLzRDLEtBQUtveEMsWUFBWTtBQUNwRCxVQUFNN29CLFVBQVVPLFVBQVU5b0IsS0FBS3E5QixlQUFlO0FBQzlDajNCLFFBQUl1VyxZQUFZMmdCO0FBRWhCLFVBQU1xNUIsZUFBZWgyRCxPQUFPNG5CLFFBQVE1bkI7QUFDcEMsVUFBTWkyRCxjQUFjcDJELE1BQU0rbkIsUUFBUS9uQjtBQUNsQyxVQUFNcTJELGdCQUFnQnAyRCxRQUFRRSxPQUFPNG5CLFFBQVFsVTtBQUM3QyxVQUFNeWlELGlCQUFpQnAyRCxTQUFTRixNQUFNK25CLFFBQVFuVTtBQUU5QyxRQUFJcFcsT0FBT1csT0FBT3l5QyxZQUFBQSxFQUFjNU4sS0FBS2x3QixDQUFBQSxNQUFLQSxNQUFNLENBQUksR0FBQTtBQUNsRGxOLFVBQUkrM0IsVUFBUztBQUNiZ2MseUJBQW1CL3pDLEtBQUs7UUFDdEI5RixHQUFHcTJEO1FBQ0hwMkQsR0FBR3EyRDtRQUNIeHZDLEdBQUd5dkM7UUFDSHZ2QyxHQUFHd3ZDO1FBQ0gzL0MsUUFBUWk2QjtNQUNWLENBQUE7QUFDQWhyQyxVQUFJbUIsS0FBSTtXQUNIO0FBQ0xuQixVQUFJdTNCLFNBQVNnNUIsY0FBY0MsYUFBYUMsZUFBZUMsY0FBQUE7OztBQUc3RDtBQUVBLFNBQVNDLGdCQUFnQmozRCxPQUFPMnJELFlBQVk7QUFDMUMsUUFBTSxFQUFDcmxELEtBQUt2SCxTQUFTLEVBQUNnaEIsWUFBVyxFQUFDLElBQUkvZjtBQUV0QyxXQUFTL0csSUFBSTB5RCxhQUFhLEdBQUcxeUQsS0FBSyxHQUFHQSxLQUFLO0FBQ3hDLFVBQU1FLE9BQU82RyxNQUFNZzJELGlCQUFpQi84RCxDQUFFO0FBQ3RDLFFBQUksQ0FBQ0UsS0FBS216QyxTQUFTO0FBRWpCOztBQUVGLFVBQU01USxjQUFjM2IsWUFBWXVVLFdBQVd0MEIsTUFBTXcxRCxxQkFBcUJ2OEQsQ0FBQUEsQ0FBQUE7QUFDdEUyOUQsc0JBQWtCdHdELEtBQUtvMUIsYUFBYXZpQyxJQUFBQTtBQUNwQyxVQUFNdzhELFNBQVNwakMsT0FBT21KLFlBQVlwSixJQUFJO0FBQ3RDLFVBQU0sRUFBQzl4QixHQUFHQyxHQUFHODdCLFVBQUFBLElBQWFwakM7QUFFMUI0bEMsZUFDRXo0QixLQUNBdEcsTUFBTW8xRCxhQUFhbjhELENBQUUsR0FDckJ1SCxHQUNBQyxJQUFLazFELE9BQU9sakMsYUFBYSxHQUN6QmtqQyxRQUNBO01BQ0V4NkQsT0FBT3VnQyxZQUFZdmdDO01BQ25Cb2hDO01BQ0FHLGNBQWM7SUFDaEIsQ0FBQTtFQUVKO0FBQ0Y7QUFFQSxTQUFTdzZCLGVBQWVsM0QsT0FBT3FYLFFBQVF5SSxVQUFVNnJDLFlBQVk7QUFDM0QsUUFBTSxFQUFDcmxELElBQUcsSUFBSXRHO0FBQ2QsTUFBSThmLFVBQVU7QUFFWnhaLFFBQUlpVixJQUFJdmIsTUFBTW9mLFNBQVNwZixNQUFNcWYsU0FBU2hJLFFBQVEsR0FBR2MsR0FBQUE7U0FDNUM7QUFFTCxRQUFJZ0ksZ0JBQWdCbmdCLE1BQU15MUQsaUJBQWlCLEdBQUdwK0MsTUFBQUE7QUFDOUMvUSxRQUFJZzRCLE9BQU9uZSxjQUFjM2YsR0FBRzJmLGNBQWMxZixDQUFDO0FBRTNDLGFBQVN4SCxJQUFJLEdBQUdBLElBQUkweUQsWUFBWTF5RCxLQUFLO0FBQ25Da25CLHNCQUFnQm5nQixNQUFNeTFELGlCQUFpQng4RCxHQUFHb2UsTUFBQUE7QUFDMUMvUSxVQUFJaTRCLE9BQU9wZSxjQUFjM2YsR0FBRzJmLGNBQWMxZixDQUFDO0lBQzdDOztBQUVKO0FBRUEsU0FBUzAyRCxlQUFlbjNELE9BQU9vM0QsY0FBYy8vQyxRQUFRczBDLFlBQVlqeEIsWUFBWTtBQUMzRSxRQUFNcDBCLE1BQU10RyxNQUFNc0c7QUFDbEIsUUFBTXdaLFdBQVdzM0MsYUFBYXQzQztBQUU5QixRQUFNLEVBQUMza0IsT0FBQUEsUUFBTytoQixVQUFBQSxJQUFhazZDO0FBRTNCLE1BQUssQ0FBQ3QzQyxZQUFZLENBQUM2ckMsY0FBZSxDQUFDeHdELFVBQVMsQ0FBQytoQixhQUFhN0YsU0FBUyxHQUFHO0FBQ3BFOztBQUdGL1EsTUFBSXMzQixLQUFJO0FBQ1J0M0IsTUFBSXlXLGNBQWM1aEI7QUFDbEJtTCxNQUFJNFcsWUFBWUE7QUFDaEI1VyxNQUFJNjNCLFlBQVl6RCxXQUFXb0IsUUFBUSxDQUFBLENBQUU7QUFDckN4MUIsTUFBSTgzQixpQkFBaUIxRCxXQUFXc0I7QUFFaEMxMUIsTUFBSSszQixVQUFTO0FBQ2I2NEIsaUJBQWVsM0QsT0FBT3FYLFFBQVF5SSxVQUFVNnJDLFVBQUFBO0FBQ3hDcmxELE1BQUlzcUMsVUFBUztBQUNidHFDLE1BQUlrNEIsT0FBTTtBQUNWbDRCLE1BQUl3M0IsUUFBTztBQUNiO0FBRUEsU0FBU3U1Qix3QkFBd0JseUQsUUFBUTFELFFBQU93SyxPQUFPO0FBQ3JELFNBQU83RyxjQUFjRCxRQUFRO0lBQzNCOEc7SUFDQXhLLE9BQUFBO0lBQ0EvSixNQUFNO0VBQ1IsQ0FBQTtBQUNGO0FBRWUsSUFBTTQvRCxvQkFBTixjQUFnQzFFLGdCQUFBQTtFQTBFN0M3N0QsWUFBWTZFLEtBQUs7QUFDZixVQUFNQSxHQUFBQTtBQUdOLFNBQUt3akIsVUFBVS9uQjtBQUVmLFNBQUtnb0IsVUFBVWhvQjtBQUVmLFNBQUtxK0QsY0FBY3IrRDtBQUVuQixTQUFLKzlELGVBQWUsQ0FBQTtBQUNwQixTQUFLWSxtQkFBbUIsQ0FBQTtFQUMxQjtFQUVBM2dDLGdCQUFnQjtBQUVkLFVBQU01TSxVQUFVLEtBQUsyK0IsV0FBV3ArQixVQUFVNnJDLHNCQUFzQixLQUFLOTFELE9BQU8sSUFBSSxDQUFBO0FBQ2hGLFVBQU11b0IsSUFBSSxLQUFLL1MsUUFBUSxLQUFLZ0csV0FBV2tPLFFBQVFsVTtBQUMvQyxVQUFNaVQsSUFBSSxLQUFLbFQsU0FBUyxLQUFLa0csWUFBWWlPLFFBQVFuVTtBQUNqRCxTQUFLOEssVUFBVWpuQixLQUFLb0UsTUFBTSxLQUFLc0UsT0FBT3ltQixJQUFJLElBQUltQixRQUFRNW5CLElBQUk7QUFDMUQsU0FBS3dlLFVBQVVsbkIsS0FBS29FLE1BQU0sS0FBS21FLE1BQU04bUIsSUFBSSxJQUFJaUIsUUFBUS9uQixHQUFHO0FBQ3hELFNBQUtnMUQsY0FBY3Y5RCxLQUFLb0UsTUFBTXBFLEtBQUtDLElBQUlrdkIsR0FBR0UsQ0FBSyxJQUFBLENBQUE7RUFDakQ7RUFFQWdPLHNCQUFzQjtBQUNwQixVQUFNLEVBQUNwOUIsS0FBS21DLElBQUcsSUFBSSxLQUFLa1IsVUFBVSxLQUFLO0FBRXZDLFNBQUtyVCxNQUFNOEosZUFBUzlKLEdBQUFBLEtBQVEsQ0FBQzRjLE1BQU01YyxHQUFPQSxJQUFBQSxNQUFNO0FBQ2hELFNBQUttQyxNQUFNMkgsZUFBUzNILEdBQUFBLEtBQVEsQ0FBQ3lhLE1BQU16YSxHQUFPQSxJQUFBQSxNQUFNO0FBR2hELFNBQUt1NEQsdUJBQXNCO0VBQzdCO0VBTUFPLG1CQUFtQjtBQUNqQixXQUFPbDdELEtBQUswNEIsS0FBSyxLQUFLNmtDLGNBQWNiLHNCQUFzQixLQUFLOTFELE9BQU8sQ0FBQTtFQUN4RTtFQUVBZzRCLG1CQUFtQmxtQixPQUFPO0FBQ3hCK2hELG9CQUFnQjl4QyxVQUFVaVcsbUJBQW1CditCLEtBQUssTUFBTXFZLEtBQUFBO0FBR3hELFNBQUt1a0QsZUFBZSxLQUFLdHFELFVBQVMsRUFDL0I0UixJQUFJLENBQUNqZCxPQUFPZ0MsV0FBVTtBQUNyQixZQUFNd0ssUUFBUWkzQixTQUFhLEtBQUtua0MsUUFBUWdoQixZQUFZaVgsVUFBVTtRQUFDdjNCO1FBQU9nQztNQUFNLEdBQUUsSUFBSTtBQUNsRixhQUFPd0ssU0FBU0EsVUFBVSxJQUFJQSxRQUFRO0tBRXZDakgsRUFBQUEsT0FBTyxDQUFDd08sR0FBR3ZhLE1BQU0sS0FBSzFCLE1BQU13ZSxrQkFBa0I5YyxDQUFBQSxDQUFBQTtFQUNuRDtFQUVBcTlCLE1BQU07QUFDSixVQUFNcDJCLE9BQU8sS0FBS25CO0FBRWxCLFFBQUltQixLQUFLMmYsV0FBVzNmLEtBQUs2ZixZQUFZRixTQUFTO0FBQzVDbzFDLHlCQUFtQixJQUFJO1dBQ2xCO0FBQ0wsV0FBS2MsZUFBZSxHQUFHLEdBQUcsR0FBRyxDQUFBOztFQUVqQztFQUVBQSxlQUFld0IsY0FBY0MsZUFBZUMsYUFBYUMsZ0JBQWdCO0FBQ3ZFLFNBQUt0NEMsV0FBV2puQixLQUFLb0UsT0FBT2c3RCxlQUFlQyxpQkFBaUIsQ0FBQTtBQUM1RCxTQUFLbjRDLFdBQVdsbkIsS0FBS29FLE9BQU9rN0QsY0FBY0Msa0JBQWtCLENBQUE7QUFDNUQsU0FBS2hDLGVBQWV2OUQsS0FBS0MsSUFBSSxLQUFLczlELGNBQWMsR0FBR3Y5RCxLQUFLb0MsSUFBSWc5RCxjQUFjQyxlQUFlQyxhQUFhQyxjQUFBQSxDQUFBQTtFQUN4RztFQUVBbjRDLGNBQWM5ZCxRQUFPO0FBQ25CLFVBQU1rMkQsa0JBQWtCeC9DLE9BQU8sS0FBS2k5QyxhQUFhcDhELFVBQVU7QUFDM0QsVUFBTW9mLGFBQWEsS0FBS3JaLFFBQVFxWixjQUFjO0FBRTlDLFdBQU9xNEIsZ0JBQWdCaHZDLFNBQVFrMkQsa0JBQWtCaCtDLFVBQVV2QixVQUFBQSxDQUFBQTtFQUM3RDtFQUVBdUgsOEJBQThCbGdCLE9BQU87QUFDbkMsUUFBSTRSLGNBQWM1UixLQUFRLEdBQUE7QUFDeEIsYUFBTytMOztBQUlULFVBQU1vc0QsZ0JBQWdCLEtBQUtsQyxlQUFlLEtBQUtuN0QsTUFBTSxLQUFLbkM7QUFDMUQsUUFBSSxLQUFLMkcsUUFBUW9CLFNBQVM7QUFDeEIsY0FBUSxLQUFLNUYsTUFBTWtGLFNBQVNtNEQ7O0FBRTlCLFlBQVFuNEQsUUFBUSxLQUFLckgsT0FBT3cvRDtFQUM5QjtFQUVBQyw4QkFBOEIxekMsVUFBVTtBQUN0QyxRQUFJOVMsY0FBYzhTLFFBQVcsR0FBQTtBQUMzQixhQUFPM1k7O0FBR1QsVUFBTXNzRCxpQkFBaUIzekMsWUFBWSxLQUFLdXhDLGVBQWUsS0FBS243RCxNQUFNLEtBQUtuQztBQUN2RSxXQUFPLEtBQUsyRyxRQUFRb0IsVUFBVSxLQUFLNUYsTUFBTXU5RCxpQkFBaUIsS0FBSzEvRCxNQUFNMC9EO0VBQ3ZFO0VBRUF0QyxxQkFBcUIvekQsUUFBTztBQUMxQixVQUFNc2UsY0FBYyxLQUFLcTFDLGdCQUFnQixDQUFBO0FBRXpDLFFBQUkzekQsVUFBUyxLQUFLQSxTQUFRc2UsWUFBWS9tQixRQUFRO0FBQzVDLFlBQU0rK0QsYUFBYWg0QyxZQUFZdGUsTUFBTTtBQUNyQyxhQUFPNDFELHdCQUF3QixLQUFLbnRELFdBQVUsR0FBSXpJLFFBQU9zMkQsVUFBQUE7O0VBRTdEO0VBRUF0QyxpQkFBaUJoMEQsUUFBT3UyRCxvQkFBb0IxQyxrQkFBa0IsR0FBRztBQUMvRCxVQUFNejhDLFFBQVEsS0FBSzBHLGNBQWM5ZCxNQUFBQSxJQUFTeVgsVUFBVW84QztBQUNwRCxXQUFPO01BQ0w5MEQsR0FBR3JJLEtBQUtvZ0IsSUFBSU0sS0FBQUEsSUFBU20vQyxxQkFBcUIsS0FBSzU0QztNQUMvQzNlLEdBQUd0SSxLQUFLc2dCLElBQUlJLEtBQUFBLElBQVNtL0MscUJBQXFCLEtBQUszNEM7TUFDL0N4RztJQUNGO0VBQ0Y7RUFFQXVILHlCQUF5QjNlLFFBQU9oQyxPQUFPO0FBQ3JDLFdBQU8sS0FBS2cyRCxpQkFBaUJoMEQsUUFBTyxLQUFLa2UsOEJBQThCbGdCLEtBQUFBLENBQUFBO0VBQ3pFO0VBRUF3NEQsZ0JBQWdCeDJELFFBQU87QUFDckIsV0FBTyxLQUFLMmUseUJBQXlCM2UsVUFBUyxHQUFHLEtBQUsyNEIsYUFBWSxDQUFBO0VBQ3BFO0VBRUE4OUIsc0JBQXNCejJELFFBQU87QUFDM0IsVUFBTSxFQUFDWixNQUFNSCxLQUFLQyxPQUFPQyxPQUFNLElBQUksS0FBS28xRCxpQkFBaUJ2MEQsTUFBTTtBQUMvRCxXQUFPO01BQ0xaO01BQ0FIO01BQ0FDO01BQ0FDO0lBQ0Y7RUFDRjtFQUtBKzhCLGlCQUFpQjtBQUNmLFVBQU0sRUFBQzdnQixpQkFBaUI3RixNQUFNLEVBQUM2SSxTQUFBQSxFQUFTLElBQUksS0FBSy9nQjtBQUNqRCxRQUFJK2QsaUJBQWlCO0FBQ25CLFlBQU14VyxNQUFNLEtBQUtBO0FBQ2pCQSxVQUFJczNCLEtBQUk7QUFDUnQzQixVQUFJKzNCLFVBQVM7QUFDYjY0QixxQkFBZSxNQUFNLEtBQUt2M0MsOEJBQThCLEtBQUtrekMsU0FBUyxHQUFHL3lDLFVBQVUsS0FBS3MxQyxhQUFhcDhELE1BQU07QUFDM0dzTixVQUFJc3FDLFVBQVM7QUFDYnRxQyxVQUFJdVcsWUFBWUM7QUFDaEJ4VyxVQUFJbUIsS0FBSTtBQUNSbkIsVUFBSXczQixRQUFPOztFQUVmO0VBS0FDLFdBQVc7QUFDVCxVQUFNejNCLE1BQU0sS0FBS0E7QUFDakIsVUFBTXBHLE9BQU8sS0FBS25CO0FBQ2xCLFVBQU0sRUFBQzZnQixZQUFZM0ksTUFBTXdILE9BQUFBLElBQVV2ZTtBQUNuQyxVQUFNeXJELGFBQWEsS0FBS3lKLGFBQWFwOEQ7QUFFckMsUUFBSUMsR0FBRytkLFFBQVF1TDtBQUVmLFFBQUlyaUIsS0FBSzZmLFlBQVlGLFNBQVM7QUFDNUJvM0Msc0JBQWdCLE1BQU10TCxVQUFBQTs7QUFHeEIsUUFBSTEwQyxLQUFLNEksU0FBUztBQUNoQixXQUFLaFAsTUFBTTlZLFFBQVEsQ0FBQ3VCLE1BQU1tSSxXQUFVO0FBQ2xDLFlBQUlBLFdBQVUsS0FBTUEsV0FBVSxLQUFLLEtBQUtySixNQUFNLEdBQUk7QUFDaEQ0ZSxtQkFBUyxLQUFLMkksOEJBQThCcm1CLEtBQUttRyxLQUFLO0FBQ3RELGdCQUFNbU4sVUFBVSxLQUFLMUMsV0FBV3pJLE1BQUFBO0FBQ2hDLGdCQUFNaTZCLGNBQWN6a0IsS0FBS3FkLFdBQVcxbkIsT0FBQUE7QUFDcEMsZ0JBQU0rdUIsb0JBQW9CbGQsT0FBTzZWLFdBQVcxbkIsT0FBQUE7QUFFNUN1cUQseUJBQWUsTUFBTXo3QixhQUFhMWtCLFFBQVEyMEMsWUFBWWh3QixpQkFBQUE7O01BRTFELENBQUE7O0FBR0YsUUFBSS9iLFdBQVdDLFNBQVM7QUFDdEJ2WixVQUFJczNCLEtBQUk7QUFFUixXQUFLM2tDLElBQUkweUQsYUFBYSxHQUFHMXlELEtBQUssR0FBR0EsS0FBSztBQUNwQyxjQUFNeWlDLGNBQWM5YixXQUFXMFUsV0FBVyxLQUFLa2hDLHFCQUFxQnY4RCxDQUFBQSxDQUFBQTtBQUNwRSxjQUFNLEVBQUNrQyxPQUFBQSxRQUFPK2hCLFVBQUFBLElBQWF3ZTtBQUUzQixZQUFJLENBQUN4ZSxhQUFhLENBQUMvaEIsUUFBTztBQUN4Qjs7QUFHRm1MLFlBQUk0VyxZQUFZQTtBQUNoQjVXLFlBQUl5VyxjQUFjNWhCO0FBRWxCbUwsWUFBSTYzQixZQUFZekMsWUFBWUcsVUFBVTtBQUN0Q3YxQixZQUFJODNCLGlCQUFpQjFDLFlBQVlLO0FBRWpDL2tCLGlCQUFTLEtBQUsySSw4QkFBOEJ6ZixLQUFLQyxVQUFVLEtBQUsvSCxNQUFNLEtBQUttQyxHQUFHO0FBQzlFZ29CLG1CQUFXLEtBQUtrekMsaUJBQWlCeDhELEdBQUcrZCxNQUFBQTtBQUNwQzFRLFlBQUkrM0IsVUFBUztBQUNiLzNCLFlBQUlnNEIsT0FBTyxLQUFLbGYsU0FBUyxLQUFLQyxPQUFPO0FBQ3JDL1ksWUFBSWk0QixPQUFPaGMsU0FBUy9oQixHQUFHK2hCLFNBQVM5aEIsQ0FBQztBQUNqQzZGLFlBQUlrNEIsT0FBTTtNQUNaO0FBRUFsNEIsVUFBSXczQixRQUFPOztFQUVmO0VBS0FZLGFBQWE7RUFBQTtFQUtiRSxhQUFhO0FBQ1gsVUFBTXQ0QixNQUFNLEtBQUtBO0FBQ2pCLFVBQU1wRyxPQUFPLEtBQUtuQjtBQUNsQixVQUFNcXdCLFdBQVdsdkIsS0FBSzJRO0FBRXRCLFFBQUksQ0FBQ3VlLFNBQVN2UCxTQUFTO0FBQ3JCOztBQUdGLFVBQU16SCxhQUFhLEtBQUttSCxjQUFjLENBQUE7QUFDdEMsUUFBSXZJLFFBQVF6QztBQUVaak8sUUFBSXMzQixLQUFJO0FBQ1J0M0IsUUFBSXF1QyxVQUFVLEtBQUt2MUIsU0FBUyxLQUFLQyxPQUFPO0FBQ3hDL1ksUUFBSTZ4RCxPQUFPLy9DLFVBQUFBO0FBQ1g5UixRQUFJaTJCLFlBQVk7QUFDaEJqMkIsUUFBSW8yQixlQUFlO0FBRW5CLFNBQUs3ckIsTUFBTTlZLFFBQVEsQ0FBQ3VCLE1BQU1tSSxXQUFVO0FBQ2xDLFVBQUtBLFdBQVUsS0FBSyxLQUFLckosT0FBTyxLQUFNLENBQUM4SCxLQUFLQyxTQUFTO0FBQ25EOztBQUdGLFlBQU11N0IsY0FBY3RNLFNBQVNrRixXQUFXLEtBQUtwcUIsV0FBV3pJLE1BQUFBLENBQUFBO0FBQ3hELFlBQU04M0IsV0FBV2hILE9BQU9tSixZQUFZcEosSUFBSTtBQUN4Q3RiLGVBQVMsS0FBSzJJLDhCQUE4QixLQUFLOU8sTUFBTXBQLE1BQU0sRUFBQ2hDLEtBQUs7QUFFbkUsVUFBSWk4QixZQUFZMEIsbUJBQW1CO0FBQ2pDOTJCLFlBQUlnc0IsT0FBT2lILFNBQVNJO0FBQ3BCcGxCLGdCQUFRak8sSUFBSXM5QyxZQUFZdHFELEtBQUsyUyxLQUFLLEVBQUVzSTtBQUNwQ2pPLFlBQUl1VyxZQUFZNmUsWUFBWThCO0FBRTVCLGNBQU0vVSxVQUFVTyxVQUFVMFMsWUFBWTZCLGVBQWU7QUFDckRqM0IsWUFBSXUzQixTQUNGLENBQUN0cEIsUUFBUSxJQUFJa1UsUUFBUTVuQixNQUNyQixDQUFDbVcsU0FBU3VpQixTQUFTNzVCLE9BQU8sSUFBSStvQixRQUFRL25CLEtBQ3RDNlQsUUFBUWtVLFFBQVFsVSxPQUNoQmdsQixTQUFTNzVCLE9BQU8rb0IsUUFBUW5VLE1BQU07O0FBSWxDeXFCLGlCQUFXejRCLEtBQUtoTixLQUFLMlMsT0FBTyxHQUFHLENBQUMrSyxRQUFRdWlCLFVBQVU7UUFDaERwK0IsT0FBT3VnQyxZQUFZdmdDO1FBQ25CNGhDLGFBQWFyQixZQUFZc0I7UUFDekJDLGFBQWF2QixZQUFZd0I7TUFDM0IsQ0FBQTtJQUNGLENBQUE7QUFFQTUyQixRQUFJdzNCLFFBQU87RUFDYjtFQUtBbUIsWUFBWTtFQUFBO0FBQ2Q7QUF4VkUsY0FGbUJxNEIsbUJBRVpuMEQsTUFBSztBQUtaLGNBUG1CbTBELG1CQU9abDVELFlBQVc7RUFDaEJ5aEIsU0FBUztFQUdUdTRDLFNBQVM7RUFDVDcxQyxVQUFVO0VBRVYzQyxZQUFZO0lBQ1ZDLFNBQVM7SUFDVDNDLFdBQVc7SUFDWDJlLFlBQVksQ0FBQTtJQUNaRSxrQkFBa0I7RUFDcEI7RUFFQTlrQixNQUFNO0lBQ0o2SSxVQUFVO0VBQ1o7RUFFQTFILFlBQVk7RUFHWnZILE9BQU87SUFFTHVzQixtQkFBbUI7SUFFbkJwRyxVQUFVeThCLE1BQU1DLFdBQVdDO0VBQzdCO0VBRUE1ekMsYUFBYTtJQUNYeWQsZUFBZW5tQztJQUdma21DLGlCQUFpQjtJQUdqQjFkLFNBQVM7SUFHVHlTLE1BQU07TUFDSjV5QixNQUFNO0lBQ1I7SUFHQXMzQixTQUFTL3FCLE9BQU87QUFDZCxhQUFPQTtJQUNUO0lBR0F3YyxTQUFTO0lBR1Q4c0MsbUJBQW1CO0VBQ3JCOztBQUdGLGNBOURtQitCLG1CQThEWnBvQyxpQkFBZ0I7RUFDckIsb0JBQW9CO0VBQ3BCLHFCQUFxQjtFQUNyQixlQUFlOztBQUdqQixjQXBFbUJvb0MsbUJBb0VacjdDLGVBQWM7RUFDbkIyRCxZQUFZO0lBQ1Y0d0MsV0FBVztFQUNiOztBQ3pZSixJQUFNNkgsWUFBWTtFQUNoQkMsYUFBYTtJQUFDQyxRQUFRO0lBQU03NEQsTUFBTTtJQUFHdzBELE9BQU87RUFBSTtFQUNoRHNFLFFBQVE7SUFBQ0QsUUFBUTtJQUFNNzRELE1BQU07SUFBTXcwRCxPQUFPO0VBQUU7RUFDNUN1RSxRQUFRO0lBQUNGLFFBQVE7SUFBTTc0RCxNQUFNO0lBQU93MEQsT0FBTztFQUFFO0VBQzdDd0UsTUFBTTtJQUFDSCxRQUFRO0lBQU03NEQsTUFBTTtJQUFTdzBELE9BQU87RUFBRTtFQUM3Q3lFLEtBQUs7SUFBQ0osUUFBUTtJQUFNNzRELE1BQU07SUFBVXcwRCxPQUFPO0VBQUU7RUFDN0MwRSxNQUFNO0lBQUNMLFFBQVE7SUFBTzc0RCxNQUFNO0lBQVd3MEQsT0FBTztFQUFDO0VBQy9DMkUsT0FBTztJQUFDTixRQUFRO0lBQU03NEQsTUFBTTtJQUFTdzBELE9BQU87RUFBRTtFQUM5QzRFLFNBQVM7SUFBQ1AsUUFBUTtJQUFPNzRELE1BQU07SUFBU3cwRCxPQUFPO0VBQUM7RUFDaEQ2RSxNQUFNO0lBQUNSLFFBQVE7SUFBTTc0RCxNQUFNO0VBQVE7QUFDckM7QUFLQSxJQUFNczVELFFBQTZDOTZELHVCQUFPQyxLQUFLazZELFNBQUFBO0FBTS9ELFNBQVNZLE9BQU8zb0QsR0FBR3JQLEdBQUc7QUFDcEIsU0FBT3FQLElBQUlyUDtBQUNiO0FBT0EsU0FBU21KLE1BQU1wSyxPQUFPazVELE9BQU87QUFDM0IsTUFBSTduRCxjQUFjNm5ELEtBQVEsR0FBQTtBQUN4QixXQUFPOztBQUdULFFBQU1DLFVBQVVuNUQsTUFBTW81RDtBQUN0QixRQUFNLEVBQUNDLFFBQUFBLFNBQVFscEMsT0FBQUEsUUFBT21wQyxXQUFVLElBQUl0NUQsTUFBTXU1RDtBQUMxQyxNQUFJOTVELFFBQVF5NUQ7QUFFWixNQUFJLE9BQU9HLFlBQVcsWUFBWTtBQUNoQzU1RCxZQUFRNDVELFFBQU81NUQsS0FBQUE7O0FBSWpCLE1BQUksQ0FBQ3lDLGVBQVN6QyxLQUFRLEdBQUE7QUFDcEJBLFlBQVEsT0FBTzQ1RCxZQUFXLFdBQ3RCRixRQUFRL3VELE1BQU0zSyxPQUFPNDVELE9BQ3JCRixJQUFBQSxRQUFRL3VELE1BQU0zSyxLQUFNOztBQUcxQixNQUFJQSxVQUFVLE1BQU07QUFDbEIsV0FBTzs7QUFHVCxNQUFJMHdCLFFBQU87QUFDVDF3QixZQUFRMHdCLFdBQVUsV0FBVy9SLFNBQVNrN0MsVUFBZUEsS0FBQUEsZUFBZSxRQUNoRUgsUUFBUWg0QyxRQUFRMWhCLE9BQU8sV0FBVzY1RCxVQUFBQSxJQUNsQ0gsUUFBUWg0QyxRQUFRMWhCLE9BQU8wd0IsTUFBTTs7QUFHbkMsU0FBTyxDQUFDMXdCO0FBQ1Y7QUFVQSxTQUFTKzVELDBCQUEwQkMsU0FBU3JoRSxLQUFLbUMsS0FBS20vRCxVQUFVO0FBQzlELFFBQU1sNEQsT0FBT3czRCxNQUFNaGdFO0FBRW5CLFdBQVNDLElBQUkrL0QsTUFBTS9qRCxRQUFRd2tELE9BQUFBLEdBQVV4Z0UsSUFBSXVJLE9BQU8sR0FBRyxFQUFFdkksR0FBRztBQUN0RCxVQUFNMGdFLFdBQVd0QixVQUFVVyxNQUFNLy9ELENBQUFBLENBQUU7QUFDbkMsVUFBTWlDLFNBQVN5K0QsU0FBU3pGLFFBQVF5RixTQUFTekYsUUFBUTN3RCxPQUFPcTJEO0FBRXhELFFBQUlELFNBQVNwQixVQUFVcGdFLEtBQUswNEIsTUFBTXQyQixNQUFNbkMsUUFBUThDLFNBQVN5K0QsU0FBU2o2RCxLQUFHLEtBQU9nNkQsVUFBVTtBQUNwRixhQUFPVixNQUFNLy9ELENBQUU7O0VBRW5CO0FBRUEsU0FBTysvRCxNQUFNeDNELE9BQU8sQ0FBRTtBQUN4QjtBQVdBLFNBQVNxNEQsMkJBQTJCNzVELE9BQU9rM0IsVUFBVXVpQyxTQUFTcmhFLEtBQUttQyxLQUFLO0FBQ3RFLFdBQVN0QixJQUFJKy9ELE1BQU1oZ0UsU0FBUyxHQUFHQyxLQUFLKy9ELE1BQU0vakQsUUFBUXdrRCxPQUFBQSxHQUFVeGdFLEtBQUs7QUFDL0QsVUFBTTA0RCxPQUFPcUgsTUFBTS8vRCxDQUFFO0FBQ3JCLFFBQUlvL0QsVUFBVTFHLElBQUssRUFBQzRHLFVBQVV2NEQsTUFBTW81RCxTQUFTbDRDLEtBQUszbUIsS0FBS25DLEtBQUt1NUQsSUFBQUEsS0FBU3o2QixXQUFXLEdBQUc7QUFDakYsYUFBT3k2Qjs7RUFFWDtBQUVBLFNBQU9xSCxNQUFNUyxVQUFVVCxNQUFNL2pELFFBQVF3a0QsT0FBQUEsSUFBVyxDQUFDO0FBQ25EO0FBTUEsU0FBU0ssbUJBQW1CbkksTUFBTTtBQUNoQyxXQUFTMTRELElBQUkrL0QsTUFBTS9qRCxRQUFRMDhDLElBQVEsSUFBQSxHQUFHbndELE9BQU93M0QsTUFBTWhnRSxRQUFRQyxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUN4RSxRQUFJby9ELFVBQVVXLE1BQU0vL0QsQ0FBQUEsQ0FBRSxFQUFFcy9ELFFBQVE7QUFDOUIsYUFBT1MsTUFBTS8vRCxDQUFFOztFQUVuQjtBQUNGO0FBT0EsU0FBUzhnRSxRQUFRbHBELE9BQU9tcEQsTUFBTUMsWUFBWTtBQUN4QyxNQUFJLENBQUNBLFlBQVk7QUFDZnBwRCxVQUFNbXBELElBQUssSUFBRzthQUNMQyxXQUFXamhFLFFBQVE7QUFDNUIsVUFBTSxFQUFDZ3BCLElBQUlHLEdBQUFBLElBQU0rM0MsUUFBUUQsWUFBWUQsSUFBQUE7QUFDckMsVUFBTUcsWUFBWUYsV0FBV2o0QyxFQUFBQSxLQUFPZzRDLE9BQU9DLFdBQVdqNEMsRUFBRyxJQUFHaTRDLFdBQVc5M0MsRUFBRztBQUMxRXRSLFVBQU1zcEQsU0FBVSxJQUFHOztBQUV2QjtBQVNBLFNBQVNDLGNBQWNwNkQsT0FBTzZRLE9BQU82TCxNQUFLMjlDLFdBQVc7QUFDbkQsUUFBTWxCLFVBQVVuNUQsTUFBTW81RDtBQUN0QixRQUFNdHBDLFFBQVEsQ0FBQ3FwQyxRQUFRaDRDLFFBQVF0USxNQUFNLENBQUEsRUFBR3BSLE9BQU80NkQsU0FBQUE7QUFDL0MsUUFBTTVsRCxPQUFPNUQsTUFBTUEsTUFBTTdYLFNBQVMsQ0FBQSxFQUFHeUc7QUFDckMsTUFBSWl3QixPQUFPanVCO0FBRVgsT0FBS2l1QixRQUFRSSxPQUFPSixTQUFTamIsTUFBTWliLFFBQVEsQ0FBQ3lwQyxRQUFRai9ELElBQUl3MUIsT0FBTyxHQUFHMnFDLFNBQVksR0FBQTtBQUM1RTU0RCxJQUFBQSxTQUFRaWIsS0FBSWdULEtBQU07QUFDbEIsUUFBSWp1QixVQUFTLEdBQUc7QUFDZG9QLFlBQU1wUCxNQUFBQSxFQUFPaXVCLFFBQVE7O0VBRXpCO0FBQ0EsU0FBTzdlO0FBQ1Q7QUFRQSxTQUFTeXBELG9CQUFvQnQ2RCxPQUFPbkIsUUFBUXc3RCxXQUFXO0FBQ3JELFFBQU14cEQsUUFBUSxDQUFBO0FBRWQsUUFBTTZMLE9BQU0sQ0FBQTtBQUNaLFFBQU1sYixPQUFPM0MsT0FBTzdGO0FBQ3BCLE1BQUlDLEdBQUd3RztBQUVQLE9BQUt4RyxJQUFJLEdBQUdBLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ3pCd0csWUFBUVosT0FBTzVGLENBQUU7QUFDakJ5akIsSUFBQUEsS0FBSWpkLEtBQUFBLElBQVN4RztBQUViNFgsVUFBTTVXLEtBQUs7TUFDVHdGO01BQ0Fpd0IsT0FBTztJQUNULENBQUE7RUFDRjtBQUlBLFNBQVFsdUIsU0FBUyxLQUFLLENBQUM2NEQsWUFBYXhwRCxRQUFRdXBELGNBQWNwNkQsT0FBTzZRLE9BQU82TCxNQUFLMjlDLFNBQVU7QUFDekY7QUFFZSxJQUFNRSxZQUFOLGNBQXdCcG5DLE1BQUFBO0VBZ0RyQ3A4QixZQUFZd0ksT0FBTztBQUNqQixVQUFNQSxLQUFBQTtBQUdOLFNBQUt5USxTQUFTO01BQ1ozTixNQUFNLENBQUE7TUFDTndJLFFBQVEsQ0FBQTtNQUNSL0ssS0FBSyxDQUFBO0lBQ1A7QUFHQSxTQUFLMDZELFFBQVE7QUFFYixTQUFLQyxhQUFhcGpFO0FBQ2xCLFNBQUtxakUsV0FBVyxDQUFBO0FBQ2hCLFNBQUtDLGNBQWM7QUFDbkIsU0FBS3BCLGFBQWFsaUU7RUFDcEI7RUFFQTBwQixLQUFLeXFCLFdBQVd0ckMsT0FBTyxDQUFBLEdBQUk7QUFDekIsVUFBTTg1RCxPQUFPeHVCLFVBQVV3dUIsU0FBU3h1QixVQUFVd3VCLE9BQU8sQ0FBQTtBQUVqRCxVQUFNYixVQUFVLEtBQUtDLFdBQVcsSUFBSXdCLFNBQVN2NUMsTUFBTW1xQixVQUFVb3ZCLFNBQVNuakUsSUFBSTtBQUUxRTBoRSxZQUFRcDRDLEtBQUs3Z0IsSUFBQUE7QUFNYndsQyxZQUFRczBCLEtBQUthLGdCQUFnQjFCLFFBQVFuNEMsUUFBTyxDQUFBO0FBRTVDLFNBQUt1NEMsYUFBYTtNQUNoQkYsUUFBUVcsS0FBS1g7TUFDYmxwQyxPQUFPNnBDLEtBQUs3cEM7TUFDWm1wQyxZQUFZVSxLQUFLVjtJQUNuQjtBQUVBLFVBQU12NEMsS0FBS3lxQixTQUFBQTtBQUVYLFNBQUttdkIsY0FBY3o2RCxLQUFLNDZEO0VBQzFCO0VBT0Exd0QsTUFBTTNFLEtBQUtoRSxRQUFPO0FBQ2hCLFFBQUlnRSxRQUFRcE8sUUFBVztBQUNyQixhQUFPOztBQUVULFdBQU8rUyxNQUFNLE1BQU0zRSxHQUFBQTtFQUNyQjtFQUVBMmpCLGVBQWU7QUFDYixVQUFNQSxhQUFZO0FBQ2xCLFNBQUtwWixTQUFTO01BQ1ozTixNQUFNLENBQUE7TUFDTndJLFFBQVEsQ0FBQTtNQUNSL0ssS0FBSyxDQUFBO0lBQ1A7RUFDRjtFQUVBMDFCLHNCQUFzQjtBQUNwQixVQUFNejJCLFdBQVUsS0FBS0E7QUFDckIsVUFBTW82RCxVQUFVLEtBQUtDO0FBQ3JCLFVBQU16SCxPQUFPNXlELFNBQVFpN0QsS0FBS3JJLFFBQVE7QUFFbEMsUUFBSSxFQUFDdjVELEtBQUttQyxLQUFLOEksWUFBWUMsV0FBQUEsSUFBYyxLQUFLRixjQUFhO0FBSzNELGFBQVMyM0QsYUFBYXRoQixRQUFRO0FBQzVCLFVBQUksQ0FBQ3AyQyxjQUFjLENBQUMyUixNQUFNeWtDLE9BQU9yaEQsR0FBRyxHQUFHO0FBQ3JDQSxjQUFNRCxLQUFLQyxJQUFJQSxLQUFLcWhELE9BQU9yaEQsR0FBRzs7QUFFaEMsVUFBSSxDQUFDa0wsY0FBYyxDQUFDMFIsTUFBTXlrQyxPQUFPbC9DLEdBQUcsR0FBRztBQUNyQ0EsY0FBTXBDLEtBQUtvQyxJQUFJQSxLQUFLay9DLE9BQU9sL0MsR0FBRzs7SUFFbEM7QUFHQSxRQUFJLENBQUM4SSxjQUFjLENBQUNDLFlBQVk7QUFFOUJ5M0QsbUJBQWEsS0FBS0MsZ0JBQWUsQ0FBQTtBQUlqQyxVQUFJajhELFNBQVEwNkMsV0FBVyxXQUFXMTZDLFNBQVE4UixNQUFNc2xCLFdBQVcsVUFBVTtBQUNuRTRrQyxxQkFBYSxLQUFLdHZELFVBQVUsS0FBSyxDQUFBOzs7QUFJckNyVCxVQUFNOEosZUFBUzlKLEdBQUFBLEtBQVEsQ0FBQzRjLE1BQU01YyxHQUFPQSxJQUFBQSxNQUFNLENBQUMrZ0UsUUFBUWg0QyxRQUFReG9CLEtBQUtDLElBQUcsR0FBSSs0RCxJQUFLO0FBQzdFcDNELFVBQU0ySCxlQUFTM0gsR0FBQUEsS0FBUSxDQUFDeWEsTUFBTXphLEdBQUFBLElBQU9BLE1BQU0sQ0FBQzQrRCxRQUFRLzNDLE1BQU16b0IsS0FBS0MsSUFBRyxHQUFJKzRELElBQUFBLElBQVE7QUFHOUUsU0FBS3Y1RCxNQUFNRCxLQUFLQyxJQUFJQSxLQUFLbUMsTUFBTSxDQUFBO0FBQy9CLFNBQUtBLE1BQU1wQyxLQUFLb0MsSUFBSW5DLE1BQU0sR0FBR21DLEdBQUFBO0VBQy9CO0VBS0F5Z0Usa0JBQWtCO0FBQ2hCLFVBQU0vckQsTUFBTSxLQUFLZ3NELG1CQUFrQjtBQUNuQyxRQUFJN2lFLE1BQU1tTCxPQUFPRTtBQUNqQixRQUFJbEosTUFBTWdKLE9BQU9DO0FBRWpCLFFBQUl5TCxJQUFJalcsUUFBUTtBQUNkWixZQUFNNlcsSUFBSSxDQUFFO0FBQ1oxVSxZQUFNMFUsSUFBSUEsSUFBSWpXLFNBQVMsQ0FBRTs7QUFFM0IsV0FBTztNQUFDWjtNQUFLbUM7SUFBRztFQUNsQjtFQUtBcTdCLGFBQWE7QUFDWCxVQUFNNzJCLFdBQVUsS0FBS0E7QUFDckIsVUFBTW04RCxXQUFXbjhELFNBQVFpN0Q7QUFDekIsVUFBTTVxQyxXQUFXcndCLFNBQVE4UjtBQUN6QixVQUFNb3BELGFBQWE3cUMsU0FBUytHLFdBQVcsV0FBVyxLQUFLOGtDLG1CQUFrQixJQUFLLEtBQUtFLFVBQVM7QUFFNUYsUUFBSXA4RCxTQUFRMDZDLFdBQVcsV0FBV3dnQixXQUFXamhFLFFBQVE7QUFDbkQsV0FBS1osTUFBTSxLQUFLNDdCLFlBQVlpbUMsV0FBVyxDQUFFO0FBQ3pDLFdBQUsxL0QsTUFBTSxLQUFLdzVCLFlBQVlrbUMsV0FBV0EsV0FBV2poRSxTQUFTLENBQUU7O0FBRy9ELFVBQU1aLE1BQU0sS0FBS0E7QUFDakIsVUFBTW1DLE1BQU0sS0FBS0E7QUFFakIsVUFBTXNXLFFBQVF1cUQsZUFBZW5CLFlBQVk3aEUsS0FBS21DLEdBQUFBO0FBSzlDLFNBQUtpZ0UsUUFBUVUsU0FBU3ZKLFNBQVN2aUMsU0FBU0QsV0FDcENxcUMsMEJBQTBCMEIsU0FBU3pCLFNBQVMsS0FBS3JoRSxLQUFLLEtBQUttQyxLQUFLLEtBQUs4Z0Usa0JBQWtCampFLEdBQ3ZGeWhFLENBQUFBLElBQUFBLDJCQUEyQixNQUFNaHBELE1BQU03WCxRQUFRa2lFLFNBQVN6QixTQUFTLEtBQUtyaEUsS0FBSyxLQUFLbUMsR0FBRztBQUN2RixTQUFLa2dFLGFBQWEsQ0FBQ3JyQyxTQUFTTSxNQUFNQyxXQUFXLEtBQUs2cUMsVUFBVSxTQUFTbmpFLFNBQ2pFeWlFLG1CQUFtQixLQUFLVSxLQUFLO0FBQ2pDLFNBQUtjLFlBQVlyQixVQUFBQTtBQUVqQixRQUFJbDdELFNBQVFvQixTQUFTO0FBQ25CMFEsWUFBTTFRLFFBQU87O0FBR2YsV0FBT202RCxvQkFBb0IsTUFBTXpwRCxPQUFPLEtBQUs0cEQsVUFBVTtFQUN6RDtFQUVBcmtDLGdCQUFnQjtBQUdkLFFBQUksS0FBS3IzQixRQUFRdzhELHFCQUFxQjtBQUNwQyxXQUFLRCxZQUFZLEtBQUt6cUQsTUFBTTZMLElBQUlwakIsQ0FBQUEsU0FBUSxDQUFDQSxLQUFLbUcsS0FBSyxDQUFBOztFQUV2RDtFQVVBNjdELFlBQVlyQixhQUFhLENBQUEsR0FBSTtBQUMzQixRQUFJNWhFLFFBQVE7QUFDWixRQUFJK0gsTUFBTTtBQUNWLFFBQUkwdkIsT0FBT3JiO0FBRVgsUUFBSSxLQUFLMVYsUUFBUWlZLFVBQVVpakQsV0FBV2poRSxRQUFRO0FBQzVDODJCLGNBQVEsS0FBSzByQyxtQkFBbUJ2QixXQUFXLENBQUUsQ0FBQTtBQUM3QyxVQUFJQSxXQUFXamhFLFdBQVcsR0FBRztBQUMzQlgsZ0JBQVEsSUFBSXkzQjthQUNQO0FBQ0x6M0IsaUJBQVMsS0FBS21qRSxtQkFBbUJ2QixXQUFXLENBQUEsQ0FBRSxJQUFJbnFDLFNBQVM7O0FBRTdEcmIsYUFBTyxLQUFLK21ELG1CQUFtQnZCLFdBQVdBLFdBQVdqaEUsU0FBUyxDQUFFLENBQUE7QUFDaEUsVUFBSWloRSxXQUFXamhFLFdBQVcsR0FBRztBQUMzQm9ILGNBQU1xVTthQUNEO0FBQ0xyVSxlQUFPcVUsT0FBTyxLQUFLK21ELG1CQUFtQnZCLFdBQVdBLFdBQVdqaEUsU0FBUyxDQUFBLENBQUUsS0FBSzs7O0FBR2hGLFVBQU13aUMsUUFBUXkrQixXQUFXamhFLFNBQVMsSUFBSSxNQUFNO0FBQzVDWCxZQUFReS9CLFlBQVl6L0IsT0FBTyxHQUFHbWpDLEtBQUFBO0FBQzlCcDdCLFVBQU0wM0IsWUFBWTEzQixLQUFLLEdBQUdvN0IsS0FBQUE7QUFFMUIsU0FBS2svQixXQUFXO01BQUNyaUU7TUFBTytIO01BQUtsRixRQUFRLEtBQUs3QyxRQUFRLElBQUkrSDtJQUFJO0VBQzVEO0VBU0ErNkQsWUFBWTtBQUNWLFVBQU1oQyxVQUFVLEtBQUtDO0FBQ3JCLFVBQU1oaEUsTUFBTSxLQUFLQTtBQUNqQixVQUFNbUMsTUFBTSxLQUFLQTtBQUNqQixVQUFNd0UsV0FBVSxLQUFLQTtBQUNyQixVQUFNbThELFdBQVduOEQsU0FBUWk3RDtBQUV6QixVQUFNeUIsUUFBUVAsU0FBU3ZKLFFBQVE2SCwwQkFBMEIwQixTQUFTekIsU0FBU3JoRSxLQUFLbUMsS0FBSyxLQUFLOGdFLGtCQUFrQmpqRSxHQUFBQSxDQUFBQTtBQUM1RyxVQUFNZzdELFdBQVdsckQsZUFBZW5KLFNBQVE4UixNQUFNdWlELFVBQVUsQ0FBQTtBQUN4RCxVQUFNc0ksVUFBVUQsVUFBVSxTQUFTUCxTQUFTNUIsYUFBYTtBQUN6RCxVQUFNcUMsYUFBYXY5QyxTQUFTczlDLE9BQVlBLEtBQUFBLFlBQVk7QUFDcEQsVUFBTTdxRCxRQUFRLENBQUE7QUFDZCxRQUFJaWYsUUFBUTEzQjtBQUNaLFFBQUk0aEUsTUFBTTN2RDtBQUdWLFFBQUlzeEQsWUFBWTtBQUNkN3JDLGNBQVEsQ0FBQ3FwQyxRQUFRaDRDLFFBQVEyTyxPQUFPLFdBQVc0ckMsT0FBQUE7O0FBSTdDNXJDLFlBQVEsQ0FBQ3FwQyxRQUFRaDRDLFFBQVEyTyxPQUFPNnJDLGFBQWEsUUFBUUYsS0FBSztBQUcxRCxRQUFJdEMsUUFBUWo0QyxLQUFLM21CLEtBQUtuQyxLQUFLcWpFLEtBQUFBLElBQVMsTUFBU3JJLFVBQVU7QUFDckQsWUFBTSxJQUFJMXlDLE1BQU10b0IsTUFBTSxVQUFVbUMsTUFBTSx5Q0FBeUM2NEQsV0FBVyxNQUFNcUksS0FBTzs7QUFHekcsVUFBTXhCLGFBQWFsN0QsU0FBUThSLE1BQU1zbEIsV0FBVyxVQUFVLEtBQUt5bEMsa0JBQWlCO0FBQzVFLFNBQUs1QixPQUFPbHFDLE9BQU96bEIsUUFBUSxHQUFHMnZELE9BQU96L0QsS0FBS3kvRCxPQUFPLENBQUNiLFFBQVFqL0QsSUFBSTgvRCxNQUFNNUcsVUFBVXFJLEtBQUFBLEdBQVFweEQsU0FBUztBQUM3RjB2RCxjQUFRbHBELE9BQU9tcEQsTUFBTUMsVUFBQUE7SUFDdkI7QUFFQSxRQUFJRCxTQUFTei9ELE9BQU93RSxTQUFRMDZDLFdBQVcsV0FBV3B2QyxVQUFVLEdBQUc7QUFDN0QwdkQsY0FBUWxwRCxPQUFPbXBELE1BQU1DLFVBQUFBOztBQUl2QixXQUFPLzdELE9BQU9DLEtBQUswUyxLQUFPUixFQUFBQSxLQUFLNG9ELE1BQUFBLEVBQVF2OEMsSUFBSWxjLENBQUFBLE1BQUssQ0FBQ0EsQ0FBQUE7RUFDbkQ7RUFNQTBMLGlCQUFpQnpNLE9BQU87QUFDdEIsVUFBTTA1RCxVQUFVLEtBQUtDO0FBQ3JCLFVBQU04QixXQUFXLEtBQUtuOEQsUUFBUWk3RDtBQUU5QixRQUFJa0IsU0FBU1csZUFBZTtBQUMxQixhQUFPMUMsUUFBUWw0QyxPQUFPeGhCLE9BQU95N0QsU0FBU1csYUFBYTs7QUFFckQsV0FBTzFDLFFBQVFsNEMsT0FBT3hoQixPQUFPeTdELFNBQVNMLGVBQWVpQixRQUFRO0VBQy9EO0VBT0E3NkMsT0FBT3hoQixPQUFPd2hCLFFBQVE7QUFDcEIsVUFBTWxpQixXQUFVLEtBQUtBO0FBQ3JCLFVBQU1paUIsVUFBVWppQixTQUFRaTdELEtBQUthO0FBQzdCLFVBQU1sSixPQUFPLEtBQUs2STtBQUNsQixVQUFNdUIsTUFBTTk2QyxVQUFVRCxRQUFRMndDLElBQUs7QUFDbkMsV0FBTyxLQUFLeUgsU0FBU240QyxPQUFPeGhCLE9BQU9zOEQsR0FBQUE7RUFDckM7RUFXQUMsb0JBQW9CaEMsTUFBTXY0RCxRQUFPb1AsT0FBT29RLFFBQVE7QUFDOUMsVUFBTWxpQixXQUFVLEtBQUtBO0FBQ3JCLFVBQU1rOUQsWUFBWWw5RCxTQUFROFIsTUFBTW1tQjtBQUVoQyxRQUFJaWxDLFdBQVc7QUFDYixhQUFPempFLFNBQUt5akUsV0FBVztRQUFDakM7UUFBTXY0RDtRQUFPb1A7TUFBTSxHQUFFLElBQUk7O0FBR25ELFVBQU1tUSxVQUFVamlCLFNBQVFpN0QsS0FBS2E7QUFDN0IsVUFBTWxKLE9BQU8sS0FBSzZJO0FBQ2xCLFVBQU1ILFlBQVksS0FBS0k7QUFDdkIsVUFBTXlCLGNBQWN2SyxRQUFRM3dDLFFBQVEyd0MsSUFBSztBQUN6QyxVQUFNd0ssY0FBYzlCLGFBQWFyNUMsUUFBUXE1QyxTQUFVO0FBQ25ELFVBQU0vZ0UsT0FBT3VYLE1BQU1wUCxNQUFNO0FBQ3pCLFVBQU1pdUIsUUFBUTJxQyxhQUFhOEIsZUFBZTdpRSxRQUFRQSxLQUFLbzJCO0FBRXZELFdBQU8sS0FBSzBwQyxTQUFTbjRDLE9BQU8rNEMsTUFBTS80QyxXQUFXeU8sUUFBUXlzQyxjQUFjRCxZQUFVO0VBQy9FO0VBS0FubEMsbUJBQW1CbG1CLE9BQU87QUFDeEIsUUFBSTVYLEdBQUd1SSxNQUFNbEk7QUFFYixTQUFLTCxJQUFJLEdBQUd1SSxPQUFPcVAsTUFBTTdYLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQzlDSyxhQUFPdVgsTUFBTTVYLENBQUU7QUFDZkssV0FBSzJTLFFBQVEsS0FBSyt2RCxvQkFBb0IxaUUsS0FBS21HLE9BQU94RyxHQUFHNFgsS0FBQUE7SUFDdkQ7RUFDRjtFQU1BMnFELG1CQUFtQi83RCxPQUFPO0FBQ3hCLFdBQU9BLFVBQVUsT0FBTytMLE9BQU8vTCxRQUFRLEtBQUtySCxRQUFRLEtBQUttQyxNQUFNLEtBQUtuQztFQUN0RTtFQU1Bd1ksaUJBQWlCblIsT0FBTztBQUN0QixVQUFNMjhELFVBQVUsS0FBSzFCO0FBQ3JCLFVBQU01MUMsTUFBTSxLQUFLMDJDLG1CQUFtQi83RCxLQUFBQTtBQUNwQyxXQUFPLEtBQUt3VyxvQkFBb0JtbUQsUUFBUS9qRSxRQUFReXNCLE9BQU9zM0MsUUFBUWxoRSxNQUFNO0VBQ3ZFO0VBTUFpYixpQkFBaUI0akIsT0FBTztBQUN0QixVQUFNcWlDLFVBQVUsS0FBSzFCO0FBQ3JCLFVBQU01MUMsTUFBTSxLQUFLcVYsbUJBQW1CSixLQUFBQSxJQUFTcWlDLFFBQVFsaEUsU0FBU2toRSxRQUFRaDhEO0FBQ3RFLFdBQU8sS0FBS2hJLE1BQU0wc0IsT0FBTyxLQUFLdnFCLE1BQU0sS0FBS25DO0VBQzNDO0VBT0Fpa0UsY0FBY3B3RCxPQUFPO0FBQ25CLFVBQU1xd0QsWUFBWSxLQUFLdjlELFFBQVE4UjtBQUMvQixVQUFNMHJELGlCQUFpQixLQUFLajJELElBQUlzOUMsWUFBWTMzQyxLQUFBQSxFQUFPc0k7QUFDbkQsVUFBTXNFLFFBQVFjLFVBQVUsS0FBS2pILGFBQVksSUFBSzRwRCxVQUFVbGxDLGNBQWNrbEMsVUFBVW5sQyxXQUFXO0FBQzNGLFVBQU1xbEMsY0FBY3JrRSxLQUFLb2dCLElBQUlNLEtBQUFBO0FBQzdCLFVBQU00akQsY0FBY3RrRSxLQUFLc2dCLElBQUlJLEtBQUFBO0FBQzdCLFVBQU02akQsZUFBZSxLQUFLaGpDLHdCQUF3QixDQUFBLEVBQUdoNkI7QUFFckQsV0FBTztNQUNMNG5CLEdBQUlpMUMsaUJBQWlCQyxjQUFnQkUsZUFBZUQ7TUFDcERqMUMsR0FBSSswQyxpQkFBaUJFLGNBQWdCQyxlQUFlRjtJQUN0RDtFQUNGO0VBT0FuQixrQkFBa0JzQixhQUFhO0FBQzdCLFVBQU16QixXQUFXLEtBQUtuOEQsUUFBUWk3RDtBQUM5QixVQUFNYSxpQkFBaUJLLFNBQVNMO0FBR2hDLFVBQU01NUMsU0FBUzQ1QyxlQUFlSyxTQUFTdkosSUFBSSxLQUFLa0osZUFBZXZDO0FBQy9ELFVBQU1zRSxlQUFlLEtBQUtaLG9CQUFvQlcsYUFBYSxHQUFHckMsb0JBQW9CLE1BQU07TUFBQ3FDO09BQWMsS0FBS2xDLFVBQVUsR0FBR3g1QyxNQUFBQTtBQUN6SCxVQUFNdmhCLE9BQU8sS0FBSzI4RCxjQUFjTyxZQUFBQTtBQUdoQyxVQUFNbEQsV0FBV3ZoRSxLQUFLb0UsTUFBTSxLQUFLbVcsYUFBWSxJQUFLLEtBQUs2QixRQUFRN1UsS0FBSzRuQixJQUFJLEtBQUtoVCxTQUFTNVUsS0FBSzhuQixDQUFDLElBQUk7QUFDaEcsV0FBT2t5QyxXQUFXLElBQUlBLFdBQVc7RUFDbkM7RUFLQWtDLG9CQUFvQjtBQUNsQixRQUFJM0IsYUFBYSxLQUFLanFELE9BQU8zTixRQUFRLENBQUE7QUFDckMsUUFBSXBKLEdBQUd1STtBQUVQLFFBQUl5NEQsV0FBV2poRSxRQUFRO0FBQ3JCLGFBQU9paEU7O0FBR1QsVUFBTXZsQyxRQUFRLEtBQUt6d0Isd0JBQXVCO0FBRTFDLFFBQUksS0FBSzAyRCxlQUFlam1DLE1BQU0xN0IsUUFBUTtBQUNwQyxhQUFRLEtBQUtnWCxPQUFPM04sT0FBT3F5QixNQUFNLENBQUEsRUFBR3Z3QixXQUFXMkgsbUJBQW1CLElBQUk7O0FBR3hFLFNBQUs3UyxJQUFJLEdBQUd1SSxPQUFPa3pCLE1BQU0xN0IsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDOUNnaEUsbUJBQWFBLFdBQVc5cEQsT0FBT3VrQixNQUFNejdCLENBQUUsRUFBQ2tMLFdBQVcySCxtQkFBbUIsSUFBSSxDQUFBO0lBQzVFO0FBRUEsV0FBUSxLQUFLa0UsT0FBTzNOLE9BQU8sS0FBS3c2RCxVQUFVNUMsVUFBQUE7RUFDNUM7RUFLQWdCLHFCQUFxQjtBQUNuQixVQUFNaEIsYUFBYSxLQUFLanFELE9BQU9uRixVQUFVLENBQUE7QUFDekMsUUFBSTVSLEdBQUd1STtBQUVQLFFBQUl5NEQsV0FBV2poRSxRQUFRO0FBQ3JCLGFBQU9paEU7O0FBR1QsVUFBTXB2RCxTQUFTLEtBQUtDLFVBQVM7QUFDN0IsU0FBSzdSLElBQUksR0FBR3VJLE9BQU9xSixPQUFPN1IsUUFBUUMsSUFBSXVJLE1BQU0sRUFBRXZJLEdBQUc7QUFDL0NnaEUsaUJBQVdoZ0UsS0FBS21RLE1BQU0sTUFBTVMsT0FBTzVSLENBQUUsQ0FBQSxDQUFBO0lBQ3ZDO0FBRUEsV0FBUSxLQUFLK1csT0FBT25GLFNBQVMsS0FBSzh2RCxjQUFjVixhQUFhLEtBQUs0QyxVQUFVNUMsVUFBVztFQUN6RjtFQU1BNEMsVUFBVWgrRCxRQUFRO0FBRWhCLFdBQU91UixhQUFhdlIsT0FBT3dSLEtBQUs0b0QsTUFBQUEsQ0FBQUE7RUFDbEM7QUFDRjtBQTFkRSxjQUZtQnNCLFdBRVpwM0QsTUFBSztBQUtaLGNBUG1CbzNELFdBT1puOEQsWUFBVztFQVFoQnE3QyxRQUFRO0VBRVJtaEIsVUFBVSxDQUFBO0VBQ1ZaLE1BQU07SUFDSlgsUUFBUTtJQUNSMUgsTUFBTTtJQUNOeGhDLE9BQU87SUFDUG1wQyxZQUFZO0lBQ1pHLFNBQVM7SUFDVG9CLGdCQUFnQixDQUFBO0VBQ2xCO0VBQ0FocUQsT0FBTztJQVNMc2xCLFFBQVE7SUFFUmEsVUFBVTtJQUVWdEgsT0FBTztNQUNMQyxTQUFTO0lBQ1g7RUFDRjs7QUNyT0osU0FBU2lvQixhQUFZa2xCLE9BQU8vbkQsS0FBSzVVLFNBQVM7QUFDeEMsTUFBSTZoQixLQUFLO0FBQ1QsTUFBSUcsS0FBSzI2QyxNQUFNOWpFLFNBQVM7QUFDeEIsTUFBSStqRSxZQUFZQyxZQUFZQyxZQUFZQztBQUN4QyxNQUFJLzhELFNBQVM7QUFDWCxRQUFJNFUsT0FBTytuRCxNQUFNOTZDLEVBQUFBLEVBQUk4QyxPQUFPL1AsT0FBTytuRCxNQUFNMzZDLEVBQUcsRUFBQzJDLEtBQUs7QUFDL0MsT0FBQSxFQUFDOUMsSUFBSUcsR0FBQUEsSUFBTVAsYUFBYWs3QyxPQUFPLE9BQU8vbkQsR0FBRzs7QUFFM0MsS0FBQSxFQUFDK1AsS0FBS2k0QyxZQUFZL0MsTUFBTWlELFdBQVUsSUFBSUgsTUFBTTk2QyxFQUFBQTtBQUM1QyxLQUFBLEVBQUM4QyxLQUFLazRDLFlBQVloRCxNQUFNa0QsV0FBVSxJQUFJSixNQUFNMzZDLEVBQUFBO1NBQ3hDO0FBQ0wsUUFBSXBOLE9BQU8rbkQsTUFBTTk2QyxFQUFBQSxFQUFJZzRDLFFBQVFqbEQsT0FBTytuRCxNQUFNMzZDLEVBQUcsRUFBQzYzQyxNQUFNO0FBQ2pELE9BQUEsRUFBQ2g0QyxJQUFJRyxHQUFBQSxJQUFNUCxhQUFhazdDLE9BQU8sUUFBUS9uRCxHQUFHOztBQUU1QyxLQUFBLEVBQUNpbEQsTUFBTStDLFlBQVlqNEMsS0FBS200QyxXQUFVLElBQUlILE1BQU05NkMsRUFBQUE7QUFDNUMsS0FBQSxFQUFDZzRDLE1BQU1nRCxZQUFZbDRDLEtBQUtvNEMsV0FBVSxJQUFJSixNQUFNMzZDLEVBQUFBOztBQUcvQyxRQUFNZzdDLE9BQU9ILGFBQWFEO0FBQzFCLFNBQU9JLE9BQU9GLGNBQWNDLGFBQWFELGVBQWVsb0QsTUFBTWdvRCxjQUFjSSxPQUFPRjtBQUNyRjtBQUVBLElBQU1HLGtCQUFOLGNBQThCN0MsVUFBQUE7RUFZNUJ4akUsWUFBWXdJLE9BQU87QUFDakIsVUFBTUEsS0FBQUE7QUFHTixTQUFLODlELFNBQVMsQ0FBQTtBQUVkLFNBQUtDLFVBQVVqbUU7QUFFZixTQUFLa21FLGNBQWNsbUU7RUFDckI7RUFLQWlrRSxjQUFjO0FBQ1osVUFBTXJCLGFBQWEsS0FBS3VELHVCQUFzQjtBQUM5QyxVQUFNVixRQUFRLEtBQUtPLFNBQVMsS0FBS0ksaUJBQWlCeEQsVUFBQUE7QUFDbEQsU0FBS3FELFVBQVUxbEIsYUFBWWtsQixPQUFPLEtBQUsxa0UsR0FBRztBQUMxQyxTQUFLbWxFLGNBQWMzbEIsYUFBWWtsQixPQUFPLEtBQUt2aUUsR0FBRyxJQUFJLEtBQUsraUU7QUFDdkQsVUFBTWhDLFlBQVlyQixVQUFBQTtFQUNwQjtFQWFBd0QsaUJBQWlCeEQsWUFBWTtBQUMzQixVQUFNLEVBQUM3aEUsS0FBS21DLElBQUcsSUFBSTtBQUNuQixVQUFNeEIsUUFBUSxDQUFBO0FBQ2QsVUFBTStqRSxRQUFRLENBQUE7QUFDZCxRQUFJN2pFLEdBQUd1SSxNQUFNZ0osTUFBTWlHLE1BQU1rQjtBQUV6QixTQUFLMVksSUFBSSxHQUFHdUksT0FBT3k0RCxXQUFXamhFLFFBQVFDLElBQUl1SSxNQUFNLEVBQUV2SSxHQUFHO0FBQ25Ed1gsYUFBT3dwRCxXQUFXaGhFLENBQUU7QUFDcEIsVUFBSXdYLFFBQVFyWSxPQUFPcVksUUFBUWxXLEtBQUs7QUFDOUJ4QixjQUFNa0IsS0FBS3dXLElBQUFBOztJQUVmO0FBRUEsUUFBSTFYLE1BQU1DLFNBQVMsR0FBRztBQUVwQixhQUFPO1FBQ0w7VUFBQ2doRSxNQUFNNWhFO1VBQUswc0IsS0FBSztRQUFDO1FBQ2xCO1VBQUNrMUMsTUFBTXovRDtVQUFLdXFCLEtBQUs7UUFBQztNQUNuQjs7QUFHSCxTQUFLN3JCLElBQUksR0FBR3VJLE9BQU96SSxNQUFNQyxRQUFRQyxJQUFJdUksTUFBTSxFQUFFdkksR0FBRztBQUM5QzBZLGFBQU81WSxNQUFNRSxJQUFJLENBQUU7QUFDbkJ1UixhQUFPelIsTUFBTUUsSUFBSSxDQUFFO0FBQ25Cd1gsYUFBTzFYLE1BQU1FLENBQUU7QUFHZixVQUFJZCxLQUFLZzRCLE9BQU94ZSxPQUFPbkgsUUFBUSxDQUFBLE1BQU9pRyxNQUFNO0FBQzFDcXNELGNBQU03aUUsS0FBSztVQUFDKy9ELE1BQU12cEQ7VUFBTXFVLEtBQUs3ckIsS0FBS3VJLE9BQU87UUFBRSxDQUFBOztJQUUvQztBQUNBLFdBQU9zN0Q7RUFDVDtFQVFBM0IsWUFBWTtBQUNWLFVBQU0vaUUsTUFBTSxLQUFLQTtBQUNqQixVQUFNbUMsTUFBTSxLQUFLQTtBQUNqQixRQUFJMC9ELGFBQWEsTUFBTTJCLGtCQUFpQjtBQUN4QyxRQUFJLENBQUMzQixXQUFXdjBDLFNBQVN0dEIsR0FBQUEsS0FBUSxDQUFDNmhFLFdBQVdqaEUsUUFBUTtBQUNuRGloRSxpQkFBVzdxRCxPQUFPLEdBQUcsR0FBR2hYLEdBQUFBOztBQUUxQixRQUFJLENBQUM2aEUsV0FBV3YwQyxTQUFTbnJCLEdBQUFBLEtBQVEwL0QsV0FBV2poRSxXQUFXLEdBQUc7QUFDeERpaEUsaUJBQVdoZ0UsS0FBS00sR0FBQUE7O0FBRWxCLFdBQU8wL0QsV0FBVzVwRCxLQUFLLENBQUNDLEdBQUdyUCxNQUFNcVAsSUFBSXJQLENBQUFBO0VBQ3ZDO0VBT0F1OEQseUJBQXlCO0FBQ3ZCLFFBQUl2RCxhQUFhLEtBQUtqcUQsT0FBT2xRLE9BQU8sQ0FBQTtBQUVwQyxRQUFJbTZELFdBQVdqaEUsUUFBUTtBQUNyQixhQUFPaWhFOztBQUdULFVBQU01M0QsT0FBTyxLQUFLdTVELGtCQUFpQjtBQUNuQyxVQUFNM3ZELFFBQVEsS0FBS2d2RCxtQkFBa0I7QUFDckMsUUFBSTU0RCxLQUFLckosVUFBVWlULE1BQU1qVCxRQUFRO0FBRy9CaWhFLG1CQUFhLEtBQUs0QyxVQUFVeDZELEtBQUs4TixPQUFPbEUsS0FBQUEsQ0FBQUE7V0FDbkM7QUFDTGd1RCxtQkFBYTUzRCxLQUFLckosU0FBU3FKLE9BQU80Sjs7QUFFcENndUQsaUJBQWEsS0FBS2pxRCxPQUFPbFEsTUFBTW02RDtBQUUvQixXQUFPQTtFQUNUO0VBTUF1QixtQkFBbUIvN0QsT0FBTztBQUN4QixZQUFRbTRDLGFBQVksS0FBS3lsQixRQUFRNTlELEtBQVMsSUFBQSxLQUFLNjlELFdBQVcsS0FBS0M7RUFDakU7RUFNQXBuRCxpQkFBaUI0akIsT0FBTztBQUN0QixVQUFNcWlDLFVBQVUsS0FBSzFCO0FBQ3JCLFVBQU0xZ0MsVUFBVSxLQUFLRyxtQkFBbUJKLEtBQUFBLElBQVNxaUMsUUFBUWxoRSxTQUFTa2hFLFFBQVFoOEQ7QUFDMUUsV0FBT3czQyxhQUFZLEtBQUt5bEIsUUFBUXJqQyxVQUFVLEtBQUt1akMsY0FBYyxLQUFLRCxTQUFTLElBQUk7RUFDakY7QUFDRjtBQTNJRSxjQUZJRixpQkFFR2o2RCxNQUFLO0FBS1osY0FQSWk2RCxpQkFPR2gvRCxZQUFXbThELFVBQVVuOEQ7Ozs7Ozs7Ozs7SUNyQmpCcy9ELGdCQUFnQjtFQUMzQnY4QjtFQUNBOTBCO0VBQ0FpUTtFQUNBdlg7Ozs7QXRGZkYsTUFBTSxTQUFTLEdBQUcsYUFBYTtBQXVDeEIsSUFBTSxpQkFBTixNQUFNLHVCQUFzQiwwQkFBUztBQUFBLEVBTzFDLFlBQVksTUFBNkIsUUFBcUI7QUFDNUQsVUFBTSxJQUFJO0FBRDZCO0FBTHpDLFNBQVEsVUFBd0Msb0JBQUksSUFBSTtBQUN4RCxTQUFRLFNBQTZCLG9CQUFJLElBQUk7QUFDN0MsU0FBUSxtQkFBd0Msb0JBQUksSUFBSTtBQUN4RCxTQUFRLGFBQWE7QUFJbkIsU0FBSyx5QkFBeUI7QUFBQSxFQUNoQztBQUFBLEVBRUEsY0FBYztBQUNaLFdBQU8sZUFBYztBQUFBLEVBQ3ZCO0FBQUEsRUFFQSxpQkFBaUI7QUFDZixXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsVUFBVTtBQUNSLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFQSxNQUFNLFNBQVM7QUFDYixVQUFNLFlBQVksS0FBSyxZQUFZLFNBQVMsQ0FBQztBQUM3QyxjQUFVLE1BQU07QUFDaEIsY0FBVSxTQUFTLGtCQUFrQjtBQUVyQyxVQUFNLEtBQUssZ0JBQWdCO0FBQzNCLFNBQUssaUJBQWlCO0FBQUEsRUFDeEI7QUFBQSxFQUVBLE1BQU0sVUFBVTtBQUNkLFNBQUssZ0JBQWdCO0FBQ3JCLFNBQUssY0FBYztBQUFBLEVBQ3JCO0FBQUEsRUFFUSwyQkFBMkI7QUFDakMsVUFBTSxpQkFBb0M7QUFBQSxNQUN4QztBQUFBLFFBQ0UsSUFBSTtBQUFBLFFBQ0osT0FBTztBQUFBLFFBQ1AsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLFFBQ04sVUFBVSxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFBQSxRQUN2QixNQUFNLENBQUM7QUFBQSxRQUNQLGlCQUFpQjtBQUFBO0FBQUEsTUFDbkI7QUFBQSxNQUNBO0FBQUEsUUFDRSxJQUFJO0FBQUEsUUFDSixPQUFPO0FBQUEsUUFDUCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsUUFDTixVQUFVLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRTtBQUFBLFFBQ3ZCLE1BQU0sRUFBRSxXQUFXLE9BQU87QUFBQSxRQUMxQixpQkFBaUI7QUFBQTtBQUFBLE1BQ25CO0FBQUEsTUFDQTtBQUFBLFFBQ0UsSUFBSTtBQUFBLFFBQ0osT0FBTztBQUFBLFFBQ1AsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLFFBQ04sVUFBVSxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFBQSxRQUN2QixNQUFNLEVBQUUsV0FBVyxXQUFXO0FBQUEsUUFDOUIsaUJBQWlCO0FBQUEsTUFDbkI7QUFBQSxNQUNBO0FBQUEsUUFDRSxJQUFJO0FBQUEsUUFDSixPQUFPO0FBQUEsUUFDUCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsUUFDTixVQUFVLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRTtBQUFBLFFBQ3ZCLE1BQU0sQ0FBQztBQUFBLFFBQ1AsaUJBQWlCO0FBQUE7QUFBQSxNQUNuQjtBQUFBLE1BQ0E7QUFBQSxRQUNFLElBQUk7QUFBQSxRQUNKLE9BQU87QUFBQSxRQUNQLE1BQU07QUFBQSxRQUNOLE1BQU07QUFBQSxRQUNOLFVBQVUsRUFBRSxHQUFHLEdBQUcsR0FBRyxFQUFFO0FBQUEsUUFDdkIsTUFBTSxFQUFFLFNBQVMsZ0RBQWdEO0FBQUEsTUFDbkU7QUFBQSxNQUNBO0FBQUEsUUFDRSxJQUFJO0FBQUEsUUFDSixPQUFPO0FBQUEsUUFDUCxNQUFNO0FBQUEsUUFDTixNQUFNO0FBQUEsUUFDTixVQUFVLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRTtBQUFBLFFBQ3ZCLE1BQU0sQ0FBQztBQUFBLFFBQ1AsaUJBQWlCO0FBQUEsTUFDbkI7QUFBQSxJQUNGO0FBRUEsbUJBQWUsUUFBUSxZQUFVO0FBQy9CLFdBQUssUUFBUSxJQUFJLE9BQU8sSUFBSSxNQUFNO0FBQUEsSUFDcEMsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVBLE1BQWMsa0JBQWtCO0FBQzlCLFVBQU0sWUFBWSxLQUFLLFlBQVksU0FBUyxDQUFDO0FBQzdDLGNBQVUsTUFBTTtBQUdoQixVQUFNLFNBQVMsVUFBVSxTQUFTLE9BQU8sRUFBRSxLQUFLLG1CQUFtQixDQUFDO0FBRXBFLFdBQU8sU0FBUyxNQUFNO0FBQUEsTUFDcEIsTUFBTTtBQUFBLE1BQ04sS0FBSztBQUFBLElBQ1AsQ0FBQztBQUVELFVBQU0sZ0JBQWdCLE9BQU8sU0FBUyxPQUFPLEVBQUUsS0FBSyxvQkFBb0IsQ0FBQztBQUd6RSxVQUFNLFVBQVUsY0FBYyxTQUFTLFVBQVU7QUFBQSxNQUMvQyxNQUFNLEtBQUssYUFBYSxnQkFBZ0I7QUFBQSxNQUN4QyxLQUFLO0FBQUEsSUFDUCxDQUFDO0FBQ0QsWUFBUSxVQUFVLE1BQU0sS0FBSyxlQUFlO0FBRzVDLFVBQU0sYUFBYSxjQUFjLFNBQVMsVUFBVTtBQUFBLE1BQ2xELE1BQU07QUFBQSxNQUNOLEtBQUs7QUFBQSxJQUNQLENBQUM7QUFDRCxlQUFXLFVBQVUsTUFBTSxLQUFLLGtCQUFrQjtBQUdsRCxVQUFNLFNBQVMsY0FBYyxTQUFTLFVBQVU7QUFBQSxNQUM5QyxNQUFNO0FBQUEsTUFDTixLQUFLO0FBQUEsSUFDUCxDQUFDO0FBQ0QsV0FBTyxVQUFVLE1BQU0sS0FBSyxtQkFBbUI7QUFHL0MsVUFBTSxPQUFPLFVBQVUsU0FBUyxPQUFPLEVBQUUsS0FBSyxpQkFBaUIsQ0FBQztBQUVoRSxRQUFJLEtBQUssWUFBWTtBQUNuQixXQUFLLFNBQVMsV0FBVztBQUFBLElBQzNCO0FBR0EsZUFBVyxDQUFDLElBQUksTUFBTSxLQUFLLEtBQUssU0FBUztBQUN2QyxZQUFNLEtBQUssYUFBYSxNQUFNLE1BQU07QUFBQSxJQUN0QztBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQWMsYUFBYSxXQUF3QixRQUF5QjtBQUMxRSxVQUFNLFdBQVcsVUFBVSxTQUFTLE9BQU87QUFBQSxNQUN6QyxLQUFLLDJCQUEyQixPQUFPLElBQUksV0FBVyxPQUFPLElBQUk7QUFBQSxNQUNqRSxNQUFNO0FBQUEsUUFDSixrQkFBa0IsT0FBTztBQUFBLFFBQ3pCLFVBQVUsT0FBTyxTQUFTLEVBQUUsU0FBUztBQUFBLFFBQ3JDLFVBQVUsT0FBTyxTQUFTLEVBQUUsU0FBUztBQUFBLE1BQ3ZDO0FBQUEsSUFDRixDQUFDO0FBR0QsVUFBTSxTQUFTLFNBQVMsU0FBUyxPQUFPLEVBQUUsS0FBSyxnQkFBZ0IsQ0FBQztBQUNoRSxXQUFPLFNBQVMsTUFBTSxFQUFFLE1BQU0sT0FBTyxPQUFPLEtBQUssZUFBZSxDQUFDO0FBRWpFLFFBQUksS0FBSyxZQUFZO0FBQ25CLFlBQU0sVUFBVSxPQUFPLFNBQVMsT0FBTyxFQUFFLEtBQUssaUJBQWlCLENBQUM7QUFFaEUsWUFBTSxZQUFZLFFBQVEsU0FBUyxVQUFVO0FBQUEsUUFDM0MsTUFBTTtBQUFBLFFBQ04sS0FBSztBQUFBLE1BQ1AsQ0FBQztBQUNELGdCQUFVLFVBQVUsTUFBTSxLQUFLLGFBQWEsT0FBTyxFQUFFO0FBRXJELFlBQU0sWUFBWSxRQUFRLFNBQVMsVUFBVTtBQUFBLFFBQzNDLE1BQU07QUFBQSxRQUNOLEtBQUs7QUFBQSxNQUNQLENBQUM7QUFDRCxnQkFBVSxVQUFVLE1BQU0sS0FBSyxnQkFBZ0IsT0FBTyxFQUFFO0FBQUEsSUFDMUQ7QUFHQSxVQUFNLFVBQVUsU0FBUyxTQUFTLE9BQU8sRUFBRSxLQUFLLGlCQUFpQixDQUFDO0FBRWxFLFFBQUk7QUFDRixZQUFNLEtBQUssb0JBQW9CLFNBQVMsTUFBTTtBQUFBLElBQ2hELFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSwyQkFBMkIsT0FBTyxFQUFFLEtBQUssS0FBSztBQUM1RCxjQUFRLFNBQVMsT0FBTztBQUFBLFFBQ3RCLE1BQU0seUJBQTBCLE1BQWdCLE9BQU87QUFBQSxRQUN2RCxLQUFLO0FBQUEsTUFDUCxDQUFDO0FBQUEsSUFDSDtBQUdBLFFBQUksS0FBSyxZQUFZO0FBQ25CLFdBQUssY0FBYyxRQUFRO0FBQUEsSUFDN0I7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLG9CQUFvQixXQUF3QixRQUF5QjtBQUNqRixZQUFRLE9BQU8sTUFBTTtBQUFBLE1BQ25CLEtBQUs7QUFDSCxjQUFNLEtBQUssbUJBQW1CLFdBQVcsTUFBTTtBQUMvQztBQUFBLE1BQ0YsS0FBSztBQUNILGNBQU0sS0FBSyxrQkFBa0IsV0FBVyxNQUFNO0FBQzlDO0FBQUEsTUFDRixLQUFLO0FBQ0gsY0FBTSxLQUFLLGlCQUFpQixXQUFXLE1BQU07QUFDN0M7QUFBQSxNQUNGLEtBQUs7QUFDSCxjQUFNLEtBQUsscUJBQXFCLFdBQVcsTUFBTTtBQUNqRDtBQUFBLE1BQ0YsS0FBSztBQUNILGNBQU0sS0FBSyx1QkFBdUIsV0FBVyxNQUFNO0FBQ25EO0FBQUEsTUFDRjtBQUNFLGtCQUFVLFNBQVMsT0FBTyxFQUFFLE1BQU0sdUJBQXVCLEtBQUssZUFBZSxDQUFDO0FBQUEsSUFDbEY7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLG1CQUFtQixXQUF3QixRQUF5QjtBQUNoRixVQUFNLFVBQVUsTUFBTSxLQUFLLG9CQUFvQjtBQUUvQyxVQUFNLGNBQWMsVUFBVSxTQUFTLE9BQU8sRUFBRSxLQUFLLGVBQWUsQ0FBQztBQUVyRSxVQUFNLGNBQWM7QUFBQSxNQUNsQixFQUFFLE9BQU8sU0FBUyxPQUFPLFFBQVEsWUFBWSxNQUFNLFlBQUs7QUFBQSxNQUN4RCxFQUFFLE9BQU8sU0FBUyxPQUFPLFFBQVEsV0FBVyxlQUFlLEdBQUcsTUFBTSxZQUFLO0FBQUEsTUFDekUsRUFBRSxPQUFPLFFBQVEsT0FBTyxRQUFRLFdBQVcsTUFBTSxrQkFBTTtBQUFBLE1BQ3ZELEVBQUUsT0FBTyxTQUFTLE9BQU8sUUFBUSxZQUFZLE1BQU0sWUFBSztBQUFBLElBQzFEO0FBRUEsZ0JBQVksUUFBUSxVQUFRO0FBQzFCLFlBQU0sV0FBVyxZQUFZLFNBQVMsT0FBTyxFQUFFLEtBQUssY0FBYyxDQUFDO0FBQ25FLGVBQVMsU0FBUyxPQUFPLEVBQUUsTUFBTSxLQUFLLE1BQU0sS0FBSyxjQUFjLENBQUM7QUFDaEUsZUFBUyxTQUFTLE9BQU8sRUFBRSxNQUFNLEtBQUssTUFBTSxTQUFTLEdBQUcsS0FBSyxlQUFlLENBQUM7QUFDN0UsZUFBUyxTQUFTLE9BQU8sRUFBRSxNQUFNLEtBQUssT0FBTyxLQUFLLGVBQWUsQ0FBQztBQUFBLElBQ3BFLENBQUM7QUFBQSxFQUNIO0FBQUEsRUFFQSxNQUFjLGtCQUFrQixXQUF3QixRQUF5QjtBQUMvRSxVQUFNLFNBQVMsVUFBVSxTQUFTLFVBQVU7QUFBQSxNQUMxQyxNQUFNLEVBQUUsT0FBTyxPQUFPLFFBQVEsTUFBTTtBQUFBLElBQ3RDLENBQUM7QUFFRCxVQUFNLFVBQVUsTUFBTSxLQUFLLG9CQUFvQjtBQUMvQyxRQUFJO0FBQ0osUUFBSTtBQUVKLFlBQVEsT0FBTyxLQUFLLFdBQVc7QUFBQSxNQUM3QixLQUFLO0FBQ0gsb0JBQVk7QUFBQSxVQUNWLFFBQVEsUUFBUSxlQUFlLElBQUksT0FBSyxFQUFFLElBQUk7QUFBQSxVQUM5QyxVQUFVLENBQUM7QUFBQSxZQUNULE9BQU87QUFBQSxZQUNQLE1BQU0sUUFBUSxlQUFlLElBQUksT0FBSyxFQUFFLEtBQUs7QUFBQSxZQUM3QyxhQUFhO0FBQUEsWUFDYixpQkFBaUI7QUFBQSxZQUNqQixTQUFTO0FBQUEsVUFDWCxDQUFDO0FBQUEsUUFDSDtBQUNBLHVCQUFlO0FBQUEsVUFDYixZQUFZO0FBQUEsVUFDWixxQkFBcUI7QUFBQSxVQUNyQixRQUFRO0FBQUEsWUFDTixHQUFHLEVBQUUsYUFBYSxLQUFLO0FBQUEsVUFDekI7QUFBQSxRQUNGO0FBQ0E7QUFBQSxNQUVGLEtBQUs7QUFDSCxvQkFBWTtBQUFBLFVBQ1YsUUFBUSxRQUFRLFFBQVEsSUFBSSxPQUFLLEVBQUUsR0FBRztBQUFBLFVBQ3RDLFVBQVUsQ0FBQztBQUFBLFlBQ1QsTUFBTSxRQUFRLFFBQVEsSUFBSSxPQUFLLEVBQUUsS0FBSztBQUFBLFlBQ3RDLGlCQUFpQjtBQUFBLGNBQ2Y7QUFBQSxjQUFXO0FBQUEsY0FBVztBQUFBLGNBQVc7QUFBQSxjQUNqQztBQUFBLGNBQVc7QUFBQSxjQUFXO0FBQUEsY0FBVztBQUFBLFlBQ25DO0FBQUEsVUFDRixDQUFDO0FBQUEsUUFDSDtBQUNBLHVCQUFlO0FBQUEsVUFDYixZQUFZO0FBQUEsVUFDWixxQkFBcUI7QUFBQSxVQUNyQixTQUFTO0FBQUEsWUFDUCxRQUFRLEVBQUUsVUFBVSxRQUFRO0FBQUEsVUFDOUI7QUFBQSxRQUNGO0FBQ0E7QUFBQSxNQUVGO0FBQ0Usa0JBQVUsU0FBUyxPQUFPLEVBQUUsTUFBTSxzQkFBc0IsS0FBSyxlQUFlLENBQUM7QUFDN0U7QUFBQSxJQUNKO0FBRUEsVUFBTSxRQUFRLElBQUksTUFBTSxRQUFRO0FBQUEsTUFDOUIsTUFBTSxPQUFPLEtBQUs7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixTQUFTO0FBQUEsSUFDWCxDQUFDO0FBRUQsU0FBSyxPQUFPLElBQUksT0FBTyxJQUFJLEtBQUs7QUFBQSxFQUNsQztBQUFBLEVBRUEsTUFBYyxpQkFBaUIsV0FBd0IsUUFBeUI7QUFDOUUsVUFBTSxjQUFjLEtBQUssT0FBTyxJQUFJLE1BQU0saUJBQWlCLEVBQ3hELEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxLQUFLLFFBQVEsRUFBRSxLQUFLLEtBQUssRUFDMUMsTUFBTSxHQUFHLEVBQUU7QUFFZCxVQUFNLE9BQU8sVUFBVSxTQUFTLE1BQU0sRUFBRSxLQUFLLGNBQWMsQ0FBQztBQUU1RCxnQkFBWSxRQUFRLFVBQVE7QUFDMUIsWUFBTSxPQUFPLEtBQUssU0FBUyxNQUFNLEVBQUUsS0FBSyxZQUFZLENBQUM7QUFFckQsWUFBTSxPQUFPLEtBQUssU0FBUyxLQUFLO0FBQUEsUUFDOUIsTUFBTSxLQUFLO0FBQUEsUUFDWCxLQUFLO0FBQUEsTUFDUCxDQUFDO0FBQ0QsV0FBSyxVQUFVLFlBQVk7QUFDekIsY0FBTSxPQUFPLEtBQUssT0FBTyxJQUFJLFVBQVUsUUFBUSxLQUFLO0FBQ3BELGNBQU0sS0FBSyxTQUFTLElBQUk7QUFBQSxNQUMxQjtBQUVBLFlBQU0sT0FBTyxLQUFLLFNBQVMsUUFBUTtBQUFBLFFBQ2pDLE1BQU0sSUFBSSxLQUFLLEtBQUssS0FBSyxLQUFLLEVBQUUsbUJBQW1CO0FBQUEsUUFDbkQsS0FBSztBQUFBLE1BQ1AsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVBLE1BQWMscUJBQXFCLFdBQXdCLFFBQXlCO0FBQ2xGLFVBQU0sVUFBVSxPQUFPLEtBQUssV0FBVztBQUV2QyxRQUFJLEtBQUssWUFBWTtBQUNuQixZQUFNLFdBQVcsVUFBVSxTQUFTLFlBQVk7QUFBQSxRQUM5QyxPQUFPO0FBQUEsUUFDUCxLQUFLO0FBQUEsTUFDUCxDQUFDO0FBQ0QsZUFBUyxXQUFXLE1BQU07QUFDeEIsZUFBTyxLQUFLLFVBQVUsU0FBUztBQUMvQixhQUFLLGlCQUFpQjtBQUFBLE1BQ3hCO0FBQUEsSUFDRixPQUFPO0FBQ0wsWUFBTSxPQUFPLE9BQU8sT0FBTztBQUUzQixnQkFBVSxZQUFZO0FBQ3RCLGdCQUFVLFNBQVMsa0JBQWtCO0FBQUEsSUFDdkM7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLHVCQUF1QixXQUF3QixRQUF5QjtBQUNwRixVQUFNLFlBQVksVUFBVSxTQUFTLE9BQU87QUFBQSxNQUMxQyxNQUFNO0FBQUEsTUFDTixLQUFLO0FBQUEsSUFDUCxDQUFDO0FBRUQsUUFBSTtBQUNGLFlBQU0sV0FBVyxNQUFNLEtBQUssbUJBQW1CO0FBQy9DLGdCQUFVLE9BQU87QUFFakIsWUFBTSxvQkFBb0IsVUFBVSxTQUFTLE9BQU8sRUFBRSxLQUFLLGNBQWMsQ0FBQztBQUUxRSxlQUFTLFFBQVEsYUFBVztBQUMxQixjQUFNLFlBQVksa0JBQWtCLFNBQVMsT0FBTyxFQUFFLEtBQUssZUFBZSxDQUFDO0FBQzNFLGtCQUFVLFNBQVMsTUFBTSxFQUFFLE1BQU0sUUFBUSxPQUFPLEtBQUssZ0JBQWdCLENBQUM7QUFDdEUsa0JBQVUsU0FBUyxLQUFLLEVBQUUsTUFBTSxRQUFRLGFBQWEsS0FBSyxzQkFBc0IsQ0FBQztBQUVqRixZQUFJLFFBQVEsUUFBUTtBQUNsQixnQkFBTSxZQUFZLFVBQVUsU0FBUyxVQUFVO0FBQUEsWUFDN0MsTUFBTSxRQUFRLE9BQU87QUFBQSxZQUNyQixLQUFLO0FBQUEsVUFDUCxDQUFDO0FBQ0Qsb0JBQVUsVUFBVSxRQUFRLE9BQU87QUFBQSxRQUNyQztBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0gsU0FBUyxPQUFPO0FBQ2QsZ0JBQVUsUUFBUSxnQ0FBaUMsTUFBZ0IsT0FBTyxFQUFFO0FBQzVFLGdCQUFVLFNBQVMsZUFBZTtBQUFBLElBQ3BDO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYyxzQkFBaUQ7QUFDN0QsVUFBTSxRQUFRLEtBQUssT0FBTyxJQUFJLE1BQU0saUJBQWlCO0FBQ3JELFVBQU0sUUFBUSxLQUFLLE9BQU8sSUFBSTtBQUU5QixRQUFJLGFBQWE7QUFDakIsVUFBTSxPQUFPLG9CQUFJLElBQVk7QUFDN0IsUUFBSSxhQUFhO0FBQ2pCLFVBQU0saUJBQXVGLENBQUM7QUFHOUYsZUFBVyxRQUFRLE9BQU87QUFDeEIsWUFBTSxZQUFZLE1BQU0sYUFBYSxJQUFJO0FBR3pDLFVBQUk7QUFDRixjQUFNLFVBQVUsTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLEtBQUssSUFBSTtBQUNyRCxzQkFBYyxRQUFRLE1BQU0sS0FBSyxFQUFFO0FBQUEsTUFDckMsU0FBUyxHQUFHO0FBQUEsTUFFWjtBQUdBLFVBQUksV0FBVyxNQUFNO0FBQ25CLGtCQUFVLEtBQUssUUFBUSxTQUFPLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBQztBQUFBLE1BQ2pEO0FBR0EsVUFBSSxXQUFXLE9BQU87QUFDcEIsc0JBQWMsVUFBVSxNQUFNO0FBQUEsTUFDaEM7QUFBQSxJQUNGO0FBR0EsVUFBTSxZQUFZLE1BQU0sS0FBSyxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsR0FBRyxNQUFNO0FBQ3BELFlBQU0sT0FBTyxvQkFBSSxLQUFLO0FBQ3RCLFdBQUssUUFBUSxLQUFLLFFBQVEsSUFBSSxDQUFDO0FBQy9CLGFBQU87QUFBQSxRQUNMLE1BQU0sS0FBSyxtQkFBbUI7QUFBQSxRQUM5QixRQUFRO0FBQUEsUUFDUixNQUFNO0FBQUEsUUFDTixPQUFPLEtBQUssTUFBTSxLQUFLLE9BQU8sSUFBSSxFQUFFLElBQUk7QUFBQSxNQUMxQztBQUFBLElBQ0YsQ0FBQyxFQUFFLFFBQVE7QUFHWCxVQUFNLFVBQVUsTUFBTSxLQUFLLElBQUksRUFDNUIsSUFBSSxVQUFRLEVBQUUsS0FBSyxPQUFPLEtBQUssTUFBTSxLQUFLLE9BQU8sSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQy9ELEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUNoQyxNQUFNLEdBQUcsQ0FBQztBQUdiLFVBQU0sUUFBUSxNQUFNLEtBQUssT0FBTyxZQUFZLEtBQUs7QUFFakQsV0FBTztBQUFBLE1BQ0wsWUFBWSxNQUFNO0FBQUEsTUFDbEI7QUFBQSxNQUNBLFdBQVcsS0FBSztBQUFBLE1BQ2hCO0FBQUEsTUFDQSxnQkFBZ0I7QUFBQSxNQUNoQjtBQUFBLE1BQ0EsZ0JBQWdCO0FBQUEsUUFDZCxPQUFPLE1BQU0sTUFBTTtBQUFBLFFBQ25CLE9BQU8sTUFBTSxNQUFNO0FBQUEsUUFDbkIsVUFBVSxLQUFLLE1BQU0sTUFBTSxNQUFNLFNBQVMsRUFBRTtBQUFBO0FBQUEsTUFDOUM7QUFBQSxNQUNBLFNBQVM7QUFBQSxRQUNQLGlCQUFpQixLQUFLLE1BQU0sS0FBSyxPQUFPLElBQUksR0FBRyxJQUFJO0FBQUEsUUFDbkQsWUFBWSxLQUFLLE1BQU0sS0FBSyxPQUFPLElBQUksR0FBSyxJQUFJO0FBQUEsUUFDaEQsWUFBWTtBQUFBLFVBQ1Y7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQWMscUJBSVY7QUFFRixXQUFPO0FBQUEsTUFDTDtBQUFBLFFBQ0UsT0FBTztBQUFBLFFBQ1AsYUFBYTtBQUFBLFFBQ2IsUUFBUTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsVUFBVSxNQUFNLElBQUksd0JBQU8scUNBQXFDO0FBQUEsUUFDbEU7QUFBQSxNQUNGO0FBQUEsTUFDQTtBQUFBLFFBQ0UsT0FBTztBQUFBLFFBQ1AsYUFBYTtBQUFBLFFBQ2IsUUFBUTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsVUFBVSxNQUFNLElBQUksd0JBQU8scUNBQXFDO0FBQUEsUUFDbEU7QUFBQSxNQUNGO0FBQUEsTUFDQTtBQUFBLFFBQ0UsT0FBTztBQUFBLFFBQ1AsYUFBYTtBQUFBLFFBQ2IsUUFBUTtBQUFBLFVBQ04sT0FBTztBQUFBLFVBQ1AsVUFBVSxNQUFNLElBQUksd0JBQU8saUNBQWlDO0FBQUEsUUFDOUQ7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQSxFQUVRLGlCQUFpQjtBQUN2QixTQUFLLGFBQWEsQ0FBQyxLQUFLO0FBQ3hCLFNBQUssZ0JBQWdCO0FBQUEsRUFDdkI7QUFBQSxFQUVBLE1BQWMsb0JBQW9CO0FBQ2hDLFFBQUksd0JBQU8seUJBQXlCO0FBQ3BDLFVBQU0sS0FBSyxnQkFBZ0I7QUFDM0IsUUFBSSx3QkFBTyxzQkFBc0I7QUFBQSxFQUNuQztBQUFBLEVBRVEscUJBQXFCO0FBQzNCLFFBQUksZUFBZSxLQUFLLE9BQU8sS0FBSyxDQUFDLFdBQVc7QUFDOUMsV0FBSyxRQUFRLElBQUksT0FBTyxJQUFJLE1BQU07QUFDbEMsV0FBSyxnQkFBZ0I7QUFBQSxJQUN2QixDQUFDLEVBQUUsS0FBSztBQUFBLEVBQ1Y7QUFBQSxFQUVRLGFBQWEsVUFBa0I7QUFDckMsUUFBSSxRQUFRLHFCQUFxQixHQUFHO0FBQ2xDLFdBQUssUUFBUSxPQUFPLFFBQVE7QUFDNUIsV0FBSyxPQUFPLE9BQU8sUUFBUTtBQUMzQixXQUFLLGdCQUFnQjtBQUFBLElBQ3ZCO0FBQUEsRUFDRjtBQUFBLEVBRVEsZ0JBQWdCLFVBQWtCO0FBQ3hDLFVBQU0sU0FBUyxLQUFLLFFBQVEsSUFBSSxRQUFRO0FBQ3hDLFFBQUksUUFBUTtBQUNWLFVBQUkscUJBQXFCLEtBQUssT0FBTyxLQUFLLFFBQVEsQ0FBQyxrQkFBa0I7QUFDbkUsYUFBSyxRQUFRLElBQUksVUFBVSxhQUFhO0FBQ3hDLGFBQUssZ0JBQWdCO0FBQUEsTUFDdkIsQ0FBQyxFQUFFLEtBQUs7QUFBQSxJQUNWO0FBQUEsRUFDRjtBQUFBLEVBRVEsY0FBYyxTQUFzQjtBQUUxQyxZQUFRLFlBQVk7QUFDcEIsWUFBUSxpQkFBaUIsYUFBYSxDQUFDLE1BQU07QUFDM0MsUUFBRSxjQUFjLFFBQVEsY0FBYyxRQUFRLFFBQVEsWUFBWSxFQUFFO0FBQUEsSUFDdEUsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVRLG1CQUFtQjtBQUN6QixlQUFXLENBQUMsSUFBSSxNQUFNLEtBQUssS0FBSyxTQUFTO0FBQ3ZDLFVBQUksT0FBTyxpQkFBaUI7QUFDMUIsY0FBTSxXQUFXLFlBQVksTUFBTTtBQUNqQyxlQUFLLGNBQWMsRUFBRTtBQUFBLFFBQ3ZCLEdBQUcsT0FBTyxlQUFlO0FBQ3pCLGFBQUssaUJBQWlCLElBQUksSUFBSSxRQUFlO0FBQUEsTUFDL0M7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBRVEsa0JBQWtCO0FBQ3hCLGVBQVcsWUFBWSxLQUFLLGlCQUFpQixPQUFPLEdBQUc7QUFDckQsb0JBQWMsUUFBUTtBQUFBLElBQ3hCO0FBQ0EsU0FBSyxpQkFBaUIsTUFBTTtBQUFBLEVBQzlCO0FBQUEsRUFFQSxNQUFjLGNBQWMsVUFBa0I7QUFDNUMsVUFBTSxTQUFTLEtBQUssUUFBUSxJQUFJLFFBQVE7QUFDeEMsUUFBSSxDQUFDO0FBQVE7QUFFYixVQUFNLFdBQVcsS0FBSyxZQUFZLGNBQWMsb0JBQW9CLFFBQVEsSUFBSTtBQUNoRixRQUFJLENBQUM7QUFBVTtBQUVmLFVBQU0sVUFBVSxTQUFTLGNBQWMsaUJBQWlCO0FBQ3hELFFBQUksU0FBUztBQUNYLGNBQVEsTUFBTTtBQUNkLFlBQU0sS0FBSyxvQkFBb0IsU0FBd0IsTUFBTTtBQUFBLElBQy9EO0FBQUEsRUFDRjtBQUFBLEVBRVEsZ0JBQWdCO0FBQ3RCLGVBQVcsU0FBUyxLQUFLLE9BQU8sT0FBTyxHQUFHO0FBQ3hDLFlBQU0sUUFBUTtBQUFBLElBQ2hCO0FBQ0EsU0FBSyxPQUFPLE1BQU07QUFBQSxFQUNwQjtBQUFBLEVBRVEsbUJBQW1CO0FBRXpCLFVBQU0sZ0JBQWdCLE1BQU0sS0FBSyxLQUFLLFFBQVEsT0FBTyxDQUFDO0FBQ3RELFNBQUssT0FBTyxTQUFTLG1CQUFtQjtBQUN4QyxTQUFLLE9BQU8sYUFBYTtBQUFBLEVBQzNCO0FBQ0Y7QUFwa0JhLGVBQ0osWUFBWTtBQURkLElBQU0sZ0JBQU47QUF1a0JQLElBQU0saUJBQU4sY0FBNkIsdUJBQU07QUFBQSxFQUNqQyxZQUNFLEtBQ1EsT0FDUjtBQUNBLFVBQU0sR0FBRztBQUZEO0FBQUEsRUFHVjtBQUFBLEVBRUEsU0FBUztBQUNQLFVBQU0sRUFBRSxVQUFVLElBQUk7QUFDdEIsY0FBVSxTQUFTLE1BQU0sRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUUvQyxVQUFNLE9BQU8sVUFBVSxTQUFTLE1BQU07QUFFdEMsUUFBSSxhQUFhO0FBQ2pCLFFBQUksY0FBYztBQUNsQixRQUFJLGFBQWE7QUFFakIsUUFBSSx5QkFBUSxJQUFJLEVBQ2IsUUFBUSxhQUFhLEVBQ3JCLFlBQVksY0FBWSxTQUN0QixVQUFVLFVBQVUsU0FBUyxFQUM3QixVQUFVLFNBQVMsT0FBTyxFQUMxQixVQUFVLFFBQVEsTUFBTSxFQUN4QixVQUFVLFlBQVksVUFBVSxFQUNoQyxVQUFVLGVBQWUsYUFBYSxFQUN0QyxTQUFTLFVBQVUsRUFDbkIsU0FBUyxXQUFTLGFBQWEsS0FBSyxDQUFDO0FBRTFDLFFBQUkseUJBQVEsSUFBSSxFQUNiLFFBQVEsT0FBTyxFQUNmLFFBQVEsVUFBUSxLQUNkLFNBQVMsV0FBVyxFQUNwQixTQUFTLFdBQVMsY0FBYyxLQUFLLENBQUM7QUFFM0MsUUFBSSx5QkFBUSxJQUFJLEVBQ2IsUUFBUSxNQUFNLEVBQ2QsWUFBWSxjQUFZLFNBQ3RCLFVBQVUsU0FBUyxPQUFPLEVBQzFCLFVBQVUsVUFBVSxRQUFRLEVBQzVCLFVBQVUsU0FBUyxPQUFPLEVBQzFCLFNBQVMsVUFBVSxFQUNuQixTQUFTLFdBQVMsYUFBYSxLQUFLLENBQUM7QUFFMUMsVUFBTSxrQkFBa0IsS0FBSyxTQUFTLE9BQU8sRUFBRSxLQUFLLHlCQUF5QixDQUFDO0FBRTlFLG9CQUFnQixTQUFTLFVBQVUsRUFBRSxNQUFNLGNBQWMsTUFBTSxTQUFTLENBQUM7QUFDekUsb0JBQWdCLFNBQVMsVUFBVSxFQUFFLE1BQU0sVUFBVSxNQUFNLFNBQVMsQ0FBQyxFQUNsRSxVQUFVLE1BQU0sS0FBSyxNQUFNO0FBRTlCLFNBQUssV0FBVyxDQUFDLE1BQU07QUFDckIsUUFBRSxlQUFlO0FBRWpCLFVBQUksQ0FBQyxZQUFZLEtBQUssR0FBRztBQUN2QixZQUFJLHdCQUFPLDZCQUE2QjtBQUN4QztBQUFBLE1BQ0Y7QUFFQSxZQUFNLFNBQTBCO0FBQUEsUUFDOUIsSUFBSSxVQUFVLEtBQUssSUFBSSxDQUFDO0FBQUEsUUFDeEIsT0FBTztBQUFBLFFBQ1AsTUFBTTtBQUFBLFFBQ04sTUFBTTtBQUFBLFFBQ04sVUFBVSxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFBQSxRQUN2QixNQUFNLENBQUM7QUFBQSxNQUNUO0FBRUEsV0FBSyxNQUFNLE1BQU07QUFDakIsV0FBSyxNQUFNO0FBQUEsSUFDYjtBQUFBLEVBQ0Y7QUFDRjtBQUdBLElBQU0sdUJBQU4sY0FBbUMsdUJBQU07QUFBQSxFQUN2QyxZQUNFLEtBQ1EsUUFDQSxRQUNSO0FBQ0EsVUFBTSxHQUFHO0FBSEQ7QUFDQTtBQUFBLEVBR1Y7QUFBQSxFQUVBLFNBQVM7QUFDUCxVQUFNLEVBQUUsVUFBVSxJQUFJO0FBQ3RCLGNBQVUsU0FBUyxNQUFNLEVBQUUsTUFBTSxhQUFhLEtBQUssT0FBTyxLQUFLLEdBQUcsQ0FBQztBQUVuRSxVQUFNLE9BQU8sVUFBVSxTQUFTLE1BQU07QUFFdEMsUUFBSSxRQUFRLEtBQUssT0FBTztBQUN4QixRQUFJLE9BQU8sS0FBSyxPQUFPO0FBQ3ZCLFFBQUksa0JBQWtCLEtBQUssT0FBTyxtQkFBbUI7QUFFckQsUUFBSSx5QkFBUSxJQUFJLEVBQ2IsUUFBUSxPQUFPLEVBQ2YsUUFBUSxVQUFRLEtBQ2QsU0FBUyxLQUFLLEVBQ2QsU0FBUyxXQUFTLFFBQVEsS0FBSyxDQUFDO0FBRXJDLFFBQUkseUJBQVEsSUFBSSxFQUNiLFFBQVEsTUFBTSxFQUNkLFlBQVksY0FBWSxTQUN0QixVQUFVLFNBQVMsT0FBTyxFQUMxQixVQUFVLFVBQVUsUUFBUSxFQUM1QixVQUFVLFNBQVMsT0FBTyxFQUMxQixTQUFTLElBQUksRUFDYixTQUFTLFdBQVMsT0FBTyxLQUFZLENBQUM7QUFFM0MsUUFBSSx5QkFBUSxJQUFJLEVBQ2IsUUFBUSw0QkFBNEIsRUFDcEMsUUFBUSxxQkFBcUIsRUFDN0IsUUFBUSxVQUFRLEtBQ2QsVUFBVSxrQkFBa0IsS0FBTSxTQUFTLENBQUMsRUFDNUMsU0FBUyxXQUFTLGtCQUFrQixTQUFTLEtBQUssSUFBSSxHQUFJLENBQUM7QUFFaEUsVUFBTSxrQkFBa0IsS0FBSyxTQUFTLE9BQU8sRUFBRSxLQUFLLHlCQUF5QixDQUFDO0FBRTlFLG9CQUFnQixTQUFTLFVBQVUsRUFBRSxNQUFNLFFBQVEsTUFBTSxTQUFTLENBQUM7QUFDbkUsb0JBQWdCLFNBQVMsVUFBVSxFQUFFLE1BQU0sVUFBVSxNQUFNLFNBQVMsQ0FBQyxFQUNsRSxVQUFVLE1BQU0sS0FBSyxNQUFNO0FBRTlCLFNBQUssV0FBVyxDQUFDLE1BQU07QUFDckIsUUFBRSxlQUFlO0FBRWpCLFdBQUssT0FBTyxRQUFRO0FBQ3BCLFdBQUssT0FBTyxPQUFPO0FBQ25CLFdBQUssT0FBTyxrQkFBa0Isa0JBQWtCLElBQUksa0JBQWtCO0FBRXRFLFdBQUssT0FBTyxLQUFLLE1BQU07QUFDdkIsV0FBSyxNQUFNO0FBQUEsSUFDYjtBQUFBLEVBQ0Y7QUFDRjs7O0F1RjF2QkEsSUFBQTQ0RCxtQkFBOEI7QUErQ3ZCLElBQU0sZUFBTixNQUFtQjtBQUFBLEVBSXhCLFlBQW9CLFFBQXFCO0FBQXJCO0FBSHBCLFNBQVEsU0FBNkI7QUFDckMsU0FBUSxlQUFlO0FBQUEsRUFFbUI7QUFBQSxFQUUxQyxNQUFNLFVBQVUsUUFBdUM7QUFDckQsUUFBSTtBQUNGLFdBQUssU0FBUztBQUdkLFlBQU0sYUFBYSxNQUFNLEtBQUssZUFBZTtBQUU3QyxVQUFJLFlBQVk7QUFDZCxhQUFLLGVBQWU7QUFDcEIsWUFBSSx3QkFBTyx1Q0FBdUM7QUFDbEQsZUFBTztBQUFBLE1BQ1QsT0FBTztBQUNMLGNBQU0sSUFBSSxNQUFNLHdCQUF3QjtBQUFBLE1BQzFDO0FBQUEsSUFDRixTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0sK0JBQStCLEtBQUs7QUFDbEQsVUFBSSx3QkFBTywrQkFBZ0MsTUFBZ0IsT0FBTyxFQUFFO0FBQ3BFLFdBQUssZUFBZTtBQUNwQixhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQU0sVUFDSkMsS0FDQSxTQUNBLGFBQ0EsYUFDQSxhQUNrQjtBQUNsQixRQUFJLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxLQUFLLFFBQVE7QUFDdEMsWUFBTSxJQUFJLE1BQU0sOEJBQThCO0FBQUEsSUFDaEQ7QUFFQSxRQUFJO0FBQ0YsWUFBTSxhQUFhLE1BQU0sUUFBUUEsR0FBRSxJQUFJQSxNQUFLLENBQUNBLEdBQUU7QUFJL0MsY0FBUSxJQUFJLDBCQUEwQjtBQUFBLFFBQ3BDLE1BQU0sSUFBSSxLQUFLLE9BQU8sUUFBUSxNQUFNLEtBQUssT0FBTyxTQUFTO0FBQUEsUUFDekQsSUFBSSxXQUFXLEtBQUssSUFBSTtBQUFBLFFBQ3hCO0FBQUEsUUFDQSxNQUFNO0FBQUEsUUFDTixNQUFNLGVBQWUsS0FBSyxXQUFXLFdBQVc7QUFBQSxRQUNoRCxhQUFhLGFBQWEsVUFBVTtBQUFBLE1BQ3RDLENBQUM7QUFRRCxVQUFJLHdCQUFPLGlCQUFpQixXQUFXLEtBQUssSUFBSSxDQUFDLEVBQUU7QUFDbkQsYUFBTztBQUFBLElBQ1QsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLHlCQUF5QixLQUFLO0FBQzVDLFlBQU07QUFBQSxJQUNSO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxtQkFDSkEsS0FDQSxZQUNBLFdBQ0EsYUFDa0I7QUFDbEIsVUFBTSxXQUFXLEtBQUssWUFBWSxVQUFVO0FBQzVDLFFBQUksQ0FBQyxVQUFVO0FBQ2IsWUFBTSxJQUFJLE1BQU0sWUFBWSxVQUFVLFlBQVk7QUFBQSxJQUNwRDtBQUVBLFVBQU0sVUFBVSxLQUFLLGdCQUFnQixTQUFTLFNBQVMsU0FBUztBQUNoRSxVQUFNLGNBQWMsS0FBSyxnQkFBZ0IsU0FBUyxjQUFjLFNBQVM7QUFDekUsVUFBTSxjQUFjLEtBQUssZ0JBQWdCLFNBQVMsY0FBYyxTQUFTO0FBRXpFLFdBQU8sTUFBTSxLQUFLLFVBQVVBLEtBQUksU0FBUyxhQUFhLGFBQWEsV0FBVztBQUFBLEVBQ2hGO0FBQUEsRUFFUSxnQkFBZ0IsVUFBa0IsV0FBd0M7QUFDaEYsUUFBSSxZQUFZO0FBRWhCLGVBQVcsQ0FBQyxLQUFLLEtBQUssS0FBSyxPQUFPLFFBQVEsU0FBUyxHQUFHO0FBQ3BELFlBQU0sUUFBUSxJQUFJLE9BQU8sU0FBUyxHQUFHLFVBQVUsR0FBRztBQUNsRCxrQkFBWSxVQUFVLFFBQVEsT0FBTyxPQUFPLEtBQUssQ0FBQztBQUFBLElBQ3BEO0FBRUEsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVRLFdBQVcsTUFBc0I7QUFFdkMsV0FBTyxLQUNKLFFBQVEsZ0JBQWdCLElBQUksRUFDNUIsUUFBUSxXQUFXLE1BQU0sRUFDekIsUUFBUSxZQUFZLEVBQUUsRUFDdEIsUUFBUSxXQUFXLEdBQUcsRUFDdEIsUUFBUSxVQUFVLEdBQUcsRUFDckIsUUFBUSxTQUFTLEdBQUcsRUFDcEIsUUFBUSxTQUFTLEdBQUcsRUFDcEIsS0FBSztBQUFBLEVBQ1Y7QUFBQSxFQUVRLFlBQVksWUFBMEM7QUFDNUQsVUFBTSxZQUFZLEtBQUssT0FBTyxTQUFTLGtCQUFrQixDQUFDO0FBQzFELFdBQU8sVUFBVSxLQUFLLE9BQUssRUFBRSxPQUFPLFVBQVUsS0FBSztBQUFBLEVBQ3JEO0FBQUEsRUFFQSxVQUFtQjtBQUNqQixXQUFPLEtBQUs7QUFBQSxFQUNkO0FBQUEsRUFFQSxNQUFNLGlCQUFtQztBQUN2QyxRQUFJLENBQUMsS0FBSztBQUFRLGFBQU87QUFFekIsUUFBSTtBQUVGLGNBQVEsSUFBSSxnQ0FBZ0M7QUFBQSxRQUMxQyxNQUFNLEtBQUssT0FBTztBQUFBLFFBQ2xCLE1BQU0sS0FBSyxPQUFPO0FBQUEsUUFDbEIsVUFBVSxLQUFLLE9BQU87QUFBQSxNQUN4QixDQUFDO0FBR0QsYUFBTztBQUFBLElBQ1QsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLGlDQUFpQyxLQUFLO0FBQ3BELGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUNGO0FBRU8sSUFBTSxtQkFBTixNQUF1QjtBQUFBLEVBQzVCLFlBQW9CLFFBQTZCLGNBQTRCO0FBQXpEO0FBQTZCO0FBQUEsRUFBNkI7QUFBQSxFQUU5RSxNQUFNLGtCQUNKLE1BQ0EsWUFDQSxTQUNBLGtCQUFrQixNQUNBO0FBQ2xCLFFBQUk7QUFDRixZQUFNLFVBQVUsTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLEtBQUssSUFBSTtBQUNyRCxZQUFNLGNBQWlDLENBQUM7QUFHeEMsa0JBQVksS0FBSztBQUFBLFFBQ2YsVUFBVSxHQUFHLEtBQUssUUFBUTtBQUFBLFFBQzFCO0FBQUEsUUFDQSxhQUFhO0FBQUEsTUFDZixDQUFDO0FBR0QsVUFBSSxpQkFBaUI7QUFDbkIsY0FBTSxXQUFXLEtBQUssb0JBQW9CLElBQUk7QUFDOUMsb0JBQVksS0FBSztBQUFBLFVBQ2YsVUFBVSxHQUFHLEtBQUssUUFBUTtBQUFBLFVBQzFCLFNBQVMsS0FBSyxVQUFVLFVBQVUsTUFBTSxDQUFDO0FBQUEsVUFDekMsYUFBYTtBQUFBLFFBQ2YsQ0FBQztBQUFBLE1BQ0g7QUFHQSxZQUFNLFlBQVk7QUFBQSxRQUNoQixVQUFVLEtBQUs7QUFBQSxRQUNmLFVBQVUsS0FBSztBQUFBLFFBQ2YsVUFBVSxLQUFLLGVBQWUsUUFBUSxNQUFNO0FBQUEsUUFDNUMsWUFBVyxvQkFBSSxLQUFLLEdBQUUsbUJBQW1CO0FBQUEsUUFDekMsWUFBVyxvQkFBSSxLQUFLLEdBQUUsbUJBQW1CO0FBQUEsUUFDekMsU0FBUyxXQUFXO0FBQUEsUUFDcEIsV0FBVyxLQUFLLE9BQU8sSUFBSSxNQUFNLFFBQVE7QUFBQSxNQUMzQztBQUVBLFlBQU0sS0FBSyxhQUFhO0FBQUEsUUFDdEI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNGO0FBRUEsVUFBSSx3QkFBTyxTQUFTLEtBQUssUUFBUSx1QkFBdUI7QUFDeEQsYUFBTztBQUFBLElBQ1QsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLHdCQUF3QixLQUFLO0FBQzNDLFVBQUksd0JBQU8seUJBQTBCLE1BQWdCLE9BQU8sRUFBRTtBQUM5RCxhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQU0sbUJBQ0osT0FDQSxZQUNBLFNBQ0EsU0FBK0IsY0FDYjtBQUNsQixRQUFJO0FBQ0YsVUFBSSxXQUFXLGNBQWM7QUFFM0IsbUJBQVcsUUFBUSxPQUFPO0FBQ3hCLGdCQUFNLEtBQUssa0JBQWtCLE1BQU0sWUFBWSxPQUFPO0FBQUEsUUFDeEQ7QUFBQSxNQUNGLE9BQU87QUFFTCxjQUFNLGNBQWlDLENBQUM7QUFFeEMsbUJBQVcsUUFBUSxPQUFPO0FBQ3hCLGdCQUFNLFVBQVUsTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLEtBQUssSUFBSTtBQUNyRCxzQkFBWSxLQUFLO0FBQUEsWUFDZixVQUFVLEdBQUcsS0FBSyxLQUFLLFFBQVEsT0FBTyxHQUFHLENBQUM7QUFBQSxZQUMxQztBQUFBLFlBQ0EsYUFBYTtBQUFBLFVBQ2YsQ0FBQztBQUFBLFFBQ0g7QUFFQSxjQUFNLFlBQVk7QUFBQSxVQUNoQixXQUFXLE1BQU07QUFBQSxVQUNqQixXQUFXLE1BQU0sSUFBSSxPQUFLLEVBQUUsUUFBUSxFQUFFLEtBQUssSUFBSTtBQUFBLFVBQy9DLFlBQVcsb0JBQUksS0FBSyxHQUFFLG1CQUFtQjtBQUFBLFVBQ3pDLFlBQVcsb0JBQUksS0FBSyxHQUFFLG1CQUFtQjtBQUFBLFVBQ3pDLFNBQVMsV0FBVztBQUFBLFVBQ3BCLFdBQVcsS0FBSyxPQUFPLElBQUksTUFBTSxRQUFRO0FBQUEsUUFDM0M7QUFFQSxjQUFNLEtBQUssYUFBYTtBQUFBLFVBQ3RCO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFQSxVQUFJLHdCQUFPLEdBQUcsTUFBTSxNQUFNLDRCQUE0QjtBQUN0RCxhQUFPO0FBQUEsSUFDVCxTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0saUNBQWlDLEtBQUs7QUFDcEQsVUFBSSx3QkFBTywwQkFBMkIsTUFBZ0IsT0FBTyxFQUFFO0FBQy9ELGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxrQkFDSixZQUNBLGVBQWUsTUFDZixxQkFBcUIsTUFDSDtBQUNsQixRQUFJO0FBQ0YsWUFBTSxVQUFVLE1BQU0sS0FBSyxxQkFBcUIsY0FBYyxrQkFBa0I7QUFFaEYsWUFBTSxZQUFZO0FBQUEsUUFDaEIsV0FBVyxLQUFLLE9BQU8sSUFBSSxNQUFNLFFBQVE7QUFBQSxRQUN6QyxjQUFhLG9CQUFJLEtBQUssR0FBRSxtQkFBbUI7QUFBQSxRQUMzQyxHQUFHO0FBQUEsTUFDTDtBQUVBLFlBQU0sS0FBSyxhQUFhO0FBQUEsUUFDdEI7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLE1BQ0Y7QUFFQSxVQUFJLHdCQUFPLG1DQUFtQztBQUM5QyxhQUFPO0FBQUEsSUFDVCxTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0saUNBQWlDLEtBQUs7QUFDcEQsVUFBSSx3QkFBTyxrQ0FBbUMsTUFBZ0IsT0FBTyxFQUFFO0FBQ3ZFLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUFBLEVBRVEsb0JBQW9CLE1BQWtCO0FBQzVDLFVBQU0sUUFBUSxLQUFLLE9BQU8sSUFBSSxjQUFjLGFBQWEsSUFBSTtBQUU3RCxXQUFPO0FBQUEsTUFDTCxNQUFNLEtBQUs7QUFBQSxNQUNYLE1BQU0sS0FBSztBQUFBLE1BQ1gsTUFBTSxLQUFLLEtBQUs7QUFBQSxNQUNoQixTQUFTLElBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxFQUFFLFlBQVk7QUFBQSxNQUMvQyxVQUFVLElBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxFQUFFLFlBQVk7QUFBQSxNQUNoRCxNQUFNLE9BQU8sTUFBTSxJQUFJLE9BQUssRUFBRSxHQUFHLEtBQUssQ0FBQztBQUFBLE1BQ3ZDLE9BQU8sT0FBTyxPQUFPLElBQUksT0FBSyxFQUFFLElBQUksS0FBSyxDQUFDO0FBQUEsTUFDMUMsVUFBVSxPQUFPLFVBQVUsSUFBSSxRQUFNO0FBQUEsUUFDbkMsT0FBTyxFQUFFO0FBQUEsUUFDVCxTQUFTLEVBQUU7QUFBQSxNQUNiLEVBQUUsS0FBSyxDQUFDO0FBQUEsTUFDUixhQUFhLE9BQU8sZUFBZSxDQUFDO0FBQUEsSUFDdEM7QUFBQSxFQUNGO0FBQUEsRUFFUSxlQUFlLE9BQXVCO0FBQzVDLFVBQU0sUUFBUSxDQUFDLFNBQVMsTUFBTSxNQUFNLElBQUk7QUFDeEMsUUFBSSxVQUFVO0FBQUcsYUFBTztBQUN4QixVQUFNLElBQUksS0FBSyxNQUFNLEtBQUssSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLElBQUksQ0FBQztBQUNyRCxXQUFPLEtBQUssTUFBTSxRQUFRLEtBQUssSUFBSSxNQUFNLENBQUMsSUFBSSxHQUFHLElBQUksTUFBTSxNQUFNLE1BQU0sQ0FBQztBQUFBLEVBQzFFO0FBQUEsRUFFQSxNQUFjLHFCQUFxQixjQUF1QixvQkFBMkM7QUFDbkcsVUFBTSxRQUFRLEtBQUssT0FBTyxJQUFJLE1BQU0saUJBQWlCO0FBQ3JELFVBQU0sVUFBZSxDQUFDO0FBRXRCLFFBQUksY0FBYztBQUNoQixVQUFJLGFBQWE7QUFDakIsWUFBTSxPQUFPLG9CQUFJLElBQVk7QUFFN0IsaUJBQVcsUUFBUSxPQUFPO0FBQ3hCLFlBQUk7QUFDRixnQkFBTSxVQUFVLE1BQU0sS0FBSyxPQUFPLElBQUksTUFBTSxLQUFLLElBQUk7QUFDckQsd0JBQWMsUUFBUSxNQUFNLEtBQUssRUFBRTtBQUVuQyxnQkFBTSxRQUFRLEtBQUssT0FBTyxJQUFJLGNBQWMsYUFBYSxJQUFJO0FBQzdELGNBQUksT0FBTyxNQUFNO0FBQ2Ysa0JBQU0sS0FBSyxRQUFRLFNBQU8sS0FBSyxJQUFJLElBQUksR0FBRyxDQUFDO0FBQUEsVUFDN0M7QUFBQSxRQUNGLFNBQVMsR0FBRztBQUFBLFFBRVo7QUFBQSxNQUNGO0FBRUEsY0FBUSxRQUFRO0FBQUEsUUFDZCxZQUFZLE1BQU07QUFBQSxRQUNsQjtBQUFBLFFBQ0EsV0FBVyxLQUFLO0FBQUEsUUFDaEIscUJBQXFCLEtBQUssTUFBTSxhQUFhLE1BQU0sTUFBTTtBQUFBLE1BQzNEO0FBQUEsSUFDRjtBQUVBLFFBQUksb0JBQW9CO0FBQ3RCLFlBQU0sY0FBYyxNQUNqQixLQUFLLENBQUMsR0FBRyxNQUFNLEVBQUUsS0FBSyxRQUFRLEVBQUUsS0FBSyxLQUFLLEVBQzFDLE1BQU0sR0FBRyxFQUFFLEVBQ1gsSUFBSSxXQUFTO0FBQUEsUUFDWixNQUFNLEtBQUs7QUFBQSxRQUNYLE1BQU0sS0FBSztBQUFBLFFBQ1gsVUFBVSxJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssRUFBRSxtQkFBbUI7QUFBQSxNQUN6RCxFQUFFO0FBRUosY0FBUSxjQUFjO0FBQUEsSUFDeEI7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBRU8sSUFBTSxzQkFBTixNQUEwQjtBQUFBLEVBSS9CLFlBQ1UsUUFDQSxjQUNBLGtCQUNSO0FBSFE7QUFDQTtBQUNBO0FBTlYsU0FBUSxRQUF1QyxvQkFBSSxJQUFJO0FBQ3ZELFNBQVEsZ0JBQTZDLG9CQUFJLElBQUk7QUFPM0QsU0FBSyxVQUFVO0FBQ2YsU0FBSyxrQkFBa0I7QUFBQSxFQUN6QjtBQUFBLEVBRUEsUUFBUSxNQUE4QjtBQUNwQyxTQUFLLE1BQU0sSUFBSSxLQUFLLElBQUksSUFBSTtBQUM1QixTQUFLLFVBQVU7QUFFZixRQUFJLEtBQUssV0FBVyxLQUFLLFdBQVcsY0FBYztBQUNoRCxXQUFLLGFBQWEsSUFBSTtBQUFBLElBQ3hCO0FBQUEsRUFDRjtBQUFBLEVBRUEsV0FBVyxRQUFzQjtBQUMvQixTQUFLLE1BQU0sT0FBTyxNQUFNO0FBQ3hCLFNBQUssZUFBZSxNQUFNO0FBQzFCLFNBQUssVUFBVTtBQUFBLEVBQ2pCO0FBQUEsRUFFQSxXQUFXLFFBQXNCO0FBQy9CLFVBQU0sT0FBTyxLQUFLLE1BQU0sSUFBSSxNQUFNO0FBQ2xDLFFBQUksTUFBTTtBQUNSLFdBQUssVUFBVTtBQUNmLFdBQUssVUFBVTtBQUVmLFVBQUksS0FBSyxXQUFXLGNBQWM7QUFDaEMsYUFBSyxhQUFhLElBQUk7QUFBQSxNQUN4QjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUEsRUFFQSxZQUFZLFFBQXNCO0FBQ2hDLFVBQU0sT0FBTyxLQUFLLE1BQU0sSUFBSSxNQUFNO0FBQ2xDLFFBQUksTUFBTTtBQUNSLFdBQUssVUFBVTtBQUNmLFdBQUssZUFBZSxNQUFNO0FBQzFCLFdBQUssVUFBVTtBQUFBLElBQ2pCO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxZQUFZLFFBQWdCLFNBQThCO0FBQzlELFVBQU0sT0FBTyxLQUFLLE1BQU0sSUFBSSxNQUFNO0FBQ2xDLFFBQUksQ0FBQyxRQUFRLENBQUMsS0FBSztBQUFTO0FBRTVCLFFBQUk7QUFDRixZQUFNLFlBQVksTUFBTSxLQUFLLGlCQUFpQixNQUFNLE9BQU87QUFFM0QsWUFBTSxLQUFLLGFBQWE7QUFBQSxRQUN0QixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTDtBQUFBLE1BQ0Y7QUFFQSxXQUFLLGlCQUFnQixvQkFBSSxLQUFLLEdBQUUsWUFBWTtBQUM1QyxXQUFLLFVBQVU7QUFFZixjQUFRLElBQUksc0JBQXNCLEtBQUssSUFBSSwwQkFBMEI7QUFBQSxJQUN2RSxTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0sMkJBQTJCLEtBQUssSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUMvRDtBQUFBLEVBQ0Y7QUFBQSxFQUVRLFlBQWtCO0FBQ3hCLFVBQU0sYUFBYSxLQUFLLE9BQU8sU0FBUyxxQkFBcUIsQ0FBQztBQUM5RCxlQUFXLFFBQVEsVUFBUTtBQUN6QixXQUFLLE1BQU0sSUFBSSxLQUFLLElBQUksSUFBSTtBQUM1QixVQUFJLEtBQUssV0FBVyxLQUFLLFdBQVcsY0FBYztBQUNoRCxhQUFLLGFBQWEsSUFBSTtBQUFBLE1BQ3hCO0FBQUEsSUFDRixDQUFDO0FBQUEsRUFDSDtBQUFBLEVBRVEsWUFBa0I7QUFDeEIsU0FBSyxPQUFPLFNBQVMsb0JBQW9CLE1BQU0sS0FBSyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBQ3ZFLFNBQUssT0FBTyxhQUFhO0FBQUEsRUFDM0I7QUFBQSxFQUVRLG9CQUEwQjtBQUVoQyxTQUFLLE9BQU87QUFBQSxNQUNWLEtBQUssT0FBTyxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsU0FBUztBQUMzQyxZQUFJLGdCQUFnQix3QkFBTztBQUN6QixlQUFLLGdCQUFnQixnQkFBZ0IsSUFBSTtBQUFBLFFBQzNDO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQUdBLFNBQUssT0FBTztBQUFBLE1BQ1YsS0FBSyxPQUFPLElBQUksTUFBTSxHQUFHLFVBQVUsQ0FBQyxTQUFTO0FBQzNDLFlBQUksZ0JBQWdCLHdCQUFPO0FBQ3pCLGVBQUssZ0JBQWdCLGlCQUFpQixJQUFJO0FBQUEsUUFDNUM7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNIO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYyxnQkFBZ0IsU0FBMkMsTUFBNEI7QUFDbkcsZUFBVyxRQUFRLEtBQUssTUFBTSxPQUFPLEdBQUc7QUFDdEMsVUFBSSxLQUFLLFdBQVcsS0FBSyxZQUFZLFNBQVM7QUFDNUMsWUFBSSxLQUFLLG1CQUFtQixNQUFNLEtBQUssV0FBVyxXQUFXLEdBQUc7QUFDOUQsZ0JBQU0sS0FBSyxZQUFZLEtBQUssSUFBSSxFQUFFLEtBQUssQ0FBQztBQUFBLFFBQzFDO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUEsRUFFUSxtQkFBbUIsTUFBYSxTQUEyQjtBQUNqRSxRQUFJLENBQUM7QUFBUyxhQUFPO0FBRXJCLFFBQUk7QUFDRixZQUFNLFFBQVEsSUFBSSxPQUFPLFNBQVMsR0FBRztBQUNyQyxhQUFPLE1BQU0sS0FBSyxLQUFLLElBQUksS0FBSyxNQUFNLEtBQUssS0FBSyxRQUFRO0FBQUEsSUFDMUQsU0FBUyxHQUFHO0FBRVYsYUFBTyxLQUFLLEtBQUssU0FBUyxPQUFPLEtBQUssS0FBSyxTQUFTLFNBQVMsT0FBTztBQUFBLElBQ3RFO0FBQUEsRUFDRjtBQUFBLEVBRVEsYUFBYSxNQUE4QjtBQUNqRCxRQUFJLENBQUMsS0FBSyxXQUFXO0FBQWM7QUFJbkMsVUFBTSxXQUFXLEtBQUssV0FBVztBQUNqQyxRQUFJO0FBRUosUUFBSSxhQUFhLFNBQVM7QUFDeEIsaUJBQVcsS0FBSyxLQUFLLEtBQUs7QUFBQSxJQUM1QixXQUFXLGFBQWEsVUFBVTtBQUNoQyxpQkFBVyxJQUFJLEtBQUssS0FBSyxLQUFLO0FBQUEsSUFDaEMsT0FBTztBQUNMO0FBQUEsSUFDRjtBQUVBLFVBQU0sVUFBVSxZQUFZLE1BQU07QUFDaEMsV0FBSyxZQUFZLEtBQUssRUFBRTtBQUFBLElBQzFCLEdBQUcsUUFBUTtBQUVYLFNBQUssY0FBYyxJQUFJLEtBQUssSUFBSSxPQUFPO0FBQUEsRUFDekM7QUFBQSxFQUVRLGVBQWUsUUFBc0I7QUFDM0MsVUFBTSxVQUFVLEtBQUssY0FBYyxJQUFJLE1BQU07QUFDN0MsUUFBSSxTQUFTO0FBQ1gsb0JBQWMsT0FBTztBQUNyQixXQUFLLGNBQWMsT0FBTyxNQUFNO0FBQUEsSUFDbEM7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLGlCQUFpQixNQUF3QixTQUE2QztBQUNsRyxVQUFNLFlBQWlDO0FBQUEsTUFDckMsVUFBVSxLQUFLO0FBQUEsTUFDZixjQUFhLG9CQUFJLEtBQUssR0FBRSxlQUFlO0FBQUEsTUFDdkMsV0FBVyxLQUFLLE9BQU8sSUFBSSxNQUFNLFFBQVE7QUFBQSxJQUMzQztBQUVBLFFBQUksU0FBUyxNQUFNO0FBQ2pCLFlBQU0sT0FBTyxRQUFRO0FBQ3JCLGdCQUFVLFdBQVcsS0FBSztBQUMxQixnQkFBVSxXQUFXLEtBQUs7QUFDMUIsZ0JBQVUsV0FBVyxLQUFLLGlCQUFpQixnQkFBZ0IsRUFBRSxLQUFLLEtBQUssSUFBSTtBQUFBLElBQzdFO0FBR0EsUUFBSSxLQUFLLFlBQVksbUJBQW1CLEtBQUssWUFBWSxpQkFBaUI7QUFDeEUsWUFBTSxVQUFVLE1BQU0sS0FBSyxpQkFBaUIsc0JBQXNCLEVBQUUsTUFBTSxJQUFJO0FBQzlFLGFBQU8sT0FBTyxXQUFXLE9BQU87QUFBQSxJQUNsQztBQUVBLFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFQSxVQUFnQjtBQUVkLGVBQVcsV0FBVyxLQUFLLGNBQWMsT0FBTyxHQUFHO0FBQ2pELG9CQUFjLE9BQU87QUFBQSxJQUN2QjtBQUNBLFNBQUssY0FBYyxNQUFNO0FBQUEsRUFDM0I7QUFDRjtBQUdPLElBQU0sMEJBQTJDO0FBQUEsRUFDdEQ7QUFBQSxJQUNFLElBQUk7QUFBQSxJQUNKLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNULGNBQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFTZCxjQUFjO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBWWQsV0FBVyxDQUFDLFlBQVksWUFBWSxhQUFhLGFBQWEsV0FBVyxXQUFXO0FBQUEsRUFDdEY7QUFBQSxFQUNBO0FBQUEsSUFDRSxJQUFJO0FBQUEsSUFDSixNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFDVCxjQUFjO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQVFkLGNBQWM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBV2QsV0FBVyxDQUFDLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxXQUFXO0FBQUEsRUFDeEY7QUFBQSxFQUNBO0FBQUEsSUFDRSxJQUFJO0FBQUEsSUFDSixNQUFNO0FBQUEsSUFDTixTQUFTO0FBQUEsSUFDVCxjQUFjO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFtQmQsY0FBYztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQWVkLFdBQVcsQ0FBQyxhQUFhLGVBQWUsU0FBUyxhQUFhO0FBQUEsRUFDaEU7QUFDRjs7O0FDMW1CTyxJQUFNLHVCQUFOLE1BQTJCO0FBQUE7QUFBQSxFQU1oQyxZQUNVLFFBQ0EsVUFDQSxVQUNSO0FBSFE7QUFDQTtBQUNBO0FBUlYsU0FBUSxnQkFBZ0YsQ0FBQztBQUN6RixTQUFRLGdCQUEwQyxvQkFBSSxJQUFJO0FBQzFELFNBQVEsY0FBeUUsb0JBQUksSUFBSTtBQUN6RixTQUFRLGVBQWUsSUFBSSxLQUFLO0FBTzlCLFNBQUssa0JBQWtCO0FBQUEsRUFDekI7QUFBQSxFQUVBLE1BQU0sT0FBT0MsVUFBaUQ7QUFDNUQsVUFBTSxXQUFXLEtBQUssaUJBQWlCQSxRQUFPO0FBQzlDLFVBQU0sU0FBUyxLQUFLLFlBQVksSUFBSSxRQUFRO0FBRTVDLFFBQUksVUFBVSxLQUFLLElBQUksSUFBSSxPQUFPLFlBQVksS0FBSyxjQUFjO0FBQy9ELGFBQU8sT0FBTztBQUFBLElBQ2hCO0FBRUEsUUFBSTtBQUNGLFVBQUksVUFBMEIsQ0FBQztBQUUvQixjQUFRQSxTQUFRLFlBQVk7QUFBQSxRQUMxQixLQUFLO0FBQ0gsb0JBQVUsTUFBTSxLQUFLLGVBQWVBLFFBQU87QUFDM0M7QUFBQSxRQUNGLEtBQUs7QUFDSCxvQkFBVSxNQUFNLEtBQUssY0FBY0EsUUFBTztBQUMxQztBQUFBLFFBQ0YsS0FBSztBQUNILG9CQUFVLE1BQU0sS0FBSyxhQUFhQSxRQUFPO0FBQ3pDO0FBQUEsUUFDRixLQUFLO0FBQ0gsb0JBQVUsTUFBTSxLQUFLLGlCQUFpQkEsUUFBTztBQUM3QztBQUFBLFFBQ0Y7QUFDRSxvQkFBVSxNQUFNLEtBQUssYUFBYUEsUUFBTztBQUFBLE1BQzdDO0FBR0EsVUFBSUEsU0FBUSxhQUFhLEtBQUssU0FBUyxRQUFRLEdBQUc7QUFDaEQsa0JBQVUsTUFBTSxLQUFLLGNBQWNBLFNBQVEsT0FBTyxTQUFTQSxRQUFPO0FBQUEsTUFDcEU7QUFHQSxnQkFBVSxLQUFLLGFBQWEsU0FBU0EsUUFBTztBQUM1QyxnQkFBVSxLQUFLLFlBQVksU0FBU0EsUUFBTztBQUczQyxnQkFBVSxRQUFRLE1BQU0sR0FBR0EsU0FBUSxVQUFVO0FBRzdDLFdBQUssWUFBWSxJQUFJLFVBQVU7QUFBQSxRQUM3QjtBQUFBLFFBQ0EsV0FBVyxLQUFLLElBQUk7QUFBQSxNQUN0QixDQUFDO0FBR0QsV0FBSyxhQUFhQSxTQUFRLE9BQU8sUUFBUSxNQUFNO0FBRS9DLGFBQU87QUFBQSxJQUNULFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSwyQkFBMkIsS0FBSztBQUM5QyxZQUFNO0FBQUEsSUFDUjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQWMsZUFBZUEsVUFBaUQ7QUFDNUUsUUFBSSxDQUFDLEtBQUssT0FBTyxZQUFZO0FBQzNCLFlBQU0sSUFBSSxNQUFNLDhDQUE4QztBQUFBLElBQ2hFO0FBRUEsVUFBTSxpQkFBaUIsTUFBTSxLQUFLLE9BQU8sV0FBVyxXQUFXQSxTQUFRLEtBQUs7QUFDNUUsVUFBTSxhQUFhLE1BQU0sS0FBSyxPQUFPLGNBQWMsY0FBYyxnQkFBZ0JBLFNBQVEsYUFBYSxDQUFDO0FBRXZHLFdBQU8sV0FBVyxJQUFJLENBQUMsUUFBUUMsWUFBVztBQUFBLE1BQ3hDLElBQUksWUFBWUEsTUFBSztBQUFBLE1BQ3JCLE9BQU8sS0FBSyxhQUFhLE9BQU8sSUFBSTtBQUFBLE1BQ3BDLFNBQVMsT0FBTztBQUFBLE1BQ2hCLE9BQU8sT0FBTztBQUFBLE1BQ2QsVUFBVTtBQUFBLFFBQ1IsTUFBTTtBQUFBLFFBQ04sUUFBUTtBQUFBLFFBQ1IsWUFBWSxLQUFLLGtCQUFrQixPQUFPLE1BQU1ELFNBQVEsS0FBSztBQUFBLE1BQy9EO0FBQUEsSUFDRixFQUFFO0FBQUEsRUFDSjtBQUFBLEVBRUEsTUFBYyxjQUFjQSxVQUFpRDtBQUMzRSxVQUFNLFFBQVEsS0FBSyxPQUFPLElBQUksTUFBTSxpQkFBaUI7QUFDckQsVUFBTSxVQUEwQixDQUFDO0FBQ2pDLFVBQU0sYUFBYUEsU0FBUSxNQUFNLFlBQVksRUFBRSxNQUFNLEtBQUs7QUFFMUQsZUFBVyxRQUFRLE9BQU87QUFDeEIsVUFBSTtBQUNGLGNBQU0sVUFBVSxNQUFNLEtBQUssT0FBTyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ3JELGNBQU0sZUFBZSxRQUFRLFlBQVk7QUFFekMsWUFBSSxRQUFRO0FBQ1osY0FBTSxhQUF1QixDQUFDO0FBRzlCLG1CQUFXLFFBQVEsWUFBWTtBQUM3QixnQkFBTSxXQUFXLGFBQWEsTUFBTSxJQUFJLE9BQU8sTUFBTSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUc7QUFDbEUsbUJBQVM7QUFFVCxjQUFJLFVBQVUsR0FBRztBQUNmLHVCQUFXLEtBQUssR0FBRyxLQUFLLGdCQUFnQixTQUFTLElBQUksQ0FBQztBQUFBLFVBQ3hEO0FBQUEsUUFDRjtBQUVBLFlBQUksUUFBUSxHQUFHO0FBQ2Isa0JBQVEsS0FBSztBQUFBLFlBQ1gsSUFBSSxXQUFXLEtBQUssSUFBSTtBQUFBLFlBQ3hCLE9BQU8sS0FBSztBQUFBLFlBQ1osU0FBU0EsU0FBUSxpQkFBaUIsVUFBVSxLQUFLLGVBQWUsT0FBTztBQUFBLFlBQ3ZFO0FBQUEsWUFDQSxPQUFPLFFBQVEsV0FBVztBQUFBLFlBQzFCLFVBQVU7QUFBQSxjQUNSLE1BQU07QUFBQSxjQUNOLFFBQVE7QUFBQSxjQUNSLE1BQU0sS0FBSztBQUFBLGNBQ1gsU0FBUyxJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssRUFBRSxZQUFZO0FBQUEsY0FDL0MsVUFBVSxJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUssRUFBRSxZQUFZO0FBQUEsY0FDaEQsV0FBVyxRQUFRLE1BQU0sS0FBSyxFQUFFO0FBQUEsY0FDaEMsWUFBWSxXQUFXLE1BQU0sR0FBRyxDQUFDO0FBQUEsWUFDbkM7QUFBQSxVQUNGLENBQUM7QUFBQSxRQUNIO0FBQUEsTUFDRixTQUFTLE9BQU87QUFDZCxnQkFBUSxNQUFNLHlCQUF5QixLQUFLLElBQUksS0FBSyxLQUFLO0FBQUEsTUFDNUQ7QUFBQSxJQUNGO0FBRUEsV0FBTyxRQUFRLEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSztBQUFBLEVBQ2pEO0FBQUEsRUFFQSxNQUFjLGFBQWFBLFVBQWlEO0FBQzFFLFVBQU0sQ0FBQyxpQkFBaUIsY0FBYyxJQUFJLE1BQU0sUUFBUSxJQUFJO0FBQUEsTUFDMUQsS0FBSyxlQUFlQSxRQUFPLEVBQUUsTUFBTSxNQUFNLENBQUMsQ0FBbUI7QUFBQSxNQUM3RCxLQUFLLGNBQWNBLFFBQU87QUFBQSxJQUM1QixDQUFDO0FBR0QsVUFBTSxrQkFBa0Isb0JBQUksSUFBMEI7QUFHdEQsb0JBQWdCLFFBQVEsQ0FBQyxXQUF5QjtBQUNoRCxzQkFBZ0IsSUFBSSxPQUFPLElBQUk7QUFBQSxRQUM3QixHQUFHO0FBQUEsUUFDSCxZQUFZLE9BQU8sUUFBUTtBQUFBO0FBQUEsTUFDN0IsQ0FBQztBQUFBLElBQ0gsQ0FBQztBQUdELG1CQUFlLFFBQVEsQ0FBQyxXQUF5QjtBQUMvQyxZQUFNLFdBQVcsZ0JBQWdCLElBQUksT0FBTyxFQUFFO0FBQzlDLFVBQUksVUFBVTtBQUNaLGlCQUFTLGNBQWMsU0FBUyxjQUFjLFNBQVMsU0FBVSxPQUFPLFFBQVE7QUFDaEYsaUJBQVMsU0FBUyxhQUFhO0FBQUEsVUFDN0IsR0FBSSxTQUFTLFNBQVMsY0FBYyxDQUFDO0FBQUEsVUFDckMsR0FBSSxPQUFPLFNBQVMsY0FBYyxDQUFDO0FBQUEsUUFDckMsRUFBRSxNQUFNLEdBQUcsQ0FBQztBQUFBLE1BQ2QsT0FBTztBQUNMLHdCQUFnQixJQUFJLE9BQU8sSUFBSTtBQUFBLFVBQzdCLEdBQUc7QUFBQSxVQUNILFlBQVksT0FBTyxRQUFRO0FBQUE7QUFBQSxRQUM3QixDQUFDO0FBQUEsTUFDSDtBQUFBLElBQ0YsQ0FBQztBQUVELFdBQU8sTUFBTSxLQUFLLGdCQUFnQixPQUFPLENBQUMsRUFDdkMsS0FBSyxDQUFDLEdBQUcsT0FBTyxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLE1BQU07QUFBQSxFQUN6RTtBQUFBLEVBRUEsTUFBYyxpQkFBaUJBLFVBQWlEO0FBQzlFLFFBQUksQ0FBQyxLQUFLLFNBQVMsUUFBUSxHQUFHO0FBQzVCLGFBQU8sTUFBTSxLQUFLLGFBQWFBLFFBQU87QUFBQSxJQUN4QztBQUVBLFFBQUk7QUFFRixZQUFNLFdBQVcsS0FBSyxTQUFTLFlBQVk7QUFDM0MsWUFBTSxrQkFBa0IsTUFBTSxTQUFTO0FBQUEsUUFDckMsaUJBQWlCQSxTQUFRLEtBQUs7QUFBQSxRQUM5QjtBQUFBLE1BQ0Y7QUFHQSxZQUFNLGFBQTZCLENBQUM7QUFFcEMsaUJBQVcsU0FBUyxDQUFDQSxTQUFRLE9BQU8sR0FBRyxlQUFlLEdBQUc7QUFDdkQsY0FBTSxlQUFlLEVBQUUsR0FBR0EsVUFBUyxNQUFNO0FBQ3pDLGNBQU0sVUFBVSxNQUFNLEtBQUssYUFBYSxZQUFZO0FBQ3BELG1CQUFXLEtBQUssR0FBRyxPQUFPO0FBQUEsTUFDNUI7QUFHQSxZQUFNLGdCQUFnQixLQUFLLG1CQUFtQixVQUFVO0FBR3hELFlBQU0sa0JBQWtCLE1BQU0sS0FBSyxxQkFBcUJBLFNBQVEsT0FBTyxhQUFhO0FBRXBGLGFBQU87QUFBQSxJQUNULFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSxzREFBc0QsS0FBSztBQUN6RSxhQUFPLE1BQU0sS0FBSyxhQUFhQSxRQUFPO0FBQUEsSUFDeEM7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLGNBQ1osT0FDQSxTQUNBQSxVQUN5QjtBQUN6QixRQUFJLENBQUMsS0FBSyxTQUFTLFFBQVEsS0FBSyxRQUFRLFdBQVcsR0FBRztBQUNwRCxhQUFPO0FBQUEsSUFDVDtBQUVBLFFBQUk7QUFDRixZQUFNLFlBQVksUUFBUSxJQUFJLE9BQUssRUFBRSxPQUFPO0FBQzVDLFlBQU0saUJBQWlCLE1BQU0sS0FBSyxTQUFTLFdBQVcsT0FBTyxXQUFXQSxTQUFRLFVBQVU7QUFFMUYsVUFBSSxDQUFDO0FBQWdCLGVBQU87QUFFNUIsWUFBTSxrQkFBa0IsZUFBZSxLQUNwQyxPQUFPLFVBQVEsS0FBSyxtQkFBbUJBLFNBQVEsZUFBZSxFQUM5RCxJQUFJLFVBQVE7QUFDWCxjQUFNLGlCQUFpQixRQUFRLEtBQUssS0FBSztBQUN6QyxlQUFPO0FBQUEsVUFDTCxHQUFHO0FBQUEsVUFDSCxhQUFhLEtBQUs7QUFBQSxVQUNsQixZQUFhLGVBQWUsUUFBUSxNQUFRLEtBQUssa0JBQWtCO0FBQUEsUUFDckU7QUFBQSxNQUNGLENBQUM7QUFFSCxhQUFPLGdCQUFnQixLQUFLLENBQUMsR0FBRyxPQUFPLEVBQUUsY0FBYyxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsTUFBTTtBQUFBLElBQzdGLFNBQVMsT0FBTztBQUNkLGNBQVEsTUFBTSxxQkFBcUIsS0FBSztBQUN4QyxhQUFPO0FBQUEsSUFDVDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQWMscUJBQXFCLE9BQWUsU0FBa0Q7QUFDbEcsUUFBSSxDQUFDLEtBQUssU0FBUyxRQUFRLEtBQUssUUFBUSxXQUFXLEdBQUc7QUFDcEQsYUFBTztBQUFBLElBQ1Q7QUFFQSxRQUFJO0FBQ0YsWUFBTSxXQUFXLEtBQUssU0FBUyxZQUFZO0FBRzNDLFlBQU0sa0JBQWtCLE1BQU0sUUFBUTtBQUFBLFFBQ3BDLFFBQVEsSUFBSSxPQUFPLFdBQVc7QUFDNUIsY0FBSTtBQUNGLGtCQUFNLFdBQVcsTUFBTSxTQUFTLGFBQWE7QUFBQSxjQUMzQztBQUFBLGdCQUNFLE1BQU07QUFBQSxnQkFDTixTQUFTO0FBQUEsY0FDWDtBQUFBLGNBQ0E7QUFBQSxnQkFDRSxNQUFNO0FBQUEsZ0JBQ04sU0FBUyxXQUFXLEtBQUs7QUFBQTtBQUFBLFlBQWtCLE9BQU8sUUFBUSxVQUFVLEdBQUcsR0FBRyxDQUFDO0FBQUE7QUFBQTtBQUFBLGNBQzdFO0FBQUEsWUFDRixHQUFHLEVBQUUsV0FBVyxHQUFHLENBQUM7QUFFcEIsa0JBQU0sVUFBVSxXQUFXLFNBQVMsS0FBSyxDQUFDLEtBQUssT0FBTztBQUV0RCxtQkFBTztBQUFBLGNBQ0wsR0FBRztBQUFBLGNBQ0gsWUFBYSxPQUFPLFFBQVEsTUFBUSxVQUFVO0FBQUEsWUFDaEQ7QUFBQSxVQUNGLFNBQVMsT0FBTztBQUNkLG9CQUFRLE1BQU0sa0NBQWtDLEtBQUs7QUFDckQsbUJBQU87QUFBQSxVQUNUO0FBQUEsUUFDRixDQUFDO0FBQUEsTUFDSDtBQUVBLGFBQU8sZ0JBQWdCLEtBQUssQ0FBQyxHQUFHLE9BQU8sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxNQUFNO0FBQUEsSUFDN0YsU0FBUyxPQUFPO0FBQ2QsY0FBUSxNQUFNLDhCQUE4QixLQUFLO0FBQ2pELGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUFBLEVBRVEsYUFBYSxTQUF5QkEsVUFBd0M7QUFDcEYsUUFBSSxXQUFXO0FBR2YsUUFBSUEsU0FBUSxVQUFVLFNBQVMsR0FBRztBQUNoQyxpQkFBVyxTQUFTLE9BQU8sWUFBVTtBQUNuQyxZQUFJLENBQUMsT0FBTztBQUFNLGlCQUFPO0FBQ3pCLGVBQU9BLFNBQVEsVUFBVSxTQUFTLE9BQU8sS0FBSyxTQUFTO0FBQUEsTUFDekQsQ0FBQztBQUFBLElBQ0g7QUFHQSxRQUFJQSxTQUFRLFdBQVc7QUFDckIsaUJBQVcsU0FBUyxPQUFPLFlBQVU7QUFDbkMsWUFBSSxDQUFDLE9BQU8sU0FBUztBQUFVLGlCQUFPO0FBQ3RDLGNBQU0sZUFBZSxJQUFJLEtBQUssT0FBTyxTQUFTLFFBQVE7QUFDdEQsZUFBTyxnQkFBZ0JBLFNBQVEsVUFBVyxRQUFRLGdCQUFnQkEsU0FBUSxVQUFXO0FBQUEsTUFDdkYsQ0FBQztBQUFBLElBQ0g7QUFHQSxRQUFJQSxTQUFRLFFBQVFBLFNBQVEsS0FBSyxTQUFTLEdBQUc7QUFDM0MsaUJBQVcsU0FBUyxPQUFPLFlBQVU7QUFDbkMsWUFBSSxDQUFDLE9BQU8sU0FBUztBQUFNLGlCQUFPO0FBQ2xDLGVBQU9BLFNBQVEsS0FBTSxLQUFLLFNBQU8sT0FBTyxTQUFTLEtBQU0sU0FBUyxHQUFHLENBQUM7QUFBQSxNQUN0RSxDQUFDO0FBQUEsSUFDSDtBQUdBLFFBQUlBLFNBQVEsV0FBV0EsU0FBUSxRQUFRLFNBQVMsR0FBRztBQUNqRCxpQkFBVyxTQUFTLE9BQU8sWUFBVTtBQUNuQyxZQUFJLENBQUMsT0FBTyxTQUFTO0FBQU0saUJBQU87QUFDbEMsZUFBT0EsU0FBUSxRQUFTLEtBQUssWUFBVSxPQUFPLFNBQVMsS0FBTSxXQUFXLE1BQU0sQ0FBQztBQUFBLE1BQ2pGLENBQUM7QUFBQSxJQUNIO0FBRUEsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVRLFlBQVksU0FBeUJBLFVBQXdDO0FBQ25GLFVBQU0sU0FBUyxDQUFDLEdBQUcsT0FBTztBQUUxQixXQUFPLEtBQUssQ0FBQyxHQUFHLE1BQU07QUFDcEIsVUFBSSxhQUFhO0FBRWpCLGNBQVFBLFNBQVEsUUFBUTtBQUFBLFFBQ3RCLEtBQUs7QUFDSCx3QkFBYyxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFO0FBQzVEO0FBQUEsUUFDRixLQUFLO0FBQ0gsZ0JBQU0sUUFBUSxJQUFJLEtBQUssRUFBRSxTQUFTLFlBQVksQ0FBQyxFQUFFLFFBQVE7QUFDekQsZ0JBQU0sUUFBUSxJQUFJLEtBQUssRUFBRSxTQUFTLFlBQVksQ0FBQyxFQUFFLFFBQVE7QUFDekQsdUJBQWEsUUFBUTtBQUNyQjtBQUFBLFFBQ0YsS0FBSztBQUNILHVCQUFhLEVBQUUsTUFBTSxjQUFjLEVBQUUsS0FBSztBQUMxQztBQUFBLFFBQ0YsS0FBSztBQUNILHdCQUFjLEVBQUUsU0FBUyxhQUFhLE1BQU0sRUFBRSxTQUFTLGFBQWE7QUFDcEU7QUFBQSxNQUNKO0FBRUEsYUFBT0EsU0FBUSxjQUFjLFNBQVMsYUFBYSxDQUFDO0FBQUEsSUFDdEQsQ0FBQztBQUVELFdBQU87QUFBQSxFQUNUO0FBQUEsRUFFUSxtQkFBbUIsU0FBeUM7QUFDbEUsVUFBTSxPQUFPLG9CQUFJLElBQTBCO0FBRTNDLGVBQVcsVUFBVSxTQUFTO0FBQzVCLFlBQU0sTUFBTSxPQUFPLE1BQU0sUUFBUSxPQUFPO0FBQ3hDLFlBQU0sV0FBVyxLQUFLLElBQUksR0FBRztBQUU3QixVQUFJLENBQUMsYUFBYSxPQUFPLGNBQWMsT0FBTyxVQUFVLFNBQVMsY0FBYyxTQUFTLFFBQVE7QUFDOUYsYUFBSyxJQUFJLEtBQUssTUFBTTtBQUFBLE1BQ3RCO0FBQUEsSUFDRjtBQUVBLFdBQU8sTUFBTSxLQUFLLEtBQUssT0FBTyxDQUFDO0FBQUEsRUFDakM7QUFBQTtBQUFBLEVBR1EsYUFBYSxTQUF5QjtBQUM1QyxVQUFNLFFBQVEsUUFBUSxNQUFNLElBQUk7QUFDaEMsVUFBTSxlQUFlLE1BQU0sS0FBSyxVQUFRLEtBQUssV0FBVyxHQUFHLENBQUM7QUFDNUQsUUFBSSxjQUFjO0FBQ2hCLGFBQU8sYUFBYSxRQUFRLFVBQVUsRUFBRTtBQUFBLElBQzFDO0FBQ0EsV0FBTyxRQUFRLFVBQVUsR0FBRyxFQUFFLEVBQUUsS0FBSyxJQUFJO0FBQUEsRUFDM0M7QUFBQSxFQUVRLGVBQWUsU0FBaUIsWUFBWSxLQUFhO0FBQy9ELFVBQU0sVUFBVSxRQUFRLFFBQVEsVUFBVSxFQUFFLEVBQUUsUUFBUSxRQUFRLEdBQUcsRUFBRSxLQUFLO0FBQ3hFLFdBQU8sUUFBUSxTQUFTLFlBQVksUUFBUSxVQUFVLEdBQUcsU0FBUyxJQUFJLFFBQVE7QUFBQSxFQUNoRjtBQUFBLEVBRVEsa0JBQWtCLFNBQWlCLE9BQXlCO0FBQ2xFLFVBQU0sUUFBUSxNQUFNLFlBQVksRUFBRSxNQUFNLEtBQUs7QUFDN0MsVUFBTSxhQUF1QixDQUFDO0FBRTlCLGVBQVcsUUFBUSxPQUFPO0FBQ3hCLFlBQU0sV0FBVyxLQUFLLGdCQUFnQixTQUFTLElBQUk7QUFDbkQsaUJBQVcsS0FBSyxHQUFHLFFBQVE7QUFBQSxJQUM3QjtBQUVBLFdBQU8sV0FBVyxNQUFNLEdBQUcsQ0FBQztBQUFBLEVBQzlCO0FBQUEsRUFFUSxnQkFBZ0IsU0FBaUIsTUFBYyxnQkFBZ0IsSUFBYztBQUNuRixVQUFNLFFBQVEsSUFBSSxPQUFPLE1BQU0sSUFBSSxPQUFPLElBQUk7QUFDOUMsVUFBTSxVQUFvQixDQUFDO0FBQzNCLFFBQUk7QUFFSixZQUFRLFFBQVEsTUFBTSxLQUFLLE9BQU8sT0FBTyxRQUFRLFFBQVEsU0FBUyxHQUFHO0FBQ25FLFlBQU0sUUFBUSxLQUFLLElBQUksR0FBRyxNQUFNLFFBQVEsYUFBYTtBQUNyRCxZQUFNLE1BQU0sS0FBSyxJQUFJLFFBQVEsUUFBUSxNQUFNLFFBQVEsS0FBSyxTQUFTLGFBQWE7QUFDOUUsWUFBTSxVQUFVLFFBQVEsVUFBVSxPQUFPLEdBQUc7QUFDNUMsY0FBUSxLQUFLLFFBQVEsS0FBSyxDQUFDO0FBQUEsSUFDN0I7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRVEsaUJBQWlCQSxVQUFnQztBQUN2RCxXQUFPLEtBQUssVUFBVTtBQUFBLE1BQ3BCLE9BQU9BLFNBQVE7QUFBQSxNQUNmLFlBQVlBLFNBQVE7QUFBQSxNQUNwQixXQUFXQSxTQUFRO0FBQUEsTUFDbkIsV0FBV0EsU0FBUTtBQUFBLE1BQ25CLE1BQU1BLFNBQVE7QUFBQSxNQUNkLFNBQVNBLFNBQVE7QUFBQSxJQUNuQixDQUFDO0FBQUEsRUFDSDtBQUFBLEVBRVEsYUFBYSxPQUFlLGFBQTJCO0FBQzdELFNBQUssY0FBYyxRQUFRO0FBQUEsTUFDekI7QUFBQSxNQUNBLFlBQVcsb0JBQUksS0FBSyxHQUFFLFlBQVk7QUFBQSxNQUNsQztBQUFBLElBQ0YsQ0FBQztBQUdELFNBQUssZ0JBQWdCLEtBQUssY0FBYyxNQUFNLEdBQUcsR0FBRztBQUNwRCxTQUFLLGtCQUFrQjtBQUFBLEVBQ3pCO0FBQUE7QUFBQSxFQUdBLFdBQVcsTUFBYyxPQUFlQSxVQUF3QixVQUEwQixDQUFDLEdBQVM7QUFDbEcsVUFBTSxjQUEyQjtBQUFBLE1BQy9CLElBQUksVUFBVSxLQUFLLElBQUksQ0FBQztBQUFBLE1BQ3hCO0FBQUEsTUFDQTtBQUFBLE1BQ0EsU0FBQUE7QUFBQSxNQUNBO0FBQUEsTUFDQSxVQUFTLG9CQUFJLEtBQUssR0FBRSxZQUFZO0FBQUEsTUFDaEMsV0FBVSxvQkFBSSxLQUFLLEdBQUUsWUFBWTtBQUFBLE1BQ2pDLFVBQVU7QUFBQSxJQUNaO0FBRUEsU0FBSyxjQUFjLElBQUksWUFBWSxJQUFJLFdBQVc7QUFDbEQsU0FBSyxrQkFBa0I7QUFBQSxFQUN6QjtBQUFBLEVBRUEsbUJBQWtDO0FBQ2hDLFdBQU8sTUFBTSxLQUFLLEtBQUssY0FBYyxPQUFPLENBQUMsRUFDMUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxJQUFJLEtBQUssRUFBRSxRQUFRLEVBQUUsUUFBUSxJQUFJLElBQUksS0FBSyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUM7QUFBQSxFQUNuRjtBQUFBLEVBRUEsTUFBTSxtQkFBbUIsVUFBMkM7QUFDbEUsVUFBTSxjQUFjLEtBQUssY0FBYyxJQUFJLFFBQVE7QUFDbkQsUUFBSSxDQUFDLGFBQWE7QUFDaEIsWUFBTSxJQUFJLE1BQU0sd0JBQXdCO0FBQUEsSUFDMUM7QUFFQSxnQkFBWSxZQUFXLG9CQUFJLEtBQUssR0FBRSxZQUFZO0FBQzlDLGdCQUFZO0FBQ1osU0FBSyxrQkFBa0I7QUFFdkIsV0FBTyxNQUFNLEtBQUssT0FBTyxZQUFZLE9BQU87QUFBQSxFQUM5QztBQUFBLEVBRUEsa0JBQWtCLFVBQXdCO0FBQ3hDLFNBQUssY0FBYyxPQUFPLFFBQVE7QUFDbEMsU0FBSyxrQkFBa0I7QUFBQSxFQUN6QjtBQUFBLEVBRUEsbUJBQW1GO0FBQ2pGLFdBQU8sS0FBSztBQUFBLEVBQ2Q7QUFBQSxFQUVBLHFCQUEyQjtBQUN6QixTQUFLLGdCQUFnQixDQUFDO0FBQ3RCLFNBQUssa0JBQWtCO0FBQUEsRUFDekI7QUFBQTtBQUFBLEVBR1Esb0JBQTBCO0FBQ2hDLFVBQU0sUUFBUSxLQUFLLE9BQU8sU0FBUyxpQkFBaUIsQ0FBQztBQUNyRCxVQUFNLFFBQVEsQ0FBQyxXQUF3QjtBQUNyQyxXQUFLLGNBQWMsSUFBSSxPQUFPLElBQUksTUFBTTtBQUFBLElBQzFDLENBQUM7QUFBQSxFQUNIO0FBQUEsRUFFUSxvQkFBMEI7QUFDaEMsU0FBSyxPQUFPLFNBQVMsZ0JBQWdCLE1BQU0sS0FBSyxLQUFLLGNBQWMsT0FBTyxDQUFDO0FBQzNFLFNBQUssT0FBTyxhQUFhO0FBQUEsRUFDM0I7QUFBQSxFQUVRLG9CQUEwQjtBQUNoQyxTQUFLLE9BQU8sU0FBUyxnQkFBZ0IsS0FBSztBQUMxQyxTQUFLLE9BQU8sYUFBYTtBQUFBLEVBQzNCO0FBQUE7QUFBQSxFQUdBLHFCQUtFO0FBQ0EsVUFBTSxhQUFhLG9CQUFJLElBQW9CO0FBQzNDLFFBQUksZUFBZTtBQUVuQixTQUFLLGNBQWMsUUFBUSxZQUFVO0FBQ25DLGlCQUFXLElBQUksT0FBTyxRQUFRLFdBQVcsSUFBSSxPQUFPLEtBQUssS0FBSyxLQUFLLENBQUM7QUFDcEUsc0JBQWdCLE9BQU87QUFBQSxJQUN6QixDQUFDO0FBRUQsVUFBTSxhQUFhLE1BQU0sS0FBSyxXQUFXLFFBQVEsQ0FBQyxFQUMvQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssT0FBTyxFQUFFLE9BQU8sTUFBTSxFQUFFLEVBQzFDLEtBQUssQ0FBQyxHQUFHLE1BQU0sRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUNoQyxNQUFNLEdBQUcsRUFBRTtBQUVkLFdBQU87QUFBQSxNQUNMLGVBQWUsS0FBSyxjQUFjO0FBQUEsTUFDbEM7QUFBQSxNQUNBLGdCQUFnQixLQUFLLGNBQWMsU0FBUyxJQUFJLGVBQWUsS0FBSyxjQUFjLFNBQVM7QUFBQSxNQUMzRixhQUFhO0FBQUEsUUFDWCxVQUFVO0FBQUEsUUFDVixTQUFTO0FBQUEsUUFDVCxRQUFRO0FBQUEsUUFDUixhQUFhO0FBQUEsTUFDZjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUEsRUFFQSxhQUFtQjtBQUNqQixTQUFLLFlBQVksTUFBTTtBQUFBLEVBQ3pCO0FBQUEsRUFFQSxVQUFnQjtBQUNkLFNBQUssV0FBVztBQUFBLEVBQ2xCO0FBQ0Y7OztBQzlsQkEsSUFBQUUsbUJBQW9DO0FBRzdCLElBQU0scUJBQU4sY0FBaUMsdUJBQU07QUFBQSxFQUM1QyxZQUFZLEtBQWtCLFNBQXlCO0FBQ3JELFVBQU0sR0FBRztBQURtQjtBQUFBLEVBRTlCO0FBQUEsRUFFQSxTQUFTO0FBQ1AsVUFBTSxFQUFFLFVBQVUsSUFBSTtBQUN0QixjQUFVLFNBQVMsTUFBTSxFQUFFLE1BQU0sbUJBQW1CLEtBQUssUUFBUSxNQUFNLElBQUksQ0FBQztBQUU1RSxRQUFJLEtBQUssUUFBUSxXQUFXLEdBQUc7QUFDN0IsZ0JBQVUsU0FBUyxLQUFLLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNyRDtBQUFBLElBQ0Y7QUFFQSxVQUFNLG1CQUFtQixVQUFVLFNBQVMsT0FBTyxFQUFFLEtBQUssMkJBQTJCLENBQUM7QUFFdEYsU0FBSyxRQUFRLFFBQVEsQ0FBQyxRQUFRQyxXQUFVO0FBQ3RDLFlBQU0sV0FBVyxpQkFBaUIsU0FBUyxPQUFPLEVBQUUsS0FBSyxxQkFBcUIsQ0FBQztBQUcvRSxZQUFNLFNBQVMsU0FBUyxTQUFTLE9BQU8sRUFBRSxLQUFLLGdCQUFnQixDQUFDO0FBQ2hFLFlBQU0sUUFBUSxPQUFPLFNBQVMsTUFBTSxFQUFFLE1BQU0sT0FBTyxPQUFPLEtBQUssZUFBZSxDQUFDO0FBRS9FLFVBQUksT0FBTyxNQUFNO0FBQ2YsY0FBTSxVQUFVLFlBQVk7QUFDMUIsZ0JBQU0sT0FBTyxLQUFLLElBQUksVUFBVSxRQUFRLEtBQUs7QUFDN0MsZ0JBQU0sS0FBSyxTQUFTLE9BQU8sSUFBSztBQUNoQyxlQUFLLE1BQU07QUFBQSxRQUNiO0FBQ0EsY0FBTSxNQUFNLFNBQVM7QUFDckIsY0FBTSxNQUFNLFFBQVE7QUFBQSxNQUN0QjtBQUVBLFlBQU0sVUFBVSxPQUFPLFNBQVMsUUFBUSxFQUFFLEtBQUssZUFBZSxDQUFDO0FBQy9ELFVBQUksT0FBTyxnQkFBZ0IsUUFBVztBQUNwQyxnQkFBUSxRQUFRLFVBQVUsT0FBTyxNQUFNLFFBQVEsQ0FBQyxDQUFDLGNBQWMsT0FBTyxZQUFZLFFBQVEsQ0FBQyxDQUFDLEVBQUU7QUFBQSxNQUNoRyxPQUFPO0FBQ0wsZ0JBQVEsUUFBUSxVQUFVLE9BQU8sTUFBTSxRQUFRLENBQUMsQ0FBQyxFQUFFO0FBQUEsTUFDckQ7QUFHQSxZQUFNQyxhQUFZLFNBQVMsU0FBUyxPQUFPLEVBQUUsS0FBSyxpQkFBaUIsQ0FBQztBQUNwRSxZQUFNLFVBQVUsT0FBTyxRQUFRLFNBQVMsTUFDcEMsT0FBTyxRQUFRLFVBQVUsR0FBRyxHQUFHLElBQUksUUFDbkMsT0FBTztBQUNYLE1BQUFBLFdBQVUsUUFBUSxPQUFPO0FBR3pCLFVBQUksT0FBTyxTQUFTLGNBQWMsT0FBTyxTQUFTLFdBQVcsU0FBUyxHQUFHO0FBQ3ZFLGNBQU0sZUFBZSxTQUFTLFNBQVMsT0FBTyxFQUFFLEtBQUssb0JBQW9CLENBQUM7QUFDMUUscUJBQWEsU0FBUyxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDeEQsZUFBTyxTQUFTLFdBQVcsUUFBUSxlQUFhO0FBQzlDLHVCQUFhLFNBQVMsUUFBUTtBQUFBLFlBQzVCLE1BQU0sSUFBSSxTQUFTO0FBQUEsWUFDbkIsS0FBSztBQUFBLFVBQ1AsQ0FBQztBQUFBLFFBQ0gsQ0FBQztBQUFBLE1BQ0g7QUFHQSxVQUFJLE9BQU8sU0FBUyxNQUFNO0FBQ3hCLGNBQU0sU0FBUyxTQUFTLFNBQVMsT0FBTyxFQUFFLEtBQUssY0FBYyxDQUFDO0FBQzlELGVBQU8sUUFBUSxTQUFTLE9BQU8sU0FBUyxJQUFJLEVBQUU7QUFBQSxNQUNoRDtBQUFBLElBQ0YsQ0FBQztBQUdELFVBQU0sa0JBQWtCLFVBQVUsU0FBUyxPQUFPLEVBQUUsS0FBSyx5QkFBeUIsQ0FBQztBQUNuRixvQkFBZ0IsU0FBUyxVQUFVLEVBQUUsTUFBTSxRQUFRLENBQUMsRUFBRSxVQUFVLE1BQU0sS0FBSyxNQUFNO0FBQUEsRUFDbkY7QUFDRjs7O0F0R3VEQSxJQUFNLG1CQUFtQztBQUFBLEVBQ3ZDLHlCQUF5QjtBQUFBLEVBQ3pCLGVBQWU7QUFBQSxFQUNmLFdBQVc7QUFBQSxFQUNYLGNBQWM7QUFBQSxFQUNkLHFCQUFxQjtBQUFBLEVBQ3JCLG9CQUFvQjtBQUFBLEVBQ3BCLHFCQUFxQjtBQUFBLEVBQ3JCLGFBQWE7QUFBQSxFQUNiLHFCQUFxQjtBQUFBLEVBQ3JCLG1CQUFtQjtBQUFBLEVBQ25CLHVCQUF1QjtBQUFBO0FBQUEsRUFHdkIsY0FBYztBQUFBLEVBQ2QsYUFBYTtBQUFBLEVBQ2Isb0JBQW9CO0FBQUE7QUFBQSxFQUdwQixpQkFBaUIsQ0FBQztBQUFBLEVBQ2xCLG1CQUFtQjtBQUFBO0FBQUEsRUFHbkIsYUFBYTtBQUFBLElBQ1gsVUFBVTtBQUFBLElBQ1YsVUFBVTtBQUFBLElBQ1YsUUFBUTtBQUFBLElBQ1IsVUFBVTtBQUFBLElBQ1YsVUFBVTtBQUFBLElBQ1YsV0FBVztBQUFBLElBQ1gsVUFBVTtBQUFBLEVBQ1o7QUFBQSxFQUNBLGdCQUFnQjtBQUFBLEVBQ2hCLG1CQUFtQixDQUFDO0FBQUE7QUFBQSxFQUdwQixrQkFBa0IsQ0FBQztBQUFBO0FBQUEsRUFHbkIsZUFBZSxDQUFDO0FBQUEsRUFDaEIsZUFBZSxDQUFDO0FBQUEsRUFDaEIsbUJBQW1CO0FBQUEsRUFDbkIsb0JBQW9CO0FBQUEsRUFDcEIsaUJBQWlCO0FBQ25CO0FBRUEsSUFBTSx1QkFBdUI7QUFBQSxFQUMzQixjQUFjO0FBQUEsRUFDZCxhQUFhO0FBQUEsSUFDWCxrQkFBa0I7QUFBQSxJQUNsQixrQkFBa0IsRUFBRSxTQUFTLENBQUMsZUFBZSxFQUFFO0FBQUEsSUFDL0MsTUFBTTtBQUFBLElBQ04sVUFBVTtBQUFBLElBQ1YscUJBQXFCO0FBQUEsSUFDckIsaUJBQWlCLENBQUMsZ0JBQWdCLFdBQVc7QUFBQSxJQUM3QyxvQkFBb0IsQ0FBQyxPQUFPO0FBQUEsSUFDNUIsT0FBTztBQUFBLE1BQ0wsV0FBVztBQUFBLE1BQ1gsU0FBUztBQUFBLE1BQ1QsWUFBWTtBQUFBLElBQ2Q7QUFBQSxFQUNGO0FBQUEsRUFDQSxZQUFZO0FBQUEsSUFDVixjQUFjO0FBQUEsTUFDWixTQUFTO0FBQUEsTUFDVCxXQUFXO0FBQUEsTUFDWCxnQkFBZ0I7QUFBQSxNQUNoQixXQUFXO0FBQUEsTUFDWCxtQkFBbUI7QUFBQSxRQUNqQixTQUFTO0FBQUEsUUFDVCxlQUFlO0FBQUEsUUFDZixZQUFZLENBQUMsS0FBSztBQUFBLFFBQ2xCLGVBQWU7QUFBQSxNQUNqQjtBQUFBLElBQ0Y7QUFBQSxJQUNBLHNCQUFzQjtBQUFBLE1BQ3BCLFNBQVM7QUFBQSxNQUNULGdCQUFnQjtBQUFBLE1BQ2hCLGVBQWU7QUFBQSxNQUNmLGdCQUFnQjtBQUFBLE1BQ2hCLHFCQUFxQjtBQUFBLElBQ3ZCO0FBQUEsSUFDQSxnQkFBZ0I7QUFBQSxNQUNkLGFBQWE7QUFBQSxNQUNiLFdBQVc7QUFBQSxJQUNiO0FBQUEsRUFDRjtBQUFBLEVBQ0EsWUFBWTtBQUFBLElBQ1YsY0FBYztBQUFBLElBQ2QsaUJBQWlCO0FBQUEsSUFDakIsWUFBWTtBQUFBLElBQ1osT0FBTztBQUFBLElBQ1AsZUFBZTtBQUFBLE1BQ2IsZUFBZTtBQUFBLE1BQ2YsaUJBQWlCO0FBQUEsSUFDbkI7QUFBQSxJQUNBLG1CQUFtQjtBQUFBLE1BQ2pCLFNBQVM7QUFBQSxNQUNULFlBQVk7QUFBQSxNQUNaLFdBQVc7QUFBQSxJQUNiO0FBQUEsRUFDRjtBQUFBLEVBQ0EsYUFBYTtBQUFBLElBQ1gsYUFBYTtBQUFBLElBQ2IsZUFBZTtBQUFBLElBQ2YsWUFBWSxDQUFDLFdBQVcsVUFBVSxPQUFPO0FBQUEsRUFDM0M7QUFDRjtBQUdBLElBQU0sWUFBTixNQUFNLGtCQUFpQiwwQkFBUztBQUFBLEVBTTlCLFlBQVksTUFBNkIsUUFBcUI7QUFDNUQsVUFBTSxJQUFJO0FBRDZCO0FBSnpDLFNBQVEsT0FBcUM7QUFDN0MsU0FBUSxjQUE0QjtBQUNwQyxTQUFRLFFBQWdDLENBQUM7QUFBQSxFQUl6QztBQUFBLEVBRUEsY0FBYztBQUNaLFdBQU8sVUFBUztBQUFBLEVBQ2xCO0FBQUEsRUFFQSxpQkFBaUI7QUFDZixXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsTUFBTSxTQUFTO0FBQ2IsVUFBTSxZQUFZLEtBQUssWUFBWSxTQUFTLENBQUM7QUFDN0MsY0FBVSxNQUFNO0FBQ2hCLGNBQVUsU0FBUyx1QkFBdUI7QUFHMUMsU0FBSyxRQUFRLE1BQU0sS0FBSyxPQUFPLG1CQUFtQjtBQUdsRCxjQUFVLFNBQVMsT0FBTyxFQUFFLEtBQUssZ0JBQWdCLEdBQUcsQ0FBQyxXQUFXO0FBQzlELFlBQU0sU0FBUyxPQUFPLFNBQVMsVUFBVTtBQUFBLFFBQ3ZDLEtBQUs7QUFBQSxRQUNMLE1BQU0sRUFBRSxjQUFjLFlBQVk7QUFBQSxNQUNwQyxDQUFDO0FBRUQsYUFBTyxLQUFLLEtBQUssS0FBSyxFQUFFLFFBQVEsVUFBUTtBQUN0QyxjQUFNLFNBQVMsT0FBTyxTQUFTLFVBQVU7QUFBQSxVQUN2QyxNQUFNLEtBQUssT0FBTyxDQUFDLEVBQUUsWUFBWSxJQUFJLEtBQUssTUFBTSxDQUFDO0FBQUEsVUFDakQsT0FBTztBQUFBLFFBQ1QsQ0FBQztBQUNELFlBQUksU0FBUyxLQUFLLE1BQU07QUFDdEIsaUJBQU8sYUFBYSxZQUFZLFVBQVU7QUFBQSxRQUM1QztBQUFBLE1BQ0YsQ0FBQztBQUVELGFBQU8sV0FBVyxDQUFDLE1BQU0sS0FBSyxRQUFTLEVBQUUsT0FBNkIsS0FBWTtBQUdsRixhQUFPLFNBQVMsVUFBVTtBQUFBLFFBQ3hCLEtBQUs7QUFBQSxRQUNMLE1BQU07QUFBQSxRQUNOLE1BQU0sRUFBRSxjQUFjLGVBQWU7QUFBQSxNQUN2QyxDQUFDLEVBQUUsVUFBVSxNQUFNLEtBQUssd0JBQXdCO0FBR2hELFVBQUksMEJBQVMsVUFBVTtBQUNyQixlQUFPLFNBQVMsVUFBVTtBQUFBLFVBQ3hCLEtBQUs7QUFBQSxVQUNMLE1BQU07QUFBQSxRQUNSLENBQUMsRUFBRSxVQUFVLE1BQU0sS0FBSyxtQkFBbUI7QUFBQSxNQUM3QztBQUFBLElBQ0YsQ0FBQztBQUdELFVBQU0sZUFBZSxVQUFVLFNBQVMsT0FBTztBQUFBLE1BQzdDLEtBQUssd0JBQXdCLDBCQUFTLFdBQVcsa0JBQWtCLEVBQUU7QUFBQSxJQUN2RSxDQUFDO0FBR0QsVUFBTSxvQkFBb0IsVUFBVSxTQUFTLE9BQU8sRUFBRSxLQUFLLGtCQUFrQixDQUFDO0FBRzlFLGNBQVUsU0FBUyxPQUFPLEVBQUUsS0FBSyxvQkFBb0IsR0FBRyxDQUFDLGNBQWM7QUFDckUsWUFBTSxXQUFXLFVBQVUsU0FBUyxZQUFZO0FBQUEsUUFDOUMsS0FBSztBQUFBLFFBQ0wsTUFBTSxFQUFFLGFBQWEsbUJBQW1CO0FBQUEsTUFDMUMsQ0FBQztBQUVELFlBQU0sVUFBVSxVQUFVLFNBQVMsVUFBVTtBQUFBLFFBQzNDLEtBQUs7QUFBQSxRQUNMLE1BQU07QUFBQSxNQUNSLENBQUM7QUFFRCxjQUFRLFVBQVUsTUFBTSxLQUFLLFlBQVk7QUFDekMsZUFBUyxpQkFBaUIsV0FBVyxDQUFDLE1BQU07QUFDMUMsWUFBSSxFQUFFLFFBQVEsV0FBVyxDQUFDLEVBQUUsVUFBVTtBQUNwQyxZQUFFLGVBQWU7QUFDakIsZUFBSyxZQUFZO0FBQUEsUUFDbkI7QUFBQSxNQUNGLENBQUM7QUFBQSxJQUNILENBQUM7QUFHRCxjQUFVLFNBQVMsT0FBTyxFQUFFLEtBQUsscUJBQXFCLEdBQUcsQ0FBQyxnQkFBZ0I7QUFDeEUsa0JBQVksU0FBUyxPQUFPO0FBQUEsUUFDMUIsS0FBSztBQUFBLFFBQ0wsTUFBTTtBQUFBLE1BQ1IsQ0FBQyxFQUFFLFVBQVUsTUFBTSxLQUFLLFVBQVUsc0JBQXNCO0FBRXhELGtCQUFZLFNBQVMsT0FBTztBQUFBLFFBQzFCLEtBQUs7QUFBQSxRQUNMLE1BQU07QUFBQSxNQUNSLENBQUMsRUFBRSxVQUFVLE1BQU0sS0FBSyxVQUFVLHFCQUFxQjtBQUV2RCxrQkFBWSxTQUFTLE9BQU87QUFBQSxRQUMxQixLQUFLO0FBQUEsUUFDTCxNQUFNO0FBQUEsTUFDUixDQUFDLEVBQUUsVUFBVSxNQUFNLEtBQUssVUFBVSx3QkFBd0I7QUFBQSxJQUM1RCxDQUFDO0FBR0QsY0FBVSxTQUFTLE9BQU8sRUFBRSxLQUFLLHlCQUF5QixHQUFHLENBQUMsbUJBQW1CO0FBQy9FLHFCQUFlLFNBQVMsVUFBVTtBQUFBLFFBQ2hDLE1BQU07QUFBQSxRQUNOLEtBQUs7QUFBQSxNQUNQLENBQUMsRUFBRSxVQUFVLE1BQU0sS0FBSyxPQUFPLFdBQVcsT0FBTztBQUVqRCxxQkFBZSxTQUFTLFVBQVU7QUFBQSxRQUNoQyxNQUFNO0FBQUEsUUFDTixLQUFLO0FBQUEsTUFDUCxDQUFDLEVBQUUsVUFBVSxNQUFNLEtBQUssT0FBTyxXQUFXLFNBQVM7QUFFbkQsVUFBSSxLQUFLLE9BQU8sU0FBUyx1QkFBdUI7QUFDOUMsdUJBQWUsU0FBUyxVQUFVO0FBQUEsVUFDaEMsTUFBTTtBQUFBLFVBQ04sS0FBSztBQUFBLFFBQ1AsQ0FBQyxFQUFFLFVBQVUsTUFBTSxLQUFLLGdCQUFnQjtBQUFBLE1BQzFDO0FBQUEsSUFDRixDQUFDO0FBR0QsVUFBTSxLQUFLLDRCQUE0QjtBQUFBLEVBQ3pDO0FBQUEsRUFFUSxVQUFVLE1BQWM7QUFDOUIsVUFBTSxRQUFRLEtBQUssWUFBWSxjQUFjLGVBQWU7QUFDNUQsUUFBSSxPQUFPO0FBQ1QsWUFBTSxRQUFRO0FBQ2QsWUFBTSxNQUFNO0FBQUEsSUFDZDtBQUFBLEVBQ0Y7QUFBQSxFQUVRLFFBQVEsTUFBb0M7QUFDbEQsU0FBSyxPQUFPO0FBQ1osVUFBTSxlQUFlLEtBQUssTUFBTSxJQUFJLEtBQUssS0FBSyxPQUFPLG9CQUFvQixZQUFZLE1BQU0sSUFBSTtBQUMvRixRQUFJLHdCQUFPLGVBQWUsSUFBSSxVQUFVLGFBQWEsVUFBVSxHQUFHLEVBQUUsQ0FBQyxLQUFLO0FBQUEsRUFDNUU7QUFBQSxFQUVRLHFCQUFxQjtBQUMzQixVQUFNLFFBQVEsS0FBSyxZQUFZLGNBQWMsdUJBQXVCO0FBQ3BFLFFBQUksT0FBTztBQUNULFVBQUksTUFBTSxTQUFTLGVBQWUsR0FBRztBQUNuQyxjQUFNLFlBQVksZUFBZTtBQUFBLE1BQ25DLE9BQU87QUFDTCxjQUFNLFNBQVMsZUFBZTtBQUFBLE1BQ2hDO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQSxFQUVRLDBCQUEwQjtBQUNoQyxRQUFJLG9CQUFvQixLQUFLLEtBQUssS0FBSyxRQUFRLE1BQU07QUFDbkQsV0FBSyxhQUFhO0FBQUEsSUFDcEIsQ0FBQyxFQUFFLEtBQUs7QUFBQSxFQUNWO0FBQUEsRUFFQSxNQUFjLGVBQWU7QUFDM0IsU0FBSyxRQUFRLE1BQU0sS0FBSyxPQUFPLG1CQUFtQjtBQUNsRCxTQUFLLG1CQUFtQjtBQUFBLEVBQzFCO0FBQUEsRUFFUSxxQkFBcUI7QUFDM0IsVUFBTSxTQUFTLEtBQUssWUFBWSxjQUFjLHFCQUFxQjtBQUNuRSxRQUFJLFFBQVE7QUFDVixhQUFPLFlBQVk7QUFDbkIsYUFBTyxLQUFLLEtBQUssS0FBSyxFQUFFLFFBQVEsVUFBUTtBQUN0QyxjQUFNLFNBQVMsT0FBTyxTQUFTLFVBQVU7QUFBQSxVQUN2QyxNQUFNLEtBQUssT0FBTyxDQUFDLEVBQUUsWUFBWSxJQUFJLEtBQUssTUFBTSxDQUFDO0FBQUEsVUFDakQsT0FBTztBQUFBLFFBQ1QsQ0FBQztBQUNELFlBQUksU0FBUyxLQUFLLE1BQU07QUFDdEIsaUJBQU8sYUFBYSxZQUFZLFVBQVU7QUFBQSxRQUM1QztBQUFBLE1BQ0YsQ0FBQztBQUFBLElBQ0g7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLDhCQUE4QjtBQUMxQyxVQUFNLGFBQWEsS0FBSyxPQUFPLElBQUksVUFBVSxjQUFjO0FBQzNELFFBQUksWUFBWTtBQUNkLFdBQUssY0FBYztBQUNuQixZQUFNLFVBQVUsTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLEtBQUssVUFBVTtBQUMzRCxZQUFNLFVBQVUsS0FBSyx1QkFBdUIsU0FBUyxVQUFVO0FBRS9ELFlBQU0sZUFBZSxLQUFLLFlBQVksY0FBYyx1QkFBdUI7QUFDM0UsVUFBSSxjQUFjO0FBQ2hCLHFCQUFhLE1BQU07QUFDbkIscUJBQWEsU0FBUyxNQUFNLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUN4RCxxQkFBYSxTQUFTLE9BQU87QUFBQSxVQUMzQixLQUFLO0FBQUEsVUFDTCxNQUFNLFFBQVEsVUFBVSxHQUFHLEdBQUcsSUFBSTtBQUFBLFFBQ3BDLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQSxFQUVRLHVCQUF1QixTQUFpQixNQUFxQjtBQUNuRSxVQUFNLFFBQVEsS0FBSyxPQUFPLElBQUksY0FBYyxhQUFhLElBQUk7QUFFN0QsVUFBTSxnQkFBZ0IsS0FBSyxPQUFPLElBQUksY0FBYztBQUVwRCxRQUFJLFVBQVU7QUFDZCxRQUFJLGlCQUFpQixjQUFjLEtBQUssSUFBSSxHQUFHO0FBQzdDLFlBQU0sY0FBYyxPQUFPLEtBQUssY0FBYyxLQUFLLElBQUksQ0FBQyxFQUFFLE1BQU0sR0FBRyxDQUFDO0FBQ3BFLGlCQUFXLGNBQWMsYUFBYTtBQUNwQyxjQUFNLGFBQWEsS0FBSyxPQUFPLElBQUksTUFBTSxzQkFBc0IsVUFBVTtBQUN6RSxZQUFJLHNCQUFzQix3QkFBTztBQUMvQixxQkFBVyxtQkFBbUIsV0FBVyxPQUFPLFFBQ3RDLFFBQVEsVUFBVSxHQUFHLEdBQUc7QUFBQSxRQUNwQztBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE1BQWMsY0FBYztBQUMxQixVQUFNLFFBQVEsS0FBSyxZQUFZLGNBQWMsZUFBZTtBQUM1RCxRQUFJLENBQUMsT0FBTyxNQUFNLEtBQUs7QUFBRztBQUUxQixVQUFNLGFBQWEsS0FBSyxZQUFZLGNBQWMsa0JBQWtCO0FBQ3BFLFFBQUksWUFBWTtBQUVkLGlCQUFXLFNBQVMsT0FBTyxFQUFFLEtBQUssZUFBZSxHQUFHLENBQUMsUUFBUTtBQUMzRCxZQUFJLFNBQVMsT0FBTyxFQUFFLEtBQUssbUJBQW1CLE1BQU0sTUFBTSxNQUFNLENBQUM7QUFDakUsWUFBSSxTQUFTLE9BQU8sRUFBRSxLQUFLLGdCQUFnQixPQUFNLG9CQUFJLEtBQUssR0FBRSxtQkFBbUIsRUFBRSxDQUFDO0FBQUEsTUFDcEYsQ0FBQztBQUVELFlBQU0sWUFBWSxNQUFNO0FBQ3hCLFlBQU0sUUFBUTtBQUdkLFlBQU0sU0FBUyxXQUFXLFNBQVMsT0FBTyxFQUFFLEtBQUssY0FBYyxHQUFHLENBQUMsUUFBUTtBQUN6RSxZQUFJLFNBQVMsT0FBTyxFQUFFLEtBQUssMkJBQTJCLE1BQU0sc0RBQWMsQ0FBQztBQUFBLE1BQzdFLENBQUM7QUFHRCxpQkFBVyxZQUFZLFdBQVc7QUFFbEMsVUFBSTtBQUNGLGNBQU0sV0FBVyxNQUFNLEtBQUssY0FBYyxTQUFTO0FBQ25ELGNBQU0sWUFBWSxPQUFPLGNBQWMsa0JBQWtCO0FBQ3pELFlBQUksV0FBVztBQUNiLG9CQUFVLFlBQVksU0FBUztBQUMvQixvQkFBVSxRQUFRLFFBQVE7QUFBQSxRQUM1QjtBQUNBLGVBQU8sU0FBUyxPQUFPLEVBQUUsS0FBSyxnQkFBZ0IsT0FBTSxvQkFBSSxLQUFLLEdBQUUsbUJBQW1CLEVBQUUsQ0FBQztBQUFBLE1BQ3ZGLFNBQVMsR0FBRztBQUNWLGNBQU0sWUFBWSxPQUFPLGNBQWMsa0JBQWtCO0FBQ3pELFlBQUksV0FBVztBQUNiLG9CQUFVLFlBQVksU0FBUztBQUMvQixvQkFBVSxTQUFTLE9BQU87QUFDMUIsb0JBQVUsUUFBUSxZQUFhLEVBQVksT0FBTztBQUFBLFFBQ3BEO0FBQUEsTUFDRjtBQUVBLGlCQUFXLFlBQVksV0FBVztBQUFBLElBQ3BDO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYyxjQUFjLE9BQWdDO0FBQzFELFVBQU0sVUFBVSxLQUFLLGNBQ25CLE1BQU0sS0FBSyxPQUFPLElBQUksTUFBTSxLQUFLLEtBQUssV0FBVyxJQUFJO0FBRXZELFlBQVEsS0FBSyxNQUFNO0FBQUEsTUFDakIsS0FBSztBQUNILFlBQUksS0FBSyxPQUFPLFlBQVk7QUFDMUIsZ0JBQU0sWUFBWSxNQUFNLEtBQUssT0FBTyxXQUFXLFdBQVcsS0FBSztBQUMvRCxnQkFBTSxVQUFVLE1BQU0sS0FBSyxPQUFPLGNBQWMsY0FBYyxTQUFTO0FBQ3ZFLGlCQUFPLFFBQVEsU0FBUyxJQUN0Qix3QkFBd0IsUUFBUSxDQUFDLEVBQUUsSUFBSSxLQUN2QztBQUFBLFFBQ0o7QUFDQSxlQUFPO0FBQUEsTUFFVCxLQUFLO0FBQ0gsZUFBTyxNQUFNLEtBQUssT0FBTyxjQUFjLGFBQWEsS0FBSyxNQUFNLEtBQUs7QUFBQSxNQUV0RSxLQUFLO0FBQ0gsZUFBTyxNQUFNLEtBQUssSUFBSSxzQkFBc0IsS0FBSztBQUFBO0FBQUEsV0FBaUIsUUFBUSxVQUFVLEdBQUcsR0FBRyxDQUFDO0FBQUE7QUFBQTtBQUFBLE1BRTdGO0FBQ0UsZUFBTztBQUFBLElBQ1g7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLGtCQUFrQjtBQUM5QixRQUFJO0FBQ0YsWUFBTSxLQUFLLE9BQU8sV0FBVyxTQUFTLElBQUk7QUFDMUMsWUFBTSxLQUFLLE9BQU8sV0FBVyxXQUFXLElBQUk7QUFDNUMsVUFBSSx3QkFBTyx3Q0FBd0M7QUFBQSxJQUNyRCxTQUFTLEdBQUc7QUFDVixVQUFJLHdCQUFPLGtCQUFtQixFQUFZLE9BQU87QUFBQSxJQUNuRDtBQUFBLEVBQ0Y7QUFDRjtBQTdTTSxVQUNHLFlBQVk7QUFEckIsSUFBTSxXQUFOO0FBZ1RBLElBQU0sc0JBQU4sY0FBa0MsdUJBQU07QUFBQSxFQUN0QyxZQUNFLEtBQ1EsUUFDQSxjQUNSO0FBQ0EsVUFBTSxHQUFHO0FBSEQ7QUFDQTtBQUFBLEVBR1Y7QUFBQSxFQUVBLFNBQVM7QUFDUCxVQUFNLEVBQUUsVUFBVSxJQUFJO0FBQ3RCLGNBQVUsU0FBUyxNQUFNLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUVwRCxTQUFLLGFBQWE7QUFHbEIsY0FBVSxTQUFTLFVBQVU7QUFBQSxNQUMzQixNQUFNO0FBQUEsTUFDTixLQUFLO0FBQUEsSUFDUCxDQUFDLEVBQUUsVUFBVSxNQUFNLEtBQUssV0FBVztBQUFBLEVBQ3JDO0FBQUEsRUFFQSxNQUFjLGVBQWU7QUFDM0IsVUFBTSxRQUFRLE1BQU0sS0FBSyxPQUFPLG1CQUFtQjtBQUNuRCxVQUFNLFlBQVksS0FBSyxVQUFVLFNBQVMsT0FBTyxFQUFFLEtBQUssWUFBWSxDQUFDO0FBRXJFLFdBQU8sUUFBUSxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUMsTUFBTUMsT0FBTSxNQUFNO0FBQ2hELFlBQU0sV0FBVyxVQUFVLFNBQVMsT0FBTyxFQUFFLEtBQUssWUFBWSxDQUFDO0FBQy9ELGVBQVMsU0FBUyxNQUFNLEVBQUUsTUFBTSxLQUFLLENBQUM7QUFFdEMsZUFBUyxTQUFTLE9BQU87QUFBQSxRQUN2QixLQUFLO0FBQUEsUUFDTCxNQUFNQSxRQUFPLFVBQVUsR0FBRyxHQUFHLEtBQUtBLFFBQU8sU0FBUyxNQUFNLFFBQVE7QUFBQSxNQUNsRSxDQUFDO0FBRUQsWUFBTSxVQUFVLFNBQVMsU0FBUyxPQUFPLEVBQUUsS0FBSyxlQUFlLENBQUM7QUFDaEUsY0FBUSxTQUFTLFVBQVUsRUFBRSxNQUFNLE9BQU8sQ0FBQyxFQUFFLFVBQVUsTUFDckQsS0FBSyxTQUFTLE1BQU1BLE9BQU07QUFDNUIsY0FBUSxTQUFTLFVBQVUsRUFBRSxNQUFNLFNBQVMsQ0FBQyxFQUFFLFVBQVUsTUFDdkQsS0FBSyxXQUFXLElBQUk7QUFDdEIsY0FBUSxTQUFTLFVBQVUsRUFBRSxNQUFNLFNBQVMsQ0FBQyxFQUFFLFVBQVUsTUFDdkQsS0FBSyxXQUFXLElBQUk7QUFBQSxJQUN4QixDQUFDO0FBQUEsRUFDSDtBQUFBLEVBRUEsTUFBYyxhQUFhO0FBQ3pCLFVBQU0sT0FBTyxPQUFPLGtCQUFrQjtBQUN0QyxRQUFJLENBQUM7QUFBTTtBQUVYLFVBQU0sYUFBYTtBQUFBLE1BQU87QUFBQSxNQUN4QjtBQUFBLElBQWlDO0FBQ25DLFFBQUksQ0FBQztBQUFZO0FBRWpCLFVBQU0sS0FBSyxPQUFPLElBQUksTUFBTTtBQUFBLE1BQzFCLFlBQVksSUFBSTtBQUFBLE1BQ2hCO0FBQUEsSUFDRjtBQUVBLFNBQUssYUFBYTtBQUNsQixTQUFLLE1BQU07QUFBQSxFQUNiO0FBQUEsRUFFQSxNQUFjLFNBQVMsTUFBYyxlQUF1QjtBQUMxRCxVQUFNLFlBQVksT0FBTyx1QkFBdUIsYUFBYTtBQUM3RCxRQUFJLENBQUMsYUFBYSxjQUFjO0FBQWU7QUFFL0MsVUFBTSxPQUFPLEtBQUssT0FBTyxJQUFJLE1BQU0sc0JBQXNCLFlBQVksSUFBSSxLQUFLO0FBQzlFLFFBQUksZ0JBQWdCLHdCQUFPO0FBQ3pCLFlBQU0sS0FBSyxPQUFPLElBQUksTUFBTSxPQUFPLE1BQU0sU0FBUztBQUNsRCxXQUFLLGFBQWE7QUFDbEIsV0FBSyxNQUFNO0FBQUEsSUFDYjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQWMsV0FBVyxNQUFjO0FBQ3JDLFVBQU0sT0FBTyxLQUFLLE9BQU8sSUFBSSxNQUFNLHNCQUFzQixZQUFZLElBQUksS0FBSztBQUM5RSxRQUFJLENBQUMsUUFBUSxFQUFFLGdCQUFnQjtBQUFRO0FBRXZDLFVBQU0sVUFBVSxNQUFNLEtBQUssT0FBTyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ3JELFVBQU0sT0FBTyxJQUFJLEtBQUssQ0FBQyxPQUFPLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzFELFVBQU0sTUFBTSxJQUFJLGdCQUFnQixJQUFJO0FBRXBDLFVBQU0sSUFBSSxTQUFTLGNBQWMsR0FBRztBQUNwQyxNQUFFLE9BQU87QUFDVCxNQUFFLFdBQVcsR0FBRyxJQUFJO0FBQ3BCLGFBQVMsS0FBSyxZQUFZLENBQUM7QUFDM0IsTUFBRSxNQUFNO0FBQ1IsYUFBUyxLQUFLLFlBQVksQ0FBQztBQUMzQixRQUFJLGdCQUFnQixHQUFHO0FBQUEsRUFDekI7QUFBQSxFQUVBLE1BQWMsV0FBVyxNQUFjO0FBQ3JDLFFBQUksQ0FBQyxRQUFRLGdCQUFnQixJQUFJLElBQUk7QUFBRztBQUV4QyxVQUFNLE9BQU8sS0FBSyxPQUFPLElBQUksTUFBTSxzQkFBc0IsWUFBWSxJQUFJLEtBQUs7QUFDOUUsUUFBSSxnQkFBZ0Isd0JBQU87QUFDekIsWUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLE9BQU8sSUFBSTtBQUN2QyxXQUFLLGFBQWE7QUFDbEIsV0FBSyxNQUFNO0FBQUEsSUFDYjtBQUFBLEVBQ0Y7QUFDRjtBQUdBLElBQU0sY0FBTixNQUFrQjtBQUFBLEVBQ2hCLFlBQW9CLFFBQXFCO0FBQXJCO0FBQUEsRUFBc0I7QUFBQSxFQUUxQyxNQUFNLFFBQVEsVUFBK0IsV0FBdUM7QUFDbEYsVUFBTSxPQUFtQjtBQUFBLE1BQ3ZCLFFBQUksWUFBQUMsSUFBTztBQUFBLE1BQ1gsTUFBTSxTQUFTLFFBQVE7QUFBQSxNQUN2QixTQUFTLFNBQVMsV0FBVztBQUFBLE1BQzdCLFNBQVMsU0FBUyxXQUFXLFNBQVMsU0FBUyxVQUFVLEdBQUcsR0FBRyxLQUFLO0FBQUEsTUFDcEUsV0FBVztBQUFBLFFBQ1QsYUFBWSxvQkFBSSxLQUFLLEdBQUUsWUFBWTtBQUFBLFFBQ25DLGFBQVksb0JBQUksS0FBSyxHQUFFLFlBQVk7QUFBQSxRQUNuQyxhQUFZLG9CQUFJLEtBQUssR0FBRSxZQUFZO0FBQUEsUUFDbkMsYUFBYTtBQUFBLE1BQ2Y7QUFBQSxNQUNBLFlBQVksU0FBUyxjQUFjO0FBQUEsTUFDbkMsU0FBUyxTQUFTLFdBQVcsQ0FBQztBQUFBLE1BQzlCLFlBQVksYUFBYSxDQUFDO0FBQUEsTUFDMUIsWUFBWSxTQUFTLGNBQWMsQ0FBQztBQUFBLE1BQ3BDLFVBQVUsU0FBUyxZQUFZO0FBQUEsTUFDL0IsU0FBUztBQUFBLE1BQ1QsWUFBWSxTQUFTLGNBQWMsQ0FBQztBQUFBLElBQ3RDO0FBRUEsVUFBTSxRQUFRLE1BQU0sS0FBSyxLQUFLO0FBQzlCLFVBQU0sTUFBTSxLQUFLLElBQUk7QUFDckIsVUFBTSxLQUFLLEtBQUssS0FBSztBQUVyQixXQUFPLEtBQUs7QUFBQSxFQUNkO0FBQUEsRUFFQSxNQUFNLE9BQTJCO0FBQy9CLFVBQU0sT0FBTyxLQUFLLE9BQU8sb0JBQW9CLFdBQVcsYUFBYTtBQUNyRSxRQUFJO0FBQ0YsVUFBSSxNQUFNLEtBQUssT0FBTyxJQUFJLE1BQU0sUUFBUSxPQUFPLElBQUksR0FBRztBQUNwRCxjQUFNLFVBQVUsTUFBTSxLQUFLLE9BQU8sSUFBSSxNQUFNLFFBQVEsS0FBSyxJQUFJO0FBQzdELGVBQU8sS0FBSyxNQUFNLE9BQU87QUFBQSxNQUMzQjtBQUFBLElBQ0YsU0FBUyxHQUFHO0FBQ1YsY0FBUSxNQUFNLHlCQUF5QixDQUFDO0FBQUEsSUFDMUM7QUFFQSxXQUFPLEtBQUssaUJBQWlCO0FBQUEsRUFDL0I7QUFBQSxFQUVBLE1BQU0sS0FBSyxPQUFpQztBQUMxQyxVQUFNLE9BQU8sS0FBSyxPQUFPLG9CQUFvQixXQUFXLGFBQWE7QUFDckUsVUFBTSxlQUFlLGFBQVksb0JBQUksS0FBSyxHQUFFLFlBQVk7QUFDeEQsVUFBTSxlQUFlLGNBQWMsTUFBTSxNQUFNO0FBQy9DLFVBQU0sZUFBZSxjQUFjLE1BQU0sTUFBTTtBQUUvQyxVQUFNLEtBQUssT0FBTyxJQUFJLE1BQU0sUUFBUSxNQUFNLE1BQU0sS0FBSyxVQUFVLE9BQU8sTUFBTSxDQUFDLENBQUM7QUFBQSxFQUNoRjtBQUFBLEVBRVEsbUJBQThCO0FBQ3BDLFdBQU87QUFBQSxNQUNMLGdCQUFnQjtBQUFBLE1BQ2hCLGdCQUFnQjtBQUFBLFFBQ2QsYUFBYTtBQUFBLFFBQ2IsYUFBYTtBQUFBLFFBQ2IsWUFBVyxvQkFBSSxLQUFLLEdBQUUsWUFBWTtBQUFBLFFBQ2xDLGVBQVcsWUFBQUEsSUFBTztBQUFBLFFBQ2xCLFNBQVM7QUFBQSxNQUNYO0FBQUEsTUFDQSxPQUFPLENBQUM7QUFBQSxNQUNSLE9BQU8sQ0FBQztBQUFBLElBQ1Y7QUFBQSxFQUNGO0FBQ0Y7QUFHQSxJQUFNLGdCQUFOLE1BQW9CO0FBQUEsRUFDbEIsWUFBb0IsUUFBcUI7QUFBckI7QUFBQSxFQUFzQjtBQUFBLEVBRTFDLE1BQU0sY0FBYyxnQkFBMEIsUUFBZ0IsR0FBa0Q7QUFDOUcsUUFBSSxDQUFDLEtBQUssT0FBTztBQUFjLGFBQU8sQ0FBQztBQUV2QyxRQUFJO0FBQ0YsWUFBTSxTQUFTLE1BQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxRQUM1QyxLQUFLLE9BQU8sb0JBQW9CLFdBQVcsY0FBYztBQUFBLFFBQ3pEO0FBQUEsVUFDRSxRQUFRO0FBQUEsVUFDUjtBQUFBLFVBQ0EsY0FBYztBQUFBLFFBQ2hCO0FBQUEsTUFDRjtBQUVBLGFBQU8sT0FBTyxJQUFJLFlBQVU7QUFBQSxRQUMxQixNQUFNLE1BQU0sU0FBUyxRQUFrQjtBQUFBLFFBQ3ZDLE9BQU8sTUFBTSxTQUFTO0FBQUEsTUFDeEIsRUFBRTtBQUFBLElBQ0osU0FBUyxHQUFHO0FBQ1YsY0FBUSxNQUFNLGtCQUFrQixDQUFDO0FBQ2pDLGFBQU8sQ0FBQztBQUFBLElBQ1Y7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLGVBQWUsSUFBWSxRQUFrQixNQUE2QjtBQUM5RSxRQUFJLENBQUMsS0FBSyxPQUFPO0FBQWM7QUFFL0IsUUFBSTtBQUNGLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxRQUM3QixLQUFLLE9BQU8sb0JBQW9CLFdBQVcsY0FBYztBQUFBLFFBQ3pEO0FBQUEsVUFDRSxRQUFRLENBQUM7QUFBQSxZQUNQO0FBQUEsWUFDQTtBQUFBLFlBQ0EsU0FBUyxFQUFFLEtBQUs7QUFBQSxVQUNsQixDQUFDO0FBQUEsUUFDSDtBQUFBLE1BQ0Y7QUFBQSxJQUNGLFNBQVMsR0FBRztBQUNWLGNBQVEsTUFBTSxrQkFBa0IsQ0FBQztBQUFBLElBQ25DO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxnQkFBZ0M7QUFDcEMsUUFBSSxDQUFDLEtBQUssT0FBTztBQUFjLGFBQU8sQ0FBQztBQUV2QyxRQUFJO0FBQ0YsWUFBTSxTQUFTLE1BQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxRQUM1QyxLQUFLLE9BQU8sb0JBQW9CLFdBQVcsY0FBYztBQUFBLFFBQ3pELEVBQUUsT0FBTyxLQUFPLGNBQWMsTUFBTSxhQUFhLEtBQUs7QUFBQSxNQUN4RDtBQUNBLGFBQU8sT0FBTztBQUFBLElBQ2hCLFNBQVMsR0FBRztBQUNWLGNBQVEsTUFBTSxrQkFBa0IsQ0FBQztBQUNqQyxhQUFPLENBQUM7QUFBQSxJQUNWO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxjQUFjLFFBQThCO0FBQ2hELFFBQUksQ0FBQyxLQUFLLE9BQU87QUFBYztBQUUvQixRQUFJO0FBQ0YsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLFFBQzdCLEtBQUssT0FBTyxvQkFBb0IsV0FBVyxjQUFjO0FBQUEsUUFDekQsRUFBRSxPQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0YsU0FBUyxHQUFHO0FBQ1YsY0FBUSxNQUFNLGtCQUFrQixDQUFDO0FBQUEsSUFDbkM7QUFBQSxFQUNGO0FBQ0Y7QUFHQSxJQUFNLGdCQUFOLE1BQW9CO0FBQUEsRUFDbEIsWUFBb0IsUUFBcUI7QUFBckI7QUFBQSxFQUFzQjtBQUFBLEVBRTFDLE1BQU0sYUFBYSxNQUFjLE9BQWlDO0FBQ2hFLFVBQU0sUUFBUSxNQUFNLEtBQUssT0FBTyxZQUFZLEtBQUs7QUFDakQsVUFBTSxlQUFlLEtBQUssT0FBTyxvQkFBb0IsWUFBWSxNQUFNLElBQUk7QUFFM0UsVUFBTSxRQUFRLE1BQU0sTUFDakIsT0FBTyxPQUFLLEVBQUUsU0FBUyxNQUFNLEVBQzdCLE1BQU0sR0FBRyxLQUFLLE9BQU8sb0JBQW9CLFdBQVcsZUFBZSxTQUFTO0FBRS9FLFVBQU0sT0FBTyxlQUFlLElBQUk7QUFBQTtBQUFBLFNBQWUsU0FBUyxrQkFBa0I7QUFBQTtBQUFBLFVBQWUsWUFBWTtBQUFBO0FBQUEsbUJBQXdCLE1BQU0sSUFBSSxPQUFLLEVBQUUsT0FBTyxFQUFFLEtBQUssSUFBSSxDQUFDO0FBQUE7QUFBQTtBQUdqSyxVQUFNLFdBQVcsUUFBUSxJQUFJLEtBQUksb0JBQUksS0FBSyxHQUFFLFlBQVksRUFBRSxNQUFNLEdBQUUsRUFBRSxDQUFDO0FBQ3JFLFVBQU0sS0FBSyxPQUFPLElBQUksTUFBTSxPQUFPLFVBQVUsSUFBSTtBQUVqRCxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBR0EsSUFBcUIsY0FBckIsY0FBeUMsd0JBQU87QUFBQSxFQUFoRDtBQUFBO0FBT0Usd0JBQW9DO0FBQ3BDLHNCQUFrQyxvQkFBSSxJQUFJO0FBQUE7QUFBQSxFQVkxQyxNQUFNLFNBQVM7QUFDYixVQUFNLEtBQUssYUFBYTtBQUd4QixTQUFLLGNBQWMsSUFBSSxZQUFZLElBQUk7QUFDdkMsU0FBSyxnQkFBZ0IsSUFBSSxjQUFjLElBQUk7QUFDM0MsU0FBSyxnQkFBZ0IsSUFBSSxjQUFjLElBQUk7QUFDM0MsU0FBSyx1QkFBdUIsSUFBSSxxQkFBcUIsSUFBSTtBQUN6RCxTQUFLLG1CQUFtQixJQUFJLGlCQUFpQixJQUFJO0FBR2pELFNBQUssV0FBVyxJQUFJLG9CQUFvQixJQUFJO0FBQzVDLFNBQUssV0FBVyxJQUFJLG9CQUFvQixJQUFJO0FBQzVDLFNBQUssZUFBZSxJQUFJLGFBQWEsSUFBSTtBQUN6QyxTQUFLLG1CQUFtQixJQUFJLGlCQUFpQixNQUFNLEtBQUssWUFBWTtBQUNwRSxTQUFLLHNCQUFzQixJQUFJLG9CQUFvQixNQUFNLEtBQUssY0FBYyxLQUFLLGdCQUFnQjtBQUNqRyxTQUFLLGlCQUFpQixJQUFJLHFCQUFxQixNQUFNLEtBQUssVUFBVSxLQUFLLFFBQVE7QUFHakYsVUFBTSxLQUFLLHVCQUF1QjtBQUVsQyxVQUFNLEtBQUssd0JBQXdCO0FBR25DLFFBQUksS0FBSyxTQUFTLGVBQWU7QUFDL0IsV0FBSyxhQUFhLElBQUkscUNBQW9CO0FBQUEsUUFDeEMsUUFBUSxLQUFLLFNBQVM7QUFBQSxNQUN4QixDQUFDO0FBQUEsSUFDSDtBQUdBLFNBQUs7QUFBQSxNQUNILEtBQUssSUFBSSxNQUFNLEdBQUcsVUFBVSxDQUFDLFNBQWdCLEtBQUssaUJBQWlCLElBQUksQ0FBQztBQUFBLElBQzFFO0FBQ0EsU0FBSztBQUFBLE1BQ0gsS0FBSyxJQUFJLE1BQU0sR0FBRyxVQUFVLENBQUMsU0FBZ0IsS0FBSyxpQkFBaUIsSUFBSSxDQUFDO0FBQUEsSUFDMUU7QUFHQSxTQUFLO0FBQUEsTUFDSCxTQUFTO0FBQUEsTUFDVCxDQUFDLFNBQVMsSUFBSSxTQUFTLE1BQU0sSUFBSTtBQUFBLElBQ25DO0FBRUEsU0FBSztBQUFBLE1BQ0gsY0FBYztBQUFBLE1BQ2QsQ0FBQyxTQUFTLElBQUksY0FBYyxNQUFNLElBQUk7QUFBQSxJQUN4QztBQUdBLFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUssYUFBYTtBQUFBLElBQ3BDLENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNkLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsTUFBTSxLQUFLLGdCQUFnQjtBQUFBLElBQ3ZDLENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNkLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLGdCQUFnQixDQUFDLFdBQVcsS0FBSyxtQkFBbUIsT0FBTyxTQUFTLENBQUM7QUFBQSxJQUN2RSxDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDZCxJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLE1BQU0sS0FBSyxXQUFXO0FBQUEsSUFDbEMsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUssV0FBVyxPQUFPO0FBQUEsSUFDekMsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUssV0FBVyxPQUFPO0FBQUEsSUFDekMsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUsscUJBQXFCO0FBQUEsSUFDNUMsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUssY0FBYyxhQUFhLEtBQUssU0FBUyxXQUFXO0FBQUEsSUFDM0UsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBQ3BCLGNBQU0sT0FBTyxLQUFLLElBQUksVUFBVSxjQUFjO0FBQzlDLFlBQUksUUFBUSxLQUFLLGNBQWMsTUFBTTtBQUNuQyxnQkFBTSxLQUFLLHVCQUF1QixJQUFJO0FBQUEsUUFDeEMsT0FBTztBQUNMLGNBQUksd0JBQU8sbUNBQW1DO0FBQUEsUUFDaEQ7QUFBQSxNQUNGO0FBQUEsSUFDRixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDZCxJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLFlBQVk7QUFDcEIsY0FBTSxjQUFjLE1BQU0sS0FBSyxpQkFBaUIseUJBQXlCO0FBQ3pFLFlBQUksc0JBQXNCLE1BQU0sV0FBVyxFQUFFLEtBQUs7QUFBQSxNQUNwRDtBQUFBLElBQ0YsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxZQUFZO0FBQ3BCLGNBQU0sT0FBTyxLQUFLLElBQUksVUFBVSxjQUFjO0FBQzlDLFlBQUksUUFBUSxLQUFLLGNBQWMsTUFBTTtBQUNuQyxnQkFBTSxVQUFVLE1BQU0sS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQzlDLGdCQUFNLE9BQU8sTUFBTSxLQUFLLGlCQUFpQixlQUFlLE1BQU0sT0FBTztBQUNyRSxjQUFJLEtBQUssU0FBUyxHQUFHO0FBQ25CLGtCQUFNLFlBQVksS0FBSyxJQUFJLFNBQU8sSUFBSSxHQUFHLEVBQUUsRUFBRSxLQUFLLEdBQUc7QUFDckQsa0JBQU0sS0FBSyxJQUFJLE1BQU0sT0FBTyxNQUFNLFVBQVUsU0FBUyxTQUFTO0FBQzlELGdCQUFJLHdCQUFPLFNBQVMsS0FBSyxNQUFNLHVCQUF1QjtBQUFBLFVBQ3hELE9BQU87QUFDTCxnQkFBSSx3QkFBTyx3QkFBd0I7QUFBQSxVQUNyQztBQUFBLFFBQ0YsT0FBTztBQUNMLGNBQUksd0JBQU8sbUNBQW1DO0FBQUEsUUFDaEQ7QUFBQSxNQUNGO0FBQUEsSUFDRixDQUFDO0FBRUQsU0FBSyxXQUFXO0FBQUEsTUFDZCxJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLFlBQVk7QUFDcEIsY0FBTSxLQUFLLHFCQUFxQixvQkFBb0I7QUFDcEQsY0FBTSxRQUFRLEtBQUsscUJBQXFCLGNBQWM7QUFDdEQsWUFBSSx3QkFBTyw0QkFBNEIsTUFBTSxJQUFJLHNCQUFzQixNQUFNLFVBQVUsS0FBSyxRQUFRLENBQUMsQ0FBQyxHQUFHO0FBQUEsTUFDM0c7QUFBQSxJQUNGLENBQUM7QUFFRCxTQUFLLFdBQVc7QUFBQSxNQUNkLElBQUk7QUFBQSxNQUNKLE1BQU07QUFBQSxNQUNOLFVBQVUsTUFBTTtBQUNkLGNBQU0sUUFBUSxPQUFPLHFCQUFxQjtBQUMxQyxZQUFJLE9BQU87QUFDVCxlQUFLLG1CQUFtQixLQUFLO0FBQUEsUUFDL0I7QUFBQSxNQUNGO0FBQUEsSUFDRixDQUFDO0FBR0QsU0FBSyxXQUFXO0FBQUEsTUFDZCxJQUFJO0FBQUEsTUFDSixNQUFNO0FBQUEsTUFDTixVQUFVLE1BQU0sS0FBSyxjQUFjO0FBQUEsSUFDckMsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUssbUJBQW1CO0FBQUEsSUFDMUMsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUsseUJBQXlCO0FBQUEsSUFDaEQsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUssc0JBQXNCO0FBQUEsSUFDN0MsQ0FBQztBQUVELFNBQUssV0FBVztBQUFBLE1BQ2QsSUFBSTtBQUFBLE1BQ0osTUFBTTtBQUFBLE1BQ04sVUFBVSxNQUFNLEtBQUssZ0JBQWdCO0FBQUEsSUFDdkMsQ0FBQztBQUdELFNBQUssY0FBYyxTQUFTLHFCQUFxQixNQUFNLEtBQUssYUFBYSxDQUFDO0FBQzFFLFNBQUssY0FBYyxvQkFBb0Isb0JBQW9CLE1BQU0sS0FBSyxjQUFjLENBQUM7QUFHckYsU0FBSyxjQUFjLElBQUksZ0JBQWdCLEtBQUssS0FBSyxJQUFJLENBQUM7QUFFdEQsUUFBSSx3QkFBTyxpQ0FBMEI7QUFBQSxFQUN2QztBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ25CLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBQUEsRUFDM0U7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNuQixVQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxFQUNuQztBQUFBLEVBRUEsTUFBTSwwQkFBMEI7QUFDOUIsUUFBSTtBQUNGLFlBQU0sT0FBTyxLQUFLLFNBQVM7QUFDM0IsVUFBSSxNQUFNLEtBQUssSUFBSSxNQUFNLFFBQVEsT0FBTyxJQUFJLEdBQUc7QUFDN0MsY0FBTSxVQUFVLE1BQU0sS0FBSyxJQUFJLE1BQU0sUUFBUSxLQUFLLElBQUk7QUFDdEQsYUFBSyxzQkFBc0IsS0FBSyxNQUFNLE9BQU87QUFBQSxNQUMvQyxPQUFPO0FBQ0wsY0FBTSxLQUFLLElBQUksTUFBTSxRQUFRO0FBQUEsVUFDM0I7QUFBQSxVQUNBLEtBQUssVUFBVSxzQkFBc0IsTUFBTSxDQUFDO0FBQUEsUUFDOUM7QUFDQSxhQUFLLHNCQUFzQjtBQUFBLE1BQzdCO0FBRUEsV0FBSyxXQUFXO0FBQUEsSUFDbEIsU0FBUyxHQUFHO0FBQ1YsY0FBUSxNQUFNLGdDQUFnQyxDQUFDO0FBQy9DLFdBQUssc0JBQXNCO0FBQUEsSUFDN0I7QUFBQSxFQUNGO0FBQUEsRUFFQSxhQUFhO0FBQ1gsUUFBSSxDQUFDLEtBQUssU0FBUztBQUFXO0FBRTlCLFNBQUssZUFBZSxJQUFJLG1DQUFhO0FBQUEsTUFDbkMsS0FBSyxLQUFLLFNBQVM7QUFBQSxNQUNuQixRQUFRLEtBQUssU0FBUyxnQkFBZ0I7QUFBQSxJQUN4QyxDQUFDO0FBR0QsVUFBTSxTQUFTLEtBQUssb0JBQW9CLFdBQVc7QUFDbkQsU0FBSyxhQUFhLGlCQUFpQixPQUFPLGlCQUFpQjtBQUFBLE1BQ3pELFNBQVMsRUFBRSxNQUFNLE1BQU0sVUFBVSxTQUFTO0FBQUEsSUFDNUMsQ0FBQyxFQUFFLE1BQU0sTUFBTTtBQUFBLElBRWYsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVBLE1BQU0scUJBQXNEO0FBQzFELFVBQU0sYUFBYTtBQUNuQixVQUFNLFFBQWdDLENBQUM7QUFHdkMsUUFBSSxDQUFFLE1BQU0sS0FBSyxJQUFJLE1BQU0sUUFBUSxPQUFPLFVBQVUsR0FBSTtBQUN0RCxZQUFNLEtBQUssSUFBSSxNQUFNLGFBQWEsVUFBVTtBQUFBLElBQzlDO0FBR0EsUUFBSTtBQUNGLFlBQU0sUUFBUSxNQUFNLEtBQUssSUFBSSxNQUFNLFFBQVEsS0FBSyxVQUFVO0FBQzFELGlCQUFXLFFBQVEsTUFBTSxPQUFPO0FBQzlCLFlBQUksS0FBSyxTQUFTLEtBQUssR0FBRztBQUN4QixnQkFBTSxXQUFXLEtBQUssTUFBTSxHQUFHLEVBQUUsSUFBSSxHQUFHLFFBQVEsT0FBTyxFQUFFLEtBQUs7QUFDOUQsZ0JBQU0sVUFBVSxNQUFNLEtBQUssSUFBSSxNQUFNLFFBQVEsS0FBSyxJQUFJO0FBQ3RELGdCQUFNLFFBQVEsSUFBSTtBQUFBLFFBQ3BCO0FBQUEsTUFDRjtBQUFBLElBQ0YsU0FBUyxHQUFHO0FBQ1YsY0FBUSxNQUFNLHlCQUF5QixDQUFDO0FBQUEsSUFDMUM7QUFHQSxRQUFJLE9BQU8sS0FBSyxLQUFLLEVBQUUsV0FBVyxHQUFHO0FBQ25DLFlBQU0sZUFBZTtBQUFBLFFBQ25CLGFBQWE7QUFBQSxRQUNiLFdBQVc7QUFBQSxRQUNYLGNBQWM7QUFBQSxNQUNoQjtBQUVBLGlCQUFXLENBQUMsTUFBTUQsT0FBTSxLQUFLLE9BQU8sUUFBUSxZQUFZLEdBQUc7QUFDekQsY0FBTSxLQUFLLElBQUksTUFBTSxPQUFPLEdBQUcsVUFBVSxJQUFJLElBQUksT0FBT0EsT0FBTTtBQUM5RCxjQUFNLElBQUksSUFBSUE7QUFBQSxNQUNoQjtBQUFBLElBQ0Y7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsTUFBTSxpQkFBaUIsTUFBYTtBQUNsQyxRQUFJLEtBQUssY0FBYztBQUFNO0FBQzdCLFFBQUksQ0FBQyxLQUFLO0FBQVk7QUFHdEIsU0FBSyxxQkFBcUIsdUJBQXVCLElBQUk7QUFBQSxFQUN2RDtBQUFBLEVBRVEsWUFBWSxTQUF5QjtBQUUzQyxRQUFJLE9BQU87QUFDWCxhQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsUUFBUSxLQUFLO0FBQ3ZDLFlBQU0sT0FBTyxRQUFRLFdBQVcsQ0FBQztBQUNqQyxjQUFTLFFBQVEsS0FBSyxPQUFRO0FBQzlCLGFBQU8sT0FBTztBQUFBLElBQ2hCO0FBQ0EsV0FBTyxLQUFLLFNBQVM7QUFBQSxFQUN2QjtBQUFBLEVBRUEsTUFBTSxrQkFBa0I7QUFDdEIsUUFBSSxDQUFDLEtBQUssWUFBWTtBQUNwQixVQUFJLHdCQUFPLGtDQUFrQztBQUM3QztBQUFBLElBQ0Y7QUFFQSxVQUFNLFFBQVEsS0FBSyxJQUFJLE1BQU0saUJBQWlCLEVBQzNDLE9BQU8sT0FBSyxFQUFFLEtBQUssUUFBUSxLQUFLLG9CQUFvQixXQUFXLGFBQWEsa0JBQWtCLGFBQWE7QUFFOUcsUUFBSSxZQUFZO0FBQ2hCLGVBQVcsUUFBUSxPQUFPO0FBQ3hCLFVBQUk7QUFDRixjQUFNLFVBQVUsTUFBTSxLQUFLLElBQUksTUFBTSxLQUFLLElBQUk7QUFDOUMsY0FBTSxLQUFLLGdCQUFnQixNQUFNLE9BQU87QUFDeEM7QUFFQSxZQUFJLFlBQVksT0FBTyxHQUFHO0FBQ3hCLGNBQUksd0JBQU8sYUFBYSxTQUFTLElBQUksTUFBTSxNQUFNLFdBQVc7QUFBQSxRQUM5RDtBQUFBLE1BQ0YsU0FBUyxHQUFHO0FBQ1YsZ0JBQVEsTUFBTSxxQkFBcUIsS0FBSyxJQUFJLEtBQUssQ0FBQztBQUFBLE1BQ3BEO0FBQUEsSUFDRjtBQUVBLFFBQUksd0JBQU8sZUFBZSxTQUFTLHNCQUFzQjtBQUFBLEVBQzNEO0FBQUEsRUFFQSxNQUFNLGdCQUFnQixNQUFhLFNBQWlCO0FBQ2xELFFBQUksQ0FBQyxLQUFLO0FBQVk7QUFFdEIsVUFBTSxTQUFTLEtBQUssVUFBVSxTQUFTLEtBQUssb0JBQW9CLFdBQVcsVUFBVTtBQUVyRixlQUFXLFNBQVMsUUFBUTtBQUMxQixVQUFJO0FBQ0YsY0FBTSxZQUFZLE1BQU0sS0FBSyxXQUFXLFdBQVcsS0FBSztBQUN4RCxjQUFNLFNBQVMsTUFBTSxLQUFLLFlBQVksUUFBUTtBQUFBLFVBQzVDLE1BQU07QUFBQSxVQUNOLFNBQVM7QUFBQSxVQUNULFNBQVMsQ0FBQztBQUFBLFlBQ1IsTUFBTTtBQUFBLFlBQ04sSUFBSSxLQUFLO0FBQUEsWUFDVCxhQUFhLEtBQUs7QUFBQSxVQUNwQixDQUFDO0FBQUEsUUFDSCxHQUFHLFNBQVM7QUFHWixjQUFNLEtBQUssY0FBYyxlQUFlLFFBQVEsV0FBVyxLQUFLO0FBQUEsTUFFbEUsU0FBUyxHQUFHO0FBQ1YsZ0JBQVEsTUFBTSxnQ0FBZ0MsS0FBSyxJQUFJLEtBQUssQ0FBQztBQUFBLE1BQy9EO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQSxFQUVRLFVBQVUsTUFBYyxNQUF3QjtBQUN0RCxVQUFNLFNBQW1CLENBQUM7QUFDMUIsYUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsS0FBSyxNQUFNO0FBQzFDLGFBQU8sS0FBSyxLQUFLLFVBQVUsR0FBRyxJQUFJLElBQUksQ0FBQztBQUFBLElBQ3pDO0FBQ0EsV0FBTztBQUFBLEVBQ1Q7QUFBQSxFQUVBLE1BQU0sbUJBQW1CLFVBQWtCO0FBQ3pDLFFBQUksQ0FBQyxLQUFLLFlBQVk7QUFDcEIsVUFBSSx3QkFBTyxrQ0FBa0M7QUFDN0M7QUFBQSxJQUNGO0FBRUEsUUFBSTtBQUNGLFlBQU0sWUFBWSxNQUFNLEtBQUssV0FBVyxXQUFXLFFBQVE7QUFDM0QsWUFBTSxTQUFTLE1BQU0sS0FBSyxZQUFZLFFBQVE7QUFBQSxRQUM1QyxNQUFNO0FBQUEsUUFDTixTQUFTO0FBQUEsUUFDVCxTQUFTLENBQUM7QUFBQSxVQUNSLE1BQU07QUFBQSxVQUNOLElBQUk7QUFBQSxVQUNKLGFBQWE7QUFBQSxRQUNmLENBQUM7QUFBQSxNQUNILEdBQUcsU0FBUztBQUVaLFVBQUksd0JBQU8sa0NBQWtDLE1BQU0sR0FBRztBQUFBLElBQ3hELFNBQVMsR0FBRztBQUNWLFVBQUksd0JBQU8sNEJBQTZCLEVBQVksT0FBTztBQUFBLElBQzdEO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxhQUFhO0FBQ2pCLFFBQUksQ0FBQyxLQUFLLFlBQVk7QUFDcEIsVUFBSSx3QkFBTyxrQ0FBa0M7QUFDN0M7QUFBQSxJQUNGO0FBRUEsVUFBTSxRQUFRLE1BQU0sS0FBSyxZQUFZLEtBQUs7QUFDMUMsUUFBSSxNQUFNLE1BQU0sV0FBVyxHQUFHO0FBQzVCLFVBQUksd0JBQU8sNkJBQTZCO0FBQ3hDO0FBQUEsSUFDRjtBQUVBLFVBQU0sYUFBYSxNQUFNLE1BQU0sS0FBSyxNQUFNLEtBQUssT0FBTyxJQUFJLE1BQU0sTUFBTSxNQUFNLENBQUM7QUFDN0UsVUFBTSxpQkFBaUIsTUFBTSxLQUFLLFdBQVc7QUFBQSxNQUMzQyxXQUFXLFFBQVEsVUFBVSxHQUFHLEVBQUU7QUFBQSxJQUNwQztBQUNBLFVBQU0sVUFBVSxNQUFNLEtBQUssY0FBYyxjQUFjLGdCQUFnQixDQUFDO0FBQ3hFLFVBQU0sUUFBUSxRQUFRLENBQUMsR0FBRyxTQUFTO0FBQ25DLFVBQU0sT0FBTyxRQUFRO0FBRXJCLFlBQVEsSUFBSTtBQUFBLE1BQ1YsYUFBYSxXQUFXO0FBQUEsTUFDeEI7QUFBQSxNQUNBO0FBQUEsSUFDRixDQUFDO0FBRUQsUUFBSSx3QkFBTyxnQkFBZ0IsT0FBTyxTQUFTLE1BQU0sWUFBWSxNQUFNLFFBQVEsQ0FBQyxDQUFDLEdBQUc7QUFBQSxFQUNsRjtBQUFBLEVBRUEsTUFBTSxXQUFXLE1BQTJCLFVBQVUsT0FBTztBQUMzRCxRQUFJLFdBQVcsS0FBSyxTQUFTLHVCQUF1QjtBQUNsRCxhQUFPLE1BQU0sS0FBSyxvQkFBb0IsSUFBSTtBQUFBLElBQzVDO0FBRUEsVUFBTSxPQUFPLFNBQVMsVUFDcEIsTUFBTSxLQUFLLFlBQVksS0FBSyxJQUM1QixNQUFNLEtBQUssY0FBYyxjQUFjO0FBRXpDLFVBQU0sT0FBTyxJQUFJLEtBQUssQ0FBQyxLQUFLLFVBQVUsTUFBTSxNQUFNLENBQUMsQ0FBQyxHQUFHO0FBQUEsTUFDckQsTUFBTTtBQUFBLElBQ1IsQ0FBQztBQUNELFVBQU0sTUFBTSxJQUFJLGdCQUFnQixJQUFJO0FBRXBDLFVBQU0sSUFBSSxTQUFTLGNBQWMsR0FBRztBQUNwQyxNQUFFLE9BQU87QUFDVCxNQUFFLFdBQVcsR0FBRyxJQUFJLFlBQVcsb0JBQUksS0FBSyxHQUFFLFlBQVksRUFBRSxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ3BFLGFBQVMsS0FBSyxZQUFZLENBQUM7QUFDM0IsTUFBRSxNQUFNO0FBQ1IsYUFBUyxLQUFLLFlBQVksQ0FBQztBQUMzQixRQUFJLGdCQUFnQixHQUFHO0FBQUEsRUFDekI7QUFBQSxFQUVBLE1BQU0sb0JBQW9CLE1BQTZDO0FBQ3JFLFFBQUksQ0FBQyxLQUFLLFNBQVMseUJBQXlCLENBQUMsS0FBSyxTQUFTLHFCQUFxQjtBQUM5RSxVQUFJLHdCQUFPLGtDQUFrQztBQUM3QyxhQUFPO0FBQUEsSUFDVDtBQUVBLFFBQUk7QUFDRixZQUFNLE9BQU8sU0FBUyxVQUNwQixNQUFNLEtBQUssWUFBWSxLQUFLLElBQzVCLE1BQU0sS0FBSyxjQUFjLGNBQWM7QUFFekMsWUFBTSxXQUFXLE1BQU0sTUFBTSxLQUFLLFNBQVMscUJBQXFCO0FBQUEsUUFDOUQsUUFBUTtBQUFBLFFBQ1IsU0FBUztBQUFBLFVBQ1AsaUJBQWlCLFVBQVUsS0FBSyxTQUFTLGlCQUFpQjtBQUFBLFVBQzFELGdCQUFnQjtBQUFBLFFBQ2xCO0FBQUEsUUFDQSxNQUFNLEtBQUssVUFBVTtBQUFBLFVBQ25CO0FBQUEsVUFDQTtBQUFBLFVBQ0EsWUFBVyxvQkFBSSxLQUFLLEdBQUUsWUFBWTtBQUFBLFVBQ2xDLFdBQVcsS0FBSyxJQUFJLE1BQU0sUUFBUTtBQUFBLFFBQ3BDLENBQUM7QUFBQSxNQUNILENBQUM7QUFFRCxVQUFJLENBQUMsU0FBUztBQUFJLGNBQU0sSUFBSSxNQUFNLE1BQU0sU0FBUyxLQUFLLENBQUM7QUFFdkQsVUFBSSx3QkFBTyx5QkFBeUIsSUFBSSxnQkFBZ0I7QUFDeEQsYUFBTztBQUFBLElBQ1QsU0FBUyxHQUFHO0FBQ1YsVUFBSSx3QkFBTyx3QkFBeUIsRUFBWSxPQUFPLEVBQUU7QUFDekQsY0FBUSxNQUFNLHVCQUF1QixDQUFDO0FBQ3RDLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxXQUFXLE1BQTJCO0FBQzFDLFVBQU0sUUFBUSxTQUFTLGNBQWMsT0FBTztBQUM1QyxVQUFNLE9BQU87QUFDYixVQUFNLFNBQVM7QUFFZixVQUFNLFdBQVcsT0FBTyxNQUFNO0FBQzVCLFlBQU0sT0FBUSxFQUFFLE9BQTRCLFFBQVEsQ0FBQztBQUNyRCxVQUFJLE1BQU07QUFDUixZQUFJO0FBQ0YsZ0JBQU0sVUFBVSxNQUFNLEtBQUssS0FBSztBQUNoQyxnQkFBTSxPQUFPLEtBQUssTUFBTSxPQUFPO0FBRS9CLGNBQUksU0FBUyxTQUFTO0FBQ3BCLGtCQUFNLEtBQUssWUFBWSxLQUFLLElBQUk7QUFBQSxVQUNsQyxPQUFPO0FBQ0wsa0JBQU0sS0FBSyxjQUFjLGNBQWMsSUFBSTtBQUFBLFVBQzdDO0FBRUEsY0FBSSx3QkFBTyxZQUFZLElBQUksZ0JBQWdCO0FBQUEsUUFDN0MsU0FBU0UsSUFBRztBQUNWLGNBQUksd0JBQU8sa0JBQW1CQSxHQUFZLE9BQU8sRUFBRTtBQUFBLFFBQ3JEO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxVQUFNLE1BQU07QUFBQSxFQUNkO0FBQUEsRUFFQSxNQUFNLHVCQUF1QjtBQUMzQixVQUFNLFFBQVEsTUFBTSxLQUFLLFlBQVksS0FBSztBQUUxQyxVQUFNLFlBQVk7QUFBQSxNQUNoQixPQUFPLE1BQU0sTUFBTSxJQUFJLFFBQU07QUFBQSxRQUMzQixJQUFJLEVBQUU7QUFBQSxRQUNOLE9BQU8sRUFBRSxXQUFXLEVBQUUsUUFBUSxNQUFNLEdBQUcsRUFBRTtBQUFBLFFBQ3pDLE1BQU0sRUFBRTtBQUFBLFFBQ1IsR0FBRyxLQUFLLE9BQU8sSUFBSTtBQUFBLFFBQ25CLEdBQUcsS0FBSyxPQUFPLElBQUk7QUFBQSxNQUNyQixFQUFFO0FBQUEsTUFDRixPQUFPLE1BQU0sTUFBTSxJQUFJLFFBQU07QUFBQSxRQUMzQixNQUFNLEVBQUU7QUFBQSxRQUNSLElBQUksRUFBRTtBQUFBLFFBQ04sT0FBTyxFQUFFO0FBQUEsUUFDVCxRQUFRLEVBQUU7QUFBQSxNQUNaLEVBQUU7QUFBQSxJQUNKO0FBRUEsVUFBTSxXQUFXLGtCQUFjLFlBQUFELElBQU8sQ0FBQztBQUN2QyxVQUFNLEtBQUssSUFBSSxNQUFNLE9BQU8sVUFBVSxLQUFLLFVBQVUsV0FBVyxNQUFNLENBQUMsQ0FBQztBQUV4RSxVQUFNLE9BQU8sS0FBSyxJQUFJLFVBQVUsUUFBUSxLQUFLO0FBQzdDLFVBQU0sT0FBTyxLQUFLLElBQUksTUFBTSxzQkFBc0IsUUFBUTtBQUMxRCxRQUFJLGdCQUFnQix3QkFBTztBQUN6QixZQUFNLEtBQUssU0FBUyxNQUFNLEVBQUUsUUFBUSxLQUFLLENBQUM7QUFBQSxJQUM1QztBQUVBLFFBQUksd0JBQU8sOEJBQThCO0FBQUEsRUFDM0M7QUFBQSxFQUVBLE1BQU0sdUJBQXVCLE1BQWE7QUFDeEMsVUFBTSxVQUFVLE1BQU0sS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQzlDLFFBQUksV0FBVyxLQUFLO0FBQ3BCLFFBQUlELFVBQVM7QUFHYixRQUFJLFFBQVEsV0FBVyxLQUFLLEdBQUc7QUFDN0IsWUFBTSxpQkFBaUIsUUFBUSxRQUFRLE9BQU8sQ0FBQztBQUMvQyxVQUFJLG1CQUFtQixJQUFJO0FBQ3pCLGNBQU0sY0FBYyxRQUFRLFVBQVUsR0FBRyxjQUFjO0FBQ3ZELFlBQUk7QUFDRixnQkFBTSxPQUFPLFlBQVksTUFBTSxJQUFJLEVBQUUsT0FBTyxDQUFDLEtBQUssU0FBUztBQUN6RCxrQkFBTSxDQUFDLEtBQUssR0FBRyxVQUFVLElBQUksS0FBSyxNQUFNLEdBQUc7QUFDM0MsZ0JBQUksT0FBTyxXQUFXLFFBQVE7QUFDNUIsa0JBQUksSUFBSSxLQUFLLENBQUMsSUFBSSxXQUFXLEtBQUssR0FBRyxFQUFFLEtBQUs7QUFBQSxZQUM5QztBQUNBLG1CQUFPO0FBQUEsVUFDVCxHQUFHLENBQUMsQ0FBMkI7QUFFL0IsY0FBSSxLQUFLO0FBQVUsdUJBQVcsS0FBSztBQUFBLFFBQ3JDLFNBQVMsR0FBRztBQUNWLGtCQUFRLE1BQU0sZ0NBQWdDLENBQUM7QUFBQSxRQUNqRDtBQUNBLFFBQUFBLFVBQVMsUUFBUSxVQUFVLGlCQUFpQixDQUFDLEVBQUUsS0FBSztBQUFBLE1BQ3REO0FBQUEsSUFDRjtBQUVBLFVBQU0sS0FBSyxJQUFJLE1BQU0sT0FBTyxZQUFZLFFBQVEsT0FBT0EsT0FBTTtBQUM3RCxRQUFJLHdCQUFPLGtCQUFrQixRQUFRLEVBQUU7QUFBQSxFQUN6QztBQUFBLEVBRUEsTUFBYyxtQkFBbUIsT0FBZTtBQUM5QyxRQUFJO0FBQ0YsWUFBTSxVQUFVLE1BQU0sS0FBSyxpQkFBaUIsWUFBWSxPQUFPO0FBQUEsUUFDN0QsZ0JBQWdCO0FBQUEsUUFDaEIsWUFBWTtBQUFBLFFBQ1osWUFBWTtBQUFBLE1BQ2QsQ0FBQztBQUVELFVBQUksUUFBUSxTQUFTLEdBQUc7QUFFdEIsY0FBTSxpQkFBaUIsNEJBQTRCLEtBQUs7QUFBQTtBQUFBLElBQ3RELFFBQVE7QUFBQSxVQUFJLENBQUMsUUFBUUcsV0FDbkIsYUFBYUEsU0FBUSxDQUFDLEtBQUssT0FBTyxJQUFJLGFBQWEsT0FBTyxTQUFTLEdBQUcsUUFBUSxDQUFDLENBQUM7QUFBQSxFQUM3RSxPQUFPLFFBQVEsT0FBTyxXQUFXLE9BQU8sT0FBTztBQUFBO0FBQUEsS0FDakQsT0FBTyxTQUFTLFNBQVMsU0FDeEIsZ0JBQWdCLE9BQU8sUUFBUSxRQUFRLElBQUksQ0FBQyxNQUFXLEVBQUUsT0FBTyxFQUFFLEtBQUssSUFBSSxDQUFDO0FBQUE7QUFBQSxJQUFTO0FBQUEsUUFDekYsRUFBRSxLQUFLLFNBQVM7QUFFbEIsY0FBTSxXQUFXLGtCQUFrQixNQUFNLFFBQVEsWUFBWSxFQUFFLENBQUMsT0FBTSxvQkFBSSxLQUFLLEdBQUUsWUFBWSxFQUFFLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDM0csY0FBTSxLQUFLLElBQUksTUFBTSxPQUFPLFVBQVUsY0FBYztBQUdwRCxjQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU0sc0JBQXNCLFFBQVE7QUFDMUQsWUFBSSxnQkFBZ0Isd0JBQU87QUFDekIsZ0JBQU0sT0FBTyxLQUFLLElBQUksVUFBVSxRQUFRLEtBQUs7QUFDN0MsZ0JBQU0sS0FBSyxTQUFTLE1BQU0sRUFBRSxRQUFRLEtBQUssQ0FBQztBQUFBLFFBQzVDO0FBRUEsWUFBSSx3QkFBTyxTQUFTLFFBQVEsTUFBTSxpQkFBaUIsS0FBSyxHQUFHO0FBQUEsTUFDN0QsT0FBTztBQUNMLFlBQUksd0JBQU8seUJBQXlCLEtBQUssR0FBRztBQUFBLE1BQzlDO0FBQUEsSUFDRixTQUFTLEdBQUc7QUFDVixVQUFJLHdCQUFPLGtCQUFtQixFQUFZLE9BQU8sRUFBRTtBQUFBLElBQ3JEO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBYyxlQUFlO0FBQzNCLFVBQU0sRUFBRSxVQUFVLElBQUksS0FBSztBQUUzQixRQUFJLE9BQU8sVUFBVSxnQkFBZ0IsU0FBUyxTQUFTLEVBQUUsQ0FBQztBQUMxRCxRQUFJLENBQUMsTUFBTTtBQUNULFlBQU0sWUFBWSxVQUFVLGFBQWEsS0FBSztBQUM5QyxVQUFJLFdBQVc7QUFDYixlQUFPO0FBQ1AsY0FBTSxLQUFLLGFBQWE7QUFBQSxVQUN0QixNQUFNLFNBQVM7QUFBQSxVQUNmLFFBQVE7QUFBQSxRQUNWLENBQUM7QUFBQSxNQUNIO0FBQUEsSUFDRjtBQUVBLFFBQUksTUFBTTtBQUNSLGdCQUFVLFdBQVcsSUFBSTtBQUFBLElBQzNCO0FBQUEsRUFDRjtBQUFBO0FBQUEsRUFHQSxNQUFNLHlCQUF5QjtBQUU3QixRQUFJLEtBQUssU0FBUyxjQUFjO0FBQzlCLFlBQU0sS0FBSyxTQUFTLFdBQVc7QUFBQSxRQUM3QixRQUFRLEtBQUssU0FBUztBQUFBLFFBQ3RCLE9BQU8sS0FBSyxTQUFTO0FBQUEsTUFDdkIsQ0FBQztBQUFBLElBQ0g7QUFHQSxRQUFJLEtBQUssU0FBUyxnQkFBZ0IsU0FBUyxHQUFHO0FBQzVDLFlBQU0sS0FBSyxTQUFTLFdBQVcsS0FBSyxTQUFTLGVBQWU7QUFBQSxJQUM5RDtBQUdBLFFBQUksS0FBSyxTQUFTLFlBQVksVUFBVTtBQUN0QyxZQUFNLEtBQUssYUFBYSxVQUFVLEtBQUssU0FBUyxXQUFXO0FBQUEsSUFDN0Q7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLGdCQUFnQjtBQUNwQixVQUFNLEVBQUUsVUFBVSxJQUFJLEtBQUs7QUFFM0IsUUFBSSxPQUE2QjtBQUNqQyxVQUFNLFNBQVMsVUFBVSxnQkFBZ0IsY0FBYyxTQUFTO0FBRWhFLFFBQUksT0FBTyxTQUFTLEdBQUc7QUFDckIsYUFBTyxPQUFPLENBQUM7QUFBQSxJQUNqQixPQUFPO0FBQ0wsYUFBTyxVQUFVLGFBQWEsS0FBSztBQUNuQyxZQUFNLE1BQU0sYUFBYSxFQUFFLE1BQU0sY0FBYyxXQUFXLFFBQVEsS0FBSyxDQUFDO0FBQUEsSUFDMUU7QUFFQSxRQUFJLE1BQU07QUFDUixnQkFBVSxXQUFXLElBQUk7QUFBQSxJQUMzQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQU0scUJBQXFCO0FBQ3pCLFVBQU0sUUFBUSxPQUFPLHFCQUFxQjtBQUMxQyxRQUFJLENBQUM7QUFBTztBQUVaLFFBQUk7QUFDRixZQUFNLFVBQVUsTUFBTSxLQUFLLGVBQWUsT0FBTztBQUFBLFFBQy9DO0FBQUEsUUFDQSxZQUFZLEtBQUssU0FBUztBQUFBLFFBQzFCLFlBQVk7QUFBQSxRQUNaLFdBQVcsS0FBSyxTQUFTO0FBQUEsUUFDekIsaUJBQWlCLEtBQUssU0FBUztBQUFBLFFBQy9CLGdCQUFnQjtBQUFBLFFBQ2hCLFdBQVcsQ0FBQyxJQUFJO0FBQUEsUUFDaEIsUUFBUTtBQUFBLFFBQ1IsV0FBVztBQUFBLE1BQ2IsQ0FBQztBQUdELFVBQUksbUJBQW1CLEtBQUssS0FBSyxPQUFPLEVBQUUsS0FBSztBQUFBLElBQ2pELFNBQVMsT0FBTztBQUNkLFVBQUksd0JBQU8sa0JBQW1CLE1BQWdCLE9BQU8sRUFBRTtBQUFBLElBQ3pEO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSwyQkFBMkI7QUFDL0IsVUFBTSxPQUFPLEtBQUssSUFBSSxVQUFVLGNBQWM7QUFDOUMsUUFBSSxDQUFDLFFBQVEsS0FBSyxjQUFjLE1BQU07QUFDcEMsVUFBSSx3QkFBTyxtQ0FBbUM7QUFDOUM7QUFBQSxJQUNGO0FBRUEsVUFBTSxhQUFhLE9BQU8sMENBQTBDO0FBQ3BFLFFBQUksQ0FBQztBQUFZO0FBRWpCLFVBQU0sZ0JBQWdCLFdBQVcsTUFBTSxHQUFHLEVBQUUsSUFBSSxXQUFTLE1BQU0sS0FBSyxDQUFDO0FBQ3JFLFVBQU0sVUFBVSxPQUFPLDZCQUE2QixLQUFLO0FBRXpELFFBQUk7QUFDRixZQUFNLEtBQUssaUJBQWlCLGtCQUFrQixNQUFNLGVBQWUsT0FBTztBQUFBLElBQzVFLFNBQVMsT0FBTztBQUNkLFVBQUksd0JBQU8seUJBQTBCLE1BQWdCLE9BQU8sRUFBRTtBQUFBLElBQ2hFO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSx3QkFBd0I7QUFDNUIsVUFBTSxhQUFhLE9BQU8sMENBQTBDO0FBQ3BFLFFBQUksQ0FBQztBQUFZO0FBRWpCLFVBQU0sZ0JBQWdCLFdBQVcsTUFBTSxHQUFHLEVBQUUsSUFBSSxXQUFTLE1BQU0sS0FBSyxDQUFDO0FBRXJFLFFBQUk7QUFDRixZQUFNLEtBQUssaUJBQWlCLGtCQUFrQixlQUFlLE1BQU0sSUFBSTtBQUFBLElBQ3pFLFNBQVMsT0FBTztBQUNkLFVBQUksd0JBQU8saUNBQWtDLE1BQWdCLE9BQU8sRUFBRTtBQUFBLElBQ3hFO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxrQkFBa0I7QUFDdEIsUUFBSSxLQUFLLFNBQVMsUUFBUSxHQUFHO0FBQzNCLFlBQU0sVUFBVSxNQUFNLEtBQUssU0FBUyxpQkFBaUI7QUFDckQsWUFBTSxVQUFVLE9BQU8sUUFBUSxPQUFPLEVBQ25DLElBQUksQ0FBQyxDQUFDLFVBQVUsT0FBTyxNQUFNLEdBQUcsUUFBUSxLQUFLLFVBQVUsV0FBTSxRQUFHLEVBQUUsRUFDbEUsS0FBSyxJQUFJO0FBRVosVUFBSSx3QkFBTztBQUFBLEVBQThCLE9BQU8sSUFBSSxHQUFJO0FBQUEsSUFDMUQsT0FBTztBQUNMLFVBQUksd0JBQU8sNEJBQTRCO0FBQUEsSUFDekM7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLFdBQVc7QUFFZixRQUFJLEtBQUssc0JBQXNCO0FBQzdCLFdBQUsscUJBQXFCLFFBQVE7QUFBQSxJQUNwQztBQUNBLFFBQUksS0FBSyxxQkFBcUI7QUFDNUIsV0FBSyxvQkFBb0IsUUFBUTtBQUFBLElBQ25DO0FBQ0EsUUFBSSxLQUFLLGdCQUFnQjtBQUN2QixXQUFLLGVBQWUsUUFBUTtBQUFBLElBQzlCO0FBQ0EsUUFBSSxLQUFLLFVBQVU7QUFDakIsV0FBSyxTQUFTLFFBQVE7QUFBQSxJQUN4QjtBQUNBLFFBQUksS0FBSyxVQUFVO0FBQ2pCLFdBQUssU0FBUyxRQUFRO0FBQUEsSUFDeEI7QUFBQSxFQUNGO0FBQ0Y7QUFHQSxJQUFNLGtCQUFOLGNBQThCLGtDQUFpQjtBQUFBLEVBRzdDLFlBQVksS0FBVSxRQUFxQjtBQUN6QyxVQUFNLEtBQUssTUFBTTtBQUNqQixTQUFLLFNBQVM7QUFBQSxFQUNoQjtBQUFBLEVBRUEsVUFBZ0I7QUFDZCxVQUFNLEVBQUUsWUFBWSxJQUFJO0FBQ3hCLGdCQUFZLE1BQU07QUFFbEIsZ0JBQVksU0FBUyxNQUFNLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUc3RCxRQUFJLHlCQUFRLFdBQVcsRUFDcEIsUUFBUSwyQkFBMkIsRUFDbkMsUUFBUSw0Q0FBNEMsRUFDcEQsUUFBUSxVQUFRLEtBQ2QsU0FBUyxLQUFLLE9BQU8sU0FBUyx1QkFBdUIsRUFDckQsU0FBUyxPQUFPLFVBQVU7QUFDekIsV0FBSyxPQUFPLFNBQVMsMEJBQTBCO0FBQy9DLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFDL0IsWUFBTSxLQUFLLE9BQU8sd0JBQXdCO0FBQUEsSUFDNUMsQ0FBQyxDQUFDO0FBR04sUUFBSSx5QkFBUSxXQUFXLEVBQ3BCLFFBQVEsaUJBQWlCLEVBQ3pCLFFBQVEsc0RBQXNELEVBQzlELFFBQVEsVUFBUSxLQUNkLGVBQWUsNEJBQTRCLEVBQzNDLFNBQVMsS0FBSyxPQUFPLFNBQVMsYUFBYSxFQUMzQyxTQUFTLE9BQU8sVUFBVTtBQUN6QixXQUFLLE9BQU8sU0FBUyxnQkFBZ0I7QUFDckMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUMvQixVQUFJLE9BQU87QUFDVCxhQUFLLE9BQU8sYUFBYSxJQUFJLHFDQUFvQixFQUFFLFFBQVEsTUFBTSxDQUFDO0FBQUEsTUFDcEU7QUFBQSxJQUNGLENBQUMsQ0FBQztBQUdOLGdCQUFZLFNBQVMsTUFBTSxFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFFN0QsUUFBSSx5QkFBUSxXQUFXLEVBQ3BCLFFBQVEsWUFBWSxFQUNwQixRQUFRLHdEQUF3RCxFQUNoRSxRQUFRLFVBQVEsS0FDZCxTQUFTLEtBQUssT0FBTyxTQUFTLFNBQVMsRUFDdkMsU0FBUyxPQUFPLFVBQVU7QUFDekIsV0FBSyxPQUFPLFNBQVMsWUFBWTtBQUNqQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQy9CLFdBQUssT0FBTyxXQUFXO0FBQUEsSUFDekIsQ0FBQyxDQUFDO0FBRU4sUUFBSSx5QkFBUSxXQUFXLEVBQ3BCLFFBQVEsd0JBQXdCLEVBQ2hDLFFBQVEsa0RBQWtELEVBQzFELFFBQVEsVUFBUSxLQUNkLGVBQWUsZ0NBQWdDLEVBQy9DLFNBQVMsS0FBSyxPQUFPLFNBQVMsWUFBWSxFQUMxQyxTQUFTLE9BQU8sVUFBVTtBQUN6QixXQUFLLE9BQU8sU0FBUyxlQUFlO0FBQ3BDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFDL0IsV0FBSyxPQUFPLFdBQVc7QUFBQSxJQUN6QixDQUFDLENBQUM7QUFHTixnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRTdELFFBQUkseUJBQVEsV0FBVyxFQUNwQixRQUFRLHVCQUF1QixFQUMvQixRQUFRLFVBQVEsS0FDZCxTQUFTLEtBQUssT0FBTyxTQUFTLG1CQUFtQixFQUNqRCxTQUFTLE9BQU8sVUFBVTtBQUN6QixXQUFLLE9BQU8sU0FBUyxzQkFBc0I7QUFDM0MsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ2pDLENBQUMsQ0FBQztBQUVOLFFBQUkseUJBQVEsV0FBVyxFQUNwQixRQUFRLHNCQUFzQixFQUM5QixRQUFRLFVBQVEsS0FDZCxTQUFTLEtBQUssT0FBTyxTQUFTLGtCQUFrQixFQUNoRCxTQUFTLE9BQU8sVUFBVTtBQUN6QixXQUFLLE9BQU8sU0FBUyxxQkFBcUI7QUFDMUMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ2pDLENBQUMsQ0FBQztBQUVOLFFBQUkseUJBQVEsV0FBVyxFQUNwQixRQUFRLGtDQUFrQyxFQUMxQyxRQUFRLCtDQUErQyxFQUN2RCxVQUFVLFlBQVUsT0FDbEIsU0FBUyxLQUFLLE9BQU8sU0FBUyxtQkFBbUIsRUFDakQsU0FBUyxPQUFPLFVBQVU7QUFDekIsV0FBSyxPQUFPLFNBQVMsc0JBQXNCO0FBQzNDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNqQyxDQUFDLENBQUM7QUFHTixnQkFBWSxTQUFTLE1BQU0sRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXhELFFBQUkseUJBQVEsV0FBVyxFQUNwQixRQUFRLDBCQUEwQixFQUNsQyxRQUFRLHdDQUF3QyxFQUNoRCxVQUFVLFlBQVUsT0FDbEIsU0FBUyxLQUFLLE9BQU8sU0FBUyxxQkFBcUIsRUFDbkQsU0FBUyxPQUFPLFVBQVU7QUFDekIsV0FBSyxPQUFPLFNBQVMsd0JBQXdCO0FBQzdDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNqQyxDQUFDLENBQUM7QUFFTixRQUFJLHlCQUFRLFdBQVcsRUFDcEIsUUFBUSx1QkFBdUIsRUFDL0IsUUFBUSxpQ0FBaUMsRUFDekMsUUFBUSxVQUFRLEtBQ2QsZUFBZSwyQkFBMkIsRUFDMUMsU0FBUyxLQUFLLE9BQU8sU0FBUyxtQkFBbUIsRUFDakQsU0FBUyxPQUFPLFVBQVU7QUFDekIsV0FBSyxPQUFPLFNBQVMsc0JBQXNCO0FBQzNDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNqQyxDQUFDLENBQUM7QUFFTixRQUFJLHlCQUFRLFdBQVcsRUFDcEIsUUFBUSxzQkFBc0IsRUFDOUIsUUFBUSxVQUFRLEtBQ2QsZUFBZSxTQUFTLEVBQ3hCLFNBQVMsS0FBSyxPQUFPLFNBQVMsaUJBQWlCLEVBQy9DLFNBQVMsT0FBTyxVQUFVO0FBQ3pCLFdBQUssT0FBTyxTQUFTLG9CQUFvQjtBQUN6QyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDakMsQ0FBQyxDQUFDO0FBR04sUUFBSSx5QkFBUSxXQUFXLEVBQ3BCLFFBQVEsY0FBYyxFQUN0QixRQUFRLG9DQUFvQyxFQUM1QyxZQUFZLGNBQVksU0FDdEIsVUFBVSxhQUFhLFdBQVcsRUFDbEMsVUFBVSxXQUFXLFNBQVMsRUFDOUIsVUFBVSxjQUFjLFlBQVksRUFDcEMsU0FBUyxLQUFLLE9BQU8sU0FBUyxXQUFXLEVBQ3pDLFNBQVMsT0FBTyxVQUFlO0FBQzlCLFdBQUssT0FBTyxTQUFTLGNBQWM7QUFDbkMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ2pDLENBQUMsQ0FBQztBQUFBLEVBQ1I7QUFDRjsiLAogICJuYW1lcyI6IFsiaW1wb3J0X29ic2lkaWFuIiwgIm9wdGlvbnMiLCAiaW1wb3J0X29ic2lkaWFuIiwgIm9wdGlvbnMiLCAiaW1wb3J0X29ic2lkaWFuIiwgInV0aWwiLCAib2JqZWN0VXRpbCIsICJtYXAiLCAibWFwIiwgImVycm9yVXRpbCIsICJlcnJvck1hcCIsICJ2ZXJzaW9uIiwgImN0eCIsICJvcHRpb25zIiwgInJlc3VsdCIsICJpbmRleCIsICJpc3N1ZXMiLCAiZWxlbWVudHMiLCAicHJvY2Vzc2VkIiwgInJlc3VsdCIsICJyIiwgIlpvZEZpcnN0UGFydHlUeXBlS2luZCIsICJvcHRpb25zIiwgInJlc29sdmUiLCAiaW1wb3J0X29ic2lkaWFuIiwgImxleGVyIiwgIm9wdGlvbnMiLCAidGV4dCIsICJibG9jayIsICJwYXJzZXIiLCAiY2FsbGJhY2siLCAiYXJncyIsICJyZXQiLCAid2Fsa1Rva2VucyIsICJzcmMiLCAiY29sb3IiLCAibm9vcCIsICJ1aWQiLCAiaWQiLCAiaXNOdWxsT3JVbmRlZiIsICJ2YWx1ZSIsICJ1bmRlZmluZWQiLCAiaXNBcnJheSIsICJBcnJheSIsICJ0eXBlIiwgIk9iamVjdCIsICJwcm90b3R5cGUiLCAidG9TdHJpbmciLCAiY2FsbCIsICJzbGljZSIsICJpc09iamVjdCIsICJpc051bWJlckZpbml0ZSIsICJOdW1iZXIiLCAiaXNGaW5pdGUiLCAiZmluaXRlT3JEZWZhdWx0IiwgImRlZmF1bHRWYWx1ZSIsICJ2YWx1ZU9yRGVmYXVsdCIsICJ0b1BlcmNlbnRhZ2UiLCAiZGltZW5zaW9uIiwgImVuZHNXaXRoIiwgInBhcnNlRmxvYXQiLCAidG9EaW1lbnNpb24iLCAiY2FsbGJhY2siLCAiZm4iLCAiYXJncyIsICJ0aGlzQXJnIiwgImFwcGx5IiwgImVhY2giLCAibG9vcGFibGUiLCAicmV2ZXJzZSIsICJpIiwgImxlbiIsICJrZXlzIiwgImxlbmd0aCIsICJfZWxlbWVudHNFcXVhbCIsICJhMCIsICJhMSIsICJpbGVuIiwgInYwIiwgInYxIiwgImRhdGFzZXRJbmRleCIsICJpbmRleCIsICJjbG9uZSIsICJzb3VyY2UiLCAibWFwIiwgInRhcmdldCIsICJjcmVhdGUiLCAia2xlbiIsICJrIiwgImlzVmFsaWRLZXkiLCAia2V5IiwgImluZGV4T2YiLCAiX21lcmdlciIsICJvcHRpb25zIiwgInR2YWwiLCAic3ZhbCIsICJtZXJnZSIsICJzb3VyY2VzIiwgIm1lcmdlciIsICJjdXJyZW50IiwgIm1lcmdlSWYiLCAiX21lcmdlcklmIiwgImhhc093blByb3BlcnR5IiwgImtleVJlc29sdmVycyIsICJ2IiwgIngiLCAibyIsICJ5IiwgIl9zcGxpdEtleSIsICJrZXkiLCAicGFydHMiLCAic3BsaXQiLCAia2V5cyIsICJ0bXAiLCAicGFydCIsICJlbmRzV2l0aCIsICJzbGljZSIsICJwdXNoIiwgIl9nZXRLZXlSZXNvbHZlciIsICJvYmoiLCAiayIsICJyZXNvbHZlT2JqZWN0S2V5IiwgInJlc29sdmVyIiwgIl9jYXBpdGFsaXplIiwgInN0ciIsICJjaGFyQXQiLCAidG9VcHBlckNhc2UiLCAiZGVmaW5lZCIsICJ2YWx1ZSIsICJpc0Z1bmN0aW9uIiwgInNldHNFcXVhbCIsICJhIiwgImIiLCAic2l6ZSIsICJpdGVtIiwgImhhcyIsICJfaXNDbGlja0V2ZW50IiwgImUiLCAidHlwZSIsICJQSSIsICJNYXRoIiwgIlRBVSIsICJQSVRBVSIsICJJTkZJTklUWSIsICJOdW1iZXIiLCAiUE9TSVRJVkVfSU5GSU5JVFkiLCAiUkFEX1BFUl9ERUciLCAiSEFMRl9QSSIsICJRVUFSVEVSX1BJIiwgIlRXT19USElSRFNfUEkiLCAibG9nMTAiLCAic2lnbiIsICJhbG1vc3RFcXVhbHMiLCAiZXBzaWxvbiIsICJhYnMiLCAibmljZU51bSIsICJyYW5nZSIsICJyb3VuZGVkUmFuZ2UiLCAicm91bmQiLCAibmljZVJhbmdlIiwgInBvdyIsICJmbG9vciIsICJmcmFjdGlvbiIsICJuaWNlRnJhY3Rpb24iLCAiX2ZhY3Rvcml6ZSIsICJyZXN1bHQiLCAic3FydCIsICJpIiwgInNvcnQiLCAicG9wIiwgImlzTm9uUHJpbWl0aXZlIiwgIm4iLCAiU3ltYm9sIiwgInRvUHJpbWl0aXZlIiwgImlzTnVtYmVyIiwgImlzTmFOIiwgInBhcnNlRmxvYXQiLCAiaXNGaW5pdGUiLCAiYWxtb3N0V2hvbGUiLCAicm91bmRlZCIsICJfc2V0TWluQW5kTWF4QnlLZXkiLCAiYXJyYXkiLCAidGFyZ2V0IiwgInByb3BlcnR5IiwgImlsZW4iLCAibGVuZ3RoIiwgIm1pbiIsICJtYXgiLCAidG9SYWRpYW5zIiwgImRlZ3JlZXMiLCAidG9EZWdyZWVzIiwgInJhZGlhbnMiLCAiX2RlY2ltYWxQbGFjZXMiLCAiaXNGaW5pdGVOdW1iZXIiLCAicCIsICJnZXRBbmdsZUZyb21Qb2ludCIsICJjZW50cmVQb2ludCIsICJhbmdsZVBvaW50IiwgImRpc3RhbmNlRnJvbVhDZW50ZXIiLCAiZGlzdGFuY2VGcm9tWUNlbnRlciIsICJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCAiYW5nbGUiLCAiYXRhbjIiLCAiZGlzdGFuY2UiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgInB0MSIsICJwdDIiLCAiX2FuZ2xlRGlmZiIsICJfbm9ybWFsaXplQW5nbGUiLCAiX2FuZ2xlQmV0d2VlbiIsICJzdGFydCIsICJlbmQiLCAic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwgInMiLCAiYW5nbGVUb1N0YXJ0IiwgImFuZ2xlVG9FbmQiLCAic3RhcnRUb0FuZ2xlIiwgImVuZFRvQW5nbGUiLCAiX2xpbWl0VmFsdWUiLCAiX2ludDE2UmFuZ2UiLCAiX2lzQmV0d2VlbiIsICJfbG9va3VwIiwgInRhYmxlIiwgImNtcCIsICJpbmRleCIsICJoaSIsICJsbyIsICJtaWQiLCAiX2xvb2t1cEJ5S2V5IiwgImxhc3QiLCAidGkiLCAiX3Jsb29rdXBCeUtleSIsICJfZmlsdGVyQmV0d2VlbiIsICJ2YWx1ZXMiLCAiYXJyYXlFdmVudHMiLCAibGlzdGVuQXJyYXlFdmVudHMiLCAibGlzdGVuZXIiLCAiX2NoYXJ0anMiLCAibGlzdGVuZXJzIiwgIk9iamVjdCIsICJkZWZpbmVQcm9wZXJ0eSIsICJjb25maWd1cmFibGUiLCAiZW51bWVyYWJsZSIsICJmb3JFYWNoIiwgIm1ldGhvZCIsICJiYXNlIiwgImFyZ3MiLCAicmVzIiwgImFwcGx5IiwgIm9iamVjdCIsICJ1bmxpc3RlbkFycmF5RXZlbnRzIiwgInN0dWIiLCAiaW5kZXhPZiIsICJzcGxpY2UiLCAiX2FycmF5VW5pcXVlIiwgIml0ZW1zIiwgInNldCIsICJTZXQiLCAiQXJyYXkiLCAiZnJvbSIsICJyZXF1ZXN0QW5pbUZyYW1lIiwgIndpbmRvdyIsICJjYWxsYmFjayIsICJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCAidGhyb3R0bGVkIiwgImZuIiwgInRoaXNBcmciLCAiYXJnc1RvVXNlIiwgInRpY2tpbmciLCAiYXJncyIsICJjYWxsIiwgImFwcGx5IiwgImRlYm91bmNlIiwgImRlbGF5IiwgInRpbWVvdXQiLCAiY2xlYXJUaW1lb3V0IiwgInNldFRpbWVvdXQiLCAiX3RvTGVmdFJpZ2h0Q2VudGVyIiwgImFsaWduIiwgIl9hbGlnblN0YXJ0RW5kIiwgInN0YXJ0IiwgImVuZCIsICJfdGV4dFgiLCAibGVmdCIsICJyaWdodCIsICJydGwiLCAiY2hlY2siLCAiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCAibWV0YSIsICJwb2ludHMiLCAiYW5pbWF0aW9uc0Rpc2FibGVkIiwgInBvaW50Q291bnQiLCAibGVuZ3RoIiwgImNvdW50IiwgIl9zb3J0ZWQiLCAiaVNjYWxlIiwgInZTY2FsZSIsICJfcGFyc2VkIiwgInNwYW5HYXBzIiwgImRhdGFzZXQiLCAib3B0aW9ucyIsICJheGlzIiwgIm1pbiIsICJtYXgiLCAibWluRGVmaW5lZCIsICJtYXhEZWZpbmVkIiwgImdldFVzZXJCb3VuZHMiLCAiTWF0aCIsICJfbG9va3VwQnlLZXkiLCAibG8iLCAiZ2V0UGl4ZWxGb3JWYWx1ZSIsICJkaXN0YW5jZVRvRGVmaW5lZExvIiwgInNsaWNlIiwgInJldmVyc2UiLCAiZmluZEluZGV4IiwgInBvaW50IiwgImlzTnVsbE9yVW5kZWYiLCAiX2xpbWl0VmFsdWUiLCAiaGkiLCAiZGlzdGFuY2VUb0RlZmluZWRIaSIsICJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwgInhTY2FsZSIsICJ5U2NhbGUiLCAiX3NjYWxlUmFuZ2VzIiwgIm5ld1JhbmdlcyIsICJ4bWluIiwgInhtYXgiLCAieW1pbiIsICJ5bWF4IiwgImNoYW5nZWQiLCAiT2JqZWN0IiwgImFzc2lnbiIsICJhdEVkZ2UiLCAidCIsICJlbGFzdGljSW4iLCAicyIsICJwIiwgInBvdyIsICJzaW4iLCAiVEFVIiwgImVsYXN0aWNPdXQiLCAiZWZmZWN0cyIsICJsaW5lYXIiLCAiZWFzZUluUXVhZCIsICJlYXNlT3V0UXVhZCIsICJlYXNlSW5PdXRRdWFkIiwgImVhc2VJbkN1YmljIiwgImVhc2VPdXRDdWJpYyIsICJlYXNlSW5PdXRDdWJpYyIsICJlYXNlSW5RdWFydCIsICJlYXNlT3V0UXVhcnQiLCAiZWFzZUluT3V0UXVhcnQiLCAiZWFzZUluUXVpbnQiLCAiZWFzZU91dFF1aW50IiwgImVhc2VJbk91dFF1aW50IiwgImVhc2VJblNpbmUiLCAiY29zIiwgIkhBTEZfUEkiLCAiZWFzZU91dFNpbmUiLCAiZWFzZUluT3V0U2luZSIsICJQSSIsICJlYXNlSW5FeHBvIiwgImVhc2VPdXRFeHBvIiwgImVhc2VJbk91dEV4cG8iLCAiZWFzZUluQ2lyYyIsICJzcXJ0IiwgImVhc2VPdXRDaXJjIiwgImVhc2VJbk91dENpcmMiLCAiZWFzZUluRWxhc3RpYyIsICJlYXNlT3V0RWxhc3RpYyIsICJlYXNlSW5PdXRFbGFzdGljIiwgImVhc2VJbkJhY2siLCAiZWFzZU91dEJhY2siLCAiZWFzZUluT3V0QmFjayIsICJlYXNlSW5Cb3VuY2UiLCAiZWFzZU91dEJvdW5jZSIsICJtIiwgImQiLCAiZWFzZUluT3V0Qm91bmNlIiwgImlzUGF0dGVybk9yR3JhZGllbnQiLCAidmFsdWUiLCAidHlwZSIsICJ0b1N0cmluZyIsICJjb2xvciIsICJDb2xvciIsICJnZXRIb3ZlckNvbG9yIiwgInNhdHVyYXRlIiwgImRhcmtlbiIsICJoZXhTdHJpbmciLCAibnVtYmVycyIsICJjb2xvcnMiLCAiYXBwbHlBbmltYXRpb25zRGVmYXVsdHMiLCAiZGVmYXVsdHMiLCAic2V0IiwgInVuZGVmaW5lZCIsICJkdXJhdGlvbiIsICJlYXNpbmciLCAiZnJvbSIsICJsb29wIiwgInRvIiwgImRlc2NyaWJlIiwgIl9mYWxsYmFjayIsICJfaW5kZXhhYmxlIiwgIl9zY3JpcHRhYmxlIiwgIm5hbWUiLCAicHJvcGVydGllcyIsICJhY3RpdmUiLCAiYW5pbWF0aW9uIiwgInJlc2l6ZSIsICJzaG93IiwgImFuaW1hdGlvbnMiLCAidmlzaWJsZSIsICJoaWRlIiwgInYiLCAiYXBwbHlMYXlvdXRzRGVmYXVsdHMiLCAiYXV0b1BhZGRpbmciLCAicGFkZGluZyIsICJ0b3AiLCAiYm90dG9tIiwgImludGxDYWNoZSIsICJNYXAiLCAiZ2V0TnVtYmVyRm9ybWF0IiwgImxvY2FsZSIsICJjYWNoZUtleSIsICJKU09OIiwgInN0cmluZ2lmeSIsICJmb3JtYXR0ZXIiLCAiZ2V0IiwgIkludGwiLCAiTnVtYmVyRm9ybWF0IiwgImZvcm1hdE51bWJlciIsICJudW0iLCAiZm9ybWF0IiwgImZvcm1hdHRlcnMiLCAidmFsdWVzIiwgImlzQXJyYXkiLCAibnVtZXJpYyIsICJ0aWNrVmFsdWUiLCAiaW5kZXgiLCAidGlja3MiLCAiY2hhcnQiLCAibm90YXRpb24iLCAiZGVsdGEiLCAibWF4VGljayIsICJhYnMiLCAiY2FsY3VsYXRlRGVsdGEiLCAibG9nRGVsdGEiLCAibG9nMTAiLCAibnVtRGVjaW1hbCIsICJpc05hTiIsICJmbG9vciIsICJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCAibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwgImxvZ2FyaXRobWljIiwgInJlbWFpbiIsICJzaWduaWZpY2FuZCIsICJpbmNsdWRlcyIsICJhcHBseVNjYWxlRGVmYXVsdHMiLCAiZGlzcGxheSIsICJvZmZzZXQiLCAiYmVnaW5BdFplcm8iLCAiYm91bmRzIiwgImNsaXAiLCAiZ3JhY2UiLCAiZ3JpZCIsICJsaW5lV2lkdGgiLCAiZHJhd09uQ2hhcnRBcmVhIiwgImRyYXdUaWNrcyIsICJ0aWNrTGVuZ3RoIiwgInRpY2tXaWR0aCIsICJfY3R4IiwgInRpY2tDb2xvciIsICJib3JkZXIiLCAiZGFzaCIsICJkYXNoT2Zmc2V0IiwgIndpZHRoIiwgInRpdGxlIiwgInRleHQiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAibWlycm9yIiwgInRleHRTdHJva2VXaWR0aCIsICJ0ZXh0U3Ryb2tlQ29sb3IiLCAiYXV0b1NraXAiLCAiYXV0b1NraXBQYWRkaW5nIiwgImxhYmVsT2Zmc2V0IiwgIlRpY2tzIiwgIm1pbm9yIiwgIm1ham9yIiwgImNyb3NzQWxpZ24iLCAic2hvd0xhYmVsQmFja2Ryb3AiLCAiYmFja2Ryb3BDb2xvciIsICJiYWNrZHJvcFBhZGRpbmciLCAicm91dGUiLCAic3RhcnRzV2l0aCIsICJvdmVycmlkZXMiLCAiY3JlYXRlIiwgImRlc2NyaXB0b3JzIiwgImdldFNjb3BlIiwgIm5vZGUiLCAia2V5IiwgImtleXMiLCAic3BsaXQiLCAiaSIsICJuIiwgImsiLCAicm9vdCIsICJzY29wZSIsICJtZXJnZSIsICJEZWZhdWx0cyIsICJjb25zdHJ1Y3RvciIsICJfZGVzY3JpcHRvcnMiLCAiX2FwcGxpZXJzIiwgImJhY2tncm91bmRDb2xvciIsICJib3JkZXJDb2xvciIsICJkYXRhc2V0cyIsICJkZXZpY2VQaXhlbFJhdGlvIiwgImNvbnRleHQiLCAicGxhdGZvcm0iLCAiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsICJlbGVtZW50cyIsICJldmVudHMiLCAiZm9udCIsICJmYW1pbHkiLCAic2l6ZSIsICJzdHlsZSIsICJsaW5lSGVpZ2h0IiwgIndlaWdodCIsICJob3ZlciIsICJob3ZlckJhY2tncm91bmRDb2xvciIsICJjdHgiLCAiaG92ZXJCb3JkZXJDb2xvciIsICJob3ZlckNvbG9yIiwgImluZGV4QXhpcyIsICJpbnRlcmFjdGlvbiIsICJtb2RlIiwgImludGVyc2VjdCIsICJpbmNsdWRlSW52aXNpYmxlIiwgIm1haW50YWluQXNwZWN0UmF0aW8iLCAib25Ib3ZlciIsICJvbkNsaWNrIiwgInBhcnNpbmciLCAicGx1Z2lucyIsICJyZXNwb25zaXZlIiwgInNjYWxlIiwgInNjYWxlcyIsICJzaG93TGluZSIsICJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsICJvdmVycmlkZSIsICJ0YXJnZXRTY29wZSIsICJ0YXJnZXROYW1lIiwgInNjb3BlT2JqZWN0IiwgInRhcmdldFNjb3BlT2JqZWN0IiwgInByaXZhdGVOYW1lIiwgImRlZmluZVByb3BlcnRpZXMiLCAid3JpdGFibGUiLCAiZW51bWVyYWJsZSIsICJsb2NhbCIsICJ0YXJnZXQiLCAiaXNPYmplY3QiLCAidmFsdWVPckRlZmF1bHQiLCAiYXBwbGllcnMiLCAiZm9yRWFjaCIsICJ0b0ZvbnRTdHJpbmciLCAiX21lYXN1cmVUZXh0IiwgImRhdGEiLCAiZ2MiLCAibG9uZ2VzdCIsICJzdHJpbmciLCAidGV4dFdpZHRoIiwgIm1lYXN1cmVUZXh0IiwgInB1c2giLCAiX2xvbmdlc3RUZXh0IiwgImFycmF5T2ZUaGluZ3MiLCAiY2FjaGUiLCAiZ2FyYmFnZUNvbGxlY3QiLCAic2F2ZSIsICJpbGVuIiwgImoiLCAiamxlbiIsICJ0aGluZyIsICJuZXN0ZWRUaGluZyIsICJyZXN0b3JlIiwgImdjTGVuIiwgInNwbGljZSIsICJfYWxpZ25QaXhlbCIsICJwaXhlbCIsICJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsICJoYWxmV2lkdGgiLCAicm91bmQiLCAiY2xlYXJDYW52YXMiLCAiY2FudmFzIiwgImdldENvbnRleHQiLCAicmVzZXRUcmFuc2Zvcm0iLCAiY2xlYXJSZWN0IiwgImhlaWdodCIsICJkcmF3UG9pbnQiLCAieCIsICJ5IiwgImRyYXdQb2ludExlZ2VuZCIsICJ3IiwgInhPZmZzZXQiLCAieU9mZnNldCIsICJjb3JuZXJSYWRpdXMiLCAieE9mZnNldFciLCAieU9mZnNldFciLCAicG9pbnRTdHlsZSIsICJyb3RhdGlvbiIsICJyYWRpdXMiLCAicmFkIiwgIlJBRF9QRVJfREVHIiwgInRyYW5zbGF0ZSIsICJyb3RhdGUiLCAiZHJhd0ltYWdlIiwgImJlZ2luUGF0aCIsICJlbGxpcHNlIiwgImFyYyIsICJjbG9zZVBhdGgiLCAibW92ZVRvIiwgIlRXT19USElSRFNfUEkiLCAibGluZVRvIiwgIlFVQVJURVJfUEkiLCAiU1FSVDFfMiIsICJyZWN0IiwgImZpbGwiLCAiYm9yZGVyV2lkdGgiLCAic3Ryb2tlIiwgIl9pc1BvaW50SW5BcmVhIiwgImFyZWEiLCAibWFyZ2luIiwgImNsaXBBcmVhIiwgInVuY2xpcEFyZWEiLCAiX3N0ZXBwZWRMaW5lVG8iLCAicHJldmlvdXMiLCAiZmxpcCIsICJtaWRwb2ludCIsICJfYmV6aWVyQ3VydmVUbyIsICJiZXppZXJDdXJ2ZVRvIiwgImNwMXgiLCAiY3AyeCIsICJjcDF5IiwgImNwMnkiLCAic2V0UmVuZGVyT3B0cyIsICJvcHRzIiwgInRyYW5zbGF0aW9uIiwgImZpbGxTdHlsZSIsICJ0ZXh0QWxpZ24iLCAidGV4dEJhc2VsaW5lIiwgImRlY29yYXRlVGV4dCIsICJsaW5lIiwgInN0cmlrZXRocm91Z2giLCAidW5kZXJsaW5lIiwgIm1ldHJpY3MiLCAiYWN0dWFsQm91bmRpbmdCb3hMZWZ0IiwgImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCAiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCAiYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50IiwgInlEZWNvcmF0aW9uIiwgInN0cm9rZVN0eWxlIiwgImRlY29yYXRpb25XaWR0aCIsICJkcmF3QmFja2Ryb3AiLCAib2xkQ29sb3IiLCAiZmlsbFJlY3QiLCAicmVuZGVyVGV4dCIsICJsaW5lcyIsICJzdHJva2VXaWR0aCIsICJzdHJva2VDb2xvciIsICJiYWNrZHJvcCIsICJzdHJva2VUZXh0IiwgIm1heFdpZHRoIiwgImZpbGxUZXh0IiwgIk51bWJlciIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAiaCIsICJ0b3BMZWZ0IiwgImJvdHRvbUxlZnQiLCAiYm90dG9tUmlnaHQiLCAidG9wUmlnaHQiLCAiTElORV9IRUlHSFQiLCAiRk9OVF9TVFlMRSIsICJ0b0xpbmVIZWlnaHQiLCAibWF0Y2hlcyIsICJtYXRjaCIsICJudW1iZXJPclplcm8iLCAiX3JlYWRWYWx1ZVRvUHJvcHMiLCAicHJvcHMiLCAicmV0IiwgIm9ialByb3BzIiwgInJlYWQiLCAicHJvcCIsICJ0b1RSQkwiLCAidG9UUkJMQ29ybmVycyIsICJ0b1BhZGRpbmciLCAib2JqIiwgInRvRm9udCIsICJmYWxsYmFjayIsICJwYXJzZUludCIsICJjb25zb2xlIiwgIndhcm4iLCAicmVzb2x2ZSIsICJpbnB1dHMiLCAiaW5mbyIsICJjYWNoZWFibGUiLCAiX2FkZEdyYWNlIiwgIm1pbm1heCIsICJjaGFuZ2UiLCAidG9EaW1lbnNpb24iLCAia2VlcFplcm8iLCAiYWRkIiwgImNyZWF0ZUNvbnRleHQiLCAicGFyZW50Q29udGV4dCIsICJfY3JlYXRlUmVzb2x2ZXIiLCAic2NvcGVzIiwgInByZWZpeGVzIiwgInJvb3RTY29wZXMiLCAiZ2V0VGFyZ2V0IiwgImZpbmFsUm9vdFNjb3BlcyIsICJfcmVzb2x2ZSIsICJTeW1ib2wiLCAidG9TdHJpbmdUYWciLCAiX2NhY2hlYWJsZSIsICJfc2NvcGVzIiwgIl9yb290U2NvcGVzIiwgIl9nZXRUYXJnZXQiLCAiUHJveHkiLCAiZGVsZXRlUHJvcGVydHkiLCAiX2tleXMiLCAiX2NhY2hlZCIsICJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsICJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCAiUmVmbGVjdCIsICJnZXRQcm90b3R5cGVPZiIsICJoYXMiLCAiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCAib3duS2V5cyIsICJzdG9yYWdlIiwgIl9zdG9yYWdlIiwgIl9hdHRhY2hDb250ZXh0IiwgInByb3h5IiwgInN1YlByb3h5IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJfcHJveHkiLCAiX2NvbnRleHQiLCAiX3N1YlByb3h5IiwgIl9zdGFjayIsICJTZXQiLCAic2V0Q29udGV4dCIsICJyZWNlaXZlciIsICJfcmVzb2x2ZVdpdGhDb250ZXh0IiwgImFsbEtleXMiLCAiY29uZmlndXJhYmxlIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgIl9hbGxLZXlzIiwgImlzU2NyaXB0YWJsZSIsICJpc0Z1bmN0aW9uIiwgImlzSW5kZXhhYmxlIiwgInJlYWRLZXkiLCAicHJlZml4IiwgIl9jYXBpdGFsaXplIiwgIm5lZWRzU3ViUmVzb2x2ZXIiLCAicHJvdG90eXBlIiwgImhhc093blByb3BlcnR5IiwgIl9yZXNvbHZlU2NyaXB0YWJsZSIsICJfcmVzb2x2ZUFycmF5IiwgImdldFZhbHVlIiwgIkVycm9yIiwgIkFycmF5IiwgImpvaW4iLCAiZGVsZXRlIiwgImNyZWF0ZVN1YlJlc29sdmVyIiwgImFyciIsICJmaWx0ZXIiLCAiaXRlbSIsICJyZXNvbHZlciIsICJyZXNvbHZlRmFsbGJhY2siLCAicGFyZW50IiwgInJlc29sdmVPYmplY3RLZXkiLCAiYWRkU2NvcGVzIiwgInBhcmVudFNjb3BlcyIsICJwYXJlbnRGYWxsYmFjayIsICJhbGxTY29wZXMiLCAiYWRkU2NvcGVzRnJvbUtleSIsICJzdWJHZXRUYXJnZXQiLCAicmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzIiwgIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsICJfcGFyc2luZyIsICJwYXJzZWQiLCAiciIsICJwYXJzZSIsICJFUFNJTE9OIiwgImdldFBvaW50IiwgInNraXAiLCAiZ2V0VmFsdWVBeGlzIiwgInNwbGluZUN1cnZlIiwgImZpcnN0UG9pbnQiLCAibWlkZGxlUG9pbnQiLCAiYWZ0ZXJQb2ludCIsICJjdXJyZW50IiwgIm5leHQiLCAiZDAxIiwgImRpc3RhbmNlQmV0d2VlblBvaW50cyIsICJkMTIiLCAiczAxIiwgInMxMiIsICJmYSIsICJmYiIsICJtb25vdG9uZUFkanVzdCIsICJkZWx0YUsiLCAibUsiLCAicG9pbnRzTGVuIiwgImFscGhhSyIsICJiZXRhSyIsICJ0YXVLIiwgInNxdWFyZWRNYWduaXR1ZGUiLCAicG9pbnRDdXJyZW50IiwgInBvaW50QWZ0ZXIiLCAiYWxtb3N0RXF1YWxzIiwgIm1vbm90b25lQ29tcHV0ZSIsICJ2YWx1ZUF4aXMiLCAicG9pbnRCZWZvcmUiLCAiaVBpeGVsIiwgInZQaXhlbCIsICJzcGxpbmVDdXJ2ZU1vbm90b25lIiwgInNsb3BlRGVsdGEiLCAic2lnbiIsICJjYXBDb250cm9sUG9pbnQiLCAicHQiLCAiY2FwQmV6aWVyUG9pbnRzIiwgImluQXJlYSIsICJpbkFyZWFQcmV2IiwgImluQXJlYU5leHQiLCAiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCAiY29udHJvbFBvaW50cyIsICJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwgInByZXYiLCAidGVuc2lvbiIsICJfaXNEb21TdXBwb3J0ZWQiLCAiZG9jdW1lbnQiLCAiX2dldFBhcmVudE5vZGUiLCAiZG9tTm9kZSIsICJwYXJlbnROb2RlIiwgImhvc3QiLCAicGFyc2VNYXhTdHlsZSIsICJzdHlsZVZhbHVlIiwgInBhcmVudFByb3BlcnR5IiwgInZhbHVlSW5QaXhlbHMiLCAiaW5kZXhPZiIsICJnZXRDb21wdXRlZFN0eWxlIiwgImVsZW1lbnQiLCAib3duZXJEb2N1bWVudCIsICJkZWZhdWx0VmlldyIsICJnZXRTdHlsZSIsICJlbCIsICJwcm9wZXJ0eSIsICJnZXRQcm9wZXJ0eVZhbHVlIiwgInBvc2l0aW9ucyIsICJnZXRQb3NpdGlvbmVkU3R5bGUiLCAic3R5bGVzIiwgInN1ZmZpeCIsICJyZXN1bHQiLCAicG9zIiwgInBhcnNlRmxvYXQiLCAidXNlT2Zmc2V0UG9zIiwgInNoYWRvd1Jvb3QiLCAiZ2V0Q2FudmFzUG9zaXRpb24iLCAiZSIsICJ0b3VjaGVzIiwgInNvdXJjZSIsICJvZmZzZXRYIiwgIm9mZnNldFkiLCAiYm94IiwgImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsICJjbGllbnRYIiwgImNsaWVudFkiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJldmVudCIsICJib3JkZXJCb3giLCAiYm94U2l6aW5nIiwgInBhZGRpbmdzIiwgImJvcmRlcnMiLCAiZ2V0Q29udGFpbmVyU2l6ZSIsICJtYXhIZWlnaHQiLCAiY29udGFpbmVyIiwgImNsaWVudFdpZHRoIiwgImNsaWVudEhlaWdodCIsICJjb250YWluZXJTdHlsZSIsICJjb250YWluZXJCb3JkZXIiLCAiY29udGFpbmVyUGFkZGluZyIsICJJTkZJTklUWSIsICJyb3VuZDEiLCAiZ2V0TWF4aW11bVNpemUiLCAiYmJXaWR0aCIsICJiYkhlaWdodCIsICJhc3BlY3RSYXRpbyIsICJtYXJnaW5zIiwgImNvbnRhaW5lclNpemUiLCAibWFpbnRhaW5IZWlnaHQiLCAicmV0aW5hU2NhbGUiLCAiZm9yY2VSYXRpbyIsICJmb3JjZVN0eWxlIiwgInBpeGVsUmF0aW8iLCAiZGV2aWNlSGVpZ2h0IiwgImRldmljZVdpZHRoIiwgInNldFRyYW5zZm9ybSIsICJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwgInBhc3NpdmVTdXBwb3J0ZWQiLCAicGFzc2l2ZSIsICJhZGRFdmVudExpc3RlbmVyIiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAicmVhZFVzZWRTaXplIiwgIl9wb2ludEluTGluZSIsICJwMSIsICJwMiIsICJfc3RlcHBlZEludGVycG9sYXRpb24iLCAiX2JlemllckludGVycG9sYXRpb24iLCAiY3AxIiwgImNwMiIsICJhIiwgImIiLCAiYyIsICJnZXRSaWdodFRvTGVmdEFkYXB0ZXIiLCAicmVjdFgiLCAic2V0V2lkdGgiLCAieFBsdXMiLCAibGVmdEZvckx0ciIsICJpdGVtV2lkdGgiLCAiZ2V0TGVmdFRvUmlnaHRBZGFwdGVyIiwgIl9pdGVtV2lkdGgiLCAiZ2V0UnRsQWRhcHRlciIsICJvdmVycmlkZVRleHREaXJlY3Rpb24iLCAiZGlyZWN0aW9uIiwgIm9yaWdpbmFsIiwgImdldFByb3BlcnR5UHJpb3JpdHkiLCAic2V0UHJvcGVydHkiLCAicHJldlRleHREaXJlY3Rpb24iLCAicmVzdG9yZVRleHREaXJlY3Rpb24iLCAicHJvcGVydHlGbiIsICJiZXR3ZWVuIiwgIl9hbmdsZUJldHdlZW4iLCAiY29tcGFyZSIsICJfYW5nbGVEaWZmIiwgIm5vcm1hbGl6ZSIsICJfbm9ybWFsaXplQW5nbGUiLCAiX2lzQmV0d2VlbiIsICJub3JtYWxpemVTZWdtZW50IiwgImdldFNlZ21lbnQiLCAic2VnbWVudCIsICJzdGFydEJvdW5kIiwgImVuZEJvdW5kIiwgIl9ib3VuZFNlZ21lbnQiLCAiaW5zaWRlIiwgInN1YlN0YXJ0IiwgInByZXZWYWx1ZSIsICJzdGFydElzQmVmb3JlIiwgImVuZElzQmVmb3JlIiwgInNob3VsZFN0YXJ0IiwgInNob3VsZFN0b3AiLCAiX2JvdW5kU2VnbWVudHMiLCAic2VnbWVudHMiLCAic3ViIiwgImZpbmRTdGFydEFuZEVuZCIsICJzb2xpZFNlZ21lbnRzIiwgImxhc3QiLCAiY3VyIiwgInN0b3AiLCAiX2NvbXB1dGVTZWdtZW50cyIsICJzZWdtZW50T3B0aW9ucyIsICJfbG9vcCIsICJzcGxpdEJ5U3R5bGVzIiwgImNvbXBsZXRlTG9vcCIsICJfZnVsbExvb3AiLCAiZG9TcGxpdEJ5U3R5bGVzIiwgImNoYXJ0Q29udGV4dCIsICJfY2hhcnQiLCAiYmFzZVN0eWxlIiwgInJlYWRTdHlsZSIsICJfZGF0YXNldEluZGV4IiwgImRhdGFzZXRJbmRleCIsICJwcmV2U3R5bGUiLCAiYWRkU3R5bGUiLCAibCIsICJzdCIsICJkaXIiLCAicDAiLCAicDBEYXRhSW5kZXgiLCAicDFEYXRhSW5kZXgiLCAic3R5bGVDaGFuZ2VkIiwgImJvcmRlckNhcFN0eWxlIiwgImJvcmRlckRhc2giLCAiYm9yZGVyRGFzaE9mZnNldCIsICJib3JkZXJKb2luU3R5bGUiLCAicmVwbGFjZXIiLCAiZ2V0U2l6ZUZvckFyZWEiLCAiY2hhcnRBcmVhIiwgImZpZWxkIiwgImdldERhdGFzZXRBcmVhIiwgImdldERhdGFzZXRDbGlwQXJlYSIsICJfY2xpcCIsICJkaXNhYmxlZCIsICJBbmltYXRvciIsICJjb25zdHJ1Y3RvciIsICJfcmVxdWVzdCIsICJfY2hhcnRzIiwgIk1hcCIsICJfcnVubmluZyIsICJfbGFzdERhdGUiLCAidW5kZWZpbmVkIiwgIl9ub3RpZnkiLCAiY2hhcnQiLCAiYW5pbXMiLCAiZGF0ZSIsICJ0eXBlIiwgImNhbGxiYWNrcyIsICJsaXN0ZW5lcnMiLCAibnVtU3RlcHMiLCAiZHVyYXRpb24iLCAiZm9yRWFjaCIsICJmbiIsICJpbml0aWFsIiwgImN1cnJlbnRTdGVwIiwgIk1hdGgiLCAibWluIiwgInN0YXJ0IiwgIl9yZWZyZXNoIiwgInJlcXVlc3RBbmltRnJhbWUiLCAiY2FsbCIsICJ3aW5kb3ciLCAiX3VwZGF0ZSIsICJEYXRlIiwgIm5vdyIsICJyZW1haW5pbmciLCAicnVubmluZyIsICJpdGVtcyIsICJsZW5ndGgiLCAiaSIsICJkcmF3IiwgIml0ZW0iLCAiX2FjdGl2ZSIsICJfdG90YWwiLCAidGljayIsICJwb3AiLCAiX2dldEFuaW1zIiwgImNoYXJ0cyIsICJnZXQiLCAiY29tcGxldGUiLCAicHJvZ3Jlc3MiLCAic2V0IiwgImxpc3RlbiIsICJldmVudCIsICJjYiIsICJwdXNoIiwgImFkZCIsICJoYXMiLCAicmVkdWNlIiwgImFjYyIsICJjdXIiLCAibWF4IiwgIl9kdXJhdGlvbiIsICJzdG9wIiwgImNhbmNlbCIsICJyZW1vdmUiLCAiZGVsZXRlIiwgInRyYW5zcGFyZW50IiwgImludGVycG9sYXRvcnMiLCAiYm9vbGVhbiIsICJmcm9tIiwgInRvIiwgImZhY3RvciIsICJjb2xvciIsICJjMCIsICJoZWxwZXJzQ29sb3IiLCAiYzEiLCAidmFsaWQiLCAibWl4IiwgImhleFN0cmluZyIsICJudW1iZXIiLCAiQW5pbWF0aW9uIiwgImNmZyIsICJ0YXJnZXQiLCAicHJvcCIsICJjdXJyZW50VmFsdWUiLCAicmVzb2x2ZSIsICJfZm4iLCAiX2Vhc2luZyIsICJlZmZlY3RzIiwgImVhc2luZyIsICJsaW5lYXIiLCAiX3N0YXJ0IiwgImZsb29yIiwgImRlbGF5IiwgIl9sb29wIiwgImxvb3AiLCAiX3RhcmdldCIsICJfcHJvcCIsICJfZnJvbSIsICJfdG8iLCAiX3Byb21pc2VzIiwgImFjdGl2ZSIsICJ1cGRhdGUiLCAiZWxhcHNlZCIsICJyZW1haW4iLCAid2FpdCIsICJwcm9taXNlcyIsICJQcm9taXNlIiwgInJlcyIsICJyZWoiLCAicmVzb2x2ZWQiLCAibWV0aG9kIiwgIkFuaW1hdGlvbnMiLCAiY29uZmlnIiwgIl9jaGFydCIsICJfcHJvcGVydGllcyIsICJjb25maWd1cmUiLCAiaXNPYmplY3QiLCAiYW5pbWF0aW9uT3B0aW9ucyIsICJPYmplY3QiLCAia2V5cyIsICJkZWZhdWx0cyIsICJhbmltYXRpb24iLCAiYW5pbWF0ZWRQcm9wcyIsICJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwgImtleSIsICJvcHRpb24iLCAiaXNBcnJheSIsICJwcm9wZXJ0aWVzIiwgIl9hbmltYXRlT3B0aW9ucyIsICJ2YWx1ZXMiLCAibmV3T3B0aW9ucyIsICJvcHRpb25zIiwgInJlc29sdmVUYXJnZXRPcHRpb25zIiwgImFuaW1hdGlvbnMiLCAiX2NyZWF0ZUFuaW1hdGlvbnMiLCAiJHNoYXJlZCIsICJhd2FpdEFsbCIsICIkYW5pbWF0aW9ucyIsICJ0aGVuIiwgInByb3BzIiwgImNoYXJBdCIsICJ2YWx1ZSIsICJzaXplIiwgImFzc2lnbiIsICJhbmltYXRvciIsICJhbmltIiwgImFsbCIsICJzY2FsZUNsaXAiLCAic2NhbGUiLCAiYWxsb3dlZE92ZXJmbG93IiwgIm9wdHMiLCAicmV2ZXJzZSIsICJlbmQiLCAiZGVmYXVsdENsaXAiLCAieFNjYWxlIiwgInlTY2FsZSIsICJ4IiwgInkiLCAidG9wIiwgInJpZ2h0IiwgImJvdHRvbSIsICJsZWZ0IiwgInRvQ2xpcCIsICJ0IiwgInIiLCAiYiIsICJsIiwgImRpc2FibGVkIiwgImdldFNvcnRlZERhdGFzZXRJbmRpY2VzIiwgImZpbHRlclZpc2libGUiLCAibWV0YXNldHMiLCAiX2dldFNvcnRlZERhdGFzZXRNZXRhcyIsICJpbGVuIiwgImluZGV4IiwgImFwcGx5U3RhY2siLCAic3RhY2siLCAiZHNJbmRleCIsICJzaW5nbGVNb2RlIiwgIm1vZGUiLCAiZGF0YXNldEluZGV4IiwgIm90aGVyVmFsdWUiLCAiZm91bmQiLCAiaXNGaW5pdGUiLCAic2lnbiIsICJjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkiLCAiZGF0YSIsICJtZXRhIiwgImlTY2FsZSIsICJ2U2NhbGUiLCAiaUF4aXNLZXkiLCAiYXhpcyIsICJ2QXhpc0tleSIsICJhZGF0YSIsICJBcnJheSIsICJpc1N0YWNrZWQiLCAic3RhY2tlZCIsICJnZXRTdGFja0tleSIsICJpbmRleFNjYWxlIiwgInZhbHVlU2NhbGUiLCAiaWQiLCAiZ2V0VXNlckJvdW5kcyIsICJtaW5EZWZpbmVkIiwgIm1heERlZmluZWQiLCAiTnVtYmVyIiwgIk5FR0FUSVZFX0lORklOSVRZIiwgIlBPU0lUSVZFX0lORklOSVRZIiwgImdldE9yQ3JlYXRlU3RhY2siLCAic3RhY2tzIiwgInN0YWNrS2V5IiwgImluZGV4VmFsdWUiLCAic3ViU3RhY2siLCAiZ2V0TGFzdEluZGV4SW5TdGFjayIsICJwb3NpdGl2ZSIsICJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsICJ1cGRhdGVTdGFja3MiLCAiY29udHJvbGxlciIsICJwYXJzZWQiLCAiX2NhY2hlZE1ldGEiLCAiX3N0YWNrcyIsICJpQXhpcyIsICJ2QXhpcyIsICJpdGVtU3RhY2tzIiwgIl90b3AiLCAiX2JvdHRvbSIsICJ2aXN1YWxWYWx1ZXMiLCAiX3Zpc3VhbFZhbHVlcyIsICJnZXRGaXJzdFNjYWxlSWQiLCAic2NhbGVzIiwgImZpbHRlciIsICJzaGlmdCIsICJjcmVhdGVEYXRhc2V0Q29udGV4dCIsICJwYXJlbnQiLCAiY3JlYXRlQ29udGV4dCIsICJkYXRhc2V0IiwgImNyZWF0ZURhdGFDb250ZXh0IiwgImVsZW1lbnQiLCAiZGF0YUluZGV4IiwgInJhdyIsICJjbGVhclN0YWNrcyIsICJfcGFyc2VkIiwgImlzRGlyZWN0VXBkYXRlTW9kZSIsICJjbG9uZUlmTm90U2hhcmVkIiwgImNhY2hlZCIsICJzaGFyZWQiLCAiY3JlYXRlU3RhY2siLCAiY2FuU3RhY2siLCAiaGlkZGVuIiwgIl9zdGFja2VkIiwgIkRhdGFzZXRDb250cm9sbGVyIiwgIl9jdHgiLCAiY3R4IiwgIl9jYWNoZWREYXRhT3B0cyIsICJnZXRNZXRhIiwgIl90eXBlIiwgIl9wYXJzaW5nIiwgIl9kYXRhIiwgIl9vYmplY3REYXRhIiwgIl9zaGFyZWRPcHRpb25zIiwgIl9kcmF3U3RhcnQiLCAiX2RyYXdDb3VudCIsICJlbmFibGVPcHRpb25TaGFyaW5nIiwgInN1cHBvcnRzRGVjaW1hdGlvbiIsICIkY29udGV4dCIsICJfc3luY0xpc3QiLCAiZGF0YXNldEVsZW1lbnRUeXBlIiwgImRhdGFFbGVtZW50VHlwZSIsICJpbml0aWFsaXplIiwgImxpbmtTY2FsZXMiLCAiYWRkRWxlbWVudHMiLCAiZmlsbCIsICJpc1BsdWdpbkVuYWJsZWQiLCAiY29uc29sZSIsICJ3YXJuIiwgInVwZGF0ZUluZGV4IiwgImdldERhdGFzZXQiLCAiY2hvb3NlSWQiLCAieGlkIiwgInhBeGlzSUQiLCAidmFsdWVPckRlZmF1bHQiLCAieWlkIiwgInlBeGlzSUQiLCAicmlkIiwgInJBeGlzSUQiLCAiaW5kZXhBeGlzIiwgImlpZCIsICJpQXhpc0lEIiwgInZpZCIsICJ2QXhpc0lEIiwgImdldFNjYWxlRm9ySWQiLCAiclNjYWxlIiwgImRhdGFzZXRzIiwgImdldERhdGFzZXRNZXRhIiwgInNjYWxlSUQiLCAiX2dldE90aGVyU2NhbGUiLCAicmVzZXQiLCAiX2Rlc3Ryb3kiLCAidW5saXN0ZW5BcnJheUV2ZW50cyIsICJfZGF0YUNoZWNrIiwgImlzRXh0ZW5zaWJsZSIsICJsaXN0ZW5BcnJheUV2ZW50cyIsICJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCAicmVzZXROZXdFbGVtZW50cyIsICJzdGFja0NoYW5nZWQiLCAib2xkU3RhY2tlZCIsICJfcmVzeW5jRWxlbWVudHMiLCAic2NvcGVLZXlzIiwgImRhdGFzZXRTY29wZUtleXMiLCAic2NvcGVzIiwgImdldE9wdGlvblNjb3BlcyIsICJjcmVhdGVSZXNvbHZlciIsICJnZXRDb250ZXh0IiwgInBhcnNpbmciLCAicGFyc2UiLCAiY291bnQiLCAic29ydGVkIiwgIl9zb3J0ZWQiLCAicHJldiIsICJwYXJzZUFycmF5RGF0YSIsICJwYXJzZU9iamVjdERhdGEiLCAicGFyc2VQcmltaXRpdmVEYXRhIiwgImlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2IiwgImxhYmVscyIsICJnZXRMYWJlbHMiLCAic2luZ2xlU2NhbGUiLCAieEF4aXNLZXkiLCAieUF4aXNLZXkiLCAicmVzb2x2ZU9iamVjdEtleSIsICJnZXRQYXJzZWQiLCAiZ2V0RGF0YUVsZW1lbnQiLCAidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwgInJhbmdlIiwgInBhcnNlZFZhbHVlIiwgIk5hTiIsICJnZXRNaW5NYXgiLCAib3RoZXJTY2FsZSIsICJvdGhlck1pbiIsICJvdGhlck1heCIsICJfc2tpcCIsICJnZXRBbGxQYXJzZWRWYWx1ZXMiLCAiZ2V0TWF4T3ZlcmZsb3ciLCAiZ2V0TGFiZWxBbmRWYWx1ZSIsICJsYWJlbCIsICJnZXRMYWJlbEZvclZhbHVlIiwgIl9jbGlwIiwgImNsaXAiLCAiZWxlbWVudHMiLCAiYXJlYSIsICJjaGFydEFyZWEiLCAiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCAiZ2V0U3R5bGUiLCAicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsICJyZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zIiwgImNvbnRleHQiLCAiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsICJlbGVtZW50VHlwZSIsICJjYWNoZSIsICJjYWNoZUtleSIsICJzaGFyaW5nIiwgImRlZmluZWQiLCAiZGF0YXNldEVsZW1lbnRTY29wZUtleXMiLCAicHJlZml4ZXMiLCAibmFtZXMiLCAicmVzb2x2ZU5hbWVkT3B0aW9ucyIsICJmcmVlemUiLCAiX3Jlc29sdmVBbmltYXRpb25zIiwgInRyYW5zaXRpb24iLCAiZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyIsICJfY2FjaGVhYmxlIiwgImdldFNoYXJlZE9wdGlvbnMiLCAiaW5jbHVkZU9wdGlvbnMiLCAic2hhcmVkT3B0aW9ucyIsICJfYW5pbWF0aW9uc0Rpc2FibGVkIiwgIl9nZXRTaGFyZWRPcHRpb25zIiwgImZpcnN0T3B0cyIsICJwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyIsICJ1cGRhdGVTaGFyZWRPcHRpb25zIiwgInVwZGF0ZUVsZW1lbnQiLCAiX3NldFN0eWxlIiwgInJlbW92ZUhvdmVyU3R5bGUiLCAic2V0SG92ZXJTdHlsZSIsICJfcmVtb3ZlRGF0YXNldEhvdmVyU3R5bGUiLCAiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwgImFyZzEiLCAiYXJnMiIsICJudW1NZXRhIiwgIm51bURhdGEiLCAiX2luc2VydEVsZW1lbnRzIiwgIl9yZW1vdmVFbGVtZW50cyIsICJtb3ZlIiwgImFyciIsICJ1cGRhdGVFbGVtZW50cyIsICJyZW1vdmVkIiwgInNwbGljZSIsICJfc3luYyIsICJhcmdzIiwgIl9kYXRhQ2hhbmdlcyIsICJfb25EYXRhUHVzaCIsICJhcmd1bWVudHMiLCAiX29uRGF0YVBvcCIsICJfb25EYXRhU2hpZnQiLCAiX29uRGF0YVNwbGljZSIsICJuZXdDb3VudCIsICJfb25EYXRhVW5zaGlmdCIsICJnZXRBbGxTY2FsZVZhbHVlcyIsICJfY2FjaGUiLCAiJGJhciIsICJ2aXNpYmxlTWV0YXMiLCAiY29uY2F0IiwgIl9hcnJheVVuaXF1ZSIsICJzb3J0IiwgImEiLCAiY29tcHV0ZU1pblNhbXBsZVNpemUiLCAiX2xlbmd0aCIsICJjdXJyIiwgInVwZGF0ZU1pbkFuZFByZXYiLCAiYWJzIiwgImdldFBpeGVsRm9yVmFsdWUiLCAidGlja3MiLCAiZ2V0UGl4ZWxGb3JUaWNrIiwgImNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyIsICJydWxlciIsICJzdGFja0NvdW50IiwgInRoaWNrbmVzcyIsICJiYXJUaGlja25lc3MiLCAicmF0aW8iLCAiaXNOdWxsT3JVbmRlZiIsICJjYXRlZ29yeVBlcmNlbnRhZ2UiLCAiYmFyUGVyY2VudGFnZSIsICJjaHVuayIsICJwaXhlbHMiLCAiY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyIsICJuZXh0IiwgInBlcmNlbnQiLCAicGFyc2VGbG9hdEJhciIsICJlbnRyeSIsICJzdGFydFZhbHVlIiwgImVuZFZhbHVlIiwgImJhclN0YXJ0IiwgImJhckVuZCIsICJfY3VzdG9tIiwgInBhcnNlVmFsdWUiLCAicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwgImlzRmxvYXRCYXIiLCAiY3VzdG9tIiwgImJhclNpZ24iLCAiYWN0dWFsQmFzZSIsICJpc0hvcml6b250YWwiLCAiYm9yZGVyUHJvcHMiLCAiaG9yaXpvbnRhbCIsICJiYXNlIiwgInNldEJvcmRlclNraXBwZWQiLCAiZWRnZSIsICJib3JkZXJTa2lwcGVkIiwgImVuYWJsZUJvcmRlclJhZGl1cyIsICJwYXJzZUVkZ2UiLCAic3dhcCIsICJzdGFydEVuZCIsICJvcmlnIiwgInYxIiwgInYyIiwgInYiLCAic2V0SW5mbGF0ZUFtb3VudCIsICJpbmZsYXRlQW1vdW50IiwgIkJhckNvbnRyb2xsZXIiLCAib2JqIiwgImJhcnMiLCAiZ2V0QmFzZVBpeGVsIiwgIl9nZXRSdWxlciIsICJ2cGl4ZWxzIiwgImhlYWQiLCAiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwgImlwaXhlbHMiLCAiX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzIiwgImNlbnRlciIsICJoZWlnaHQiLCAid2lkdGgiLCAiX2dldFN0YWNrcyIsICJsYXN0IiwgImdyb3VwZWQiLCAiY3VycmVudFBhcnNlZCIsICJpU2NhbGVWYWx1ZSIsICJza2lwTnVsbCIsICJmaW5kIiwgInZhbCIsICJpc05hTiIsICJpbmRleE9mIiwgIl9nZXRTdGFja0NvdW50IiwgIl9nZXRBeGlzQ291bnQiLCAiX2dldEF4aXMiLCAiZ2V0Rmlyc3RTY2FsZUlkRm9ySW5kZXhBeGlzIiwgImluZGV4U2NhbGVJZCIsICJmaXJzdFNjYWxlQXhpc0lkIiwgIl9nZXRTdGFja0luZGV4IiwgIm5hbWUiLCAiX3N0YXJ0UGl4ZWwiLCAiX2VuZFBpeGVsIiwgImJhc2VWYWx1ZSIsICJtaW5CYXJMZW5ndGgiLCAiZmxvYXRpbmciLCAiZ2V0RGF0YVZpc2liaWxpdHkiLCAic3RhcnRQaXhlbCIsICJnZXRQaXhlbEZvckRlY2ltYWwiLCAiZW5kUGl4ZWwiLCAiZ2V0VmFsdWVGb3JQaXhlbCIsICJoYWxmR3JpZCIsICJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsICJtYXhCYXJUaGlja25lc3MiLCAiSW5maW5pdHkiLCAiYXhpc0NvdW50IiwgImF4aXNJRCIsICJheGlzTnVtYmVyIiwgInN0YWNrSW5kZXgiLCAicmVjdHMiLCAibnVtYmVycyIsICJvdmVycmlkZXMiLCAiX2luZGV4XyIsICJvZmZzZXQiLCAiZ3JpZCIsICJfdmFsdWVfIiwgImJlZ2luQXRaZXJvIiwgIkJ1YmJsZUNvbnRyb2xsZXIiLCAicmFkaXVzIiwgInBvaW50cyIsICJwb2ludCIsICJpUGl4ZWwiLCAidlBpeGVsIiwgInNraXAiLCAiZ2V0UmF0aW9BbmRPZmZzZXQiLCAicm90YXRpb24iLCAiY2lyY3VtZmVyZW5jZSIsICJjdXRvdXQiLCAicmF0aW9YIiwgInJhdGlvWSIsICJvZmZzZXRYIiwgIm9mZnNldFkiLCAiVEFVIiwgInN0YXJ0QW5nbGUiLCAiZW5kQW5nbGUiLCAic3RhcnRYIiwgImNvcyIsICJzdGFydFkiLCAic2luIiwgImVuZFgiLCAiZW5kWSIsICJjYWxjTWF4IiwgImFuZ2xlIiwgIl9hbmdsZUJldHdlZW4iLCAiY2FsY01pbiIsICJtYXhYIiwgIm1heFkiLCAiSEFMRl9QSSIsICJtaW5YIiwgIlBJIiwgIm1pblkiLCAiRG91Z2hudXRDb250cm9sbGVyIiwgImlubmVyUmFkaXVzIiwgIm91dGVyUmFkaXVzIiwgImdldHRlciIsICJfZ2V0Um90YXRpb24iLCAidG9SYWRpYW5zIiwgIl9nZXRDaXJjdW1mZXJlbmNlIiwgIl9nZXRSb3RhdGlvbkV4dGVudHMiLCAiaXNEYXRhc2V0VmlzaWJsZSIsICJhcmNzIiwgInNwYWNpbmciLCAiZ2V0TWF4Qm9yZGVyV2lkdGgiLCAiZ2V0TWF4T2Zmc2V0IiwgIm1heFNpemUiLCAidG9QZXJjZW50YWdlIiwgImNoYXJ0V2VpZ2h0IiwgIl9nZXRSaW5nV2VpZ2h0IiwgIm1heFdpZHRoIiwgIm1heEhlaWdodCIsICJtYXhSYWRpdXMiLCAidG9EaW1lbnNpb24iLCAicmFkaXVzTGVuZ3RoIiwgIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwgInRvdGFsIiwgImNhbGN1bGF0ZVRvdGFsIiwgIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwgIl9jaXJjdW1mZXJlbmNlIiwgImFuaW1hdGVSb3RhdGUiLCAiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsICJhbmltYXRpb25PcHRzIiwgImNlbnRlclgiLCAiY2VudGVyWSIsICJhbmltYXRlU2NhbGUiLCAiYXJjIiwgIm1ldGFEYXRhIiwgImZvcm1hdE51bWJlciIsICJsb2NhbGUiLCAiYm9yZGVyQWxpZ24iLCAiYm9yZGVyV2lkdGgiLCAiaG92ZXJCb3JkZXJXaWR0aCIsICJob3Zlck9mZnNldCIsICJyaW5nV2VpZ2h0T2Zmc2V0IiwgIndlaWdodCIsICJkZXNjcmlwdG9ycyIsICJfc2NyaXB0YWJsZSIsICJfaW5kZXhhYmxlIiwgInN0YXJ0c1dpdGgiLCAiYXNwZWN0UmF0aW8iLCAicGx1Z2lucyIsICJsZWdlbmQiLCAiZ2VuZXJhdGVMYWJlbHMiLCAicG9pbnRTdHlsZSIsICJtYXAiLCAic3R5bGUiLCAidGV4dCIsICJmaWxsU3R5bGUiLCAiYmFja2dyb3VuZENvbG9yIiwgInN0cm9rZVN0eWxlIiwgImJvcmRlckNvbG9yIiwgImZvbnRDb2xvciIsICJsaW5lV2lkdGgiLCAib25DbGljayIsICJlIiwgImxlZ2VuZEl0ZW0iLCAidG9nZ2xlRGF0YVZpc2liaWxpdHkiLCAiTGluZUNvbnRyb2xsZXIiLCAibGluZSIsICJfZGF0YXNldCIsICJhbmltYXRpb25zRGlzYWJsZWQiLCAiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCAiX3NjYWxlUmFuZ2VzQ2hhbmdlZCIsICJfZGF0YXNldEluZGV4IiwgIl9kZWNpbWF0ZWQiLCAic2hvd0xpbmUiLCAic2VnbWVudCIsICJhbmltYXRlZCIsICJzcGFuR2FwcyIsICJtYXhHYXBMZW5ndGgiLCAiaXNOdW1iZXIiLCAiZGlyZWN0VXBkYXRlIiwgInBvaW50c0NvdW50IiwgInByZXZQYXJzZWQiLCAibnVsbERhdGEiLCAiYm9yZGVyIiwgImZpcnN0UG9pbnQiLCAibGFzdFBvaW50IiwgInVwZGF0ZUNvbnRyb2xQb2ludHMiLCAiUG9sYXJBcmVhQ29udHJvbGxlciIsICJfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUiLCAiYmluZCIsICJfdXBkYXRlUmFkaXVzIiwgIm1pblNpemUiLCAiY3V0b3V0UGVyY2VudGFnZSIsICJnZXRWaXNpYmxlRGF0YXNldENvdW50IiwgInhDZW50ZXIiLCAieUNlbnRlciIsICJkYXRhc2V0U3RhcnRBbmdsZSIsICJnZXRJbmRleEFuZ2xlIiwgImRlZmF1bHRBbmdsZSIsICJjb3VudFZpc2libGVFbGVtZW50cyIsICJfY29tcHV0ZUFuZ2xlIiwgImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwgImFuZ2xlTGluZXMiLCAiZGlzcGxheSIsICJjaXJjdWxhciIsICJwb2ludExhYmVscyIsICJQaWVDb250cm9sbGVyIiwgIlJhZGFyQ29udHJvbGxlciIsICJfZnVsbExvb3AiLCAicG9pbnRQb3NpdGlvbiIsICJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCAiU2NhdHRlckNvbnRyb2xsZXIiLCAicmVnaXN0cnkiLCAiZ2V0RWxlbWVudCIsICJpbnRlcmFjdGlvbiIsICJhYnN0cmFjdCIsICJFcnJvciIsICJEYXRlQWRhcHRlckJhc2UiLCAib3ZlcnJpZGUiLCAibWVtYmVycyIsICJwcm90b3R5cGUiLCAiaW5pdCIsICJmb3JtYXRzIiwgImZvcm1hdCIsICJkaWZmIiwgInN0YXJ0T2YiLCAiZW5kT2YiLCAiX2RhdGUiLCAiYmluYXJ5U2VhcmNoIiwgIm1ldGFzZXQiLCAiaW50ZXJzZWN0IiwgImxvb2t1cE1ldGhvZCIsICJfcmV2ZXJzZVBpeGVscyIsICJfcmxvb2t1cEJ5S2V5IiwgIl9sb29rdXBCeUtleSIsICJyZXN1bHQiLCAiZGlzdGFuY2VUb0RlZmluZWRMbyIsICJzbGljZSIsICJsbyIsICJmaW5kSW5kZXgiLCAiZGlzdGFuY2VUb0RlZmluZWRIaSIsICJoaSIsICJlbCIsICJnZXRSYW5nZSIsICJldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMiLCAicG9zaXRpb24iLCAiaGFuZGxlciIsICJnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzIiwgImoiLCAiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwgInVzZVgiLCAidXNlWSIsICJwdDEiLCAicHQyIiwgImRlbHRhWCIsICJkZWx0YVkiLCAic3FydCIsICJwb3ciLCAiZ2V0SW50ZXJzZWN0SXRlbXMiLCAidXNlRmluYWxQb3NpdGlvbiIsICJpbmNsdWRlSW52aXNpYmxlIiwgImlzUG9pbnRJbkFyZWEiLCAiZXZhbHVhdGlvbkZ1bmMiLCAiX2lzUG9pbnRJbkFyZWEiLCAiaW5SYW5nZSIsICJnZXROZWFyZXN0UmFkaWFsSXRlbXMiLCAiZ2V0UHJvcHMiLCAiZ2V0QW5nbGVGcm9tUG9pbnQiLCAiZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zIiwgImRpc3RhbmNlTWV0cmljIiwgIm1pbkRpc3RhbmNlIiwgImdldENlbnRlclBvaW50IiwgInBvaW50SW5BcmVhIiwgImRpc3RhbmNlIiwgImdldE5lYXJlc3RJdGVtcyIsICJnZXRBeGlzSXRlbXMiLCAicmFuZ2VNZXRob2QiLCAiaW50ZXJzZWN0c0l0ZW0iLCAibW9kZXMiLCAiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsICJuZWFyZXN0IiwgIlNUQVRJQ19QT1NJVElPTlMiLCAiZmlsdGVyQnlQb3NpdGlvbiIsICJhcnJheSIsICJwb3MiLCAiZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzIiwgImJveCIsICJzb3J0QnlXZWlnaHQiLCAidjAiLCAid3JhcEJveGVzIiwgImJveGVzIiwgImxheW91dEJveGVzIiwgInN0YWNrV2VpZ2h0IiwgImJ1aWxkU3RhY2tzIiwgImxheW91dHMiLCAid3JhcCIsICJpbmNsdWRlcyIsICJfc3RhY2siLCAicGxhY2VkIiwgInNldExheW91dERpbXMiLCAicGFyYW1zIiwgInZCb3hNYXhXaWR0aCIsICJoQm94TWF4SGVpZ2h0IiwgImxheW91dCIsICJmdWxsU2l6ZSIsICJhdmFpbGFibGVXaWR0aCIsICJhdmFpbGFibGVIZWlnaHQiLCAiYnVpbGRMYXlvdXRCb3hlcyIsICJjZW50ZXJIb3Jpem9udGFsIiwgImNlbnRlclZlcnRpY2FsIiwgImxlZnRBbmRUb3AiLCAicmlnaHRBbmRCb3R0b20iLCAidmVydGljYWwiLCAiZ2V0Q29tYmluZWRNYXgiLCAibWF4UGFkZGluZyIsICJ1cGRhdGVNYXhQYWRkaW5nIiwgImJveFBhZGRpbmciLCAidXBkYXRlRGltcyIsICJnZXRQYWRkaW5nIiwgIm5ld1dpZHRoIiwgIm91dGVyV2lkdGgiLCAibmV3SGVpZ2h0IiwgIm91dGVySGVpZ2h0IiwgIndpZHRoQ2hhbmdlZCIsICJ3IiwgImhlaWdodENoYW5nZWQiLCAiaCIsICJzYW1lIiwgIm90aGVyIiwgImhhbmRsZU1heFBhZGRpbmciLCAidXBkYXRlUG9zIiwgImNoYW5nZSIsICJnZXRNYXJnaW5zIiwgIm1hcmdpbkZvclBvc2l0aW9ucyIsICJwb3NpdGlvbnMiLCAibWFyZ2luIiwgImZpdEJveGVzIiwgInJlZml0Qm94ZXMiLCAicmVmaXQiLCAiY2hhbmdlZCIsICJzZXRCb3hEaW1zIiwgInBsYWNlQm94ZXMiLCAidXNlclBhZGRpbmciLCAicGFkZGluZyIsICJhZGRCb3giLCAiX2xheWVycyIsICJ6IiwgInJlbW92ZUJveCIsICJsYXlvdXRJdGVtIiwgIm1pblBhZGRpbmciLCAidG9QYWRkaW5nIiwgInZlcnRpY2FsQm94ZXMiLCAiaG9yaXpvbnRhbEJveGVzIiwgImVhY2giLCAiYmVmb3JlTGF5b3V0IiwgInZpc2libGVWZXJ0aWNhbEJveENvdW50IiwgIkJhc2VQbGF0Zm9ybSIsICJhY3F1aXJlQ29udGV4dCIsICJjYW52YXMiLCAicmVsZWFzZUNvbnRleHQiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJsaXN0ZW5lciIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgImdldERldmljZVBpeGVsUmF0aW8iLCAiZ2V0TWF4aW11bVNpemUiLCAiaXNBdHRhY2hlZCIsICJ1cGRhdGVDb25maWciLCAiQmFzaWNQbGF0Zm9ybSIsICJFWFBBTkRPX0tFWSIsICJFVkVOVF9UWVBFUyIsICJ0b3VjaHN0YXJ0IiwgInRvdWNobW92ZSIsICJ0b3VjaGVuZCIsICJwb2ludGVyZW50ZXIiLCAicG9pbnRlcmRvd24iLCAicG9pbnRlcm1vdmUiLCAicG9pbnRlcnVwIiwgInBvaW50ZXJsZWF2ZSIsICJwb2ludGVyb3V0IiwgImlzTnVsbE9yRW1wdHkiLCAiaW5pdENhbnZhcyIsICJyZW5kZXJIZWlnaHQiLCAiZ2V0QXR0cmlidXRlIiwgInJlbmRlcldpZHRoIiwgImJveFNpemluZyIsICJkaXNwbGF5V2lkdGgiLCAicmVhZFVzZWRTaXplIiwgImRpc3BsYXlIZWlnaHQiLCAiZXZlbnRMaXN0ZW5lck9wdGlvbnMiLCAic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsICJwYXNzaXZlIiwgImFkZExpc3RlbmVyIiwgIm5vZGUiLCAicmVtb3ZlTGlzdGVuZXIiLCAiZnJvbU5hdGl2ZUV2ZW50IiwgIm5hdGl2ZSIsICJub2RlTGlzdENvbnRhaW5zIiwgIm5vZGVMaXN0IiwgImNvbnRhaW5zIiwgImNyZWF0ZUF0dGFjaE9ic2VydmVyIiwgIm9ic2VydmVyIiwgIk11dGF0aW9uT2JzZXJ2ZXIiLCAiZW50cmllcyIsICJ0cmlnZ2VyIiwgImFkZGVkTm9kZXMiLCAicmVtb3ZlZE5vZGVzIiwgIm9ic2VydmUiLCAiZG9jdW1lbnQiLCAiY2hpbGRMaXN0IiwgInN1YnRyZWUiLCAiY3JlYXRlRGV0YWNoT2JzZXJ2ZXIiLCAiZHJwTGlzdGVuaW5nQ2hhcnRzIiwgIm9sZERldmljZVBpeGVsUmF0aW8iLCAib25XaW5kb3dSZXNpemUiLCAiZHByIiwgImRldmljZVBpeGVsUmF0aW8iLCAicmVzaXplIiwgImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwgImxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwgInVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCAiY3JlYXRlUmVzaXplT2JzZXJ2ZXIiLCAiY29udGFpbmVyIiwgIl9nZXRQYXJlbnROb2RlIiwgInRocm90dGxlZCIsICJjbGllbnRXaWR0aCIsICJSZXNpemVPYnNlcnZlciIsICJjb250ZW50UmVjdCIsICJyZWxlYXNlT2JzZXJ2ZXIiLCAiZGlzY29ubmVjdCIsICJjcmVhdGVQcm94eUFuZExpc3RlbiIsICJwcm94eSIsICJEb21QbGF0Zm9ybSIsICJyZW1vdmVBdHRyaWJ1dGUiLCAic2V0QXR0cmlidXRlIiwgInByb3hpZXMiLCAiJHByb3hpZXMiLCAiaGFuZGxlcnMiLCAiYXR0YWNoIiwgImRldGFjaCIsICJpc0Nvbm5lY3RlZCIsICJfZGV0ZWN0UGxhdGZvcm0iLCAiX2lzRG9tU3VwcG9ydGVkIiwgIk9mZnNjcmVlbkNhbnZhcyIsICJFbGVtZW50IiwgInRvb2x0aXBQb3NpdGlvbiIsICJoYXNWYWx1ZSIsICJmaW5hbCIsICJyZXQiLCAiZGVmYXVsdFJvdXRlcyIsICJhdXRvU2tpcCIsICJ0aWNrT3B0cyIsICJkZXRlcm1pbmVkTWF4VGlja3MiLCAiZGV0ZXJtaW5lTWF4VGlja3MiLCAidGlja3NMaW1pdCIsICJtYXhUaWNrc0xpbWl0IiwgIm1ham9ySW5kaWNlcyIsICJtYWpvciIsICJlbmFibGVkIiwgImdldE1ham9ySW5kaWNlcyIsICJudW1NYWpvckluZGljZXMiLCAiZmlyc3QiLCAibmV3VGlja3MiLCAic2tpcE1ham9ycyIsICJjYWxjdWxhdGVTcGFjaW5nIiwgImF2Z01ham9yU3BhY2luZyIsICJyb3VuZCIsICJ0aWNrTGVuZ3RoIiwgIl90aWNrU2l6ZSIsICJtYXhTY2FsZSIsICJtYXhDaGFydCIsICJfbWF4TGVuZ3RoIiwgImV2ZW5NYWpvclNwYWNpbmciLCAiZ2V0RXZlblNwYWNpbmciLCAiZmFjdG9ycyIsICJfZmFjdG9yaXplIiwgImNlaWwiLCAibWFqb3JTdGFydCIsICJtYWpvckVuZCIsICJsZW4iLCAicmV2ZXJzZUFsaWduIiwgImFsaWduIiwgIm9mZnNldEZyb21FZGdlIiwgImdldFRpY2tzTGltaXQiLCAidGlja3NMZW5ndGgiLCAic2FtcGxlIiwgIm51bUl0ZW1zIiwgImluY3JlbWVudCIsICJnZXRQaXhlbEZvckdyaWRMaW5lIiwgIm9mZnNldEdyaWRMaW5lcyIsICJ2YWxpZEluZGV4IiwgImVwc2lsb24iLCAibGluZVZhbHVlIiwgImdhcmJhZ2VDb2xsZWN0IiwgImNhY2hlcyIsICJnYyIsICJnY0xlbiIsICJnZXRUaWNrTWFya0xlbmd0aCIsICJkcmF3VGlja3MiLCAiZ2V0VGl0bGVIZWlnaHQiLCAiZmFsbGJhY2siLCAiZm9udCIsICJ0b0ZvbnQiLCAibGluZXMiLCAibGluZUhlaWdodCIsICJjcmVhdGVTY2FsZUNvbnRleHQiLCAiY3JlYXRlVGlja0NvbnRleHQiLCAidGl0bGVBbGlnbiIsICJfdG9MZWZ0UmlnaHRDZW50ZXIiLCAidGl0bGVBcmdzIiwgInRpdGxlWCIsICJ0aXRsZVkiLCAiX2FsaWduU3RhcnRFbmQiLCAicG9zaXRpb25BeGlzSUQiLCAiU2NhbGUiLCAiX21hcmdpbnMiLCAicGFkZGluZ1RvcCIsICJwYWRkaW5nQm90dG9tIiwgInBhZGRpbmdMZWZ0IiwgInBhZGRpbmdSaWdodCIsICJsYWJlbFJvdGF0aW9uIiwgIl9yYW5nZSIsICJfZ3JpZExpbmVJdGVtcyIsICJfbGFiZWxJdGVtcyIsICJfbGFiZWxTaXplcyIsICJfbG9uZ2VzdFRleHRDYWNoZSIsICJfdXNlck1heCIsICJfdXNlck1pbiIsICJfc3VnZ2VzdGVkTWF4IiwgIl9zdWdnZXN0ZWRNaW4iLCAiX3RpY2tzTGVuZ3RoIiwgIl9ib3JkZXJWYWx1ZSIsICJfZGF0YUxpbWl0c0NhY2hlZCIsICJzZXRDb250ZXh0IiwgInN1Z2dlc3RlZE1pbiIsICJzdWdnZXN0ZWRNYXgiLCAiZmluaXRlT3JEZWZhdWx0IiwgIm1ldGFzIiwgImdldFRpY2tzIiwgInhMYWJlbHMiLCAieUxhYmVscyIsICJnZXRMYWJlbEl0ZW1zIiwgIl9jb21wdXRlTGFiZWxJdGVtcyIsICJiZWZvcmVVcGRhdGUiLCAibWFyZ2lucyIsICJncmFjZSIsICJzYW1wbGVTaXplIiwgImJlZm9yZVNldERpbWVuc2lvbnMiLCAic2V0RGltZW5zaW9ucyIsICJhZnRlclNldERpbWVuc2lvbnMiLCAiYmVmb3JlRGF0YUxpbWl0cyIsICJkZXRlcm1pbmVEYXRhTGltaXRzIiwgImFmdGVyRGF0YUxpbWl0cyIsICJfYWRkR3JhY2UiLCAiYmVmb3JlQnVpbGRUaWNrcyIsICJidWlsZFRpY2tzIiwgImFmdGVyQnVpbGRUaWNrcyIsICJzYW1wbGluZ0VuYWJsZWQiLCAiX2NvbnZlcnRUaWNrc1RvTGFiZWxzIiwgImJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAiY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsICJhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCAic291cmNlIiwgImFmdGVyQXV0b1NraXAiLCAiYmVmb3JlRml0IiwgImZpdCIsICJhZnRlckZpdCIsICJhZnRlclVwZGF0ZSIsICJyZXZlcnNlUGl4ZWxzIiwgIl9hbGlnblRvUGl4ZWxzIiwgImFsaWduVG9QaXhlbHMiLCAiX2NhbGxIb29rcyIsICJub3RpZnlQbHVnaW5zIiwgImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsICJnZW5lcmF0ZVRpY2tMYWJlbHMiLCAiY2FsbGJhY2siLCAiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCAibnVtVGlja3MiLCAibWluUm90YXRpb24iLCAibWF4Um90YXRpb24iLCAidGlja1dpZHRoIiwgIm1heExhYmVsRGlhZ29uYWwiLCAiX2lzVmlzaWJsZSIsICJsYWJlbFNpemVzIiwgIl9nZXRMYWJlbFNpemVzIiwgIm1heExhYmVsV2lkdGgiLCAid2lkZXN0IiwgIm1heExhYmVsSGVpZ2h0IiwgImhpZ2hlc3QiLCAiX2xpbWl0VmFsdWUiLCAidGl0bGUiLCAidG9EZWdyZWVzIiwgImFzaW4iLCAidGl0bGVPcHRzIiwgImdyaWRPcHRzIiwgInRpdGxlSGVpZ2h0IiwgInRpY2tQYWRkaW5nIiwgImFuZ2xlUmFkaWFucyIsICJsYWJlbEhlaWdodCIsICJtaXJyb3IiLCAibGFiZWxXaWR0aCIsICJfY2FsY3VsYXRlUGFkZGluZyIsICJfaGFuZGxlTWFyZ2lucyIsICJpc1JvdGF0ZWQiLCAibGFiZWxzQmVsb3dUaWNrcyIsICJvZmZzZXRMZWZ0IiwgIm9mZnNldFJpZ2h0IiwgImlzRnVsbFNpemUiLCAiX2NvbXB1dGVMYWJlbFNpemVzIiwgIndpZHRocyIsICJoZWlnaHRzIiwgIndpZGVzdExhYmVsU2l6ZSIsICJoaWdoZXN0TGFiZWxTaXplIiwgImpsZW4iLCAidGlja0ZvbnQiLCAiZm9udFN0cmluZyIsICJuZXN0ZWRMYWJlbCIsICJfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyIsICJzdHJpbmciLCAiX21lYXN1cmVUZXh0IiwgInZhbHVlQXQiLCAiaWR4IiwgInBpeGVsIiwgImRlY2ltYWwiLCAiX2ludDE2UmFuZ2UiLCAiX2FsaWduUGl4ZWwiLCAiZ2V0RGVjaW1hbEZvclBpeGVsIiwgImdldEJhc2VWYWx1ZSIsICJvcHRpb25UaWNrcyIsICJyb3QiLCAiYXV0b1NraXBQYWRkaW5nIiwgIl9jb21wdXRlR3JpZExpbmVJdGVtcyIsICJ0bCIsICJib3JkZXJPcHRzIiwgImF4aXNXaWR0aCIsICJheGlzSGFsZldpZHRoIiwgImFsaWduQm9yZGVyVmFsdWUiLCAiYm9yZGVyVmFsdWUiLCAiYWxpZ25lZExpbmVWYWx1ZSIsICJ0eDEiLCAidHkxIiwgInR4MiIsICJ0eTIiLCAieDEiLCAieTEiLCAieDIiLCAieTIiLCAibGltaXQiLCAic3RlcCIsICJvcHRzQXRJbmRleCIsICJvcHRzQXRJbmRleEJvcmRlciIsICJsaW5lQ29sb3IiLCAiYm9yZGVyRGFzaCIsICJkYXNoIiwgImJvcmRlckRhc2hPZmZzZXQiLCAiZGFzaE9mZnNldCIsICJ0aWNrQ29sb3IiLCAidGlja0JvcmRlckRhc2giLCAidGlja0JvcmRlckRhc2hPZmZzZXQiLCAiY3Jvc3NBbGlnbiIsICJ0aWNrQW5kUGFkZGluZyIsICJoVGlja0FuZFBhZGRpbmciLCAidGV4dEFsaWduIiwgImxpbmVDb3VudCIsICJ0ZXh0T2Zmc2V0IiwgInRleHRCYXNlbGluZSIsICJfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCIsICJfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCIsICJsYWJlbE9mZnNldCIsICJoYWxmQ291bnQiLCAic3Ryb2tlQ29sb3IiLCAidGV4dFN0cm9rZUNvbG9yIiwgInN0cm9rZVdpZHRoIiwgInRleHRTdHJva2VXaWR0aCIsICJ0aWNrVGV4dEFsaWduIiwgInNob3dMYWJlbEJhY2tkcm9wIiwgImJhY2tkcm9wIiwgImxhYmVsUGFkZGluZyIsICJiYWNrZHJvcFBhZGRpbmciLCAiYmFja2Ryb3BDb2xvciIsICJ0cmFuc2xhdGlvbiIsICJfY29tcHV0ZUxhYmVsQXJlYSIsICJkcmF3QmFja2dyb3VuZCIsICJzYXZlIiwgImZpbGxSZWN0IiwgInJlc3RvcmUiLCAiZHJhd0dyaWQiLCAiZHJhd0xpbmUiLCAicDEiLCAicDIiLCAic2V0TGluZURhc2giLCAibGluZURhc2hPZmZzZXQiLCAiYmVnaW5QYXRoIiwgIm1vdmVUbyIsICJsaW5lVG8iLCAic3Ryb2tlIiwgImRyYXdPbkNoYXJ0QXJlYSIsICJkcmF3Qm9yZGVyIiwgImxhc3RMaW5lV2lkdGgiLCAiZHJhd0xhYmVscyIsICJjbGlwQXJlYSIsICJyZW5kZXJUZXh0T3B0aW9ucyIsICJyZW5kZXJUZXh0IiwgInVuY2xpcEFyZWEiLCAiZHJhd1RpdGxlIiwgInR6IiwgImd6IiwgImJ6IiwgIl9tYXhEaWdpdHMiLCAiZm9udFNpemUiLCAiVHlwZWRSZWdpc3RyeSIsICJzY29wZSIsICJjcmVhdGUiLCAiaXNGb3JUeXBlIiwgImlzUHJvdG90eXBlT2YiLCAicmVnaXN0ZXIiLCAicHJvdG8iLCAiZ2V0UHJvdG90eXBlT2YiLCAicGFyZW50U2NvcGUiLCAiaXNJQ2hhcnRDb21wb25lbnQiLCAicmVnaXN0ZXJEZWZhdWx0cyIsICJ1bnJlZ2lzdGVyIiwgIml0ZW1EZWZhdWx0cyIsICJtZXJnZSIsICJyb3V0ZURlZmF1bHRzIiwgImRlc2NyaWJlIiwgInJvdXRlcyIsICJwcm9wZXJ0eSIsICJwcm9wZXJ0eVBhcnRzIiwgInNwbGl0IiwgInNvdXJjZU5hbWUiLCAic291cmNlU2NvcGUiLCAiam9pbiIsICJwYXJ0cyIsICJ0YXJnZXROYW1lIiwgInRhcmdldFNjb3BlIiwgInJvdXRlIiwgIlJlZ2lzdHJ5IiwgImNvbnRyb2xsZXJzIiwgIl90eXBlZFJlZ2lzdHJpZXMiLCAiX2VhY2giLCAiYWRkQ29udHJvbGxlcnMiLCAiYWRkUGx1Z2lucyIsICJhZGRTY2FsZXMiLCAiZ2V0Q29udHJvbGxlciIsICJfZ2V0IiwgImdldFBsdWdpbiIsICJnZXRTY2FsZSIsICJyZW1vdmVDb250cm9sbGVycyIsICJyZW1vdmVFbGVtZW50cyIsICJyZW1vdmVQbHVnaW5zIiwgInJlbW92ZVNjYWxlcyIsICJ0eXBlZFJlZ2lzdHJ5IiwgImFyZyIsICJyZWciLCAiX2dldFJlZ2lzdHJ5Rm9yVHlwZSIsICJfZXhlYyIsICJpdGVtUmVnIiwgImNvbXBvbmVudCIsICJjYW1lbE1ldGhvZCIsICJfY2FwaXRhbGl6ZSIsICJQbHVnaW5TZXJ2aWNlIiwgIl9pbml0IiwgIm5vdGlmeSIsICJob29rIiwgIl9jcmVhdGVEZXNjcmlwdG9ycyIsICJfZGVzY3JpcHRvcnMiLCAiZGVzY3JpcHRvciIsICJwbHVnaW4iLCAiY2FsbENhbGxiYWNrIiwgImNhbmNlbGFibGUiLCAiaW52YWxpZGF0ZSIsICJfb2xkQ2FjaGUiLCAiX25vdGlmeVN0YXRlQ2hhbmdlcyIsICJhbGxQbHVnaW5zIiwgImNyZWF0ZURlc2NyaXB0b3JzIiwgInByZXZpb3VzRGVzY3JpcHRvcnMiLCAic29tZSIsICJsb2NhbElkcyIsICJsb2NhbCIsICJnZXRPcHRzIiwgInBsdWdpbk9wdHMiLCAicGx1Z2luU2NvcGVLZXlzIiwgInNjcmlwdGFibGUiLCAiaW5kZXhhYmxlIiwgImFsbEtleXMiLCAiZ2V0SW5kZXhBeGlzIiwgImRhdGFzZXREZWZhdWx0cyIsICJkYXRhc2V0T3B0aW9ucyIsICJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwgImdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMiLCAiaWRNYXRjaGVzQXhpcyIsICJheGlzRnJvbVBvc2l0aW9uIiwgImRldGVybWluZUF4aXMiLCAic2NhbGVPcHRpb25zIiwgInRvTG93ZXJDYXNlIiwgImdldEF4aXNGcm9tRGF0YXNldCIsICJyZXRyaWV2ZUF4aXNGcm9tRGF0YXNldHMiLCAiYm91bmREcyIsICJkIiwgIm1lcmdlU2NhbGVDb25maWciLCAiY2hhcnREZWZhdWx0cyIsICJjb25maWdTY2FsZXMiLCAiY2hhcnRJbmRleEF4aXMiLCAic2NhbGVDb25mIiwgImVycm9yIiwgIl9wcm94eSIsICJkZWZhdWx0SWQiLCAiZGVmYXVsdFNjYWxlT3B0aW9ucyIsICJtZXJnZUlmIiwgImRlZmF1bHRJRCIsICJpbml0T3B0aW9ucyIsICJpbml0RGF0YSIsICJpbml0Q29uZmlnIiwgImtleUNhY2hlIiwgImtleXNDYWNoZWQiLCAiU2V0IiwgImNhY2hlZEtleXMiLCAiZ2VuZXJhdGUiLCAiYWRkSWZGb3VuZCIsICJDb25maWciLCAiX2NvbmZpZyIsICJfc2NvcGVDYWNoZSIsICJfcmVzb2x2ZXJDYWNoZSIsICJwbGF0Zm9ybSIsICJjbGVhckNhY2hlIiwgImNsZWFyIiwgImRhdGFzZXRUeXBlIiwgImFkZGl0aW9uYWxPcHRpb25TY29wZXMiLCAiX2NhY2hlZFNjb3BlcyIsICJtYWluU2NvcGUiLCAicmVzZXRDYWNoZSIsICJrZXlMaXN0cyIsICJjaGFydE9wdGlvblNjb3BlcyIsICJyZXNvbHZlciIsICJzdWJQcmVmaXhlcyIsICJnZXRSZXNvbHZlciIsICJuZWVkQ29udGV4dCIsICJpc0Z1bmN0aW9uIiwgInN1YlJlc29sdmVyIiwgIl9hdHRhY2hDb250ZXh0IiwgImRlc2NyaXB0b3JEZWZhdWx0cyIsICJyZXNvbHZlckNhY2hlIiwgIl9jcmVhdGVSZXNvbHZlciIsICJwIiwgImhhc0Z1bmN0aW9uIiwgImlzU2NyaXB0YWJsZSIsICJpc0luZGV4YWJsZSIsICJLTk9XTl9QT1NJVElPTlMiLCAicG9zaXRpb25Jc0hvcml6b250YWwiLCAiY29tcGFyZTJMZXZlbCIsICJsMSIsICJsMiIsICJvbkFuaW1hdGlvbnNDb21wbGV0ZSIsICJvbkNvbXBsZXRlIiwgIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCAib25Qcm9ncmVzcyIsICJnZXRDYW52YXMiLCAiZ2V0RWxlbWVudEJ5SWQiLCAiaW5zdGFuY2VzIiwgImdldENoYXJ0IiwgImMiLCAibW92ZU51bWVyaWNLZXlzIiwgImludEtleSIsICJkZXRlcm1pbmVMYXN0RXZlbnQiLCAibGFzdEV2ZW50IiwgImluQ2hhcnRBcmVhIiwgImlzQ2xpY2siLCAiQ2hhcnQiLCAiaW52YWxpZGF0ZVBsdWdpbnMiLCAidXNlckNvbmZpZyIsICJpbml0aWFsQ2FudmFzIiwgImV4aXN0aW5nQ2hhcnQiLCAidWlkIiwgIl9vcHRpb25zIiwgIl9hc3BlY3RSYXRpbyIsICJfbWV0YXNldHMiLCAiX2xhc3RFdmVudCIsICJfbGlzdGVuZXJzIiwgIl9yZXNwb25zaXZlTGlzdGVuZXJzIiwgIl9zb3J0ZWRNZXRhc2V0cyIsICJfcGx1Z2lucyIsICJfaGlkZGVuSW5kaWNlcyIsICJhdHRhY2hlZCIsICJfZG9SZXNpemUiLCAiZGVib3VuY2UiLCAicmVzaXplRGVsYXkiLCAiX2luaXRpYWxpemUiLCAibWFpbnRhaW5Bc3BlY3RSYXRpbyIsICJyZXNwb25zaXZlIiwgInJldGluYVNjYWxlIiwgImJpbmRFdmVudHMiLCAiY2xlYXJDYW52YXMiLCAiX3Jlc2l6ZSIsICJfcmVzaXplQmVmb3JlRHJhdyIsICJuZXdTaXplIiwgIm5ld1JhdGlvIiwgIm9uUmVzaXplIiwgInJlbmRlciIsICJlbnN1cmVTY2FsZXNIYXZlSURzIiwgInNjYWxlc09wdGlvbnMiLCAiYXhpc09wdGlvbnMiLCAiYnVpbGRPclVwZGF0ZVNjYWxlcyIsICJzY2FsZU9wdHMiLCAidXBkYXRlZCIsICJpc1JhZGlhbCIsICJkcG9zaXRpb24iLCAiZHR5cGUiLCAic2NhbGVUeXBlIiwgInNjYWxlQ2xhc3MiLCAiaGFzVXBkYXRlZCIsICJfdXBkYXRlTWV0YXNldHMiLCAiX2Rlc3Ryb3lEYXRhc2V0TWV0YSIsICJfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMiLCAiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwgIm5ld0NvbnRyb2xsZXJzIiwgIm9yZGVyIiwgInZpc2libGUiLCAiQ29udHJvbGxlckNsYXNzIiwgIl9yZXNldEVsZW1lbnRzIiwgImFuaW1zRGlzYWJsZWQiLCAiX3VwZGF0ZVNjYWxlcyIsICJfY2hlY2tFdmVudEJpbmRpbmdzIiwgIl91cGRhdGVIaWRkZW5JbmRpY2VzIiwgIl9taW5QYWRkaW5nIiwgImF1dG9QYWRkaW5nIiwgIl91cGRhdGVMYXlvdXQiLCAiX3VwZGF0ZURhdGFzZXRzIiwgIl9ldmVudEhhbmRsZXIiLCAiX3VwZGF0ZUhvdmVyU3R5bGVzIiwgImV4aXN0aW5nRXZlbnRzIiwgIm5ld0V2ZW50cyIsICJldmVudHMiLCAic2V0c0VxdWFsIiwgInVuYmluZEV2ZW50cyIsICJjaGFuZ2VzIiwgIl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMiLCAiZGF0YXNldENvdW50IiwgIm1ha2VTZXQiLCAiY2hhbmdlU2V0IiwgIm5vQXJlYSIsICJfaWR4IiwgIl91cGRhdGVEYXRhc2V0IiwgImxheWVycyIsICJfZHJhd0RhdGFzZXRzIiwgIl9kcmF3RGF0YXNldCIsICJnZXREYXRhc2V0Q2xpcEFyZWEiLCAiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsICJJbnRlcmFjdGlvbiIsICJzZXREYXRhc2V0VmlzaWJpbGl0eSIsICJfdXBkYXRlVmlzaWJpbGl0eSIsICJoaWRlIiwgInNob3ciLCAiX3N0b3AiLCAiZGVzdHJveSIsICJ0b0Jhc2U2NEltYWdlIiwgInRvRGF0YVVSTCIsICJiaW5kVXNlckV2ZW50cyIsICJiaW5kUmVzcG9uc2l2ZUV2ZW50cyIsICJfYWRkIiwgIl9yZW1vdmUiLCAiZGV0YWNoZWQiLCAidXBkYXRlSG92ZXJTdHlsZSIsICJwcmVmaXgiLCAiZ2V0QWN0aXZlRWxlbWVudHMiLCAic2V0QWN0aXZlRWxlbWVudHMiLCAiYWN0aXZlRWxlbWVudHMiLCAibGFzdEFjdGl2ZSIsICJfZWxlbWVudHNFcXVhbCIsICJwbHVnaW5JZCIsICJyZXBsYXkiLCAiaG92ZXJPcHRpb25zIiwgImhvdmVyIiwgImRlYWN0aXZhdGVkIiwgImFjdGl2YXRlZCIsICJldmVudEZpbHRlciIsICJfaGFuZGxlRXZlbnQiLCAiX2dldEFjdGl2ZUVsZW1lbnRzIiwgIl9pc0NsaWNrRXZlbnQiLCAib25Ib3ZlciIsICJ2ZXJzaW9uIiwgImNsaXBTZWxmIiwgImJvcmRlckpvaW5TdHlsZSIsICJvdXRlckFuZ2xlQ2xpcCIsICJfbm9ybWFsaXplQW5nbGUiLCAiaW5uZXJBbmdsZUNsaXAiLCAiY2xpcFdpZHRoIiwgImNsb3NlUGF0aCIsICJyZWN0IiwgImNsaXBBcmMiLCAicGl4ZWxNYXJnaW4iLCAiYW5nbGVNYXJnaW4iLCAidG9SYWRpdXNDb3JuZXJzIiwgIl9yZWFkVmFsdWVUb1Byb3BzIiwgInBhcnNlQm9yZGVyUmFkaXVzIiwgImFuZ2xlRGVsdGEiLCAibyIsICJib3JkZXJSYWRpdXMiLCAiaGFsZlRoaWNrbmVzcyIsICJpbm5lckxpbWl0IiwgImNvbXB1dGVPdXRlckxpbWl0IiwgIm91dGVyQXJjTGltaXQiLCAib3V0ZXJTdGFydCIsICJvdXRlckVuZCIsICJpbm5lclN0YXJ0IiwgImlubmVyRW5kIiwgInJUaGV0YVRvWFkiLCAidGhldGEiLCAicGF0aEFyYyIsICJpbm5lclIiLCAic3BhY2luZ09mZnNldCIsICJhbHBoYSIsICJub1NwYWNpbmdJbm5lclJhZGl1cyIsICJub1NwYWNpbmdPdXRlclJhZGl1cyIsICJhdk5vZ1NwYWNpbmdSYWRpdXMiLCAiYWRqdXN0ZWRBbmdsZSIsICJiZXRhIiwgImFuZ2xlT2Zmc2V0IiwgIm91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsICJvdXRlckVuZEFkanVzdGVkUmFkaXVzIiwgIm91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlIiwgIm91dGVyRW5kQWRqdXN0ZWRBbmdsZSIsICJpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCAiaW5uZXJFbmRBZGp1c3RlZFJhZGl1cyIsICJpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSIsICJpbm5lckVuZEFkanVzdGVkQW5nbGUiLCAib3V0ZXJNaWRBZGp1c3RlZEFuZ2xlIiwgInBDZW50ZXIiLCAicDQiLCAiaW5uZXJNaWRBZGp1c3RlZEFuZ2xlIiwgInA4IiwgIm91dGVyU3RhcnRYIiwgIm91dGVyU3RhcnRZIiwgIm91dGVyRW5kWCIsICJvdXRlckVuZFkiLCAiZHJhd0FyYyIsICJmdWxsQ2lyY2xlcyIsICJpbm5lciIsICJsaW5lSm9pbiIsICJzZWxmSm9pbiIsICJBcmNFbGVtZW50IiwgImNoYXJ0WCIsICJjaGFydFkiLCAickFkanVzdCIsICJub25aZXJvQmV0d2VlbiIsICJiZXR3ZWVuQW5nbGVzIiwgIndpdGhpblJhZGl1cyIsICJfaXNCZXR3ZWVuIiwgImhhbGZBbmdsZSIsICJoYWxmUmFkaXVzIiwgInRyYW5zbGF0ZSIsICJmaXgiLCAicmFkaXVzT2Zmc2V0IiwgInNldFN0eWxlIiwgImxpbmVDYXAiLCAiYm9yZGVyQ2FwU3R5bGUiLCAicHJldmlvdXMiLCAiZ2V0TGluZU1ldGhvZCIsICJzdGVwcGVkIiwgIl9zdGVwcGVkTGluZVRvIiwgInRlbnNpb24iLCAiY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSIsICJfYmV6aWVyQ3VydmVUbyIsICJwYXRoVmFycyIsICJwYXJhbXNTdGFydCIsICJwYXJhbXNFbmQiLCAic2VnbWVudFN0YXJ0IiwgInNlZ21lbnRFbmQiLCAib3V0c2lkZSIsICJwYXRoU2VnbWVudCIsICJsaW5lTWV0aG9kIiwgImZhc3RQYXRoU2VnbWVudCIsICJhdmdYIiwgImNvdW50WCIsICJwcmV2WCIsICJsYXN0WSIsICJwb2ludEluZGV4IiwgImRyYXdYIiwgInRydW5jWCIsICJfZ2V0U2VnbWVudE1ldGhvZCIsICJ1c2VGYXN0UGF0aCIsICJfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZCIsICJfc3RlcHBlZEludGVycG9sYXRpb24iLCAiX2JlemllckludGVycG9sYXRpb24iLCAiX3BvaW50SW5MaW5lIiwgInN0cm9rZVBhdGhXaXRoQ2FjaGUiLCAicGF0aCIsICJfcGF0aCIsICJQYXRoMkQiLCAic3Ryb2tlUGF0aERpcmVjdCIsICJzZWdtZW50cyIsICJzZWdtZW50TWV0aG9kIiwgInVzZVBhdGgyRCIsICJMaW5lRWxlbWVudCIsICJfcG9pbnRzIiwgIl9zZWdtZW50cyIsICJfcG9pbnRzVXBkYXRlZCIsICJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsICJfY29tcHV0ZVNlZ21lbnRzIiwgImludGVycG9sYXRlIiwgIl9ib3VuZFNlZ21lbnRzIiwgIl9pbnRlcnBvbGF0ZSIsICJpbnRlcnBvbGF0ZWQiLCAiY2FwQmV6aWVyUG9pbnRzIiwgImhpdFJhZGl1cyIsICJQb2ludEVsZW1lbnQiLCAibW91c2VYIiwgIm1vdXNlWSIsICJpblhSYW5nZSIsICJpbllSYW5nZSIsICJob3ZlclJhZGl1cyIsICJkcmF3UG9pbnQiLCAiZ2V0QmFyQm91bmRzIiwgImJhciIsICJoYWxmIiwgInNraXBPckxpbWl0IiwgInBhcnNlQm9yZGVyV2lkdGgiLCAibWF4VyIsICJtYXhIIiwgInRvVFJCTCIsICJ0b1RSQkxDb3JuZXJzIiwgIm1heFIiLCAiZW5hYmxlQm9yZGVyIiwgInRvcExlZnQiLCAidG9wUmlnaHQiLCAiYm90dG9tTGVmdCIsICJib3R0b21SaWdodCIsICJib3VuZGluZ1JlY3RzIiwgImJvdW5kcyIsICJvdXRlciIsICJza2lwWCIsICJza2lwWSIsICJza2lwQm90aCIsICJoYXNSYWRpdXMiLCAiYWRkTm9ybWFsUmVjdFBhdGgiLCAiaW5mbGF0ZVJlY3QiLCAiYW1vdW50IiwgInJlZlJlY3QiLCAiQmFyRWxlbWVudCIsICJhZGRSZWN0UGF0aCIsICJhZGRSb3VuZGVkUmVjdFBhdGgiLCAiQk9SREVSX0NPTE9SUyIsICJCQUNLR1JPVU5EX0NPTE9SUyIsICJyZXBsYWNlIiwgImdldEJvcmRlckNvbG9yIiwgImdldEJhY2tncm91bmRDb2xvciIsICJjb2xvcml6ZURlZmF1bHREYXRhc2V0IiwgImNvbG9yaXplRG91Z2hudXREYXRhc2V0IiwgImNvbG9yaXplUG9sYXJBcmVhRGF0YXNldCIsICJnZXRDb2xvcml6ZXIiLCAiY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyIsICJrIiwgImNvbnRhaW5zQ29sb3JzRGVmaW5pdGlvbiIsICJjb250YWluc0RlZmF1bHRDb2xvcnNEZWZlbml0aW9ucyIsICJmb3JjZU92ZXJyaWRlIiwgIl9hcmdzIiwgImNoYXJ0T3B0aW9ucyIsICJjb250YWluc0NvbG9yRGVmZW5pdGlvbiIsICJjb2xvcml6ZXIiLCAibHR0YkRlY2ltYXRpb24iLCAic2FtcGxlcyIsICJkZWNpbWF0ZWQiLCAiYnVja2V0V2lkdGgiLCAic2FtcGxlZEluZGV4IiwgImVuZEluZGV4IiwgIm1heEFyZWFQb2ludCIsICJtYXhBcmVhIiwgIm5leHRBIiwgImF2Z1kiLCAiYXZnUmFuZ2VTdGFydCIsICJhdmdSYW5nZUVuZCIsICJhdmdSYW5nZUxlbmd0aCIsICJyYW5nZU9mZnMiLCAicmFuZ2VUbyIsICJwb2ludEF4IiwgInBvaW50QXkiLCAibWluTWF4RGVjaW1hdGlvbiIsICJtaW5JbmRleCIsICJtYXhJbmRleCIsICJzdGFydEluZGV4IiwgInhNaW4iLCAieE1heCIsICJkeCIsICJsYXN0SW5kZXgiLCAiaW50ZXJtZWRpYXRlSW5kZXgxIiwgImludGVybWVkaWF0ZUluZGV4MiIsICJjbGVhbkRlY2ltYXRlZERhdGFzZXQiLCAiZGVmaW5lUHJvcGVydHkiLCAiY29uZmlndXJhYmxlIiwgImVudW1lcmFibGUiLCAid3JpdGFibGUiLCAiY2xlYW5EZWNpbWF0ZWREYXRhIiwgImdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkIiwgInBvaW50Q291bnQiLCAiYWxnb3JpdGhtIiwgImJlZm9yZUVsZW1lbnRzVXBkYXRlIiwgInhBeGlzIiwgInRocmVzaG9sZCIsICJ0cG9pbnRzIiwgIl9maW5kU2VnbWVudEVuZCIsICJfZ2V0Qm91bmRzIiwgInRhcmdldFNlZ21lbnRzIiwgInRndCIsICJzdWJCb3VuZHMiLCAiZmlsbFNvdXJjZXMiLCAiX2JvdW5kU2VnbWVudCIsICJmaWxsU291cmNlIiwgIl9nZXRFZGdlIiwgIl9wb2ludHNGcm9tU2VnbWVudHMiLCAiYm91bmRhcnkiLCAibGluZVBvaW50cyIsICJfY3JlYXRlQm91bmRhcnlMaW5lIiwgIl9zaG91bGRBcHBseUZpbGwiLCAiX3Jlc29sdmVUYXJnZXQiLCAic291cmNlcyIsICJwcm9wYWdhdGUiLCAidmlzaXRlZCIsICJfZGVjb2RlRmlsbCIsICJwYXJzZUZpbGxPcHRpb24iLCAicGFyc2VGbG9hdCIsICJkZWNvZGVUYXJnZXRJbmRleCIsICJmaXJzdENoIiwgIl9nZXRUYXJnZXRQaXhlbCIsICJfZ2V0VGFyZ2V0VmFsdWUiLCAiZmlsbE9wdGlvbiIsICJfYnVpbGRTdGFja0xpbmUiLCAic291cmNlUG9pbnRzIiwgImxpbmVzQmVsb3ciLCAiZ2V0TGluZXNCZWxvdyIsICJhZGRQb2ludHNCZWxvdyIsICJiZWxvdyIsICJ1bnNoaWZ0IiwgInNvdXJjZVBvaW50IiwgInBvc3Rwb25lZCIsICJmaW5kUG9pbnQiLCAicG9pbnRWYWx1ZSIsICJmaXJzdFZhbHVlIiwgImxhc3RWYWx1ZSIsICJzaW1wbGVBcmMiLCAiX2dldFRhcmdldCIsICJnZXRMaW5lQnlJbmRleCIsICJjb21wdXRlQm91bmRhcnkiLCAiY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkiLCAiY29tcHV0ZUxpbmVhckJvdW5kYXJ5IiwgIl9kcmF3ZmlsbCIsICJsaW5lT3B0cyIsICJhYm92ZSIsICJkb0ZpbGwiLCAiZmlsbENvbG9yIiwgImNsaXBWZXJ0aWNhbCIsICJjbGlwSG9yaXpvbnRhbCIsICJjbGlwWSIsICJsaW5lTG9vcCIsICJjbGlwWCIsICJzcmMiLCAibm90U2hhcGUiLCAiY2xpcEJvdW5kcyIsICJpbnRlcnBvbGF0ZWRMaW5lVG8iLCAidGFyZ2V0TG9vcCIsICJpbnRlcnBvbGF0ZWRQb2ludCIsICJhZnRlckRhdGFzZXRzVXBkYXRlIiwgIiRmaWxsZXIiLCAiYmVmb3JlRHJhdyIsICJkcmF3VGltZSIsICJiZWZvcmVEYXRhc2V0c0RyYXciLCAiYmVmb3JlRGF0YXNldERyYXciLCAiZ2V0Qm94U2l6ZSIsICJsYWJlbE9wdHMiLCAiYm94SGVpZ2h0IiwgImJveFdpZHRoIiwgInVzZVBvaW50U3R5bGUiLCAicG9pbnRTdHlsZVdpZHRoIiwgIml0ZW1IZWlnaHQiLCAiaXRlbXNFcXVhbCIsICJMZWdlbmQiLCAiX2FkZGVkIiwgImxlZ2VuZEhpdEJveGVzIiwgIl9ob3ZlcmVkSXRlbSIsICJkb3VnaG51dE1vZGUiLCAibGVnZW5kSXRlbXMiLCAiY29sdW1uU2l6ZXMiLCAibGluZVdpZHRocyIsICJidWlsZExhYmVscyIsICJsYWJlbEZvbnQiLCAiX2NvbXB1dGVUaXRsZUhlaWdodCIsICJfZml0Um93cyIsICJfZml0Q29scyIsICJoaXRib3hlcyIsICJ0b3RhbEhlaWdodCIsICJyb3ciLCAiaXRlbVdpZHRoIiwgIm1lYXN1cmVUZXh0IiwgIl9pdGVtSGVpZ2h0IiwgImhlaWdodExpbWl0IiwgInRvdGFsV2lkdGgiLCAiY3VycmVudENvbFdpZHRoIiwgImN1cnJlbnRDb2xIZWlnaHQiLCAiY29sIiwgImNhbGN1bGF0ZUl0ZW1TaXplIiwgImFkanVzdEhpdEJveGVzIiwgInJ0bCIsICJydGxIZWxwZXIiLCAiZ2V0UnRsQWRhcHRlciIsICJoaXRib3giLCAibGVmdEZvckx0ciIsICJfZHJhdyIsICJkZWZhdWx0Q29sb3IiLCAiaGFsZkZvbnRTaXplIiwgImN1cnNvciIsICJkcmF3TGVnZW5kQm94IiwgImxpbmVEYXNoIiwgImRyYXdPcHRpb25zIiwgIlNRUlQyIiwgInhQbHVzIiwgImRyYXdQb2ludExlZ2VuZCIsICJ5Qm94VG9wIiwgInhCb3hMZWZ0IiwgImZpbGxUZXh0IiwgInN0cmlrZXRocm91Z2giLCAib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwgInRleHREaXJlY3Rpb24iLCAidGV4dFdpZHRoIiwgInNldFdpZHRoIiwgInJlYWxYIiwgIl90ZXh0WCIsICJmb250TGluZUhlaWdodCIsICJjYWxjdWxhdGVMZWdlbmRJdGVtSGVpZ2h0IiwgInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwgInRpdGxlRm9udCIsICJ0aXRsZVBhZGRpbmciLCAidG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUiLCAiX2dldExlZ2VuZEl0ZW1BdCIsICJoaXRCb3giLCAibGgiLCAiaGFuZGxlRXZlbnQiLCAiaXNMaXN0ZW5lZCIsICJob3ZlcmVkSXRlbSIsICJzYW1lSXRlbSIsICJvbkxlYXZlIiwgImNhbGN1bGF0ZUl0ZW1XaWR0aCIsICJjYWxjdWxhdGVJdGVtSGVpZ2h0IiwgImxlZ2VuZEl0ZW1UZXh0IiwgIl9lbGVtZW50IiwgImFmdGVyRXZlbnQiLCAiY2kiLCAidXNlQm9yZGVyUmFkaXVzIiwgIlRpdGxlIiwgIl9wYWRkaW5nIiwgInRleHRTaXplIiwgIl9kcmF3QXJncyIsICJmb250T3B0cyIsICJjcmVhdGVUaXRsZSIsICJ0aXRsZUJsb2NrIiwgIldlYWtNYXAiLCAicG9zaXRpb25lcnMiLCAiYXZlcmFnZSIsICJ4U2V0IiwgInhBdmVyYWdlIiwgImV2ZW50UG9zaXRpb24iLCAibmVhcmVzdEVsZW1lbnQiLCAiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwgInRwIiwgInB1c2hPckNvbmNhdCIsICJ0b1B1c2giLCAiYXBwbHkiLCAic3BsaXROZXdsaW5lcyIsICJzdHIiLCAiU3RyaW5nIiwgImNyZWF0ZVRvb2x0aXBJdGVtIiwgImZvcm1hdHRlZFZhbHVlIiwgImdldFRvb2x0aXBTaXplIiwgInRvb2x0aXAiLCAiYm9keSIsICJmb290ZXIiLCAiYm9keUZvbnQiLCAiZm9vdGVyRm9udCIsICJ0aXRsZUxpbmVDb3VudCIsICJmb290ZXJMaW5lQ291bnQiLCAiYm9keUxpbmVJdGVtQ291bnQiLCAiY29tYmluZWRCb2R5TGVuZ3RoIiwgImJvZHlJdGVtIiwgImJlZm9yZSIsICJhZnRlciIsICJiZWZvcmVCb2R5IiwgImFmdGVyQm9keSIsICJ0aXRsZVNwYWNpbmciLCAidGl0bGVNYXJnaW5Cb3R0b20iLCAiYm9keUxpbmVIZWlnaHQiLCAiZGlzcGxheUNvbG9ycyIsICJib2R5U3BhY2luZyIsICJmb290ZXJNYXJnaW5Ub3AiLCAiZm9vdGVyU3BhY2luZyIsICJ3aWR0aFBhZGRpbmciLCAibWF4TGluZVdpZHRoIiwgImRldGVybWluZVlBbGlnbiIsICJkb2VzTm90Rml0V2l0aEFsaWduIiwgInhBbGlnbiIsICJjYXJldCIsICJjYXJldFNpemUiLCAiY2FyZXRQYWRkaW5nIiwgImRldGVybWluZVhBbGlnbiIsICJ5QWxpZ24iLCAiY2hhcnRXaWR0aCIsICJkZXRlcm1pbmVBbGlnbm1lbnQiLCAiYWxpZ25YIiwgImFsaWduWSIsICJwYWRkaW5nQW5kU2l6ZSIsICJnZXRCYWNrZ3JvdW5kUG9pbnQiLCAiYWxpZ25tZW50IiwgImNvcm5lclJhZGl1cyIsICJnZXRBbGlnbmVkWCIsICJnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyIsICJjcmVhdGVUb29sdGlwQ29udGV4dCIsICJ0b29sdGlwSXRlbXMiLCAib3ZlcnJpZGVDYWxsYmFja3MiLCAiZGVmYXVsdENhbGxiYWNrcyIsICJiZWZvcmVUaXRsZSIsICJub29wIiwgImxhYmVsQ291bnQiLCAiYWZ0ZXJUaXRsZSIsICJiZWZvcmVMYWJlbCIsICJ0b29sdGlwSXRlbSIsICJsYWJlbENvbG9yIiwgImxhYmVsVGV4dENvbG9yIiwgImJvZHlDb2xvciIsICJsYWJlbFBvaW50U3R5bGUiLCAiYWZ0ZXJMYWJlbCIsICJiZWZvcmVGb290ZXIiLCAiYWZ0ZXJGb290ZXIiLCAiaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2siLCAiVG9vbHRpcCIsICJvcGFjaXR5IiwgIl9ldmVudFBvc2l0aW9uIiwgIl9zaXplIiwgIl9jYWNoZWRBbmltYXRpb25zIiwgIl90b29sdGlwSXRlbXMiLCAiZGF0YVBvaW50cyIsICJjYXJldFgiLCAiY2FyZXRZIiwgImxhYmVsQ29sb3JzIiwgImxhYmVsUG9pbnRTdHlsZXMiLCAibGFiZWxUZXh0Q29sb3JzIiwgImdldFRpdGxlIiwgImdldEJlZm9yZUJvZHkiLCAiZ2V0Qm9keSIsICJib2R5SXRlbXMiLCAic2NvcGVkIiwgImdldEFmdGVyQm9keSIsICJnZXRGb290ZXIiLCAiX2NyZWF0ZUl0ZW1zIiwgIml0ZW1Tb3J0IiwgInBvc2l0aW9uQW5kU2l6ZSIsICJiYWNrZ3JvdW5kUG9pbnQiLCAiZXh0ZXJuYWwiLCAiZHJhd0NhcmV0IiwgInRvb2x0aXBQb2ludCIsICJjYXJldFBvc2l0aW9uIiwgImdldENhcmV0UG9zaXRpb24iLCAieDMiLCAieTMiLCAicHRYIiwgInB0WSIsICJwdCIsICJ0aXRsZUNvbG9yIiwgIl9kcmF3Q29sb3JCb3giLCAiY29sb3JYIiwgInJ0bENvbG9yWCIsICJ5T2ZmU2V0IiwgImNvbG9yWSIsICJtdWx0aUtleUJhY2tncm91bmQiLCAib3V0ZXJYIiwgImlubmVyWCIsICJzdHJva2VSZWN0IiwgImRyYXdCb2R5IiwgImJvZHlBbGlnbiIsICJ4TGluZVBhZGRpbmciLCAiZmlsbExpbmVPZlRleHQiLCAiYm9keUFsaWduRm9yQ2FsY3VsYXRpb24iLCAidGV4dENvbG9yIiwgImRyYXdGb290ZXIiLCAiZm9vdGVyQWxpZ24iLCAiZm9vdGVyQ29sb3IiLCAidG9vbHRpcFNpemUiLCAicXVhZHJhdGljQ3VydmVUbyIsICJfdXBkYXRlQW5pbWF0aW9uVGFyZ2V0IiwgImFuaW1YIiwgImFuaW1ZIiwgIl93aWxsUmVuZGVyIiwgImhhc1Rvb2x0aXBDb250ZW50IiwgImdsb2JhbEFscGhhIiwgInBvc2l0aW9uQ2hhbmdlZCIsICJfcG9zaXRpb25DaGFuZ2VkIiwgIl9pZ25vcmVSZXBsYXlFdmVudHMiLCAiYWZ0ZXJJbml0IiwgImFmdGVyRHJhdyIsICJfZmFsbGJhY2siLCAiYWRkSWZTdHJpbmciLCAiYWRkZWRMYWJlbHMiLCAiZmluZE9yQWRkTGFiZWwiLCAibGFzdEluZGV4T2YiLCAiX2dldExhYmVsRm9yVmFsdWUiLCAiQ2F0ZWdvcnlTY2FsZSIsICJfc3RhcnRWYWx1ZSIsICJfdmFsdWVSYW5nZSIsICJfYWRkZWRMYWJlbHMiLCAiYWRkZWQiLCAiZ2VuZXJhdGVUaWNrcyIsICJnZW5lcmF0aW9uT3B0aW9ucyIsICJkYXRhUmFuZ2UiLCAiTUlOX1NQQUNJTkciLCAicHJlY2lzaW9uIiwgIm1heFRpY2tzIiwgIm1heERpZ2l0cyIsICJpbmNsdWRlQm91bmRzIiwgInVuaXQiLCAibWF4U3BhY2VzIiwgInJtaW4iLCAicm1heCIsICJjb3VudERlZmluZWQiLCAibWluU3BhY2luZyIsICJuaWNlTnVtIiwgIm5pY2VNaW4iLCAibmljZU1heCIsICJudW1TcGFjZXMiLCAiYWxtb3N0V2hvbGUiLCAiYWxtb3N0RXF1YWxzIiwgImRlY2ltYWxQbGFjZXMiLCAiX2RlY2ltYWxQbGFjZXMiLCAicmVsYXRpdmVMYWJlbFNpemUiLCAidGlja1ZhbHVlIiwgInJhZCIsICJMaW5lYXJTY2FsZUJhc2UiLCAiX2VuZFZhbHVlIiwgImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCAic2V0TWluIiwgInNldE1heCIsICJtaW5TaWduIiwgIm1heFNpZ24iLCAiZ2V0VGlja0xpbWl0IiwgInN0ZXBTaXplIiwgImNvbXB1dGVUaWNrTGltaXQiLCAibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCAiX3NldE1pbkFuZE1heEJ5S2V5IiwgIkxpbmVhclNjYWxlIiwgIlRpY2tzIiwgImZvcm1hdHRlcnMiLCAibnVtZXJpYyIsICJsb2cxMEZsb29yIiwgImxvZzEwIiwgImNoYW5nZUV4cG9uZW50IiwgIm0iLCAiaXNNYWpvciIsICJ0aWNrVmFsIiwgInN0ZXBzIiwgInJhbmdlRXhwIiwgInJhbmdlU3RlcCIsICJzdGFydEV4cCIsICJtaW5FeHAiLCAiZXhwIiwgInNpZ25pZmljYW5kIiwgImxhc3RUaWNrIiwgIkxvZ2FyaXRobWljU2NhbGUiLCAiX3plcm8iLCAibG9nYXJpdGhtaWMiLCAiZ2V0VGlja0JhY2tkcm9wSGVpZ2h0IiwgIm1lYXN1cmVMYWJlbFNpemUiLCAiX2xvbmdlc3RUZXh0IiwgImRldGVybWluZUxpbWl0cyIsICJmaXRXaXRoUG9pbnRMYWJlbHMiLCAibGltaXRzIiwgInZhbHVlQ291bnQiLCAiX3BvaW50TGFiZWxzIiwgInBvaW50TGFiZWxPcHRzIiwgImFkZGl0aW9uYWxBbmdsZSIsICJjZW50ZXJQb2ludExhYmVscyIsICJnZXRQb2ludExhYmVsQ29udGV4dCIsICJnZXRQb2ludFBvc2l0aW9uIiwgImRyYXdpbmdBcmVhIiwgInBsRm9udCIsICJoTGltaXRzIiwgInZMaW1pdHMiLCAidXBkYXRlTGltaXRzIiwgInNldENlbnRlclBvaW50IiwgIl9wb2ludExhYmVsSXRlbXMiLCAiYnVpbGRQb2ludExhYmVsSXRlbXMiLCAiY3JlYXRlUG9pbnRMYWJlbEl0ZW0iLCAiaXRlbU9wdHMiLCAib3V0ZXJEaXN0YW5jZSIsICJleHRyYSIsICJwb2ludExhYmVsUG9zaXRpb24iLCAieUZvckFuZ2xlIiwgImdldFRleHRBbGlnbkZvckFuZ2xlIiwgImxlZnRGb3JUZXh0QWxpZ24iLCAiaXNOb3RPdmVybGFwcGVkIiwgImFwZXhlc0luQXJlYSIsICJkcmF3UG9pbnRMYWJlbEJveCIsICJiYWNrZHJvcExlZnQiLCAiYmFja2Ryb3BUb3AiLCAiYmFja2Ryb3BXaWR0aCIsICJiYWNrZHJvcEhlaWdodCIsICJkcmF3UG9pbnRMYWJlbHMiLCAicGF0aFJhZGl1c0xpbmUiLCAiZHJhd1JhZGl1c0xpbmUiLCAiZ3JpZExpbmVPcHRzIiwgImNyZWF0ZVBvaW50TGFiZWxDb250ZXh0IiwgIlJhZGlhbExpbmVhclNjYWxlIiwgImxlZnRNb3ZlbWVudCIsICJyaWdodE1vdmVtZW50IiwgInRvcE1vdmVtZW50IiwgImJvdHRvbU1vdmVtZW50IiwgImFuZ2xlTXVsdGlwbGllciIsICJzY2FsaW5nRmFjdG9yIiwgImdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyIiwgInNjYWxlZERpc3RhbmNlIiwgInBvaW50TGFiZWwiLCAiZGlzdGFuY2VGcm9tQ2VudGVyIiwgImdldEJhc2VQb3NpdGlvbiIsICJnZXRQb2ludExhYmVsUG9zaXRpb24iLCAicm90YXRlIiwgImFuaW1hdGUiLCAiSU5URVJWQUxTIiwgIm1pbGxpc2Vjb25kIiwgImNvbW1vbiIsICJzZWNvbmQiLCAibWludXRlIiwgImhvdXIiLCAiZGF5IiwgIndlZWsiLCAibW9udGgiLCAicXVhcnRlciIsICJ5ZWFyIiwgIlVOSVRTIiwgInNvcnRlciIsICJpbnB1dCIsICJhZGFwdGVyIiwgIl9hZGFwdGVyIiwgInBhcnNlciIsICJpc29XZWVrZGF5IiwgIl9wYXJzZU9wdHMiLCAiZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyIsICJtaW5Vbml0IiwgImNhcGFjaXR5IiwgImludGVydmFsIiwgIk1BWF9TQUZFX0lOVEVHRVIiLCAiZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmciLCAiZGV0ZXJtaW5lTWFqb3JVbml0IiwgImFkZFRpY2siLCAidGltZSIsICJ0aW1lc3RhbXBzIiwgIl9sb29rdXAiLCAidGltZXN0YW1wIiwgInNldE1ham9yVGlja3MiLCAibWFqb3JVbml0IiwgInRpY2tzRnJvbVRpbWVzdGFtcHMiLCAiVGltZVNjYWxlIiwgIl91bml0IiwgIl9tYWpvclVuaXQiLCAiX29mZnNldHMiLCAiX25vcm1hbGl6ZWQiLCAiYWRhcHRlcnMiLCAiZGlzcGxheUZvcm1hdHMiLCAibm9ybWFsaXplZCIsICJfYXBwbHlCb3VuZHMiLCAiX2dldExhYmVsQm91bmRzIiwgImdldExhYmVsVGltZXN0YW1wcyIsICJ0aW1lT3B0cyIsICJfZ2VuZXJhdGUiLCAiX2ZpbHRlckJldHdlZW4iLCAiX2dldExhYmVsQ2FwYWNpdHkiLCAiaW5pdE9mZnNldHMiLCAib2Zmc2V0QWZ0ZXJBdXRvc2tpcCIsICJnZXREZWNpbWFsRm9yVmFsdWUiLCAibWlub3IiLCAid2Vla2RheSIsICJoYXNXZWVrZGF5IiwgImdldERhdGFUaW1lc3RhbXBzIiwgInRvb2x0aXBGb3JtYXQiLCAiZGF0ZXRpbWUiLCAiZm10IiwgIl90aWNrRm9ybWF0RnVuY3Rpb24iLCAiZm9ybWF0dGVyIiwgIm1pbm9yRm9ybWF0IiwgIm1ham9yRm9ybWF0IiwgIm9mZnNldHMiLCAiX2dldExhYmVsU2l6ZSIsICJ0aWNrc09wdHMiLCAidGlja0xhYmVsV2lkdGgiLCAiY29zUm90YXRpb24iLCAic2luUm90YXRpb24iLCAidGlja0ZvbnRTaXplIiwgImV4YW1wbGVUaW1lIiwgImV4YW1wbGVMYWJlbCIsICJub3JtYWxpemUiLCAidGFibGUiLCAicHJldlNvdXJjZSIsICJuZXh0U291cmNlIiwgInByZXZUYXJnZXQiLCAibmV4dFRhcmdldCIsICJzcGFuIiwgIlRpbWVTZXJpZXNTY2FsZSIsICJfdGFibGUiLCAiX21pblBvcyIsICJfdGFibGVSYW5nZSIsICJfZ2V0VGltZXN0YW1wc0ZvclRhYmxlIiwgImJ1aWxkTG9va3VwVGFibGUiLCAicmVnaXN0ZXJhYmxlcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAidG8iLCAib3B0aW9ucyIsICJpbmRleCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW5kZXgiLCAiY29udGVudEVsIiwgInByb21wdCIsICJ1dWlkdjQiLCAiZSIsICJpbmRleCJdCn0K
